#pragma section("__nv_managed_data__")
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
#line 1 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#define __nv_is_extended_device_lambda_closure_type(X) false
#define __nv_is_extended_host_device_lambda_closure_type(X) false
#if defined(__nv_is_extended_device_lambda_closure_type) && defined(__nv_is_extended_host_device_lambda_closure_type)
#endif

#line 1
#line 67 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#pragma warning(push)
#pragma warning(disable: 4820)
#line 231 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"
#pragma external_header(push)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#pragma external_header(push)
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#pragma external_header(push)
#line 708 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
#pragma region Input Buffer SAL 1 compatibility macros
#line 1472
#pragma endregion Input Buffer SAL 1 compatibility macros
#line 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
extern "C" {
#line 2971 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
}
#line 2974 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
#pragma external_header(push)
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"
extern "C" {
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"
}
#line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"
#pragma external_header(pop)
#line 2975 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
#pragma external_header(pop)
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
#pragma pack ( push, 8 )
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 51
extern "C" {
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
typedef unsigned __int64 uintptr_t; 
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
typedef char *va_list; 
#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
void __cdecl __va_start(va_list *, ...); 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
}
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
extern "C++" {
#line 173
template< class _Ty> 
#line 174
struct __vcrt_va_list_is_reference { 
#line 176
enum: bool { __the_value}; 
#line 177
}; 
#line 179
template< class _Ty> 
#line 180
struct __vcrt_va_list_is_reference< _Ty &>  { 
#line 182
enum: bool { __the_value = '\001'}; 
#line 183
}; 
#line 185
template< class _Ty> 
#line 186
struct __vcrt_va_list_is_reference< _Ty &&>  { 
#line 188
enum: bool { __the_value = '\001'}; 
#line 189
}; 
#line 191
template< class _Ty> 
#line 192
struct __vcrt_assert_va_start_is_not_reference { 
#line 194
static_assert((!__vcrt_va_list_is_reference< _Ty> ::__the_value), "va_start argument must not have reference type and must not be parenthesized");
#line 196
}; 
#line 197
}
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
#pragma warning(pop)
#pragma pack ( pop )
#pragma external_header(pop)
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
typedef unsigned __int64 size_t; 
#if !defined(__CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__)
#define __CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__
#endif
#include "crt/host_runtime.h"
#line 194
typedef __int64 ptrdiff_t; 
#line 195
typedef __int64 intptr_t; 
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
typedef bool __vcrt_bool; 
#line 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
extern "C++" {
#line 252
template< class _CountofType, size_t _SizeOfArray> char (*__countof_helper(__unaligned _CountofType (& _Array)[_SizeOfArray]))[_SizeOfArray]; 
#line 256
}
#line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
void __cdecl __security_init_cookie(); 
#line 351 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
void __cdecl __security_check_cookie(uintptr_t _StackCookie); 
#line 352
__declspec(noreturn) void __cdecl __report_gsfailure(uintptr_t _StackCookie); 
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
extern uintptr_t __security_cookie; 
#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
}__pragma( pack ( pop )) 
#line 366
#pragma warning(pop)
#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#pragma external_header(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#pragma external_header(push)
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 77
__pragma( pack ( push, 8 )) extern "C" {
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
extern "C++" {
#line 201
template< bool _Enable, class _Ty> struct _CrtEnableIf; 
#line 204
template< class _Ty> 
#line 205
struct _CrtEnableIf< true, _Ty>  { 
#line 207
typedef _Ty _Type; 
#line 208
}; 
#line 209
}
#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
typedef bool __crt_bool; 
#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
void __cdecl _invalid_parameter_noinfo(); 
#line 358
__declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(); 
#line 360
__declspec(noreturn) void __cdecl 
#line 361
_invoke_watson(const __wchar_t * _Expression, const __wchar_t * _FunctionName, const __wchar_t * _FileName, unsigned _LineNo, uintptr_t _Reserved); 
#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
typedef int errno_t; 
#line 591
typedef unsigned short wint_t; 
#line 592
typedef unsigned short wctype_t; 
#line 593
typedef long __time32_t; 
#line 594
typedef __int64 __time64_t; 
#line 601
typedef 
#line 596
struct __crt_locale_data_public { 
#line 598
const unsigned short *_locale_pctype; 
#line 599
int _locale_mb_cur_max; 
#line 600
unsigned _locale_lc_codepage; 
#line 601
} __crt_locale_data_public; 
#line 607
typedef 
#line 603
struct __crt_locale_pointers { 
#line 605
struct __crt_locale_data *locinfo; 
#line 606
struct __crt_multibyte_data *mbcinfo; 
#line 607
} __crt_locale_pointers; 
#line 609
typedef __crt_locale_pointers *_locale_t; 
#line 615
typedef 
#line 611
struct _Mbstatet { 
#line 613
unsigned long _Wchar; 
#line 614
unsigned short _Byte, _State; 
#line 615
} _Mbstatet; 
#line 617
typedef _Mbstatet mbstate_t; 
#line 631 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
typedef __time64_t time_t; 
#line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
typedef size_t rsize_t; 
#line 2058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
}__pragma( pack ( pop )) 
#line 2061
#pragma warning(pop)
#pragma external_header(pop)
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#pragma external_header(pop)
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#if 0
#line 68
enum cudaRoundMode { 
#line 70
cudaRoundNearest, 
#line 71
cudaRoundZero, 
#line 72
cudaRoundPosInf, 
#line 73
cudaRoundMinInf
#line 74
}; 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 100
struct char1 { 
#line 102
signed char x; 
#line 103
}; 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 105
struct uchar1 { 
#line 107
unsigned char x; 
#line 108
}; 
#endif
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 111
struct __declspec(align(2)) char2 { 
#line 113
signed char x, y; 
#line 114
}; 
#endif
#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 116
struct __declspec(align(2)) uchar2 { 
#line 118
unsigned char x, y; 
#line 119
}; 
#endif
#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 121
struct char3 { 
#line 123
signed char x, y, z; 
#line 124
}; 
#endif
#line 126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 126
struct uchar3 { 
#line 128
unsigned char x, y, z; 
#line 129
}; 
#endif
#line 131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 131
struct __declspec(align(4)) char4 { 
#line 133
signed char x, y, z, w; 
#line 134
}; 
#endif
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 136
struct __declspec(align(4)) uchar4 { 
#line 138
unsigned char x, y, z, w; 
#line 139
}; 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 141
struct short1 { 
#line 143
short x; 
#line 144
}; 
#endif
#line 146 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 146
struct ushort1 { 
#line 148
unsigned short x; 
#line 149
}; 
#endif
#line 151 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 151
struct __declspec(align(4)) short2 { 
#line 153
short x, y; 
#line 154
}; 
#endif
#line 156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 156
struct __declspec(align(4)) ushort2 { 
#line 158
unsigned short x, y; 
#line 159
}; 
#endif
#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 161
struct short3 { 
#line 163
short x, y, z; 
#line 164
}; 
#endif
#line 166 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 166
struct ushort3 { 
#line 168
unsigned short x, y, z; 
#line 169
}; 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 171
struct __declspec(align(8)) short4 { short x; short y; short z; short w; }; 
#endif
#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 172
struct __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
#line 174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 174
struct int1 { 
#line 176
int x; 
#line 177
}; 
#endif
#line 179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 179
struct uint1 { 
#line 181
unsigned x; 
#line 182
}; 
#endif
#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 184
struct __declspec(align(8)) int2 { int x; int y; }; 
#endif
#line 185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 185
struct __declspec(align(8)) uint2 { unsigned x; unsigned y; }; 
#endif
#line 187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 187
struct int3 { 
#line 189
int x, y, z; 
#line 190
}; 
#endif
#line 192 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 192
struct uint3 { 
#line 194
unsigned x, y, z; 
#line 195
}; 
#endif
#line 197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 197
struct __declspec(align(16)) int4 { 
#line 199
int x, y, z, w; 
#line 200
}; 
#endif
#line 202 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 202
struct __declspec(align(16)) uint4 { 
#line 204
unsigned x, y, z, w; 
#line 205
}; 
#endif
#line 207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 207
struct long1 { 
#line 209
long x; 
#line 210
}; 
#endif
#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 212
struct ulong1 { 
#line 214
unsigned long x; 
#line 215
}; 
#endif
#line 218 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 218
struct __declspec(align(8)) long2 { long x; long y; }; 
#endif
#line 219 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 219
struct __declspec(align(8)) ulong2 { unsigned long x; unsigned long y; }; 
#endif
#line 234 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 234
struct long3 { 
#line 236
long x, y, z; 
#line 237
}; 
#endif
#line 239 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 239
struct ulong3 { 
#line 241
unsigned long x, y, z; 
#line 242
}; 
#endif
#line 244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 244
struct __declspec(align(16)) long4 { 
#line 246
long x, y, z, w; 
#line 247
}; 
#endif
#line 249 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 249
struct __declspec(align(16)) ulong4 { 
#line 251
unsigned long x, y, z, w; 
#line 252
}; 
#endif
#line 254 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 254
struct float1 { 
#line 256
float x; 
#line 257
}; 
#endif
#line 276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 276
struct __declspec(align(8)) float2 { float x; float y; }; 
#endif
#line 281 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 281
struct float3 { 
#line 283
float x, y, z; 
#line 284
}; 
#endif
#line 286 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 286
struct __declspec(align(16)) float4 { 
#line 288
float x, y, z, w; 
#line 289
}; 
#endif
#line 291 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 291
struct longlong1 { 
#line 293
__int64 x; 
#line 294
}; 
#endif
#line 296 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 296
struct ulonglong1 { 
#line 298
unsigned __int64 x; 
#line 299
}; 
#endif
#line 301 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 301
struct __declspec(align(16)) longlong2 { 
#line 303
__int64 x, y; 
#line 304
}; 
#endif
#line 306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 306
struct __declspec(align(16)) ulonglong2 { 
#line 308
unsigned __int64 x, y; 
#line 309
}; 
#endif
#line 311 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 311
struct longlong3 { 
#line 313
__int64 x, y, z; 
#line 314
}; 
#endif
#line 316 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 316
struct ulonglong3 { 
#line 318
unsigned __int64 x, y, z; 
#line 319
}; 
#endif
#line 321 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 321
struct __declspec(align(16)) longlong4 { 
#line 323
__int64 x, y, z, w; 
#line 324
}; 
#endif
#line 326 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 326
struct __declspec(align(16)) ulonglong4 { 
#line 328
unsigned __int64 x, y, z, w; 
#line 329
}; 
#endif
#line 331 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 331
struct double1 { 
#line 333
double x; 
#line 334
}; 
#endif
#line 336 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 336
struct __declspec(align(16)) double2 { 
#line 338
double x, y; 
#line 339
}; 
#endif
#line 341 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 341
struct double3 { 
#line 343
double x, y, z; 
#line 344
}; 
#endif
#line 346 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 346
struct __declspec(align(16)) double4 { 
#line 348
double x, y, z, w; 
#line 349
}; 
#endif
#line 363 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef char1 
#line 363
char1; 
#endif
#line 364 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef uchar1 
#line 364
uchar1; 
#endif
#line 365 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef char2 
#line 365
char2; 
#endif
#line 366 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef uchar2 
#line 366
uchar2; 
#endif
#line 367 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef char3 
#line 367
char3; 
#endif
#line 368 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef uchar3 
#line 368
uchar3; 
#endif
#line 369 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef char4 
#line 369
char4; 
#endif
#line 370 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef uchar4 
#line 370
uchar4; 
#endif
#line 371 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef short1 
#line 371
short1; 
#endif
#line 372 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ushort1 
#line 372
ushort1; 
#endif
#line 373 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef short2 
#line 373
short2; 
#endif
#line 374 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ushort2 
#line 374
ushort2; 
#endif
#line 375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef short3 
#line 375
short3; 
#endif
#line 376 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ushort3 
#line 376
ushort3; 
#endif
#line 377 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef short4 
#line 377
short4; 
#endif
#line 378 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ushort4 
#line 378
ushort4; 
#endif
#line 379 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef int1 
#line 379
int1; 
#endif
#line 380 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef uint1 
#line 380
uint1; 
#endif
#line 381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef int2 
#line 381
int2; 
#endif
#line 382 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef uint2 
#line 382
uint2; 
#endif
#line 383 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef int3 
#line 383
int3; 
#endif
#line 384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef uint3 
#line 384
uint3; 
#endif
#line 385 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef int4 
#line 385
int4; 
#endif
#line 386 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef uint4 
#line 386
uint4; 
#endif
#line 387 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef long1 
#line 387
long1; 
#endif
#line 388 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ulong1 
#line 388
ulong1; 
#endif
#line 389 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef long2 
#line 389
long2; 
#endif
#line 390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ulong2 
#line 390
ulong2; 
#endif
#line 391 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef long3 
#line 391
long3; 
#endif
#line 392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ulong3 
#line 392
ulong3; 
#endif
#line 393 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef long4 
#line 393
long4; 
#endif
#line 394 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ulong4 
#line 394
ulong4; 
#endif
#line 395 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef float1 
#line 395
float1; 
#endif
#line 396 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef float2 
#line 396
float2; 
#endif
#line 397 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef float3 
#line 397
float3; 
#endif
#line 398 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef float4 
#line 398
float4; 
#endif
#line 399 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef longlong1 
#line 399
longlong1; 
#endif
#line 400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ulonglong1 
#line 400
ulonglong1; 
#endif
#line 401 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef longlong2 
#line 401
longlong2; 
#endif
#line 402 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ulonglong2 
#line 402
ulonglong2; 
#endif
#line 403 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef longlong3 
#line 403
longlong3; 
#endif
#line 404 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ulonglong3 
#line 404
ulonglong3; 
#endif
#line 405 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef longlong4 
#line 405
longlong4; 
#endif
#line 406 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef ulonglong4 
#line 406
ulonglong4; 
#endif
#line 407 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef double1 
#line 407
double1; 
#endif
#line 408 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef double2 
#line 408
double2; 
#endif
#line 409 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef double3 
#line 409
double3; 
#endif
#line 410 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef double4 
#line 410
double4; 
#endif
#line 418 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
#line 418
struct dim3 { 
#line 420
unsigned x, y, z; 
#line 432 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
}; 
#endif
#line 434 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#if 0
typedef dim3 
#line 434
dim3; 
#endif
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 16
__pragma( pack ( push, 8 )) extern "C" {
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits.h"
}__pragma( pack ( pop )) 
#line 78
#pragma warning(pop)
#pragma external_header(pop)
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 23
namespace std { 
#line 25
typedef decltype(nullptr) nullptr_t; 
#line 26
}
#line 28
using std::nullptr_t;
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"
int *__cdecl _errno(); 
#line 38
errno_t __cdecl _set_errno(int _Value); 
#line 39
errno_t __cdecl _get_errno(int * _Value); 
#line 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"
extern unsigned long __cdecl __threadid(); 
#line 57
extern uintptr_t __cdecl __threadhandle(); 
#line 61
}__pragma( pack ( pop )) 
#line 63
#pragma warning(pop)
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"
#pragma external_header(pop)
#line 202 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 202
enum cudaError { 
#line 209
cudaSuccess, 
#line 215
cudaErrorInvalidValue, 
#line 221
cudaErrorMemoryAllocation, 
#line 227
cudaErrorInitializationError, 
#line 234
cudaErrorCudartUnloading, 
#line 241
cudaErrorProfilerDisabled, 
#line 249
cudaErrorProfilerNotInitialized, 
#line 256
cudaErrorProfilerAlreadyStarted, 
#line 263
cudaErrorProfilerAlreadyStopped, 
#line 272
cudaErrorInvalidConfiguration, 
#line 278
cudaErrorInvalidPitchValue = 12, 
#line 284
cudaErrorInvalidSymbol, 
#line 292
cudaErrorInvalidHostPointer = 16, 
#line 300
cudaErrorInvalidDevicePointer, 
#line 306
cudaErrorInvalidTexture, 
#line 312
cudaErrorInvalidTextureBinding, 
#line 319
cudaErrorInvalidChannelDescriptor, 
#line 325
cudaErrorInvalidMemcpyDirection, 
#line 335
cudaErrorAddressOfConstant, 
#line 344
cudaErrorTextureFetchFailed, 
#line 353
cudaErrorTextureNotBound, 
#line 362
cudaErrorSynchronizationError, 
#line 368
cudaErrorInvalidFilterSetting, 
#line 374
cudaErrorInvalidNormSetting, 
#line 382
cudaErrorMixedDeviceExecution, 
#line 390
cudaErrorNotYetImplemented = 31, 
#line 399
cudaErrorMemoryValueTooLarge, 
#line 406
cudaErrorStubLibrary = 34, 
#line 413
cudaErrorInsufficientDriver, 
#line 420
cudaErrorCallRequiresNewerDriver, 
#line 426
cudaErrorInvalidSurface, 
#line 432
cudaErrorDuplicateVariableName = 43, 
#line 438
cudaErrorDuplicateTextureName, 
#line 444
cudaErrorDuplicateSurfaceName, 
#line 454
cudaErrorDevicesUnavailable, 
#line 467
cudaErrorIncompatibleDriverContext = 49, 
#line 473
cudaErrorMissingConfiguration = 52, 
#line 482
cudaErrorPriorLaunchFailure, 
#line 489
cudaErrorLaunchMaxDepthExceeded = 65, 
#line 497
cudaErrorLaunchFileScopedTex, 
#line 505
cudaErrorLaunchFileScopedSurf, 
#line 520
cudaErrorSyncDepthExceeded, 
#line 532
cudaErrorLaunchPendingCountExceeded, 
#line 538
cudaErrorInvalidDeviceFunction = 98, 
#line 544
cudaErrorNoDevice = 100, 
#line 551
cudaErrorInvalidDevice, 
#line 556
cudaErrorDeviceNotLicensed, 
#line 565
cudaErrorSoftwareValidityNotEstablished, 
#line 570
cudaErrorStartupFailure = 127, 
#line 575
cudaErrorInvalidKernelImage = 200, 
#line 585
cudaErrorDeviceUninitialized, 
#line 590
cudaErrorMapBufferObjectFailed = 205, 
#line 595
cudaErrorUnmapBufferObjectFailed, 
#line 601
cudaErrorArrayIsMapped, 
#line 606
cudaErrorAlreadyMapped, 
#line 614
cudaErrorNoKernelImageForDevice, 
#line 619
cudaErrorAlreadyAcquired, 
#line 624
cudaErrorNotMapped, 
#line 630
cudaErrorNotMappedAsArray, 
#line 636
cudaErrorNotMappedAsPointer, 
#line 642
cudaErrorECCUncorrectable, 
#line 648
cudaErrorUnsupportedLimit, 
#line 654
cudaErrorDeviceAlreadyInUse, 
#line 660
cudaErrorPeerAccessUnsupported, 
#line 666
cudaErrorInvalidPtx, 
#line 671
cudaErrorInvalidGraphicsContext, 
#line 677
cudaErrorNvlinkUncorrectable, 
#line 684
cudaErrorJitCompilerNotFound, 
#line 691
cudaErrorUnsupportedPtxVersion, 
#line 698
cudaErrorJitCompilationDisabled, 
#line 703
cudaErrorUnsupportedExecAffinity, 
#line 708
cudaErrorInvalidSource = 300, 
#line 713
cudaErrorFileNotFound, 
#line 718
cudaErrorSharedObjectSymbolNotFound, 
#line 723
cudaErrorSharedObjectInitFailed, 
#line 728
cudaErrorOperatingSystem, 
#line 735
cudaErrorInvalidResourceHandle = 400, 
#line 741
cudaErrorIllegalState, 
#line 748
cudaErrorSymbolNotFound = 500, 
#line 756
cudaErrorNotReady = 600, 
#line 764
cudaErrorIllegalAddress = 700, 
#line 773
cudaErrorLaunchOutOfResources, 
#line 784
cudaErrorLaunchTimeout, 
#line 790
cudaErrorLaunchIncompatibleTexturing, 
#line 797
cudaErrorPeerAccessAlreadyEnabled, 
#line 804
cudaErrorPeerAccessNotEnabled, 
#line 817
cudaErrorSetOnActiveProcess = 708, 
#line 824
cudaErrorContextIsDestroyed, 
#line 831
cudaErrorAssert, 
#line 838
cudaErrorTooManyPeers, 
#line 844
cudaErrorHostMemoryAlreadyRegistered, 
#line 850
cudaErrorHostMemoryNotRegistered, 
#line 859
cudaErrorHardwareStackError, 
#line 867
cudaErrorIllegalInstruction, 
#line 876
cudaErrorMisalignedAddress, 
#line 887
cudaErrorInvalidAddressSpace, 
#line 895
cudaErrorInvalidPc, 
#line 906
cudaErrorLaunchFailure, 
#line 915
cudaErrorCooperativeLaunchTooLarge, 
#line 920
cudaErrorNotPermitted = 800, 
#line 926
cudaErrorNotSupported, 
#line 935
cudaErrorSystemNotReady, 
#line 942
cudaErrorSystemDriverMismatch, 
#line 951
cudaErrorCompatNotSupportedOnDevice, 
#line 956
cudaErrorMpsConnectionFailed, 
#line 961
cudaErrorMpsRpcFailure, 
#line 967
cudaErrorMpsServerNotReady, 
#line 972
cudaErrorMpsMaxClientsReached, 
#line 977
cudaErrorMpsMaxConnectionsReached, 
#line 982
cudaErrorMpsClientTerminated, 
#line 987
cudaErrorStreamCaptureUnsupported = 900, 
#line 993
cudaErrorStreamCaptureInvalidated, 
#line 999
cudaErrorStreamCaptureMerge, 
#line 1004
cudaErrorStreamCaptureUnmatched, 
#line 1010
cudaErrorStreamCaptureUnjoined, 
#line 1017
cudaErrorStreamCaptureIsolation, 
#line 1023
cudaErrorStreamCaptureImplicit, 
#line 1029
cudaErrorCapturedEvent, 
#line 1036
cudaErrorStreamCaptureWrongThread, 
#line 1041
cudaErrorTimeout, 
#line 1047
cudaErrorGraphExecUpdateFailure, 
#line 1057
cudaErrorExternalDevice, 
#line 1063
cudaErrorInvalidClusterSize, 
#line 1068
cudaErrorUnknown = 999, 
#line 1076
cudaErrorApiFailureBase = 10000
#line 1077
}; 
#endif
#line 1082 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1082
enum cudaChannelFormatKind { 
#line 1084
cudaChannelFormatKindSigned, 
#line 1085
cudaChannelFormatKindUnsigned, 
#line 1086
cudaChannelFormatKindFloat, 
#line 1087
cudaChannelFormatKindNone, 
#line 1088
cudaChannelFormatKindNV12, 
#line 1089
cudaChannelFormatKindUnsignedNormalized8X1, 
#line 1090
cudaChannelFormatKindUnsignedNormalized8X2, 
#line 1091
cudaChannelFormatKindUnsignedNormalized8X4, 
#line 1092
cudaChannelFormatKindUnsignedNormalized16X1, 
#line 1093
cudaChannelFormatKindUnsignedNormalized16X2, 
#line 1094
cudaChannelFormatKindUnsignedNormalized16X4, 
#line 1095
cudaChannelFormatKindSignedNormalized8X1, 
#line 1096
cudaChannelFormatKindSignedNormalized8X2, 
#line 1097
cudaChannelFormatKindSignedNormalized8X4, 
#line 1098
cudaChannelFormatKindSignedNormalized16X1, 
#line 1099
cudaChannelFormatKindSignedNormalized16X2, 
#line 1100
cudaChannelFormatKindSignedNormalized16X4, 
#line 1101
cudaChannelFormatKindUnsignedBlockCompressed1, 
#line 1102
cudaChannelFormatKindUnsignedBlockCompressed1SRGB, 
#line 1103
cudaChannelFormatKindUnsignedBlockCompressed2, 
#line 1104
cudaChannelFormatKindUnsignedBlockCompressed2SRGB, 
#line 1105
cudaChannelFormatKindUnsignedBlockCompressed3, 
#line 1106
cudaChannelFormatKindUnsignedBlockCompressed3SRGB, 
#line 1107
cudaChannelFormatKindUnsignedBlockCompressed4, 
#line 1108
cudaChannelFormatKindSignedBlockCompressed4, 
#line 1109
cudaChannelFormatKindUnsignedBlockCompressed5, 
#line 1110
cudaChannelFormatKindSignedBlockCompressed5, 
#line 1111
cudaChannelFormatKindUnsignedBlockCompressed6H, 
#line 1112
cudaChannelFormatKindSignedBlockCompressed6H, 
#line 1113
cudaChannelFormatKindUnsignedBlockCompressed7, 
#line 1114
cudaChannelFormatKindUnsignedBlockCompressed7SRGB
#line 1115
}; 
#endif
#line 1120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1120
struct cudaChannelFormatDesc { 
#line 1122
int x; 
#line 1123
int y; 
#line 1124
int z; 
#line 1125
int w; 
#line 1126
cudaChannelFormatKind f; 
#line 1127
}; 
#endif
#line 1132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
typedef struct cudaArray *cudaArray_t; 
#line 1137
typedef const cudaArray *cudaArray_const_t; 
#line 1139
struct cudaArray; 
#line 1144
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
#line 1149
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
#line 1151
struct cudaMipmappedArray; 
#line 1161
#if 0
#line 1161
struct cudaArraySparseProperties { 
#line 1162
struct { 
#line 1163
unsigned width; 
#line 1164
unsigned height; 
#line 1165
unsigned depth; 
#line 1166
} tileExtent; 
#line 1167
unsigned miptailFirstLevel; 
#line 1168
unsigned __int64 miptailSize; 
#line 1169
unsigned flags; 
#line 1170
unsigned reserved[4]; 
#line 1171
}; 
#endif
#line 1176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1176
struct cudaArrayMemoryRequirements { 
#line 1177
size_t size; 
#line 1178
size_t alignment; 
#line 1179
unsigned reserved[4]; 
#line 1180
}; 
#endif
#line 1185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1185
enum cudaMemoryType { 
#line 1187
cudaMemoryTypeUnregistered, 
#line 1188
cudaMemoryTypeHost, 
#line 1189
cudaMemoryTypeDevice, 
#line 1190
cudaMemoryTypeManaged
#line 1191
}; 
#endif
#line 1196 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1196
enum cudaMemcpyKind { 
#line 1198
cudaMemcpyHostToHost, 
#line 1199
cudaMemcpyHostToDevice, 
#line 1200
cudaMemcpyDeviceToHost, 
#line 1201
cudaMemcpyDeviceToDevice, 
#line 1202
cudaMemcpyDefault
#line 1203
}; 
#endif
#line 1210 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1210
struct cudaPitchedPtr { 
#line 1212
void *ptr; 
#line 1213
size_t pitch; 
#line 1214
size_t xsize; 
#line 1215
size_t ysize; 
#line 1216
}; 
#endif
#line 1223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1223
struct cudaExtent { 
#line 1225
size_t width; 
#line 1226
size_t height; 
#line 1227
size_t depth; 
#line 1228
}; 
#endif
#line 1235 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1235
struct cudaPos { 
#line 1237
size_t x; 
#line 1238
size_t y; 
#line 1239
size_t z; 
#line 1240
}; 
#endif
#line 1245 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1245
struct cudaMemcpy3DParms { 
#line 1247
cudaArray_t srcArray; 
#line 1248
cudaPos srcPos; 
#line 1249
cudaPitchedPtr srcPtr; 
#line 1251
cudaArray_t dstArray; 
#line 1252
cudaPos dstPos; 
#line 1253
cudaPitchedPtr dstPtr; 
#line 1255
cudaExtent extent; 
#line 1256
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1257
}; 
#endif
#line 1262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1262
struct cudaMemcpy3DPeerParms { 
#line 1264
cudaArray_t srcArray; 
#line 1265
cudaPos srcPos; 
#line 1266
cudaPitchedPtr srcPtr; 
#line 1267
int srcDevice; 
#line 1269
cudaArray_t dstArray; 
#line 1270
cudaPos dstPos; 
#line 1271
cudaPitchedPtr dstPtr; 
#line 1272
int dstDevice; 
#line 1274
cudaExtent extent; 
#line 1275
}; 
#endif
#line 1280 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1280
struct cudaMemsetParams { 
#line 1281
void *dst; 
#line 1282
size_t pitch; 
#line 1283
unsigned value; 
#line 1284
unsigned elementSize; 
#line 1285
size_t width; 
#line 1286
size_t height; 
#line 1287
}; 
#endif
#line 1292 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1292
enum cudaAccessProperty { 
#line 1293
cudaAccessPropertyNormal, 
#line 1294
cudaAccessPropertyStreaming, 
#line 1295
cudaAccessPropertyPersisting
#line 1296
}; 
#endif
#line 1309 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1309
struct cudaAccessPolicyWindow { 
#line 1310
void *base_ptr; 
#line 1311
size_t num_bytes; 
#line 1312
float hitRatio; 
#line 1313
cudaAccessProperty hitProp; 
#line 1314
cudaAccessProperty missProp; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1315
}; 
#endif
#line 1327 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
typedef void (__stdcall *cudaHostFn_t)(void * userData); 
#line 1332
#if 0
#line 1332
struct cudaHostNodeParams { 
#line 1333
cudaHostFn_t fn; 
#line 1334
void *userData; 
#line 1335
}; 
#endif
#line 1340 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1340
enum cudaStreamCaptureStatus { 
#line 1341
cudaStreamCaptureStatusNone, 
#line 1342
cudaStreamCaptureStatusActive, 
#line 1343
cudaStreamCaptureStatusInvalidated
#line 1345
}; 
#endif
#line 1351 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1351
enum cudaStreamCaptureMode { 
#line 1352
cudaStreamCaptureModeGlobal, 
#line 1353
cudaStreamCaptureModeThreadLocal, 
#line 1354
cudaStreamCaptureModeRelaxed
#line 1355
}; 
#endif
#line 1357 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1357
enum cudaSynchronizationPolicy { 
#line 1358
cudaSyncPolicyAuto = 1, 
#line 1359
cudaSyncPolicySpin, 
#line 1360
cudaSyncPolicyYield, 
#line 1361
cudaSyncPolicyBlockingSync
#line 1362
}; 
#endif
#line 1367 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1367
enum cudaClusterSchedulingPolicy { 
#line 1368
cudaClusterSchedulingPolicyDefault, 
#line 1369
cudaClusterSchedulingPolicySpread, 
#line 1370
cudaClusterSchedulingPolicyLoadBalancing
#line 1371
}; 
#endif
#line 1376 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1376
enum cudaStreamUpdateCaptureDependenciesFlags { 
#line 1377
cudaStreamAddCaptureDependencies, 
#line 1378
cudaStreamSetCaptureDependencies
#line 1379
}; 
#endif
#line 1384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1384
enum cudaUserObjectFlags { 
#line 1385
cudaUserObjectNoDestructorSync = 1
#line 1386
}; 
#endif
#line 1391 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1391
enum cudaUserObjectRetainFlags { 
#line 1392
cudaGraphUserObjectMove = 1
#line 1393
}; 
#endif
#line 1398 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
struct cudaGraphicsResource; 
#line 1403
#if 0
#line 1403
enum cudaGraphicsRegisterFlags { 
#line 1405
cudaGraphicsRegisterFlagsNone, 
#line 1406
cudaGraphicsRegisterFlagsReadOnly, 
#line 1407
cudaGraphicsRegisterFlagsWriteDiscard, 
#line 1408
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
#line 1409
cudaGraphicsRegisterFlagsTextureGather = 8
#line 1410
}; 
#endif
#line 1415 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1415
enum cudaGraphicsMapFlags { 
#line 1417
cudaGraphicsMapFlagsNone, 
#line 1418
cudaGraphicsMapFlagsReadOnly, 
#line 1419
cudaGraphicsMapFlagsWriteDiscard
#line 1420
}; 
#endif
#line 1425 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1425
enum cudaGraphicsCubeFace { 
#line 1427
cudaGraphicsCubeFacePositiveX, 
#line 1428
cudaGraphicsCubeFaceNegativeX, 
#line 1429
cudaGraphicsCubeFacePositiveY, 
#line 1430
cudaGraphicsCubeFaceNegativeY, 
#line 1431
cudaGraphicsCubeFacePositiveZ, 
#line 1432
cudaGraphicsCubeFaceNegativeZ
#line 1433
}; 
#endif
#line 1438 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1438
enum cudaResourceType { 
#line 1440
cudaResourceTypeArray, 
#line 1441
cudaResourceTypeMipmappedArray, 
#line 1442
cudaResourceTypeLinear, 
#line 1443
cudaResourceTypePitch2D
#line 1444
}; 
#endif
#line 1449 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1449
enum cudaResourceViewFormat { 
#line 1451
cudaResViewFormatNone, 
#line 1452
cudaResViewFormatUnsignedChar1, 
#line 1453
cudaResViewFormatUnsignedChar2, 
#line 1454
cudaResViewFormatUnsignedChar4, 
#line 1455
cudaResViewFormatSignedChar1, 
#line 1456
cudaResViewFormatSignedChar2, 
#line 1457
cudaResViewFormatSignedChar4, 
#line 1458
cudaResViewFormatUnsignedShort1, 
#line 1459
cudaResViewFormatUnsignedShort2, 
#line 1460
cudaResViewFormatUnsignedShort4, 
#line 1461
cudaResViewFormatSignedShort1, 
#line 1462
cudaResViewFormatSignedShort2, 
#line 1463
cudaResViewFormatSignedShort4, 
#line 1464
cudaResViewFormatUnsignedInt1, 
#line 1465
cudaResViewFormatUnsignedInt2, 
#line 1466
cudaResViewFormatUnsignedInt4, 
#line 1467
cudaResViewFormatSignedInt1, 
#line 1468
cudaResViewFormatSignedInt2, 
#line 1469
cudaResViewFormatSignedInt4, 
#line 1470
cudaResViewFormatHalf1, 
#line 1471
cudaResViewFormatHalf2, 
#line 1472
cudaResViewFormatHalf4, 
#line 1473
cudaResViewFormatFloat1, 
#line 1474
cudaResViewFormatFloat2, 
#line 1475
cudaResViewFormatFloat4, 
#line 1476
cudaResViewFormatUnsignedBlockCompressed1, 
#line 1477
cudaResViewFormatUnsignedBlockCompressed2, 
#line 1478
cudaResViewFormatUnsignedBlockCompressed3, 
#line 1479
cudaResViewFormatUnsignedBlockCompressed4, 
#line 1480
cudaResViewFormatSignedBlockCompressed4, 
#line 1481
cudaResViewFormatUnsignedBlockCompressed5, 
#line 1482
cudaResViewFormatSignedBlockCompressed5, 
#line 1483
cudaResViewFormatUnsignedBlockCompressed6H, 
#line 1484
cudaResViewFormatSignedBlockCompressed6H, 
#line 1485
cudaResViewFormatUnsignedBlockCompressed7
#line 1486
}; 
#endif
#line 1491 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1491
struct cudaResourceDesc { 
#line 1492
cudaResourceType resType; 
#line 1494
union { 
#line 1495
struct { 
#line 1496
cudaArray_t array; 
#line 1497
} array; 
#line 1498
struct { 
#line 1499
cudaMipmappedArray_t mipmap; 
#line 1500
} mipmap; 
#line 1501
struct { 
#line 1502
void *devPtr; 
#line 1503
cudaChannelFormatDesc desc; 
#line 1504
size_t sizeInBytes; 
#line 1505
} linear; 
#line 1506
struct { 
#line 1507
void *devPtr; 
#line 1508
cudaChannelFormatDesc desc; 
#line 1509
size_t width; 
#line 1510
size_t height; 
#line 1511
size_t pitchInBytes; 
#line 1512
} pitch2D; 
#line 1513
} res; 
#line 1514
}; 
#endif
#line 1519 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1519
struct cudaResourceViewDesc { 
#line 1521
cudaResourceViewFormat format; 
#line 1522
size_t width; 
#line 1523
size_t height; 
#line 1524
size_t depth; 
#line 1525
unsigned firstMipmapLevel; 
#line 1526
unsigned lastMipmapLevel; 
#line 1527
unsigned firstLayer; 
#line 1528
unsigned lastLayer; 
#line 1529
}; 
#endif
#line 1534 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1534
struct cudaPointerAttributes { 
#line 1540
cudaMemoryType type; 
#line 1551
int device; 
#line 1557
void *devicePointer; 
#line 1566
void *hostPointer; 
#line 1567
}; 
#endif
#line 1572 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1572
struct cudaFuncAttributes { 
#line 1579
size_t sharedSizeBytes; 
#line 1585
size_t constSizeBytes; 
#line 1590
size_t localSizeBytes; 
#line 1597
int maxThreadsPerBlock; 
#line 1602
int numRegs; 
#line 1609
int ptxVersion; 
#line 1616
int binaryVersion; 
#line 1622
int cacheModeCA; 
#line 1629
int maxDynamicSharedSizeBytes; 
#line 1638
int preferredShmemCarveout; 
#line 1639
}; 
#endif
#line 1644 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1644
enum cudaFuncAttribute { 
#line 1646
cudaFuncAttributeMaxDynamicSharedMemorySize = 8, 
#line 1647
cudaFuncAttributePreferredSharedMemoryCarveout, 
#line 1648
cudaFuncAttributeClusterDimMustBeSet, 
#line 1649
cudaFuncAttributeRequiredClusterWidth, 
#line 1650
cudaFuncAttributeRequiredClusterHeight, 
#line 1651
cudaFuncAttributeRequiredClusterDepth, 
#line 1652
cudaFuncAttributeNonPortableClusterSizeAllowed, 
#line 1653
cudaFuncAttributeClusterSchedulingPolicyPreference, 
#line 1654
cudaFuncAttributeMax
#line 1655
}; 
#endif
#line 1660 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1660
enum cudaFuncCache { 
#line 1662
cudaFuncCachePreferNone, 
#line 1663
cudaFuncCachePreferShared, 
#line 1664
cudaFuncCachePreferL1, 
#line 1665
cudaFuncCachePreferEqual
#line 1666
}; 
#endif
#line 1672 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1672
enum cudaSharedMemConfig { 
#line 1674
cudaSharedMemBankSizeDefault, 
#line 1675
cudaSharedMemBankSizeFourByte, 
#line 1676
cudaSharedMemBankSizeEightByte
#line 1677
}; 
#endif
#line 1682 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1682
enum cudaSharedCarveout { 
#line 1683
cudaSharedmemCarveoutDefault = (-1), 
#line 1684
cudaSharedmemCarveoutMaxShared = 100, 
#line 1685
cudaSharedmemCarveoutMaxL1 = 0
#line 1686
}; 
#endif
#line 1691 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1691
enum cudaComputeMode { 
#line 1693
cudaComputeModeDefault, 
#line 1694
cudaComputeModeExclusive, 
#line 1695
cudaComputeModeProhibited, 
#line 1696
cudaComputeModeExclusiveProcess
#line 1697
}; 
#endif
#line 1702 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1702
enum cudaLimit { 
#line 1704
cudaLimitStackSize, 
#line 1705
cudaLimitPrintfFifoSize, 
#line 1706
cudaLimitMallocHeapSize, 
#line 1707
cudaLimitDevRuntimeSyncDepth, 
#line 1708
cudaLimitDevRuntimePendingLaunchCount, 
#line 1709
cudaLimitMaxL2FetchGranularity, 
#line 1710
cudaLimitPersistingL2CacheSize
#line 1711
}; 
#endif
#line 1716 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1716
enum cudaMemoryAdvise { 
#line 1718
cudaMemAdviseSetReadMostly = 1, 
#line 1719
cudaMemAdviseUnsetReadMostly, 
#line 1720
cudaMemAdviseSetPreferredLocation, 
#line 1721
cudaMemAdviseUnsetPreferredLocation, 
#line 1722
cudaMemAdviseSetAccessedBy, 
#line 1723
cudaMemAdviseUnsetAccessedBy
#line 1724
}; 
#endif
#line 1729 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1729
enum cudaMemRangeAttribute { 
#line 1731
cudaMemRangeAttributeReadMostly = 1, 
#line 1732
cudaMemRangeAttributePreferredLocation, 
#line 1733
cudaMemRangeAttributeAccessedBy, 
#line 1734
cudaMemRangeAttributeLastPrefetchLocation
#line 1735
}; 
#endif
#line 1740 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1740
enum cudaOutputMode { 
#line 1742
cudaKeyValuePair, 
#line 1743
cudaCSV
#line 1744
}; 
#endif
#line 1749 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1749
enum cudaFlushGPUDirectRDMAWritesOptions { 
#line 1750
cudaFlushGPUDirectRDMAWritesOptionHost = (1 << 0), 
#line 1751
cudaFlushGPUDirectRDMAWritesOptionMemOps
#line 1752
}; 
#endif
#line 1757 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1757
enum cudaGPUDirectRDMAWritesOrdering { 
#line 1758
cudaGPUDirectRDMAWritesOrderingNone, 
#line 1759
cudaGPUDirectRDMAWritesOrderingOwner = 100, 
#line 1760
cudaGPUDirectRDMAWritesOrderingAllDevices = 200
#line 1761
}; 
#endif
#line 1766 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1766
enum cudaFlushGPUDirectRDMAWritesScope { 
#line 1767
cudaFlushGPUDirectRDMAWritesToOwner = 100, 
#line 1768
cudaFlushGPUDirectRDMAWritesToAllDevices = 200
#line 1769
}; 
#endif
#line 1774 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1774
enum cudaFlushGPUDirectRDMAWritesTarget { 
#line 1775
cudaFlushGPUDirectRDMAWritesTargetCurrentDevice
#line 1776
}; 
#endif
#line 1782 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1782
enum cudaDeviceAttr { 
#line 1784
cudaDevAttrMaxThreadsPerBlock = 1, 
#line 1785
cudaDevAttrMaxBlockDimX, 
#line 1786
cudaDevAttrMaxBlockDimY, 
#line 1787
cudaDevAttrMaxBlockDimZ, 
#line 1788
cudaDevAttrMaxGridDimX, 
#line 1789
cudaDevAttrMaxGridDimY, 
#line 1790
cudaDevAttrMaxGridDimZ, 
#line 1791
cudaDevAttrMaxSharedMemoryPerBlock, 
#line 1792
cudaDevAttrTotalConstantMemory, 
#line 1793
cudaDevAttrWarpSize, 
#line 1794
cudaDevAttrMaxPitch, 
#line 1795
cudaDevAttrMaxRegistersPerBlock, 
#line 1796
cudaDevAttrClockRate, 
#line 1797
cudaDevAttrTextureAlignment, 
#line 1798
cudaDevAttrGpuOverlap, 
#line 1799
cudaDevAttrMultiProcessorCount, 
#line 1800
cudaDevAttrKernelExecTimeout, 
#line 1801
cudaDevAttrIntegrated, 
#line 1802
cudaDevAttrCanMapHostMemory, 
#line 1803
cudaDevAttrComputeMode, 
#line 1804
cudaDevAttrMaxTexture1DWidth, 
#line 1805
cudaDevAttrMaxTexture2DWidth, 
#line 1806
cudaDevAttrMaxTexture2DHeight, 
#line 1807
cudaDevAttrMaxTexture3DWidth, 
#line 1808
cudaDevAttrMaxTexture3DHeight, 
#line 1809
cudaDevAttrMaxTexture3DDepth, 
#line 1810
cudaDevAttrMaxTexture2DLayeredWidth, 
#line 1811
cudaDevAttrMaxTexture2DLayeredHeight, 
#line 1812
cudaDevAttrMaxTexture2DLayeredLayers, 
#line 1813
cudaDevAttrSurfaceAlignment, 
#line 1814
cudaDevAttrConcurrentKernels, 
#line 1815
cudaDevAttrEccEnabled, 
#line 1816
cudaDevAttrPciBusId, 
#line 1817
cudaDevAttrPciDeviceId, 
#line 1818
cudaDevAttrTccDriver, 
#line 1819
cudaDevAttrMemoryClockRate, 
#line 1820
cudaDevAttrGlobalMemoryBusWidth, 
#line 1821
cudaDevAttrL2CacheSize, 
#line 1822
cudaDevAttrMaxThreadsPerMultiProcessor, 
#line 1823
cudaDevAttrAsyncEngineCount, 
#line 1824
cudaDevAttrUnifiedAddressing, 
#line 1825
cudaDevAttrMaxTexture1DLayeredWidth, 
#line 1826
cudaDevAttrMaxTexture1DLayeredLayers, 
#line 1827
cudaDevAttrMaxTexture2DGatherWidth = 45, 
#line 1828
cudaDevAttrMaxTexture2DGatherHeight, 
#line 1829
cudaDevAttrMaxTexture3DWidthAlt, 
#line 1830
cudaDevAttrMaxTexture3DHeightAlt, 
#line 1831
cudaDevAttrMaxTexture3DDepthAlt, 
#line 1832
cudaDevAttrPciDomainId, 
#line 1833
cudaDevAttrTexturePitchAlignment, 
#line 1834
cudaDevAttrMaxTextureCubemapWidth, 
#line 1835
cudaDevAttrMaxTextureCubemapLayeredWidth, 
#line 1836
cudaDevAttrMaxTextureCubemapLayeredLayers, 
#line 1837
cudaDevAttrMaxSurface1DWidth, 
#line 1838
cudaDevAttrMaxSurface2DWidth, 
#line 1839
cudaDevAttrMaxSurface2DHeight, 
#line 1840
cudaDevAttrMaxSurface3DWidth, 
#line 1841
cudaDevAttrMaxSurface3DHeight, 
#line 1842
cudaDevAttrMaxSurface3DDepth, 
#line 1843
cudaDevAttrMaxSurface1DLayeredWidth, 
#line 1844
cudaDevAttrMaxSurface1DLayeredLayers, 
#line 1845
cudaDevAttrMaxSurface2DLayeredWidth, 
#line 1846
cudaDevAttrMaxSurface2DLayeredHeight, 
#line 1847
cudaDevAttrMaxSurface2DLayeredLayers, 
#line 1848
cudaDevAttrMaxSurfaceCubemapWidth, 
#line 1849
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
#line 1850
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
#line 1851
cudaDevAttrMaxTexture1DLinearWidth, 
#line 1852
cudaDevAttrMaxTexture2DLinearWidth, 
#line 1853
cudaDevAttrMaxTexture2DLinearHeight, 
#line 1854
cudaDevAttrMaxTexture2DLinearPitch, 
#line 1855
cudaDevAttrMaxTexture2DMipmappedWidth, 
#line 1856
cudaDevAttrMaxTexture2DMipmappedHeight, 
#line 1857
cudaDevAttrComputeCapabilityMajor, 
#line 1858
cudaDevAttrComputeCapabilityMinor, 
#line 1859
cudaDevAttrMaxTexture1DMipmappedWidth, 
#line 1860
cudaDevAttrStreamPrioritiesSupported, 
#line 1861
cudaDevAttrGlobalL1CacheSupported, 
#line 1862
cudaDevAttrLocalL1CacheSupported, 
#line 1863
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
#line 1864
cudaDevAttrMaxRegistersPerMultiprocessor, 
#line 1865
cudaDevAttrManagedMemory, 
#line 1866
cudaDevAttrIsMultiGpuBoard, 
#line 1867
cudaDevAttrMultiGpuBoardGroupID, 
#line 1868
cudaDevAttrHostNativeAtomicSupported, 
#line 1869
cudaDevAttrSingleToDoublePrecisionPerfRatio, 
#line 1870
cudaDevAttrPageableMemoryAccess, 
#line 1871
cudaDevAttrConcurrentManagedAccess, 
#line 1872
cudaDevAttrComputePreemptionSupported, 
#line 1873
cudaDevAttrCanUseHostPointerForRegisteredMem, 
#line 1874
cudaDevAttrReserved92, 
#line 1875
cudaDevAttrReserved93, 
#line 1876
cudaDevAttrReserved94, 
#line 1877
cudaDevAttrCooperativeLaunch, 
#line 1878
cudaDevAttrCooperativeMultiDeviceLaunch, 
#line 1879
cudaDevAttrMaxSharedMemoryPerBlockOptin, 
#line 1880
cudaDevAttrCanFlushRemoteWrites, 
#line 1881
cudaDevAttrHostRegisterSupported, 
#line 1882
cudaDevAttrPageableMemoryAccessUsesHostPageTables, 
#line 1883
cudaDevAttrDirectManagedMemAccessFromHost, 
#line 1884
cudaDevAttrMaxBlocksPerMultiprocessor = 106, 
#line 1885
cudaDevAttrMaxPersistingL2CacheSize = 108, 
#line 1886
cudaDevAttrMaxAccessPolicyWindowSize, 
#line 1887
cudaDevAttrReservedSharedMemoryPerBlock = 111, 
#line 1888
cudaDevAttrSparseCudaArraySupported, 
#line 1889
cudaDevAttrHostRegisterReadOnlySupported, 
#line 1890
cudaDevAttrTimelineSemaphoreInteropSupported, 
#line 1891
cudaDevAttrMaxTimelineSemaphoreInteropSupported = 114, 
#line 1892
cudaDevAttrMemoryPoolsSupported, 
#line 1893
cudaDevAttrGPUDirectRDMASupported, 
#line 1894
cudaDevAttrGPUDirectRDMAFlushWritesOptions, 
#line 1895
cudaDevAttrGPUDirectRDMAWritesOrdering, 
#line 1896
cudaDevAttrMemoryPoolSupportedHandleTypes, 
#line 1897
cudaDevAttrClusterLaunch, 
#line 1898
cudaDevAttrDeferredMappingCudaArraySupported, 
#line 1899
cudaDevAttrMax
#line 1900
}; 
#endif
#line 1905 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1905
enum cudaMemPoolAttr { 
#line 1915
cudaMemPoolReuseFollowEventDependencies = 1, 
#line 1922
cudaMemPoolReuseAllowOpportunistic, 
#line 1930
cudaMemPoolReuseAllowInternalDependencies, 
#line 1941
cudaMemPoolAttrReleaseThreshold, 
#line 1947
cudaMemPoolAttrReservedMemCurrent, 
#line 1954
cudaMemPoolAttrReservedMemHigh, 
#line 1960
cudaMemPoolAttrUsedMemCurrent, 
#line 1967
cudaMemPoolAttrUsedMemHigh
#line 1968
}; 
#endif
#line 1973 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1973
enum cudaMemLocationType { 
#line 1974
cudaMemLocationTypeInvalid, 
#line 1975
cudaMemLocationTypeDevice
#line 1976
}; 
#endif
#line 1983 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1983
struct cudaMemLocation { 
#line 1984
cudaMemLocationType type; 
#line 1985
int id; 
#line 1986
}; 
#endif
#line 1991 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 1991
enum cudaMemAccessFlags { 
#line 1992
cudaMemAccessFlagsProtNone, 
#line 1993
cudaMemAccessFlagsProtRead, 
#line 1994
cudaMemAccessFlagsProtReadWrite = 3
#line 1995
}; 
#endif
#line 2000 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2000
struct cudaMemAccessDesc { 
#line 2001
cudaMemLocation location; 
#line 2002
cudaMemAccessFlags flags; 
#line 2003
}; 
#endif
#line 2008 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2008
enum cudaMemAllocationType { 
#line 2009
cudaMemAllocationTypeInvalid, 
#line 2013
cudaMemAllocationTypePinned, 
#line 2014
cudaMemAllocationTypeMax = 2147483647
#line 2015
}; 
#endif
#line 2020 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2020
enum cudaMemAllocationHandleType { 
#line 2021
cudaMemHandleTypeNone, 
#line 2022
cudaMemHandleTypePosixFileDescriptor, 
#line 2023
cudaMemHandleTypeWin32, 
#line 2024
cudaMemHandleTypeWin32Kmt = 4
#line 2025
}; 
#endif
#line 2030 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2030
struct cudaMemPoolProps { 
#line 2031
cudaMemAllocationType allocType; 
#line 2032
cudaMemAllocationHandleType handleTypes; 
#line 2033
cudaMemLocation location; 
#line 2040
void *win32SecurityAttributes; 
#line 2041
unsigned char reserved[64]; 
#line 2042
}; 
#endif
#line 2047 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2047
struct cudaMemPoolPtrExportData { 
#line 2048
unsigned char reserved[64]; 
#line 2049
}; 
#endif
#line 2054 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2054
struct cudaMemAllocNodeParams { 
#line 2059
cudaMemPoolProps poolProps; 
#line 2060
const cudaMemAccessDesc *accessDescs; 
#line 2061
size_t accessDescCount; 
#line 2062
size_t bytesize; 
#line 2063
void *dptr; 
#line 2064
}; 
#endif
#line 2069 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2069
enum cudaGraphMemAttributeType { 
#line 2074
cudaGraphMemAttrUsedMemCurrent, 
#line 2081
cudaGraphMemAttrUsedMemHigh, 
#line 2088
cudaGraphMemAttrReservedMemCurrent, 
#line 2095
cudaGraphMemAttrReservedMemHigh
#line 2096
}; 
#endif
#line 2102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2102
enum cudaDeviceP2PAttr { 
#line 2103
cudaDevP2PAttrPerformanceRank = 1, 
#line 2104
cudaDevP2PAttrAccessSupported, 
#line 2105
cudaDevP2PAttrNativeAtomicSupported, 
#line 2106
cudaDevP2PAttrCudaArrayAccessSupported
#line 2107
}; 
#endif
#line 2114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2114
struct CUuuid_st { 
#line 2115
char bytes[16]; 
#line 2116
}; 
#endif
#line 2117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef CUuuid_st 
#line 2117
CUuuid; 
#endif
#line 2119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef CUuuid_st 
#line 2119
cudaUUID_t; 
#endif
#line 2124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2124
struct cudaDeviceProp { 
#line 2126
char name[256]; 
#line 2127
cudaUUID_t uuid; 
#line 2128
char luid[8]; 
#line 2129
unsigned luidDeviceNodeMask; 
#line 2130
size_t totalGlobalMem; 
#line 2131
size_t sharedMemPerBlock; 
#line 2132
int regsPerBlock; 
#line 2133
int warpSize; 
#line 2134
size_t memPitch; 
#line 2135
int maxThreadsPerBlock; 
#line 2136
int maxThreadsDim[3]; 
#line 2137
int maxGridSize[3]; 
#line 2138
int clockRate; 
#line 2139
size_t totalConstMem; 
#line 2140
int major; 
#line 2141
int minor; 
#line 2142
size_t textureAlignment; 
#line 2143
size_t texturePitchAlignment; 
#line 2144
int deviceOverlap; 
#line 2145
int multiProcessorCount; 
#line 2146
int kernelExecTimeoutEnabled; 
#line 2147
int integrated; 
#line 2148
int canMapHostMemory; 
#line 2149
int computeMode; 
#line 2150
int maxTexture1D; 
#line 2151
int maxTexture1DMipmap; 
#line 2152
int maxTexture1DLinear; 
#line 2153
int maxTexture2D[2]; 
#line 2154
int maxTexture2DMipmap[2]; 
#line 2155
int maxTexture2DLinear[3]; 
#line 2156
int maxTexture2DGather[2]; 
#line 2157
int maxTexture3D[3]; 
#line 2158
int maxTexture3DAlt[3]; 
#line 2159
int maxTextureCubemap; 
#line 2160
int maxTexture1DLayered[2]; 
#line 2161
int maxTexture2DLayered[3]; 
#line 2162
int maxTextureCubemapLayered[2]; 
#line 2163
int maxSurface1D; 
#line 2164
int maxSurface2D[2]; 
#line 2165
int maxSurface3D[3]; 
#line 2166
int maxSurface1DLayered[2]; 
#line 2167
int maxSurface2DLayered[3]; 
#line 2168
int maxSurfaceCubemap; 
#line 2169
int maxSurfaceCubemapLayered[2]; 
#line 2170
size_t surfaceAlignment; 
#line 2171
int concurrentKernels; 
#line 2172
int ECCEnabled; 
#line 2173
int pciBusID; 
#line 2174
int pciDeviceID; 
#line 2175
int pciDomainID; 
#line 2176
int tccDriver; 
#line 2177
int asyncEngineCount; 
#line 2178
int unifiedAddressing; 
#line 2179
int memoryClockRate; 
#line 2180
int memoryBusWidth; 
#line 2181
int l2CacheSize; 
#line 2182
int persistingL2CacheMaxSize; 
#line 2183
int maxThreadsPerMultiProcessor; 
#line 2184
int streamPrioritiesSupported; 
#line 2185
int globalL1CacheSupported; 
#line 2186
int localL1CacheSupported; 
#line 2187
size_t sharedMemPerMultiprocessor; 
#line 2188
int regsPerMultiprocessor; 
#line 2189
int managedMemory; 
#line 2190
int isMultiGpuBoard; 
#line 2191
int multiGpuBoardGroupID; 
#line 2192
int hostNativeAtomicSupported; 
#line 2193
int singleToDoublePrecisionPerfRatio; 
#line 2194
int pageableMemoryAccess; 
#line 2195
int concurrentManagedAccess; 
#line 2196
int computePreemptionSupported; 
#line 2197
int canUseHostPointerForRegisteredMem; 
#line 2198
int cooperativeLaunch; 
#line 2199
int cooperativeMultiDeviceLaunch; 
#line 2200
size_t sharedMemPerBlockOptin; 
#line 2201
int pageableMemoryAccessUsesHostPageTables; 
#line 2202
int directManagedMemAccessFromHost; 
#line 2203
int maxBlocksPerMultiProcessor; 
#line 2204
int accessPolicyMaxWindowSize; 
#line 2205
size_t reservedSharedMemPerBlock; 
#line 2206
}; 
#endif
#line 2302 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef 
#line 2299
struct cudaIpcEventHandle_st { 
#line 2301
char reserved[64]; 
#line 2302
} cudaIpcEventHandle_t; 
#endif
#line 2310 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef 
#line 2307
struct cudaIpcMemHandle_st { 
#line 2309
char reserved[64]; 
#line 2310
} cudaIpcMemHandle_t; 
#endif
#line 2315 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2315
enum cudaExternalMemoryHandleType { 
#line 2319
cudaExternalMemoryHandleTypeOpaqueFd = 1, 
#line 2323
cudaExternalMemoryHandleTypeOpaqueWin32, 
#line 2327
cudaExternalMemoryHandleTypeOpaqueWin32Kmt, 
#line 2331
cudaExternalMemoryHandleTypeD3D12Heap, 
#line 2335
cudaExternalMemoryHandleTypeD3D12Resource, 
#line 2339
cudaExternalMemoryHandleTypeD3D11Resource, 
#line 2343
cudaExternalMemoryHandleTypeD3D11ResourceKmt, 
#line 2347
cudaExternalMemoryHandleTypeNvSciBuf
#line 2348
}; 
#endif
#line 2390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2390
struct cudaExternalMemoryHandleDesc { 
#line 2394
cudaExternalMemoryHandleType type; 
#line 2395
union { 
#line 2401
int fd; 
#line 2417
struct { 
#line 2421
void *handle; 
#line 2426
const void *name; 
#line 2427
} win32; 
#line 2432
const void *nvSciBufObject; 
#line 2433
} handle; 
#line 2437
unsigned __int64 size; 
#line 2441
unsigned flags; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 2442
}; 
#endif
#line 2447 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2447
struct cudaExternalMemoryBufferDesc { 
#line 2451
unsigned __int64 offset; 
#line 2455
unsigned __int64 size; 
#line 2459
unsigned flags; 
#line 2460
}; 
#endif
#line 2465 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2465
struct cudaExternalMemoryMipmappedArrayDesc { 
#line 2470
unsigned __int64 offset; 
#line 2474
cudaChannelFormatDesc formatDesc; 
#line 2478
cudaExtent extent; 
#line 2483
unsigned flags; 
#line 2487
unsigned numLevels; 
#line 2488
}; 
#endif
#line 2493 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2493
enum cudaExternalSemaphoreHandleType { 
#line 2497
cudaExternalSemaphoreHandleTypeOpaqueFd = 1, 
#line 2501
cudaExternalSemaphoreHandleTypeOpaqueWin32, 
#line 2505
cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt, 
#line 2509
cudaExternalSemaphoreHandleTypeD3D12Fence, 
#line 2513
cudaExternalSemaphoreHandleTypeD3D11Fence, 
#line 2517
cudaExternalSemaphoreHandleTypeNvSciSync, 
#line 2521
cudaExternalSemaphoreHandleTypeKeyedMutex, 
#line 2525
cudaExternalSemaphoreHandleTypeKeyedMutexKmt, 
#line 2529
cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd, 
#line 2533
cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32
#line 2534
}; 
#endif
#line 2539 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2539
struct cudaExternalSemaphoreHandleDesc { 
#line 2543
cudaExternalSemaphoreHandleType type; 
#line 2544
union { 
#line 2551
int fd; 
#line 2567
struct { 
#line 2571
void *handle; 
#line 2576
const void *name; 
#line 2577
} win32; 
#line 2581
const void *nvSciSyncObj; 
#line 2582
} handle; 
#line 2586
unsigned flags; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 2587
}; 
#endif
#line 2592 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2592
struct cudaExternalSemaphoreSignalParams_v1 { 
#line 2593
struct { 
#line 2597
struct { 
#line 2601
unsigned __int64 value; 
#line 2602
} fence; 
#line 2603
union { 
#line 2608
void *fence; 
#line 2609
unsigned __int64 reserved; 
#line 2610
} nvSciSync; 
#line 2614
struct { 
#line 2618
unsigned __int64 key; 
#line 2619
} keyedMutex; 
#line 2620
} params; 
#line 2631
unsigned flags; 
#line 2632
}; 
#endif
#line 2637 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2637
struct cudaExternalSemaphoreWaitParams_v1 { 
#line 2638
struct { 
#line 2642
struct { 
#line 2646
unsigned __int64 value; 
#line 2647
} fence; 
#line 2648
union { 
#line 2653
void *fence; 
#line 2654
unsigned __int64 reserved; 
#line 2655
} nvSciSync; 
#line 2659
struct { 
#line 2663
unsigned __int64 key; 
#line 2667
unsigned timeoutMs; 
#line 2668
} keyedMutex; 
#line 2669
} params; 
#line 2680
unsigned flags; 
#line 2681
}; 
#endif
#line 2686 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2686
struct cudaExternalSemaphoreSignalParams { 
#line 2687
struct { 
#line 2691
struct { 
#line 2695
unsigned __int64 value; 
#line 2696
} fence; 
#line 2697
union { 
#line 2702
void *fence; 
#line 2703
unsigned __int64 reserved; 
#line 2704
} nvSciSync; 
#line 2708
struct { 
#line 2712
unsigned __int64 key; 
#line 2713
} keyedMutex; 
#line 2714
unsigned reserved[12]; 
#line 2715
} params; 
#line 2726
unsigned flags; 
#line 2727
unsigned reserved[16]; 
#line 2728
}; 
#endif
#line 2733 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2733
struct cudaExternalSemaphoreWaitParams { 
#line 2734
struct { 
#line 2738
struct { 
#line 2742
unsigned __int64 value; 
#line 2743
} fence; 
#line 2744
union { 
#line 2749
void *fence; 
#line 2750
unsigned __int64 reserved; 
#line 2751
} nvSciSync; 
#line 2755
struct { 
#line 2759
unsigned __int64 key; 
#line 2763
unsigned timeoutMs; 
#line 2764
} keyedMutex; 
#line 2765
unsigned reserved[10]; 
#line 2766
} params; 
#line 2777
unsigned flags; 
#line 2778
unsigned reserved[16]; 
#line 2779
}; 
#endif
#line 2790 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef cudaError 
#line 2790
cudaError_t; 
#endif
#line 2795 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUstream_st *
#line 2795
cudaStream_t; 
#endif
#line 2800 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUevent_st *
#line 2800
cudaEvent_t; 
#endif
#line 2805 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef cudaGraphicsResource *
#line 2805
cudaGraphicsResource_t; 
#endif
#line 2810 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef cudaOutputMode 
#line 2810
cudaOutputMode_t; 
#endif
#line 2815 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUexternalMemory_st *
#line 2815
cudaExternalMemory_t; 
#endif
#line 2820 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUexternalSemaphore_st *
#line 2820
cudaExternalSemaphore_t; 
#endif
#line 2825 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUgraph_st *
#line 2825
cudaGraph_t; 
#endif
#line 2830 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUgraphNode_st *
#line 2830
cudaGraphNode_t; 
#endif
#line 2835 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUuserObject_st *
#line 2835
cudaUserObject_t; 
#endif
#line 2840 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUfunc_st *
#line 2840
cudaFunction_t; 
#endif
#line 2845 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef struct CUmemPoolHandle_st *
#line 2845
cudaMemPool_t; 
#endif
#line 2850 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2850
enum cudaCGScope { 
#line 2851
cudaCGScopeInvalid, 
#line 2852
cudaCGScopeGrid, 
#line 2853
cudaCGScopeMultiGrid
#line 2854
}; 
#endif
#line 2859 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2859
struct cudaLaunchParams { 
#line 2861
void *func; 
#line 2862
dim3 gridDim; 
#line 2863
dim3 blockDim; 
#line 2864
void **args; 
#line 2865
size_t sharedMem; 
#line 2866
cudaStream_t stream; 
#line 2867
}; 
#endif
#line 2872 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2872
struct cudaKernelNodeParams { 
#line 2873
void *func; 
#line 2874
dim3 gridDim; 
#line 2875
dim3 blockDim; 
#line 2876
unsigned sharedMemBytes; 
#line 2877
void **kernelParams; 
#line 2878
void **extra; 
#line 2879
}; 
#endif
#line 2884 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2884
struct cudaExternalSemaphoreSignalNodeParams { 
#line 2885
cudaExternalSemaphore_t *extSemArray; 
#line 2886
const cudaExternalSemaphoreSignalParams *paramsArray; 
#line 2887
unsigned numExtSems; 
#line 2888
}; 
#endif
#line 2893 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2893
struct cudaExternalSemaphoreWaitNodeParams { 
#line 2894
cudaExternalSemaphore_t *extSemArray; 
#line 2895
const cudaExternalSemaphoreWaitParams *paramsArray; 
#line 2896
unsigned numExtSems; 
#line 2897
}; 
#endif
#line 2902 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2902
enum cudaGraphNodeType { 
#line 2903
cudaGraphNodeTypeKernel, 
#line 2904
cudaGraphNodeTypeMemcpy, 
#line 2905
cudaGraphNodeTypeMemset, 
#line 2906
cudaGraphNodeTypeHost, 
#line 2907
cudaGraphNodeTypeGraph, 
#line 2908
cudaGraphNodeTypeEmpty, 
#line 2909
cudaGraphNodeTypeWaitEvent, 
#line 2910
cudaGraphNodeTypeEventRecord, 
#line 2911
cudaGraphNodeTypeExtSemaphoreSignal, 
#line 2912
cudaGraphNodeTypeExtSemaphoreWait, 
#line 2913
cudaGraphNodeTypeMemAlloc, 
#line 2914
cudaGraphNodeTypeMemFree, 
#line 2915
cudaGraphNodeTypeCount
#line 2916
}; 
#endif
#line 2921 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
typedef struct CUgraphExec_st *cudaGraphExec_t; 
#line 2926
#if 0
#line 2926
enum cudaGraphExecUpdateResult { 
#line 2927
cudaGraphExecUpdateSuccess, 
#line 2928
cudaGraphExecUpdateError, 
#line 2929
cudaGraphExecUpdateErrorTopologyChanged, 
#line 2930
cudaGraphExecUpdateErrorNodeTypeChanged, 
#line 2931
cudaGraphExecUpdateErrorFunctionChanged, 
#line 2932
cudaGraphExecUpdateErrorParametersChanged, 
#line 2933
cudaGraphExecUpdateErrorNotSupported, 
#line 2934
cudaGraphExecUpdateErrorUnsupportedFunctionChange, 
#line 2935
cudaGraphExecUpdateErrorAttributesChanged
#line 2936
}; 
#endif
#line 2942 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2942
enum cudaGetDriverEntryPointFlags { 
#line 2943
cudaEnableDefault, 
#line 2944
cudaEnableLegacyStream, 
#line 2945
cudaEnablePerThreadDefaultStream
#line 2946
}; 
#endif
#line 2951 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2951
enum cudaGraphDebugDotFlags { 
#line 2952
cudaGraphDebugDotFlagsVerbose = (1 << 0), 
#line 2953
cudaGraphDebugDotFlagsKernelNodeParams = (1 << 2), 
#line 2954
cudaGraphDebugDotFlagsMemcpyNodeParams = (1 << 3), 
#line 2955
cudaGraphDebugDotFlagsMemsetNodeParams = (1 << 4), 
#line 2956
cudaGraphDebugDotFlagsHostNodeParams = (1 << 5), 
#line 2957
cudaGraphDebugDotFlagsEventNodeParams = (1 << 6), 
#line 2958
cudaGraphDebugDotFlagsExtSemasSignalNodeParams = (1 << 7), 
#line 2959
cudaGraphDebugDotFlagsExtSemasWaitNodeParams = (1 << 8), 
#line 2960
cudaGraphDebugDotFlagsKernelNodeAttributes = (1 << 9), 
#line 2961
cudaGraphDebugDotFlagsHandles = (1 << 10)
#line 2962
}; 
#endif
#line 2967 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
#line 2967
enum cudaGraphInstantiateFlags { 
#line 2968
cudaGraphInstantiateFlagAutoFreeOnLaunch = 1, 
#line 2969
cudaGraphInstantiateFlagUseNodePriority = 8
#line 2971
}; 
#endif
#line 3010 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef 
#line 2976
enum cudaLaunchAttributeID { 
#line 2977
cudaLaunchAttributeIgnore, 
#line 2978
cudaLaunchAttributeAccessPolicyWindow, 
#line 2979
cudaLaunchAttributeCooperative, 
#line 2980
cudaLaunchAttributeSynchronizationPolicy, 
#line 2981
cudaLaunchAttributeClusterDimension, 
#line 2982
cudaLaunchAttributeClusterSchedulingPolicyPreference, 
#line 2983
cudaLaunchAttributeProgrammaticStreamSerialization, 
#line 2991
cudaLaunchAttributeProgrammaticEvent, 
#line 3009
cudaLaunchAttributePriority
#line 3010
} cudaLaunchAttributeID; 
#endif
#line 3033 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef 
#line 3015
union cudaLaunchAttributeValue { 
#line 3016
char pad[64]; 
#line 3017
cudaAccessPolicyWindow accessPolicyWindow; 
#line 3018
int cooperative; 
#line 3019
cudaSynchronizationPolicy syncPolicy; 
#line 3020
struct { 
#line 3021
unsigned x; 
#line 3022
unsigned y; 
#line 3023
unsigned z; 
#line 3024
} clusterDim; 
#line 3025
cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference; 
#line 3026
int programmaticStreamSerializationAllowed; 
#line 3027
struct { 
#line 3028
cudaEvent_t event; 
#line 3029
int flags; 
#line 3030
int triggerAtBlockStart; 
#line 3031
} programmaticEvent; 
#line 3032
int priority; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 3033
} cudaLaunchAttributeValue; 
#endif
#line 3042 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef 
#line 3038
struct cudaLaunchAttribute_st { 
#line 3039
cudaLaunchAttributeID id; 
#line 3040
char pad[(8) - sizeof(cudaLaunchAttributeID)]; 
#line 3041
cudaLaunchAttributeValue val; 
#line 3042
} cudaLaunchAttribute; 
#endif
#line 3054 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#if 0
typedef 
#line 3047
struct cudaLaunchConfig_st { 
#line 3048
dim3 gridDim; 
#line 3049
dim3 blockDim; 
#line 3050
size_t dynamicSmemBytes; 
#line 3051
cudaStream_t stream; 
#line 3052
cudaLaunchAttribute *attrs; 
#line 3053
unsigned numAttrs; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 3054
} cudaLaunchConfig_t; 
#endif
#line 84 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#if 0
#line 84
enum cudaSurfaceBoundaryMode { 
#line 86
cudaBoundaryModeZero, 
#line 87
cudaBoundaryModeClamp, 
#line 88
cudaBoundaryModeTrap
#line 89
}; 
#endif
#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#if 0
#line 94
enum cudaSurfaceFormatMode { 
#line 96
cudaFormatModeForced, 
#line 97
cudaFormatModeAuto
#line 98
}; 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#if 0
#line 103
struct surfaceReference { 
#line 108
cudaChannelFormatDesc channelDesc; 
#line 109
}; 
#endif
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#if 0
typedef unsigned __int64 
#line 114
cudaSurfaceObject_t; 
#endif
#line 84 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#if 0
#line 84
enum cudaTextureAddressMode { 
#line 86
cudaAddressModeWrap, 
#line 87
cudaAddressModeClamp, 
#line 88
cudaAddressModeMirror, 
#line 89
cudaAddressModeBorder
#line 90
}; 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#if 0
#line 95
enum cudaTextureFilterMode { 
#line 97
cudaFilterModePoint, 
#line 98
cudaFilterModeLinear
#line 99
}; 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#if 0
#line 104
enum cudaTextureReadMode { 
#line 106
cudaReadModeElementType, 
#line 107
cudaReadModeNormalizedFloat
#line 108
}; 
#endif
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#if 0
#line 113
struct textureReference { 
#line 118
int normalized; 
#line 122
cudaTextureFilterMode filterMode; 
#line 126
cudaTextureAddressMode addressMode[3]; 
#line 130
cudaChannelFormatDesc channelDesc; 
#line 134
int sRGB; 
#line 138
unsigned maxAnisotropy; 
#line 142
cudaTextureFilterMode mipmapFilterMode; 
#line 146
float mipmapLevelBias; 
#line 150
float minMipmapLevelClamp; 
#line 154
float maxMipmapLevelClamp; 
#line 158
int disableTrilinearOptimization; 
#line 159
int __cudaReserved[14]; 
#line 160
}; 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#if 0
#line 165
struct cudaTextureDesc { 
#line 170
cudaTextureAddressMode addressMode[3]; 
#line 174
cudaTextureFilterMode filterMode; 
#line 178
cudaTextureReadMode readMode; 
#line 182
int sRGB; 
#line 186
float borderColor[4]; 
#line 190
int normalizedCoords; 
#line 194
unsigned maxAnisotropy; 
#line 198
cudaTextureFilterMode mipmapFilterMode; 
#line 202
float mipmapLevelBias; 
#line 206
float minMipmapLevelClamp; 
#line 210
float maxMipmapLevelClamp; 
#line 214
int disableTrilinearOptimization; 
#line 215
}; 
#endif
#line 217 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#if 0
#line 217
struct cudaTextureDesc_v2 { 
#line 222
cudaTextureAddressMode addressMode[3]; 
#line 226
cudaTextureFilterMode filterMode; 
#line 230
cudaTextureReadMode readMode; 
#line 234
int sRGB; 
#line 238
float borderColor[4]; 
#line 242
int normalizedCoords; 
#line 246
unsigned maxAnisotropy; 
#line 250
cudaTextureFilterMode mipmapFilterMode; 
#line 254
float mipmapLevelBias; 
#line 258
float minMipmapLevelClamp; 
#line 262
float maxMipmapLevelClamp; 
#line 266
int disableTrilinearOptimization; 
#line 270
int seamlessCubemap; 
#line 271
}; 
#endif
#line 276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#if 0
typedef unsigned __int64 
#line 276
cudaTextureObject_t; 
#endif
#line 87 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\library_types.h"
typedef 
#line 55
enum cudaDataType_t { 
#line 57
CUDA_R_16F = 2, 
#line 58
CUDA_C_16F = 6, 
#line 59
CUDA_R_16BF = 14, 
#line 60
CUDA_C_16BF, 
#line 61
CUDA_R_32F = 0, 
#line 62
CUDA_C_32F = 4, 
#line 63
CUDA_R_64F = 1, 
#line 64
CUDA_C_64F = 5, 
#line 65
CUDA_R_4I = 16, 
#line 66
CUDA_C_4I, 
#line 67
CUDA_R_4U, 
#line 68
CUDA_C_4U, 
#line 69
CUDA_R_8I = 3, 
#line 70
CUDA_C_8I = 7, 
#line 71
CUDA_R_8U, 
#line 72
CUDA_C_8U, 
#line 73
CUDA_R_16I = 20, 
#line 74
CUDA_C_16I, 
#line 75
CUDA_R_16U, 
#line 76
CUDA_C_16U, 
#line 77
CUDA_R_32I = 10, 
#line 78
CUDA_C_32I, 
#line 79
CUDA_R_32U, 
#line 80
CUDA_C_32U, 
#line 81
CUDA_R_64I = 24, 
#line 82
CUDA_C_64I, 
#line 83
CUDA_R_64U, 
#line 84
CUDA_C_64U, 
#line 85
CUDA_R_8F_E4M3, 
#line 86
CUDA_R_8F_E5M2
#line 87
} cudaDataType; 
#line 95
typedef 
#line 90
enum libraryPropertyType_t { 
#line 92
MAJOR_VERSION, 
#line 93
MINOR_VERSION, 
#line 94
PATCH_LEVEL
#line 95
} libraryPropertyType; 
#line 131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
extern "C" {
#line 133
extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
#line 134
extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
#line 135
extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 136
extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
#line 139
extern cudaError_t __stdcall cudaDeviceSynchronize(); 
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
extern cudaError_t __stdcall __cudaDeviceSynchronizeDeprecationAvoidance(); 
#line 142
extern cudaError_t __stdcall cudaGetLastError(); 
#line 143
extern cudaError_t __stdcall cudaPeekAtLastError(); 
#line 144
extern const char *__stdcall cudaGetErrorString(cudaError_t error); 
#line 145
extern const char *__stdcall cudaGetErrorName(cudaError_t error); 
#line 146
extern cudaError_t __stdcall cudaGetDeviceCount(int * count); 
#line 147
extern cudaError_t __stdcall cudaGetDevice(int * device); 
#line 148
extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
#line 149
extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); 
#line 150
extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 151
extern cudaError_t __stdcall cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 152
extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
#line 153
extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream); 
#line 154
extern cudaError_t __stdcall cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); 
#line 155
extern cudaError_t __stdcall cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream, unsigned flags); 
#line 156
extern cudaError_t __stdcall cudaEventRecordWithFlags_ptsz(cudaEvent_t event, cudaStream_t stream, unsigned flags); 
#line 157
extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); 
#line 158
extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
#line 159
extern cudaError_t __stdcall cudaFree(void * devPtr); 
#line 160
extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); 
#line 161
extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
#line 162
extern cudaError_t __stdcall cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
#line 163
extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
#line 164
extern cudaError_t __stdcall cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
#line 165
extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); 
#line 166
extern cudaError_t __stdcall cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); 
#line 167
extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); 
#line 168
extern cudaError_t __stdcall cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); 
#line 169
extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
#line 170
extern cudaError_t __stdcall cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
#line 171
extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
#line 172
extern cudaError_t __stdcall cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
#line 173
extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); 
#line 194
extern void *__stdcall cudaGetParameterBuffer(size_t alignment, size_t size); 
#line 222
extern void *__stdcall cudaGetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); 
#line 223
extern cudaError_t __stdcall cudaLaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
#line 224
extern cudaError_t __stdcall cudaLaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); 
#line 242 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
extern cudaError_t __stdcall cudaLaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
#line 243
extern cudaError_t __stdcall cudaLaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); 
#line 246 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); 
#line 247
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 249
extern unsigned __int64 __stdcall cudaCGGetIntrinsicHandle(cudaCGScope scope); 
#line 250
extern cudaError_t __stdcall cudaCGSynchronize(unsigned __int64 handle, unsigned flags); 
#line 251
extern cudaError_t __stdcall cudaCGSynchronizeGrid(unsigned __int64 handle, unsigned flags); 
#line 252
extern cudaError_t __stdcall cudaCGGetSize(unsigned * numThreads, unsigned * numGrids, unsigned __int64 handle); 
#line 253
extern cudaError_t __stdcall cudaCGGetRank(unsigned * threadRank, unsigned * gridRank, unsigned __int64 handle); 
#line 254
}
#line 256
template< class T> static __inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
#line 257
template< class T> static __inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
#line 258
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
#line 259
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 267 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern "C" {
#line 307 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceReset(); 
#line 329
extern cudaError_t __stdcall cudaDeviceSynchronize(); 
#line 416
extern cudaError_t __stdcall cudaDeviceSetLimit(cudaLimit limit, size_t value); 
#line 449
extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
#line 472
extern cudaError_t __stdcall cudaDeviceGetTexture1DLinearMaxWidth(size_t * maxWidthInElements, const cudaChannelFormatDesc * fmtDesc, int device); 
#line 506 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 543
extern cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
#line 587
extern cudaError_t __stdcall cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); 
#line 618
extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
#line 662
extern cudaError_t __stdcall cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); 
#line 689
extern cudaError_t __stdcall cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); 
#line 719
extern cudaError_t __stdcall cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); 
#line 767
extern cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); 
#line 808
extern cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); 
#line 851
extern cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); 
#line 915
extern cudaError_t __stdcall cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); 
#line 951
extern cudaError_t __stdcall cudaIpcCloseMemHandle(void * devPtr); 
#line 983
extern cudaError_t __stdcall cudaDeviceFlushGPUDirectRDMAWrites(cudaFlushGPUDirectRDMAWritesTarget target, cudaFlushGPUDirectRDMAWritesScope scope); 
#line 1026 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadExit(); 
#line 1052
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSynchronize(); 
#line 1101
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSetLimit(cudaLimit limit, size_t value); 
#line 1134
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadGetLimit(size_t * pValue, cudaLimit limit); 
#line 1170
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 1217
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); 
#line 1278
extern cudaError_t __stdcall cudaGetLastError(); 
#line 1326
extern cudaError_t __stdcall cudaPeekAtLastError(); 
#line 1342
extern const char *__stdcall cudaGetErrorName(cudaError_t error); 
#line 1358
extern const char *__stdcall cudaGetErrorString(cudaError_t error); 
#line 1386
extern cudaError_t __stdcall cudaGetDeviceCount(int * count); 
#line 1659
extern cudaError_t __stdcall cudaGetDeviceProperties(cudaDeviceProp * prop, int device); 
#line 1859
extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
#line 1877
extern cudaError_t __stdcall cudaDeviceGetDefaultMemPool(cudaMemPool_t * memPool, int device); 
#line 1901
extern cudaError_t __stdcall cudaDeviceSetMemPool(int device, cudaMemPool_t memPool); 
#line 1921
extern cudaError_t __stdcall cudaDeviceGetMemPool(cudaMemPool_t * memPool, int device); 
#line 1969
extern cudaError_t __stdcall cudaDeviceGetNvSciSyncAttributes(void * nvSciSyncAttrList, int device, int flags); 
#line 2009
extern cudaError_t __stdcall cudaDeviceGetP2PAttribute(int * value, cudaDeviceP2PAttr attr, int srcDevice, int dstDevice); 
#line 2030
extern cudaError_t __stdcall cudaChooseDevice(int * device, const cudaDeviceProp * prop); 
#line 2074
extern cudaError_t __stdcall cudaSetDevice(int device); 
#line 2095
extern cudaError_t __stdcall cudaGetDevice(int * device); 
#line 2126
extern cudaError_t __stdcall cudaSetValidDevices(int * device_arr, int len); 
#line 2191
extern cudaError_t __stdcall cudaSetDeviceFlags(unsigned flags); 
#line 2235
extern cudaError_t __stdcall cudaGetDeviceFlags(unsigned * flags); 
#line 2275
extern cudaError_t __stdcall cudaStreamCreate(cudaStream_t * pStream); 
#line 2307
extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
#line 2353
extern cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); 
#line 2380
extern cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t hStream, int * priority); 
#line 2405
extern cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t hStream, unsigned * flags); 
#line 2420
extern cudaError_t __stdcall cudaCtxResetPersistingL2Cache(); 
#line 2440
extern cudaError_t __stdcall cudaStreamCopyAttributes(cudaStream_t dst, cudaStream_t src); 
#line 2461
extern cudaError_t __stdcall cudaStreamGetAttribute(cudaStream_t hStream, cudaLaunchAttributeID attr, cudaLaunchAttributeValue * value_out); 
#line 2485
extern cudaError_t __stdcall cudaStreamSetAttribute(cudaStream_t hStream, cudaLaunchAttributeID attr, const cudaLaunchAttributeValue * value); 
#line 2519
extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); 
#line 2550
extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags = 0); 
#line 2558
typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); 
#line 2625
extern cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); 
#line 2649
extern cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream); 
#line 2674
extern cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream); 
#line 2758
extern cudaError_t __stdcall cudaStreamAttachMemAsync(cudaStream_t stream, void * devPtr, size_t length = 0, unsigned flags = 4); 
#line 2797 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaStreamBeginCapture(cudaStream_t stream, cudaStreamCaptureMode mode); 
#line 2848
extern cudaError_t __stdcall cudaThreadExchangeStreamCaptureMode(cudaStreamCaptureMode * mode); 
#line 2876
extern cudaError_t __stdcall cudaStreamEndCapture(cudaStream_t stream, cudaGraph_t * pGraph); 
#line 2914
extern cudaError_t __stdcall cudaStreamIsCapturing(cudaStream_t stream, cudaStreamCaptureStatus * pCaptureStatus); 
#line 2946
extern cudaError_t __stdcall cudaStreamGetCaptureInfo(cudaStream_t stream, cudaStreamCaptureStatus * pCaptureStatus, unsigned __int64 * pId); 
#line 3001
extern cudaError_t __stdcall cudaStreamGetCaptureInfo_v2(cudaStream_t stream, cudaStreamCaptureStatus * captureStatus_out, unsigned __int64 * id_out = 0, cudaGraph_t * graph_out = 0, const cudaGraphNode_t ** dependencies_out = 0, size_t * numDependencies_out = 0); 
#line 3034
extern cudaError_t __stdcall cudaStreamUpdateCaptureDependencies(cudaStream_t stream, cudaGraphNode_t * dependencies, size_t numDependencies, unsigned flags = 0); 
#line 3071
extern cudaError_t __stdcall cudaEventCreate(cudaEvent_t * event); 
#line 3108
extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
#line 3148
extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0); 
#line 3195
extern cudaError_t __stdcall cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream = 0, unsigned flags = 0); 
#line 3227 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaEventQuery(cudaEvent_t event); 
#line 3257
extern cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event); 
#line 3286
extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); 
#line 3330
extern cudaError_t __stdcall cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); 
#line 3510
extern cudaError_t __stdcall cudaImportExternalMemory(cudaExternalMemory_t * extMem_out, const cudaExternalMemoryHandleDesc * memHandleDesc); 
#line 3565
extern cudaError_t __stdcall cudaExternalMemoryGetMappedBuffer(void ** devPtr, cudaExternalMemory_t extMem, const cudaExternalMemoryBufferDesc * bufferDesc); 
#line 3627
extern cudaError_t __stdcall cudaExternalMemoryGetMappedMipmappedArray(cudaMipmappedArray_t * mipmap, cudaExternalMemory_t extMem, const cudaExternalMemoryMipmappedArrayDesc * mipmapDesc); 
#line 3651
extern cudaError_t __stdcall cudaDestroyExternalMemory(cudaExternalMemory_t extMem); 
#line 3804
extern cudaError_t __stdcall cudaImportExternalSemaphore(cudaExternalSemaphore_t * extSem_out, const cudaExternalSemaphoreHandleDesc * semHandleDesc); 
#line 3871
extern cudaError_t __stdcall cudaSignalExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t * extSemArray, const cudaExternalSemaphoreSignalParams * paramsArray, unsigned numExtSems, cudaStream_t stream = 0); 
#line 3947
extern cudaError_t __stdcall cudaWaitExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t * extSemArray, const cudaExternalSemaphoreWaitParams * paramsArray, unsigned numExtSems, cudaStream_t stream = 0); 
#line 3970
extern cudaError_t __stdcall cudaDestroyExternalSemaphore(cudaExternalSemaphore_t extSem); 
#line 4037
extern cudaError_t __stdcall cudaLaunchKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
#line 4099
extern cudaError_t __stdcall cudaLaunchKernelExC(const cudaLaunchConfig_t * config, const void * func, void ** args); 
#line 4156
extern cudaError_t __stdcall cudaLaunchCooperativeKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
#line 4257
__declspec(deprecated) extern cudaError_t __stdcall cudaLaunchCooperativeKernelMultiDevice(cudaLaunchParams * launchParamsList, unsigned numDevices, unsigned flags = 0); 
#line 4304
extern cudaError_t __stdcall cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); 
#line 4359
extern cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); 
#line 4392
extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
#line 4429
extern cudaError_t __stdcall cudaFuncSetAttribute(const void * func, cudaFuncAttribute attr, int value); 
#line 4453
__declspec(deprecated) extern cudaError_t __stdcall cudaSetDoubleForDevice(double * d); 
#line 4477
__declspec(deprecated) extern cudaError_t __stdcall cudaSetDoubleForHost(double * d); 
#line 4543
extern cudaError_t __stdcall cudaLaunchHostFunc(cudaStream_t stream, cudaHostFn_t fn, void * userData); 
#line 4600
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); 
#line 4629
extern cudaError_t __stdcall cudaOccupancyAvailableDynamicSMemPerBlock(size_t * dynamicSmemSize, const void * func, int numBlocks, int blockSize); 
#line 4674
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
#line 4709
extern cudaError_t __stdcall cudaOccupancyMaxPotentialClusterSize(int * clusterSize, const void * func, const cudaLaunchConfig_t * launchConfig); 
#line 4748
extern cudaError_t __stdcall cudaOccupancyMaxActiveClusters(int * numClusters, const void * func, const cudaLaunchConfig_t * launchConfig); 
#line 4868
extern cudaError_t __stdcall cudaMallocManaged(void ** devPtr, size_t size, unsigned flags = 1); 
#line 4901 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); 
#line 4934
extern cudaError_t __stdcall cudaMallocHost(void ** ptr, size_t size); 
#line 4977
extern cudaError_t __stdcall cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); 
#line 5029
extern cudaError_t __stdcall cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); 
#line 5067
extern cudaError_t __stdcall cudaFree(void * devPtr); 
#line 5090
extern cudaError_t __stdcall cudaFreeHost(void * ptr); 
#line 5113
extern cudaError_t __stdcall cudaFreeArray(cudaArray_t array); 
#line 5136
extern cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); 
#line 5202
extern cudaError_t __stdcall cudaHostAlloc(void ** pHost, size_t size, unsigned flags); 
#line 5295
extern cudaError_t __stdcall cudaHostRegister(void * ptr, size_t size, unsigned flags); 
#line 5318
extern cudaError_t __stdcall cudaHostUnregister(void * ptr); 
#line 5363
extern cudaError_t __stdcall cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); 
#line 5385
extern cudaError_t __stdcall cudaHostGetFlags(unsigned * pFlags, void * pHost); 
#line 5424
extern cudaError_t __stdcall cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); 
#line 5569
extern cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); 
#line 5714
extern cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); 
#line 5747
extern cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); 
#line 5852
extern cudaError_t __stdcall cudaMemcpy3D(const cudaMemcpy3DParms * p); 
#line 5883
extern cudaError_t __stdcall cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * p); 
#line 6001
extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); 
#line 6027
extern cudaError_t __stdcall cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); 
#line 6061
extern cudaError_t __stdcall cudaMemGetInfo(size_t * free, size_t * total); 
#line 6087
extern cudaError_t __stdcall cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); 
#line 6116
extern cudaError_t __stdcall cudaArrayGetPlane(cudaArray_t * pPlaneArray, cudaArray_t hArray, unsigned planeIdx); 
#line 6139
extern cudaError_t __stdcall cudaArrayGetMemoryRequirements(cudaArrayMemoryRequirements * memoryRequirements, cudaArray_t array, int device); 
#line 6163
extern cudaError_t __stdcall cudaMipmappedArrayGetMemoryRequirements(cudaArrayMemoryRequirements * memoryRequirements, cudaMipmappedArray_t mipmap, int device); 
#line 6191
extern cudaError_t __stdcall cudaArrayGetSparseProperties(cudaArraySparseProperties * sparseProperties, cudaArray_t array); 
#line 6221 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaMipmappedArrayGetSparseProperties(cudaArraySparseProperties * sparseProperties, cudaMipmappedArray_t mipmap); 
#line 6266 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaMemcpy(void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 6301
extern cudaError_t __stdcall cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); 
#line 6350
extern cudaError_t __stdcall cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
#line 6400
extern cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
#line 6450
extern cudaError_t __stdcall cudaMemcpy2DFromArray(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); 
#line 6497
extern cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
#line 6540
extern cudaError_t __stdcall cudaMemcpyToSymbol(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); 
#line 6583
extern cudaError_t __stdcall cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); 
#line 6640
extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 6675
extern cudaError_t __stdcall cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); 
#line 6738
extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 6796
extern cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 6853
extern cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 6904
extern cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 6955
extern cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 6984
extern cudaError_t __stdcall cudaMemset(void * devPtr, int value, size_t count); 
#line 7018
extern cudaError_t __stdcall cudaMemset2D(void * devPtr, size_t pitch, int value, size_t width, size_t height); 
#line 7064
extern cudaError_t __stdcall cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); 
#line 7100
extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream = 0); 
#line 7141
extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); 
#line 7194
extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); 
#line 7222
extern cudaError_t __stdcall cudaGetSymbolAddress(void ** devPtr, const void * symbol); 
#line 7249
extern cudaError_t __stdcall cudaGetSymbolSize(size_t * size, const void * symbol); 
#line 7319
extern cudaError_t __stdcall cudaMemPrefetchAsync(const void * devPtr, size_t count, int dstDevice, cudaStream_t stream = 0); 
#line 7435
extern cudaError_t __stdcall cudaMemAdvise(const void * devPtr, size_t count, cudaMemoryAdvise advice, int device); 
#line 7494
extern cudaError_t __stdcall cudaMemRangeGetAttribute(void * data, size_t dataSize, cudaMemRangeAttribute attribute, const void * devPtr, size_t count); 
#line 7533
extern cudaError_t __stdcall cudaMemRangeGetAttributes(void ** data, size_t * dataSizes, cudaMemRangeAttribute * attributes, size_t numAttributes, const void * devPtr, size_t count); 
#line 7593
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); 
#line 7635
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyFromArray(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); 
#line 7678
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
#line 7729
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 7779
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 7848
extern cudaError_t __stdcall cudaMallocAsync(void ** devPtr, size_t size, cudaStream_t hStream); 
#line 7874
extern cudaError_t __stdcall cudaFreeAsync(void * devPtr, cudaStream_t hStream); 
#line 7899
extern cudaError_t __stdcall cudaMemPoolTrimTo(cudaMemPool_t memPool, size_t minBytesToKeep); 
#line 7943
extern cudaError_t __stdcall cudaMemPoolSetAttribute(cudaMemPool_t memPool, cudaMemPoolAttr attr, void * value); 
#line 7991
extern cudaError_t __stdcall cudaMemPoolGetAttribute(cudaMemPool_t memPool, cudaMemPoolAttr attr, void * value); 
#line 8006
extern cudaError_t __stdcall cudaMemPoolSetAccess(cudaMemPool_t memPool, const cudaMemAccessDesc * descList, size_t count); 
#line 8019
extern cudaError_t __stdcall cudaMemPoolGetAccess(cudaMemAccessFlags * flags, cudaMemPool_t memPool, cudaMemLocation * location); 
#line 8039
extern cudaError_t __stdcall cudaMemPoolCreate(cudaMemPool_t * memPool, const cudaMemPoolProps * poolProps); 
#line 8061
extern cudaError_t __stdcall cudaMemPoolDestroy(cudaMemPool_t memPool); 
#line 8097
extern cudaError_t __stdcall cudaMallocFromPoolAsync(void ** ptr, size_t size, cudaMemPool_t memPool, cudaStream_t stream); 
#line 8122
extern cudaError_t __stdcall cudaMemPoolExportToShareableHandle(void * shareableHandle, cudaMemPool_t memPool, cudaMemAllocationHandleType handleType, unsigned flags); 
#line 8149
extern cudaError_t __stdcall cudaMemPoolImportFromShareableHandle(cudaMemPool_t * memPool, void * shareableHandle, cudaMemAllocationHandleType handleType, unsigned flags); 
#line 8172
extern cudaError_t __stdcall cudaMemPoolExportPointer(cudaMemPoolPtrExportData * exportData, void * ptr); 
#line 8201
extern cudaError_t __stdcall cudaMemPoolImportPointer(void ** ptr, cudaMemPool_t memPool, cudaMemPoolPtrExportData * exportData); 
#line 8353
extern cudaError_t __stdcall cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); 
#line 8394
extern cudaError_t __stdcall cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); 
#line 8436
extern cudaError_t __stdcall cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); 
#line 8458
extern cudaError_t __stdcall cudaDeviceDisablePeerAccess(int peerDevice); 
#line 8522
extern cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); 
#line 8557
extern cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); 
#line 8596
extern cudaError_t __stdcall cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
#line 8631
extern cudaError_t __stdcall cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
#line 8663
extern cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); 
#line 8701
extern cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); 
#line 8730
extern cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); 
#line 8801
__declspec(deprecated) extern cudaError_t __stdcall cudaBindTexture(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t size = 4294967295U); 
#line 8860
__declspec(deprecated) extern cudaError_t __stdcall cudaBindTexture2D(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t width, size_t height, size_t pitch); 
#line 8898
__declspec(deprecated) extern cudaError_t __stdcall cudaBindTextureToArray(const textureReference * texref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
#line 8938
__declspec(deprecated) extern cudaError_t __stdcall cudaBindTextureToMipmappedArray(const textureReference * texref, cudaMipmappedArray_const_t mipmappedArray, const cudaChannelFormatDesc * desc); 
#line 8964
__declspec(deprecated) extern cudaError_t __stdcall cudaUnbindTexture(const textureReference * texref); 
#line 8993
__declspec(deprecated) extern cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t * offset, const textureReference * texref); 
#line 9023
__declspec(deprecated) extern cudaError_t __stdcall cudaGetTextureReference(const textureReference ** texref, const void * symbol); 
#line 9068
__declspec(deprecated) extern cudaError_t __stdcall cudaBindSurfaceToArray(const surfaceReference * surfref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
#line 9093
__declspec(deprecated) extern cudaError_t __stdcall cudaGetSurfaceReference(const surfaceReference ** surfref, const void * symbol); 
#line 9128
extern cudaError_t __stdcall cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); 
#line 9158
extern cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); 
#line 9375
extern cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
#line 9599
extern cudaError_t __stdcall cudaCreateTextureObject_v2(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc_v2 * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
#line 9619
extern cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t texObject); 
#line 9639
extern cudaError_t __stdcall cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); 
#line 9659
extern cudaError_t __stdcall cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); 
#line 9679
extern cudaError_t __stdcall cudaGetTextureObjectTextureDesc_v2(cudaTextureDesc_v2 * pTexDesc, cudaTextureObject_t texObject); 
#line 9700
extern cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); 
#line 9745
extern cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); 
#line 9765
extern cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); 
#line 9784
extern cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); 
#line 9818
extern cudaError_t __stdcall cudaDriverGetVersion(int * driverVersion); 
#line 9843
extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); 
#line 9890
extern cudaError_t __stdcall cudaGraphCreate(cudaGraph_t * pGraph, unsigned flags); 
#line 9987
extern cudaError_t __stdcall cudaGraphAddKernelNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaKernelNodeParams * pNodeParams); 
#line 10020
extern cudaError_t __stdcall cudaGraphKernelNodeGetParams(cudaGraphNode_t node, cudaKernelNodeParams * pNodeParams); 
#line 10045
extern cudaError_t __stdcall cudaGraphKernelNodeSetParams(cudaGraphNode_t node, const cudaKernelNodeParams * pNodeParams); 
#line 10065
extern cudaError_t __stdcall cudaGraphKernelNodeCopyAttributes(cudaGraphNode_t hSrc, cudaGraphNode_t hDst); 
#line 10088
extern cudaError_t __stdcall cudaGraphKernelNodeGetAttribute(cudaGraphNode_t hNode, cudaLaunchAttributeID attr, cudaLaunchAttributeValue * value_out); 
#line 10112
extern cudaError_t __stdcall cudaGraphKernelNodeSetAttribute(cudaGraphNode_t hNode, cudaLaunchAttributeID attr, const cudaLaunchAttributeValue * value); 
#line 10162
extern cudaError_t __stdcall cudaGraphAddMemcpyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaMemcpy3DParms * pCopyParams); 
#line 10221
extern cudaError_t __stdcall cudaGraphAddMemcpyNodeToSymbol(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 10290 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemcpyNodeFromSymbol(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 10358 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemcpyNode1D(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 10390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemcpyNodeGetParams(cudaGraphNode_t node, cudaMemcpy3DParms * pNodeParams); 
#line 10416
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParams(cudaGraphNode_t node, const cudaMemcpy3DParms * pNodeParams); 
#line 10455
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParamsToSymbol(cudaGraphNode_t node, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 10501 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParamsFromSymbol(cudaGraphNode_t node, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 10547 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParams1D(cudaGraphNode_t node, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 10594 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemsetNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaMemsetParams * pMemsetParams); 
#line 10617
extern cudaError_t __stdcall cudaGraphMemsetNodeGetParams(cudaGraphNode_t node, cudaMemsetParams * pNodeParams); 
#line 10640
extern cudaError_t __stdcall cudaGraphMemsetNodeSetParams(cudaGraphNode_t node, const cudaMemsetParams * pNodeParams); 
#line 10681
extern cudaError_t __stdcall cudaGraphAddHostNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaHostNodeParams * pNodeParams); 
#line 10704
extern cudaError_t __stdcall cudaGraphHostNodeGetParams(cudaGraphNode_t node, cudaHostNodeParams * pNodeParams); 
#line 10727
extern cudaError_t __stdcall cudaGraphHostNodeSetParams(cudaGraphNode_t node, const cudaHostNodeParams * pNodeParams); 
#line 10767
extern cudaError_t __stdcall cudaGraphAddChildGraphNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaGraph_t childGraph); 
#line 10794
extern cudaError_t __stdcall cudaGraphChildGraphNodeGetGraph(cudaGraphNode_t node, cudaGraph_t * pGraph); 
#line 10831
extern cudaError_t __stdcall cudaGraphAddEmptyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies); 
#line 10874
extern cudaError_t __stdcall cudaGraphAddEventRecordNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaEvent_t event); 
#line 10901 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphEventRecordNodeGetEvent(cudaGraphNode_t node, cudaEvent_t * event_out); 
#line 10928 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphEventRecordNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event); 
#line 10974 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddEventWaitNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaEvent_t event); 
#line 11001 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphEventWaitNodeGetEvent(cudaGraphNode_t node, cudaEvent_t * event_out); 
#line 11028 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphEventWaitNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event); 
#line 11077 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddExternalSemaphoresSignalNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
#line 11110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExternalSemaphoresSignalNodeGetParams(cudaGraphNode_t hNode, cudaExternalSemaphoreSignalNodeParams * params_out); 
#line 11137 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExternalSemaphoresSignalNodeSetParams(cudaGraphNode_t hNode, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
#line 11186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddExternalSemaphoresWaitNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
#line 11219 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExternalSemaphoresWaitNodeGetParams(cudaGraphNode_t hNode, cudaExternalSemaphoreWaitNodeParams * params_out); 
#line 11246 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExternalSemaphoresWaitNodeSetParams(cudaGraphNode_t hNode, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
#line 11323 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemAllocNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaMemAllocNodeParams * nodeParams); 
#line 11350 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemAllocNodeGetParams(cudaGraphNode_t node, cudaMemAllocNodeParams * params_out); 
#line 11410 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphAddMemFreeNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dptr); 
#line 11434 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphMemFreeNodeGetParams(cudaGraphNode_t node, void * dptr_out); 
#line 11462 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceGraphMemTrim(int device); 
#line 11499 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceGetGraphMemAttribute(int device, cudaGraphMemAttributeType attr, void * value); 
#line 11533 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceSetGraphMemAttribute(int device, cudaGraphMemAttributeType attr, void * value); 
#line 11561 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphClone(cudaGraph_t * pGraphClone, cudaGraph_t originalGraph); 
#line 11589
extern cudaError_t __stdcall cudaGraphNodeFindInClone(cudaGraphNode_t * pNode, cudaGraphNode_t originalNode, cudaGraph_t clonedGraph); 
#line 11620
extern cudaError_t __stdcall cudaGraphNodeGetType(cudaGraphNode_t node, cudaGraphNodeType * pType); 
#line 11651
extern cudaError_t __stdcall cudaGraphGetNodes(cudaGraph_t graph, cudaGraphNode_t * nodes, size_t * numNodes); 
#line 11682
extern cudaError_t __stdcall cudaGraphGetRootNodes(cudaGraph_t graph, cudaGraphNode_t * pRootNodes, size_t * pNumRootNodes); 
#line 11716
extern cudaError_t __stdcall cudaGraphGetEdges(cudaGraph_t graph, cudaGraphNode_t * from, cudaGraphNode_t * to, size_t * numEdges); 
#line 11747
extern cudaError_t __stdcall cudaGraphNodeGetDependencies(cudaGraphNode_t node, cudaGraphNode_t * pDependencies, size_t * pNumDependencies); 
#line 11779
extern cudaError_t __stdcall cudaGraphNodeGetDependentNodes(cudaGraphNode_t node, cudaGraphNode_t * pDependentNodes, size_t * pNumDependentNodes); 
#line 11810
extern cudaError_t __stdcall cudaGraphAddDependencies(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t numDependencies); 
#line 11841
extern cudaError_t __stdcall cudaGraphRemoveDependencies(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t numDependencies); 
#line 11871
extern cudaError_t __stdcall cudaGraphDestroyNode(cudaGraphNode_t node); 
#line 11909
extern cudaError_t __stdcall cudaGraphInstantiate(cudaGraphExec_t * pGraphExec, cudaGraph_t graph, cudaGraphNode_t * pErrorNode, char * pLogBuffer, size_t bufferSize); 
#line 11957
extern cudaError_t __stdcall cudaGraphInstantiateWithFlags(cudaGraphExec_t * pGraphExec, cudaGraph_t graph, unsigned __int64 flags); 
#line 12001 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecKernelNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaKernelNodeParams * pNodeParams); 
#line 12051
extern cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaMemcpy3DParms * pNodeParams); 
#line 12106
extern cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParamsToSymbol(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 12169 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParamsFromSymbol(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
#line 12230 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParams1D(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 12284 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecMemsetNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaMemsetParams * pNodeParams); 
#line 12323
extern cudaError_t __stdcall cudaGraphExecHostNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaHostNodeParams * pNodeParams); 
#line 12369
extern cudaError_t __stdcall cudaGraphExecChildGraphNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, cudaGraph_t childGraph); 
#line 12413 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecEventRecordNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event); 
#line 12457 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecEventWaitNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event); 
#line 12504 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecExternalSemaphoresSignalNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
#line 12551 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecExternalSemaphoresWaitNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
#line 12591 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphNodeSetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned isEnabled); 
#line 12625 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphNodeGetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned * isEnabled); 
#line 12706 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphExecUpdate(cudaGraphExec_t hGraphExec, cudaGraph_t hGraph, cudaGraphNode_t * hErrorNode_out, cudaGraphExecUpdateResult * updateResult_out); 
#line 12731
extern cudaError_t __stdcall cudaGraphUpload(cudaGraphExec_t graphExec, cudaStream_t stream); 
#line 12762 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaGraphLaunch(cudaGraphExec_t graphExec, cudaStream_t stream); 
#line 12785
extern cudaError_t __stdcall cudaGraphExecDestroy(cudaGraphExec_t graphExec); 
#line 12806
extern cudaError_t __stdcall cudaGraphDestroy(cudaGraph_t graph); 
#line 12825
extern cudaError_t __stdcall cudaGraphDebugDotPrint(cudaGraph_t graph, const char * path, unsigned flags); 
#line 12861
extern cudaError_t __stdcall cudaUserObjectCreate(cudaUserObject_t * object_out, void * ptr, cudaHostFn_t destroy, unsigned initialRefcount, unsigned flags); 
#line 12885
extern cudaError_t __stdcall cudaUserObjectRetain(cudaUserObject_t object, unsigned count = 1); 
#line 12913
extern cudaError_t __stdcall cudaUserObjectRelease(cudaUserObject_t object, unsigned count = 1); 
#line 12941
extern cudaError_t __stdcall cudaGraphRetainUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned count = 1, unsigned flags = 0); 
#line 12966
extern cudaError_t __stdcall cudaGraphReleaseUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned count = 1); 
#line 13032
extern cudaError_t __stdcall cudaGetDriverEntryPoint(const char * symbol, void ** funcPtr, unsigned __int64 flags); 
#line 13037
extern cudaError_t __stdcall cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); 
#line 13213
extern cudaError_t __cdecl cudaGetFuncBySymbol(cudaFunction_t * functionPtr, const void * symbolPtr); 
#line 13365 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
}
#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
template< class T> __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 125
{ 
#line 126
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 127
} 
#line 129
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
#line 130
{ 
#line 131
int e = (((int)sizeof(unsigned short)) * 8); 
#line 133
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 134
} 
#line 136
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
#line 137
{ 
#line 138
int e = (((int)sizeof(unsigned short)) * 8); 
#line 140
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 141
} 
#line 143
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
#line 144
{ 
#line 145
int e = (((int)sizeof(unsigned short)) * 8); 
#line 147
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 148
} 
#line 150
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
#line 151
{ 
#line 152
int e = (((int)sizeof(unsigned short)) * 8); 
#line 154
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 155
} 
#line 157
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
#line 158
{ 
#line 159
int e = (((int)sizeof(char)) * 8); 
#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 166 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
} 
#line 168
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
#line 169
{ 
#line 170
int e = (((int)sizeof(signed char)) * 8); 
#line 172
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 173
} 
#line 175
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
#line 176
{ 
#line 177
int e = (((int)sizeof(unsigned char)) * 8); 
#line 179
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 180
} 
#line 182
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
#line 183
{ 
#line 184
int e = (((int)sizeof(signed char)) * 8); 
#line 186
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 187
} 
#line 189
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
#line 190
{ 
#line 191
int e = (((int)sizeof(unsigned char)) * 8); 
#line 193
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 194
} 
#line 196
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
#line 197
{ 
#line 198
int e = (((int)sizeof(signed char)) * 8); 
#line 200
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 201
} 
#line 203
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
#line 204
{ 
#line 205
int e = (((int)sizeof(unsigned char)) * 8); 
#line 207
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 208
} 
#line 210
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
#line 211
{ 
#line 212
int e = (((int)sizeof(signed char)) * 8); 
#line 214
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 215
} 
#line 217
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
#line 218
{ 
#line 219
int e = (((int)sizeof(unsigned char)) * 8); 
#line 221
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 222
} 
#line 224
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
#line 225
{ 
#line 226
int e = (((int)sizeof(short)) * 8); 
#line 228
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 229
} 
#line 231
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
#line 232
{ 
#line 233
int e = (((int)sizeof(unsigned short)) * 8); 
#line 235
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 236
} 
#line 238
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
#line 239
{ 
#line 240
int e = (((int)sizeof(short)) * 8); 
#line 242
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 243
} 
#line 245
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
#line 246
{ 
#line 247
int e = (((int)sizeof(unsigned short)) * 8); 
#line 249
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 250
} 
#line 252
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
#line 253
{ 
#line 254
int e = (((int)sizeof(short)) * 8); 
#line 256
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 257
} 
#line 259
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
#line 260
{ 
#line 261
int e = (((int)sizeof(unsigned short)) * 8); 
#line 263
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 264
} 
#line 266
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
#line 267
{ 
#line 268
int e = (((int)sizeof(short)) * 8); 
#line 270
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 271
} 
#line 273
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
#line 274
{ 
#line 275
int e = (((int)sizeof(unsigned short)) * 8); 
#line 277
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 278
} 
#line 280
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
#line 281
{ 
#line 282
int e = (((int)sizeof(int)) * 8); 
#line 284
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 285
} 
#line 287
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
#line 288
{ 
#line 289
int e = (((int)sizeof(unsigned)) * 8); 
#line 291
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 292
} 
#line 294
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
#line 295
{ 
#line 296
int e = (((int)sizeof(int)) * 8); 
#line 298
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 299
} 
#line 301
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
#line 302
{ 
#line 303
int e = (((int)sizeof(unsigned)) * 8); 
#line 305
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 306
} 
#line 308
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
#line 309
{ 
#line 310
int e = (((int)sizeof(int)) * 8); 
#line 312
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 313
} 
#line 315
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
#line 316
{ 
#line 317
int e = (((int)sizeof(unsigned)) * 8); 
#line 319
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 320
} 
#line 322
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
#line 323
{ 
#line 324
int e = (((int)sizeof(int)) * 8); 
#line 326
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 327
} 
#line 329
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
#line 330
{ 
#line 331
int e = (((int)sizeof(unsigned)) * 8); 
#line 333
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 334
} 
#line 338
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long> () 
#line 339
{ 
#line 340
int e = (((int)sizeof(long)) * 8); 
#line 342
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 343
} 
#line 345
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned long> () 
#line 346
{ 
#line 347
int e = (((int)sizeof(unsigned long)) * 8); 
#line 349
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 350
} 
#line 352
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long1> () 
#line 353
{ 
#line 354
int e = (((int)sizeof(long)) * 8); 
#line 356
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 357
} 
#line 359
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong1> () 
#line 360
{ 
#line 361
int e = (((int)sizeof(unsigned long)) * 8); 
#line 363
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 364
} 
#line 366
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long2> () 
#line 367
{ 
#line 368
int e = (((int)sizeof(long)) * 8); 
#line 370
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 371
} 
#line 373
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong2> () 
#line 374
{ 
#line 375
int e = (((int)sizeof(unsigned long)) * 8); 
#line 377
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 378
} 
#line 380
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long4> () 
#line 381
{ 
#line 382
int e = (((int)sizeof(long)) * 8); 
#line 384
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 385
} 
#line 387
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong4> () 
#line 388
{ 
#line 389
int e = (((int)sizeof(unsigned long)) * 8); 
#line 391
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 392
} 
#line 396 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
#line 397
{ 
#line 398
int e = (((int)sizeof(float)) * 8); 
#line 400
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 401
} 
#line 403
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
#line 404
{ 
#line 405
int e = (((int)sizeof(float)) * 8); 
#line 407
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 408
} 
#line 410
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
#line 411
{ 
#line 412
int e = (((int)sizeof(float)) * 8); 
#line 414
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 415
} 
#line 417
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
#line 418
{ 
#line 419
int e = (((int)sizeof(float)) * 8); 
#line 421
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 422
} 
#line 424
static __inline cudaChannelFormatDesc cudaCreateChannelDescNV12() 
#line 425
{ 
#line 426
int e = (((int)sizeof(char)) * 8); 
#line 428
return cudaCreateChannelDesc(e, e, e, 0, cudaChannelFormatKindNV12); 
#line 429
} 
#line 431
template< cudaChannelFormatKind > __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 432
{ 
#line 433
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 434
} 
#line 437
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X1> () 
#line 438
{ 
#line 439
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedNormalized8X1); 
#line 440
} 
#line 442
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X2> () 
#line 443
{ 
#line 444
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedNormalized8X2); 
#line 445
} 
#line 447
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X4> () 
#line 448
{ 
#line 449
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindSignedNormalized8X4); 
#line 450
} 
#line 453
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X1> () 
#line 454
{ 
#line 455
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized8X1); 
#line 456
} 
#line 458
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X2> () 
#line 459
{ 
#line 460
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedNormalized8X2); 
#line 461
} 
#line 463
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X4> () 
#line 464
{ 
#line 465
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedNormalized8X4); 
#line 466
} 
#line 469
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X1> () 
#line 470
{ 
#line 471
return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindSignedNormalized16X1); 
#line 472
} 
#line 474
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X2> () 
#line 475
{ 
#line 476
return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindSignedNormalized16X2); 
#line 477
} 
#line 479
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X4> () 
#line 480
{ 
#line 481
return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindSignedNormalized16X4); 
#line 482
} 
#line 485
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X1> () 
#line 486
{ 
#line 487
return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized16X1); 
#line 488
} 
#line 490
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X2> () 
#line 491
{ 
#line 492
return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindUnsignedNormalized16X2); 
#line 493
} 
#line 495
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X4> () 
#line 496
{ 
#line 497
return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindUnsignedNormalized16X4); 
#line 498
} 
#line 501
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindNV12> () 
#line 502
{ 
#line 503
return cudaCreateChannelDesc(8, 8, 8, 0, cudaChannelFormatKindNV12); 
#line 504
} 
#line 507
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed1> () 
#line 508
{ 
#line 509
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1); 
#line 510
} 
#line 513
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed1SRGB> () 
#line 514
{ 
#line 515
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1SRGB); 
#line 516
} 
#line 519
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed2> () 
#line 520
{ 
#line 521
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2); 
#line 522
} 
#line 525
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed2SRGB> () 
#line 526
{ 
#line 527
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2SRGB); 
#line 528
} 
#line 531
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed3> () 
#line 532
{ 
#line 533
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3); 
#line 534
} 
#line 537
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed3SRGB> () 
#line 538
{ 
#line 539
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3SRGB); 
#line 540
} 
#line 543
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed4> () 
#line 544
{ 
#line 545
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed4); 
#line 546
} 
#line 549
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed4> () 
#line 550
{ 
#line 551
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedBlockCompressed4); 
#line 552
} 
#line 555
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed5> () 
#line 556
{ 
#line 557
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed5); 
#line 558
} 
#line 561
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed5> () 
#line 562
{ 
#line 563
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedBlockCompressed5); 
#line 564
} 
#line 567
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed6H> () 
#line 568
{ 
#line 569
return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindUnsignedBlockCompressed6H); 
#line 570
} 
#line 573
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed6H> () 
#line 574
{ 
#line 575
return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindSignedBlockCompressed6H); 
#line 576
} 
#line 579
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed7> () 
#line 580
{ 
#line 581
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7); 
#line 582
} 
#line 585
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed7SRGB> () 
#line 586
{ 
#line 587
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7SRGB); 
#line 588
} 
#line 79 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_functions.h"
static __inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
#line 80
{ 
#line 81
cudaPitchedPtr s; 
#line 83
(s.ptr) = d; 
#line 84
(s.pitch) = p; 
#line 85
(s.xsize) = xsz; 
#line 86
(s.ysize) = ysz; 
#line 88
return s; 
#line 89
} 
#line 106
static __inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
#line 107
{ 
#line 108
cudaPos p; 
#line 110
(p.x) = x; 
#line 111
(p.y) = y; 
#line 112
(p.z) = z; 
#line 114
return p; 
#line 115
} 
#line 132
static __inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
#line 133
{ 
#line 134
cudaExtent e; 
#line 136
(e.width) = w; 
#line 137
(e.height) = h; 
#line 138
(e.depth) = d; 
#line 140
return e; 
#line 141
} 
#line 73 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.h"
static __inline char1 make_char1(signed char x); 
#line 75
static __inline uchar1 make_uchar1(unsigned char x); 
#line 77
static __inline char2 make_char2(signed char x, signed char y); 
#line 79
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y); 
#line 81
static __inline char3 make_char3(signed char x, signed char y, signed char z); 
#line 83
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z); 
#line 85
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w); 
#line 87
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w); 
#line 89
static __inline short1 make_short1(short x); 
#line 91
static __inline ushort1 make_ushort1(unsigned short x); 
#line 93
static __inline short2 make_short2(short x, short y); 
#line 95
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y); 
#line 97
static __inline short3 make_short3(short x, short y, short z); 
#line 99
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z); 
#line 101
static __inline short4 make_short4(short x, short y, short z, short w); 
#line 103
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w); 
#line 105
static __inline int1 make_int1(int x); 
#line 107
static __inline uint1 make_uint1(unsigned x); 
#line 109
static __inline int2 make_int2(int x, int y); 
#line 111
static __inline uint2 make_uint2(unsigned x, unsigned y); 
#line 113
static __inline int3 make_int3(int x, int y, int z); 
#line 115
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z); 
#line 117
static __inline int4 make_int4(int x, int y, int z, int w); 
#line 119
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w); 
#line 121
static __inline long1 make_long1(long x); 
#line 123
static __inline ulong1 make_ulong1(unsigned long x); 
#line 125
static __inline long2 make_long2(long x, long y); 
#line 127
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y); 
#line 129
static __inline long3 make_long3(long x, long y, long z); 
#line 131
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z); 
#line 133
static __inline long4 make_long4(long x, long y, long z, long w); 
#line 135
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w); 
#line 137
static __inline float1 make_float1(float x); 
#line 139
static __inline float2 make_float2(float x, float y); 
#line 141
static __inline float3 make_float3(float x, float y, float z); 
#line 143
static __inline float4 make_float4(float x, float y, float z, float w); 
#line 145
static __inline longlong1 make_longlong1(__int64 x); 
#line 147
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x); 
#line 149
static __inline longlong2 make_longlong2(__int64 x, __int64 y); 
#line 151
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y); 
#line 153
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z); 
#line 155
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z); 
#line 157
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w); 
#line 159
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w); 
#line 161
static __inline double1 make_double1(double x); 
#line 163
static __inline double2 make_double2(double x, double y); 
#line 165
static __inline double3 make_double3(double x, double y, double z); 
#line 167
static __inline double4 make_double4(double x, double y, double z, double w); 
#line 73 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.hpp"
static __inline char1 make_char1(signed char x) 
#line 74
{ 
#line 75
char1 t; (t.x) = x; return t; 
#line 76
} 
#line 78
static __inline uchar1 make_uchar1(unsigned char x) 
#line 79
{ 
#line 80
uchar1 t; (t.x) = x; return t; 
#line 81
} 
#line 83
static __inline char2 make_char2(signed char x, signed char y) 
#line 84
{ 
#line 85
char2 t; (t.x) = x; (t.y) = y; return t; 
#line 86
} 
#line 88
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
#line 89
{ 
#line 90
uchar2 t; (t.x) = x; (t.y) = y; return t; 
#line 91
} 
#line 93
static __inline char3 make_char3(signed char x, signed char y, signed char z) 
#line 94
{ 
#line 95
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 96
} 
#line 98
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
#line 99
{ 
#line 100
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 101
} 
#line 103
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
#line 104
{ 
#line 105
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 106
} 
#line 108
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
#line 109
{ 
#line 110
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 111
} 
#line 113
static __inline short1 make_short1(short x) 
#line 114
{ 
#line 115
short1 t; (t.x) = x; return t; 
#line 116
} 
#line 118
static __inline ushort1 make_ushort1(unsigned short x) 
#line 119
{ 
#line 120
ushort1 t; (t.x) = x; return t; 
#line 121
} 
#line 123
static __inline short2 make_short2(short x, short y) 
#line 124
{ 
#line 125
short2 t; (t.x) = x; (t.y) = y; return t; 
#line 126
} 
#line 128
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
#line 129
{ 
#line 130
ushort2 t; (t.x) = x; (t.y) = y; return t; 
#line 131
} 
#line 133
static __inline short3 make_short3(short x, short y, short z) 
#line 134
{ 
#line 135
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 136
} 
#line 138
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
#line 139
{ 
#line 140
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 141
} 
#line 143
static __inline short4 make_short4(short x, short y, short z, short w) 
#line 144
{ 
#line 145
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 146
} 
#line 148
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
#line 149
{ 
#line 150
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 151
} 
#line 153
static __inline int1 make_int1(int x) 
#line 154
{ 
#line 155
int1 t; (t.x) = x; return t; 
#line 156
} 
#line 158
static __inline uint1 make_uint1(unsigned x) 
#line 159
{ 
#line 160
uint1 t; (t.x) = x; return t; 
#line 161
} 
#line 163
static __inline int2 make_int2(int x, int y) 
#line 164
{ 
#line 165
int2 t; (t.x) = x; (t.y) = y; return t; 
#line 166
} 
#line 168
static __inline uint2 make_uint2(unsigned x, unsigned y) 
#line 169
{ 
#line 170
uint2 t; (t.x) = x; (t.y) = y; return t; 
#line 171
} 
#line 173
static __inline int3 make_int3(int x, int y, int z) 
#line 174
{ 
#line 175
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 176
} 
#line 178
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
#line 179
{ 
#line 180
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 181
} 
#line 183
static __inline int4 make_int4(int x, int y, int z, int w) 
#line 184
{ 
#line 185
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 186
} 
#line 188
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
#line 189
{ 
#line 190
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 191
} 
#line 193
static __inline long1 make_long1(long x) 
#line 194
{ 
#line 195
long1 t; (t.x) = x; return t; 
#line 196
} 
#line 198
static __inline ulong1 make_ulong1(unsigned long x) 
#line 199
{ 
#line 200
ulong1 t; (t.x) = x; return t; 
#line 201
} 
#line 203
static __inline long2 make_long2(long x, long y) 
#line 204
{ 
#line 205
long2 t; (t.x) = x; (t.y) = y; return t; 
#line 206
} 
#line 208
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
#line 209
{ 
#line 210
ulong2 t; (t.x) = x; (t.y) = y; return t; 
#line 211
} 
#line 213
static __inline long3 make_long3(long x, long y, long z) 
#line 214
{ 
#line 215
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 216
} 
#line 218
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
#line 219
{ 
#line 220
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 221
} 
#line 223
static __inline long4 make_long4(long x, long y, long z, long w) 
#line 224
{ 
#line 225
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 226
} 
#line 228
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
#line 229
{ 
#line 230
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 231
} 
#line 233
static __inline float1 make_float1(float x) 
#line 234
{ 
#line 235
float1 t; (t.x) = x; return t; 
#line 236
} 
#line 238
static __inline float2 make_float2(float x, float y) 
#line 239
{ 
#line 240
float2 t; (t.x) = x; (t.y) = y; return t; 
#line 241
} 
#line 243
static __inline float3 make_float3(float x, float y, float z) 
#line 244
{ 
#line 245
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 246
} 
#line 248
static __inline float4 make_float4(float x, float y, float z, float w) 
#line 249
{ 
#line 250
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 251
} 
#line 253
static __inline longlong1 make_longlong1(__int64 x) 
#line 254
{ 
#line 255
longlong1 t; (t.x) = x; return t; 
#line 256
} 
#line 258
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x) 
#line 259
{ 
#line 260
ulonglong1 t; (t.x) = x; return t; 
#line 261
} 
#line 263
static __inline longlong2 make_longlong2(__int64 x, __int64 y) 
#line 264
{ 
#line 265
longlong2 t; (t.x) = x; (t.y) = y; return t; 
#line 266
} 
#line 268
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y) 
#line 269
{ 
#line 270
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
#line 271
} 
#line 273
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z) 
#line 274
{ 
#line 275
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 276
} 
#line 278
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z) 
#line 279
{ 
#line 280
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 281
} 
#line 283
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w) 
#line 284
{ 
#line 285
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 286
} 
#line 288
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w) 
#line 289
{ 
#line 290
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 291
} 
#line 293
static __inline double1 make_double1(double x) 
#line 294
{ 
#line 295
double1 t; (t.x) = x; return t; 
#line 296
} 
#line 298
static __inline double2 make_double2(double x, double y) 
#line 299
{ 
#line 300
double2 t; (t.x) = x; (t.y) = y; return t; 
#line 301
} 
#line 303
static __inline double3 make_double3(double x, double y, double z) 
#line 304
{ 
#line 305
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 306
} 
#line 308
static __inline double4 make_double4(double x, double y, double z, double w) 
#line 309
{ 
#line 310
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 311
} 
#line 85 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 23
int *__cdecl _errno(); 
#line 26
errno_t __cdecl _set_errno(int _Value); 
#line 27
errno_t __cdecl _get_errno(int * _Value); 
#line 29
unsigned long *__cdecl __doserrno(); 
#line 32
errno_t __cdecl _set_doserrno(unsigned long _Value); 
#line 33
errno_t __cdecl _get_doserrno(unsigned long * _Value); 
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"
}__pragma( pack ( pop )) 
#line 136
#pragma warning(pop)
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_string.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 21
[[nodiscard]] const void *__cdecl 
#line 22
memchr(const void * _Buf, int _Val, size_t _MaxCount); 
#line 28
[[nodiscard]] int __cdecl 
#line 29
memcmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_string.h"
void *__cdecl memcpy(void * _Dst, const void * _Src, size_t _Size); 
#line 50
void *__cdecl memmove(void * _Dst, const void * _Src, size_t _Size); 
#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_string.h"
void *__cdecl memset(void * _Dst, int _Val, size_t _Size); 
#line 69
[[nodiscard]] const char *__cdecl 
#line 70
strchr(const char * _Str, int _Val); 
#line 75
[[nodiscard]] const char *__cdecl 
#line 76
strrchr(const char * _Str, int _Ch); 
#line 81
[[nodiscard]] const char *__cdecl 
#line 82
strstr(const char * _Str, const char * _SubStr); 
#line 87
[[nodiscard]] const __wchar_t *__cdecl 
#line 89
wcschr(const __wchar_t * _Str, __wchar_t _Ch); 
#line 94
[[nodiscard]] const __wchar_t *__cdecl 
#line 95
wcsrchr(const __wchar_t * _Str, __wchar_t _Ch); 
#line 100
[[nodiscard]] const __wchar_t *__cdecl 
#line 102
wcsstr(const __wchar_t * _Str, const __wchar_t * _SubStr); 
#line 109
}__pragma( pack ( pop )) 
#line 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_string.h"
#pragma warning(pop)
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"
static __inline errno_t __cdecl memcpy_s(void *const 
#line 40
_Destination, const rsize_t 
#line 41
_DestinationSize, const void *const 
#line 42
_Source, const rsize_t 
#line 43
_SourceSize) 
#line 45
{ 
#line 46
if (_SourceSize == (0)) 
#line 47
{ 
#line 48
return 0; 
#line 49
}  
#line 51
{ int _Expr_val = !(!(_Destination != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 52
if ((_Source == (0)) || (_DestinationSize < _SourceSize)) 
#line 53
{ 
#line 54
memset(_Destination, 0, _DestinationSize); 
#line 56
{ int _Expr_val = !(!(_Source != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 57
{ int _Expr_val = !(!(_DestinationSize >= _SourceSize)); if (!_Expr_val) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; }  } ; 
#line 60
return 22; 
#line 61
}  
#line 62
memcpy(_Destination, _Source, _SourceSize); 
#line 63
return 0; 
#line 64
} 
#line 67
static __inline errno_t __cdecl memmove_s(void *const 
#line 68
_Destination, const rsize_t 
#line 69
_DestinationSize, const void *const 
#line 70
_Source, const rsize_t 
#line 71
_SourceSize) 
#line 73
{ 
#line 74
if (_SourceSize == (0)) 
#line 75
{ 
#line 76
return 0; 
#line 77
}  
#line 79
{ int _Expr_val = !(!(_Destination != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 80
{ int _Expr_val = !(!(_Source != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 81
{ int _Expr_val = !(!(_DestinationSize >= _SourceSize)); if (!_Expr_val) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; }  } ; 
#line 83
memmove(_Destination, _Source, _SourceSize); 
#line 84
return 0; 
#line 85
} 
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"
}
#line 92
#pragma warning(pop)
__pragma( pack ( pop )) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 23
__pragma( pack ( push, 8 )) extern "C" {
#line 28
int __cdecl _memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 35
int __cdecl _memicmp_l(const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale); 
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"
void *__cdecl memccpy(void * _Dst, const void * _Src, int _Val, size_t _Size); 
#line 91
int __cdecl memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"
extern "C++" inline void *__cdecl memchr(void *
#line 105
_Pv, int 
#line 106
_C, size_t 
#line 107
_N) 
#line 109
{ 
#line 110
const void *const _Pvc = _Pv; 
#line 111
return const_cast< void *>(memchr(_Pvc, _C, _N)); 
#line 112
} 
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"
}__pragma( pack ( pop )) 
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"
#pragma warning(pop)
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 20
__pragma( pack ( push, 8 )) extern "C" {
#line 32
errno_t __cdecl wcscat_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source); 
#line 39
errno_t __cdecl wcscpy_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source); 
#line 46
errno_t __cdecl wcsncat_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source, rsize_t _MaxCount); 
#line 54
errno_t __cdecl wcsncpy_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source, rsize_t _MaxCount); 
#line 62
__wchar_t *__cdecl wcstok_s(__wchar_t * _String, const __wchar_t * _Delimiter, __wchar_t ** _Context); 
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__declspec(allocator) __wchar_t *__cdecl _wcsdup(const __wchar_t * _String); 
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source ) throw ( ) { return wcscat_s ( _Destination, _Size, _Source ); }}
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcscat(__wchar_t * _Destination, const __wchar_t * _Source); 
#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
int __cdecl wcscmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 113
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source ) throw ( ) { return wcscpy_s ( _Destination, _Size, _Source ); }}
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcscpy(__wchar_t * _Destination, const __wchar_t * _Source); 
#line 126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
size_t __cdecl wcscspn(const __wchar_t * _String, const __wchar_t * _Control); 
#line 132
size_t __cdecl wcslen(const __wchar_t * _String); 
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
size_t __cdecl wcsnlen(const __wchar_t * _Source, size_t _MaxCount); 
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
static __inline size_t __cdecl wcsnlen_s(const __wchar_t *
#line 162
_Source, size_t 
#line 163
_MaxCount) 
#line 165
{ 
#line 166
return (_Source == (0)) ? 0 : wcsnlen(_Source, _MaxCount); 
#line 167
} 
#line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source, size_t _Count ) throw ( ) { return wcsncat_s ( _Destination, _Size, _Source, _Count ); }}
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcsncat(__wchar_t * _Destination, const __wchar_t * _Source, size_t _Count); 
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
int __cdecl wcsncmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 193
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source, size_t _Count ) throw ( ) { return wcsncpy_s ( _Destination, _Size, _Source, _Count ); }}
#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcsncpy(__wchar_t * _Destination, const __wchar_t * _Source, size_t _Count); 
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
const __wchar_t *__cdecl wcspbrk(const __wchar_t * _String, const __wchar_t * _Control); 
#line 215
size_t __cdecl wcsspn(const __wchar_t * _String, const __wchar_t * _Control); 
#line 221
__wchar_t *__cdecl wcstok(__wchar_t * _String, const __wchar_t * _Delimiter, __wchar_t ** _Context); 
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
static __inline __wchar_t *__cdecl _wcstok(__wchar_t *const 
#line 240
_String, const __wchar_t *const 
#line 241
_Delimiter) 
#line 243
{ 
#line 244
return wcstok(_String, _Delimiter, 0); 
#line 245
} 
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
extern "C++" 
#line 252
__declspec(deprecated("wcstok has been changed to conform with the ISO C standard, adding an extra context parameter. To use the legacy Microsoft wcsto" "k, define _CRT_NON_CONFORMING_WCSTOK.")) inline __wchar_t *__cdecl 
#line 253
wcstok(__wchar_t *
#line 254
_String, const __wchar_t *
#line 255
_Delimiter) throw() 
#line 257
{ 
#line 258
return wcstok(_String, _Delimiter, 0); 
#line 259
} 
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcserror(int _ErrorNumber); 
#line 273
errno_t __cdecl _wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, int _ErrorNumber); 
#line 279
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) throw ( ) { return _wcserror_s ( _Buffer, _Size, _Error ); }}
#line 288 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl __wcserror(const __wchar_t * _String); 
#line 292
errno_t __cdecl __wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _ErrorMessage); 
#line 298
extern "C++" {template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _ErrorMessage ) throw ( ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
int __cdecl _wcsicmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 309
int __cdecl _wcsicmp_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 315
int __cdecl _wcsnicmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 321
int __cdecl _wcsnicmp_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 328
errno_t __cdecl _wcsnset_s(__wchar_t * _Destination, size_t _SizeInWords, __wchar_t _Value, size_t _MaxCount); 
#line 335
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t _Value, size_t _MaxCount ) throw ( ) { return _wcsnset_s ( _Destination, _Size, _Value, _MaxCount ); }}
#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsnset(__wchar_t * _String, __wchar_t _Value, size_t _MaxCount); 
#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsrev(__wchar_t * _String); 
#line 354
errno_t __cdecl _wcsset_s(__wchar_t * _Destination, size_t _SizeInWords, __wchar_t _Value); 
#line 360
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _String ) [ _Size ], wchar_t _Value ) throw ( ) { return _wcsset_s ( _String, _Size, _Value ); }}
#line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsset(__wchar_t * _String, __wchar_t _Value); 
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
errno_t __cdecl _wcslwr_s(__wchar_t * _String, size_t _SizeInWords); 
#line 378
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcslwr_s ( _String, _Size ); }}
#line 383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcslwr(__wchar_t * _String); 
#line 389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
errno_t __cdecl _wcslwr_s_l(__wchar_t * _String, size_t _SizeInWords, _locale_t _Locale); 
#line 395
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }}
#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcslwr_l(__wchar_t * _String, _locale_t _Locale); 
#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
errno_t __cdecl _wcsupr_s(__wchar_t * _String, size_t _Size); 
#line 414
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcsupr_s ( _String, _Size ); }}
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsupr(__wchar_t * _String); 
#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
errno_t __cdecl _wcsupr_s_l(__wchar_t * _String, size_t _Size, _locale_t _Locale); 
#line 431
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }}
#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl _wcsupr_l(__wchar_t * _String, _locale_t _Locale); 
#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
size_t __cdecl wcsxfrm(__wchar_t * _Destination, const __wchar_t * _Source, size_t _MaxCount); 
#line 454
size_t __cdecl _wcsxfrm_l(__wchar_t * _Destination, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 462
int __cdecl wcscoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 468
int __cdecl _wcscoll_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 475
int __cdecl _wcsicoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 481
int __cdecl _wcsicoll_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 488
int __cdecl _wcsncoll(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 495
int __cdecl _wcsncoll_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 503
int __cdecl _wcsnicoll(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 510
int __cdecl _wcsnicoll_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 525
extern "C++" {
#line 529
inline __wchar_t *__cdecl wcschr(__wchar_t *_String, __wchar_t _C) 
#line 530
{ 
#line 531
return const_cast< __wchar_t *>(wcschr(static_cast< const __wchar_t *>(_String), _C)); 
#line 532
} 
#line 535
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_String, const __wchar_t *_Control) 
#line 536
{ 
#line 537
return const_cast< __wchar_t *>(wcspbrk(static_cast< const __wchar_t *>(_String), _Control)); 
#line 538
} 
#line 541
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_String, __wchar_t _C) 
#line 542
{ 
#line 543
return const_cast< __wchar_t *>(wcsrchr(static_cast< const __wchar_t *>(_String), _C)); 
#line 544
} 
#line 548
inline __wchar_t *__cdecl wcsstr(__wchar_t *_String, const __wchar_t *_SubStr) 
#line 549
{ 
#line 550
return const_cast< __wchar_t *>(wcsstr(static_cast< const __wchar_t *>(_String), _SubStr)); 
#line 551
} 
#line 553
}
#line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__wchar_t *__cdecl wcsdup(const __wchar_t * _String); 
#line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
int __cdecl wcsicmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 588
int __cdecl wcsnicmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 596
__wchar_t *__cdecl wcsnset(__wchar_t * _String, __wchar_t _Value, size_t _MaxCount); 
#line 604
__wchar_t *__cdecl wcsrev(__wchar_t * _String); 
#line 610
__wchar_t *__cdecl wcsset(__wchar_t * _String, __wchar_t _Value); 
#line 617
__wchar_t *__cdecl wcslwr(__wchar_t * _String); 
#line 623
__wchar_t *__cdecl wcsupr(__wchar_t * _String); 
#line 628
int __cdecl wcsicoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
}__pragma( pack ( pop )) 
#line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 23
__pragma( pack ( push, 8 )) extern "C" {
#line 32
errno_t __cdecl strcpy_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source); 
#line 39
errno_t __cdecl strcat_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source); 
#line 46
errno_t __cdecl strerror_s(char * _Buffer, size_t _SizeInBytes, int _ErrorNumber); 
#line 52
errno_t __cdecl strncat_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source, rsize_t _MaxCount); 
#line 60
errno_t __cdecl strncpy_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source, rsize_t _MaxCount); 
#line 68
char *__cdecl strtok_s(char * _String, const char * _Delimiter, char ** _Context); 
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
void *__cdecl _memccpy(void * _Dst, const void * _Src, int _Val, size_t _MaxCount); 
#line 83
extern "C++" {template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Destination ) [ _Size ], char const * _Source ) throw ( ) { return strcat_s ( _Destination, _Size, _Source ); }}
#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl strcat(char * _Destination, const char * _Source); 
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
int __cdecl strcmp(const char * _Str1, const char * _Str2); 
#line 106
int __cdecl _strcmpi(const char * _String1, const char * _String2); 
#line 112
int __cdecl strcoll(const char * _String1, const char * _String2); 
#line 118
int __cdecl _strcoll_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 124
extern "C++" {template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Destination ) [ _Size ], char const * _Source ) throw ( ) { return strcpy_s ( _Destination, _Size, _Source ); }}
#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl strcpy(char * _Destination, const char * _Source); 
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
size_t __cdecl strcspn(const char * _Str, const char * _Control); 
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
__declspec(allocator) char *__cdecl _strdup(const char * _Source); 
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl _strerror(const char * _ErrorMessage); 
#line 164
errno_t __cdecl _strerror_s(char * _Buffer, size_t _SizeInBytes, const char * _ErrorMessage); 
#line 170
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], char const * _ErrorMessage ) throw ( ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl strerror(int _ErrorMessage); 
#line 182
extern "C++" {template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) throw ( ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
int __cdecl _stricmp(const char * _String1, const char * _String2); 
#line 195
int __cdecl _stricoll(const char * _String1, const char * _String2); 
#line 201
int __cdecl _stricoll_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 208
int __cdecl _stricmp_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 215
size_t __cdecl strlen(const char * _Str); 
#line 220
errno_t __cdecl _strlwr_s(char * _String, size_t _Size); 
#line 225
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strlwr_s ( _String, _Size ); }}
#line 230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl _strlwr(char * _String); 
#line 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
errno_t __cdecl _strlwr_s_l(char * _String, size_t _Size, _locale_t _Locale); 
#line 242
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strlwr_s_l ( _String, _Size, _Locale ); }}
#line 248 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl _strlwr_l(char * _String, _locale_t _Locale); 
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Destination ) [ _Size ], char const * _Source, size_t _Count ) throw ( ) { return strncat_s ( _Destination, _Size, _Source, _Count ); }}
#line 262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl strncat(char * _Destination, const char * _Source, size_t _Count); 
#line 271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
int __cdecl strncmp(const char * _Str1, const char * _Str2, size_t _MaxCount); 
#line 278
int __cdecl _strnicmp(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 285
int __cdecl _strnicmp_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 293
int __cdecl _strnicoll(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 300
int __cdecl _strnicoll_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 308
int __cdecl _strncoll(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 315
int __cdecl _strncoll_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 322
size_t __cdecl __strncnt(const char * _String, size_t _Count); 
#line 327
extern "C++" {template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Destination ) [ _Size ], char const * _Source, size_t _Count ) throw ( ) { return strncpy_s ( _Destination, _Size, _Source, _Count ); }}
#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl strncpy(char * _Destination, const char * _Source, size_t _Count); 
#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
size_t __cdecl strnlen(const char * _String, size_t _MaxCount); 
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
static __inline size_t __cdecl strnlen_s(const char *
#line 368
_String, size_t 
#line 369
_MaxCount) 
#line 371
{ 
#line 372
return (_String == (0)) ? 0 : strnlen(_String, _MaxCount); 
#line 373
} 
#line 378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
errno_t __cdecl _strnset_s(char * _String, size_t _SizeInBytes, int _Value, size_t _MaxCount); 
#line 385
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Destination ) [ _Size ], int _Value, size_t _Count ) throw ( ) { return _strnset_s ( _Destination, _Size, _Value, _Count ); }}
#line 392 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl _strnset(char * _Destination, int _Value, size_t _Count); 
#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
const char *__cdecl strpbrk(const char * _Str, const char * _Control); 
#line 406
char *__cdecl _strrev(char * _Str); 
#line 411
errno_t __cdecl _strset_s(char * _Destination, size_t _DestinationSize, int _Value); 
#line 417
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Destination ) [ _Size ], int _Value ) throw ( ) { return _strset_s ( _Destination, _Size, _Value ); }}
#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl _strset(char * _Destination, int _Value); 
#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
size_t __cdecl strspn(const char * _Str, const char * _Control); 
#line 436
char *__cdecl strtok(char * _String, const char * _Delimiter); 
#line 442
errno_t __cdecl _strupr_s(char * _String, size_t _Size); 
#line 447
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strupr_s ( _String, _Size ); }}
#line 452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl _strupr(char * _String); 
#line 458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
errno_t __cdecl _strupr_s_l(char * _String, size_t _Size, _locale_t _Locale); 
#line 464
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strupr_s_l ( _String, _Size, _Locale ); }}
#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl _strupr_l(char * _String, _locale_t _Locale); 
#line 479 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
size_t __cdecl strxfrm(char * _Destination, const char * _Source, size_t _MaxCount); 
#line 487
size_t __cdecl _strxfrm_l(char * _Destination, const char * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 497
extern "C++" {
#line 500
inline char *__cdecl strchr(char *const _String, const int _Ch) 
#line 501
{ 
#line 502
return const_cast< char *>(strchr(static_cast< const char *>(_String), _Ch)); 
#line 503
} 
#line 506
inline char *__cdecl strpbrk(char *const _String, const char *const _Control) 
#line 507
{ 
#line 508
return const_cast< char *>(strpbrk(static_cast< const char *>(_String), _Control)); 
#line 509
} 
#line 512
inline char *__cdecl strrchr(char *const _String, const int _Ch) 
#line 513
{ 
#line 514
return const_cast< char *>(strrchr(static_cast< const char *>(_String), _Ch)); 
#line 515
} 
#line 518
inline char *__cdecl strstr(char *const _String, const char *const _SubString) 
#line 519
{ 
#line 520
return const_cast< char *>(strstr(static_cast< const char *>(_String), _SubString)); 
#line 521
} 
#line 522
}
#line 532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
char *__cdecl strdup(const char * _String); 
#line 539
int __cdecl strcmpi(const char * _String1, const char * _String2); 
#line 545
int __cdecl stricmp(const char * _String1, const char * _String2); 
#line 551
char *__cdecl strlwr(char * _String); 
#line 556
int __cdecl strnicmp(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 563
char *__cdecl strnset(char * _String, int _Value, size_t _MaxCount); 
#line 570
char *__cdecl strrev(char * _String); 
#line 575
char *__cdecl strset(char * _String, int _Value); 
#line 580
char *__cdecl strupr(char * _String); 
#line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
}__pragma( pack ( pop )) 
#line 590
#pragma warning(pop)
#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#pragma external_header(pop)
#line 86 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 26
struct tm { 
#line 28
int tm_sec; 
#line 29
int tm_min; 
#line 30
int tm_hour; 
#line 31
int tm_mday; 
#line 32
int tm_mon; 
#line 33
int tm_year; 
#line 34
int tm_wday; 
#line 35
int tm_yday; 
#line 36
int tm_isdst; 
#line 37
}; 
#line 48
__wchar_t *__cdecl _wasctime(const tm * _Tm); 
#line 54
errno_t __cdecl _wasctime_s(__wchar_t * _Buffer, size_t _SizeInWords, const tm * _Tm); 
#line 60
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], struct tm const * _Time ) throw ( ) { return _wasctime_s ( _Buffer, _Size, _Time ); }}
#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
size_t __cdecl wcsftime(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm); 
#line 78
size_t __cdecl _wcsftime_l(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm, _locale_t _Locale); 
#line 88
__wchar_t *__cdecl _wctime32(const __time32_t * _Time); 
#line 93
errno_t __cdecl _wctime32_s(__wchar_t * _Buffer, size_t _SizeInWords, const __time32_t * _Time); 
#line 99
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], __time32_t const * _Time ) throw ( ) { return _wctime32_s ( _Buffer, _Size, _Time ); }}
#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
__wchar_t *__cdecl _wctime64(const __time64_t * _Time); 
#line 113
errno_t __cdecl _wctime64_s(__wchar_t * _Buffer, size_t _SizeInWords, const __time64_t * _Time); 
#line 118
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], __time64_t const * _Time ) throw ( ) { return _wctime64_s ( _Buffer, _Size, _Time ); }}
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
errno_t __cdecl _wstrdate_s(__wchar_t * _Buffer, size_t _SizeInWords); 
#line 130
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrdate_s ( _Buffer, _Size ); }}
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
__wchar_t *__cdecl _wstrdate(__wchar_t * _Buffer); 
#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
errno_t __cdecl _wstrtime_s(__wchar_t * _Buffer, size_t _SizeInWords); 
#line 146
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrtime_s ( _Buffer, _Size ); }}
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
__wchar_t *__cdecl _wstrtime(__wchar_t * _Buffer); 
#line 186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
static __inline __wchar_t *__cdecl _wctime(const time_t *const 
#line 187
_Time) 
#line 188
{ 
#line 189
return _wctime64(_Time); 
#line 190
} 
#line 193
static __inline errno_t __cdecl _wctime_s(__wchar_t *const 
#line 194
_Buffer, const size_t 
#line 195
_SizeInWords, const time_t *const 
#line 196
_Time) 
#line 198
{ 
#line 199
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
#line 200
} 
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
}__pragma( pack ( pop )) 
#line 207
#pragma warning(pop)
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 28
typedef long clock_t; 
#line 30
struct _timespec32 { 
#line 32
__time32_t tv_sec; 
#line 33
long tv_nsec; 
#line 34
}; 
#line 36
struct _timespec64 { 
#line 38
__time64_t tv_sec; 
#line 39
long tv_nsec; 
#line 40
}; 
#line 43
struct timespec { 
#line 45
time_t tv_sec; 
#line 46
long tv_nsec; 
#line 47
}; 
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
int *__cdecl __daylight(); 
#line 72
long *__cdecl __dstbias(); 
#line 78
long *__cdecl __timezone(); 
#line 84
char **__cdecl __tzname(); 
#line 89
errno_t __cdecl _get_daylight(int * _Daylight); 
#line 94
errno_t __cdecl _get_dstbias(long * _DaylightSavingsBias); 
#line 99
errno_t __cdecl _get_timezone(long * _TimeZone); 
#line 104
errno_t __cdecl _get_tzname(size_t * _ReturnValue, char * _Buffer, size_t _SizeInBytes, int _Index); 
#line 121
char *__cdecl asctime(const tm * _Tm); 
#line 128
errno_t __cdecl asctime_s(char * _Buffer, size_t _SizeInBytes, const tm * _Tm); 
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl asctime_s ( char ( & _Buffer ) [ _Size ], struct tm const * _Time ) throw ( ) { return asctime_s ( _Buffer, _Size, _Time ); }}
#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
clock_t __cdecl clock(); 
#line 147
char *__cdecl _ctime32(const __time32_t * _Time); 
#line 152
errno_t __cdecl _ctime32_s(char * _Buffer, size_t _SizeInBytes, const __time32_t * _Time); 
#line 158
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ctime32_s ( char ( & _Buffer ) [ _Size ], __time32_t const * _Time ) throw ( ) { return _ctime32_s ( _Buffer, _Size, _Time ); }}
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
char *__cdecl _ctime64(const __time64_t * _Time); 
#line 172
errno_t __cdecl _ctime64_s(char * _Buffer, size_t _SizeInBytes, const __time64_t * _Time); 
#line 178
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ctime64_s ( char ( & _Buffer ) [ _Size ], __time64_t const * _Time ) throw ( ) { return _ctime64_s ( _Buffer, _Size, _Time ); }}
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
double __cdecl _difftime32(__time32_t _Time1, __time32_t _Time2); 
#line 191
double __cdecl _difftime64(__time64_t _Time1, __time64_t _Time2); 
#line 198
tm *__cdecl _gmtime32(const __time32_t * _Time); 
#line 203
errno_t __cdecl _gmtime32_s(tm * _Tm, const __time32_t * _Time); 
#line 210
tm *__cdecl _gmtime64(const __time64_t * _Time); 
#line 215
errno_t __cdecl _gmtime64_s(tm * _Tm, const __time64_t * _Time); 
#line 222
tm *__cdecl _localtime32(const __time32_t * _Time); 
#line 227
errno_t __cdecl _localtime32_s(tm * _Tm, const __time32_t * _Time); 
#line 234
tm *__cdecl _localtime64(const __time64_t * _Time); 
#line 239
errno_t __cdecl _localtime64_s(tm * _Tm, const __time64_t * _Time); 
#line 245
__time32_t __cdecl _mkgmtime32(tm * _Tm); 
#line 250
__time64_t __cdecl _mkgmtime64(tm * _Tm); 
#line 255
__time32_t __cdecl _mktime32(tm * _Tm); 
#line 260
__time64_t __cdecl _mktime64(tm * _Tm); 
#line 266
size_t __cdecl strftime(char * _Buffer, size_t _SizeInBytes, const char * _Format, const tm * _Tm); 
#line 275
size_t __cdecl _strftime_l(char * _Buffer, size_t _MaxSize, const char * _Format, const tm * _Tm, _locale_t _Locale); 
#line 284
errno_t __cdecl _strdate_s(char * _Buffer, size_t _SizeInBytes); 
#line 289
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strdate_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strdate_s ( _Buffer, _Size ); }}
#line 294 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
char *__cdecl _strdate(char * _Buffer); 
#line 300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
errno_t __cdecl _strtime_s(char * _Buffer, size_t _SizeInBytes); 
#line 305
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strtime_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strtime_s ( _Buffer, _Size ); }}
#line 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
char *__cdecl _strtime(char * _Buffer); 
#line 315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
__time32_t __cdecl _time32(__time32_t * _Time); 
#line 319
__time64_t __cdecl _time64(__time64_t * _Time); 
#line 325
int __cdecl _timespec32_get(_timespec32 * _Ts, int _Base); 
#line 332
int __cdecl _timespec64_get(_timespec64 * _Ts, int _Base); 
#line 346
void __cdecl _tzset(); 
#line 349
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime in" "stead. See online help for details.")) unsigned __cdecl 
#line 350
_getsystime(tm * _Tm); 
#line 354
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime in" "stead. See online help for details.")) unsigned __cdecl 
#line 355
_setsystime(tm * _Tm, unsigned _Milliseconds); 
#line 471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
static __inline char *__cdecl ctime(const time_t *const 
#line 472
_Time) 
#line 474
{ 
#line 475
return _ctime64(_Time); 
#line 476
} 
#line 479
static __inline double __cdecl difftime(const time_t 
#line 480
_Time1, const time_t 
#line 481
_Time2) 
#line 483
{ 
#line 484
return _difftime64(_Time1, _Time2); 
#line 485
} 
#line 488
static __inline tm *__cdecl gmtime(const time_t *const 
#line 489
_Time) 
#line 490
{ 
#line 491
return _gmtime64(_Time); 
#line 492
} 
#line 495
static __inline tm *__cdecl localtime(const time_t *const 
#line 496
_Time) 
#line 498
{ 
#line 499
return _localtime64(_Time); 
#line 500
} 
#line 503
static __inline time_t __cdecl _mkgmtime(tm *const 
#line 504
_Tm) 
#line 506
{ 
#line 507
return _mkgmtime64(_Tm); 
#line 508
} 
#line 511
static __inline time_t __cdecl mktime(tm *const 
#line 512
_Tm) 
#line 514
{ 
#line 515
return _mktime64(_Tm); 
#line 516
} 
#line 518
static __inline time_t __cdecl time(time_t *const 
#line 519
_Time) 
#line 521
{ 
#line 522
return _time64(_Time); 
#line 523
} 
#line 526
static __inline int __cdecl timespec_get(timespec *const 
#line 527
_Ts, const int 
#line 528
_Base) 
#line 530
{ 
#line 531
return _timespec64_get((_timespec64 *)_Ts, _Base); 
#line 532
} 
#line 536
static __inline errno_t __cdecl ctime_s(char *const 
#line 537
_Buffer, const size_t 
#line 538
_SizeInBytes, const time_t *const 
#line 539
_Time) 
#line 541
{ 
#line 542
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
#line 543
} 
#line 546
static __inline errno_t __cdecl gmtime_s(tm *const 
#line 547
_Tm, const time_t *const 
#line 548
_Time) 
#line 550
{ 
#line 551
return _gmtime64_s(_Tm, _Time); 
#line 552
} 
#line 555
static __inline errno_t __cdecl localtime_s(tm *const 
#line 556
_Tm, const time_t *const 
#line 557
_Time) 
#line 559
{ 
#line 560
return _localtime64_s(_Tm, _Time); 
#line 561
} 
#line 580 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
void __cdecl tzset(); 
#line 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
}__pragma( pack ( pop )) 
#line 589
#pragma warning(pop)
#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
#pragma external_header(pop)
#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
extern "C" {
#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
extern clock_t __cdecl clock(); 
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
extern void *__cdecl memset(void *, int, size_t); 
#line 97
extern void *__cdecl memcpy(void *, const void *, size_t); 
#line 99
}
#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern "C" {
#line 219 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern int __cdecl abs(int a); 
#line 227
extern long __cdecl labs(long a); 
#line 235
extern __int64 llabs(__int64 a); 
#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl fabs(double x); 
#line 328
extern __inline float fabsf(float x); 
#line 338 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline int min(const int a, const int b); 
#line 345
extern inline unsigned umin(const unsigned a, const unsigned b); 
#line 352
extern inline __int64 llmin(const __int64 a, const __int64 b); 
#line 359
extern inline unsigned __int64 ullmin(const unsigned __int64 a, const unsigned __int64 b); 
#line 382 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl fminf(float x, float y); 
#line 402 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl fmin(double x, double y); 
#line 413 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline int max(const int a, const int b); 
#line 421
extern inline unsigned umax(const unsigned a, const unsigned b); 
#line 428
extern inline __int64 llmax(const __int64 a, const __int64 b); 
#line 435
extern inline unsigned __int64 ullmax(const unsigned __int64 a, const unsigned __int64 b); 
#line 458 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl fmaxf(float x, float y); 
#line 478 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl fmax(double, double); 
#line 520 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl sin(double x); 
#line 553
extern double __cdecl cos(double x); 
#line 572 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern void sincos(double x, double * sptr, double * cptr); 
#line 588
extern void sincosf(float x, float * sptr, float * cptr); 
#line 633 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl tan(double x); 
#line 702
extern double __cdecl sqrt(double x); 
#line 774 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double rsqrt(double x); 
#line 844
extern float rsqrtf(float x); 
#line 902 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl log2(double x); 
#line 967 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl exp2(double x); 
#line 1032 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl exp2f(float x); 
#line 1097 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double exp10(double x); 
#line 1160
extern float exp10f(float x); 
#line 1255 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl expm1(double x); 
#line 1347 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl expm1f(float x); 
#line 1403 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl log2f(float x); 
#line 1455 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl log10(double x); 
#line 1525
extern double __cdecl log(double x); 
#line 1623 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl log1p(double x); 
#line 1722 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl log1pf(float x); 
#line 1784 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl floor(double x); 
#line 1863
extern double __cdecl exp(double x); 
#line 1904
extern double __cdecl cosh(double x); 
#line 1954
extern double __cdecl sinh(double x); 
#line 2004
extern double __cdecl tanh(double x); 
#line 2061 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl acosh(double x); 
#line 2119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl acoshf(float x); 
#line 2172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl asinh(double x); 
#line 2225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl asinhf(float x); 
#line 2279 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl atanh(double x); 
#line 2333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl atanhf(float x); 
#line 2380 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl ldexp(double x, int exp); 
#line 2426
extern __inline float ldexpf(float x, int exp); 
#line 2480 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl logb(double x); 
#line 2535 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl logbf(float x); 
#line 2575 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern int __cdecl ilogb(double x); 
#line 2615 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern int __cdecl ilogbf(float x); 
#line 2691 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl scalbn(double x, int n); 
#line 2767 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl scalbnf(float x, int n); 
#line 2843 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl scalbln(double x, long n); 
#line 2919 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl scalblnf(float x, long n); 
#line 2994 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl frexp(double x, int * nptr); 
#line 3068
extern __inline float frexpf(float x, int * nptr); 
#line 3122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl round(double x); 
#line 3177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl roundf(float x); 
#line 3195 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern long __cdecl lround(double x); 
#line 3213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern long __cdecl lroundf(float x); 
#line 3231 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __int64 __cdecl llround(double x); 
#line 3249 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __int64 __cdecl llroundf(float x); 
#line 3377 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl rintf(float x); 
#line 3394 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern long __cdecl lrint(double x); 
#line 3411 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern long __cdecl lrintf(float x); 
#line 3428 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __int64 __cdecl llrint(double x); 
#line 3445 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __int64 __cdecl llrintf(float x); 
#line 3498 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl nearbyint(double x); 
#line 3551 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl nearbyintf(float x); 
#line 3611 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl ceil(double x); 
#line 3663 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl trunc(double x); 
#line 3716 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl truncf(float x); 
#line 3742 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl fdim(double x, double y); 
#line 3768 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl fdimf(float x, float y); 
#line 4066 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl atan2(double y, double x); 
#line 4137
extern double __cdecl atan(double x); 
#line 4160
extern double __cdecl acos(double x); 
#line 4211
extern double __cdecl asin(double x); 
#line 4276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl hypot(double x, double y); 
#line 4400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline float __cdecl hypotf(float x, float y); 
#line 5190 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl cbrt(double x); 
#line 5276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl cbrtf(float x); 
#line 5329 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double rcbrt(double x); 
#line 5379
extern float rcbrtf(float x); 
#line 5439
extern double sinpi(double x); 
#line 5499
extern float sinpif(float x); 
#line 5551
extern double cospi(double x); 
#line 5603
extern float cospif(float x); 
#line 5633
extern void sincospi(double x, double * sptr, double * cptr); 
#line 5663
extern void sincospif(float x, float * sptr, float * cptr); 
#line 5996 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl pow(double x, double y); 
#line 6052
extern double __cdecl modf(double x, double * iptr); 
#line 6111
extern double __cdecl fmod(double x, double y); 
#line 6209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl remainder(double x, double y); 
#line 6308 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl remainderf(float x, float y); 
#line 6380 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl remquo(double x, double y, int * quo); 
#line 6452 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl remquof(float x, float y, int * quo); 
#line 6491 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl j0(double x); 
#line 6533 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float j0f(float x); 
#line 6602 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl j1(double x); 
#line 6671 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float j1f(float x); 
#line 6714 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl jn(int n, double x); 
#line 6757 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float jnf(int n, float x); 
#line 6818 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl y0(double x); 
#line 6879 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float y0f(float x); 
#line 6940 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl y1(double x); 
#line 7001 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float y1f(float x); 
#line 7064 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl yn(int n, double x); 
#line 7127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float ynf(int n, float x); 
#line 7318 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl erf(double x); 
#line 7400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl erff(float x); 
#line 7470 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double erfinv(double x); 
#line 7535
extern float erfinvf(float x); 
#line 7576 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl erfc(double x); 
#line 7614 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl erfcf(float x); 
#line 7731 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl lgamma(double x); 
#line 7791 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double erfcinv(double x); 
#line 7846
extern float erfcinvf(float x); 
#line 7914
extern double normcdfinv(double x); 
#line 7982
extern float normcdfinvf(float x); 
#line 8025
extern double normcdf(double x); 
#line 8068
extern float normcdff(float x); 
#line 8132
extern double erfcx(double x); 
#line 8196
extern float erfcxf(float x); 
#line 8317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl lgammaf(float x); 
#line 8415 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl tgamma(double x); 
#line 8513 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl tgammaf(float x); 
#line 8526 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl copysign(double x, double y); 
#line 8539 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl copysignf(float x, float y); 
#line 8558 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl nextafter(double x, double y); 
#line 8577 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl nextafterf(float x, float y); 
#line 8593 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl nan(const char * tagp); 
#line 8609 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl nanf(const char * tagp); 
#line 8614 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern int __isinff(float); 
#line 8615
extern int __isnanf(float); 
#line 8625 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern int __finite(double); 
#line 8626
extern int __finitef(float); 
#line 8627
extern int __signbit(double); 
#line 8628
extern int __isnan(double); 
#line 8629
extern int __isinf(double); 
#line 8632 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern int __signbitf(float); 
#line 8793 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern double __cdecl fma(double x, double y, double z); 
#line 8951 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl fmaf(float x, float y, float z); 
#line 8960 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern int __signbitl(long double); 
#line 8966 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern int __finitel(long double); 
#line 8967
extern int __isinfl(long double); 
#line 8968
extern int __isnanl(long double); 
#line 8972 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern float __cdecl acosf(float); 
#line 8973
extern float __cdecl asinf(float); 
#line 8974
extern float __cdecl atanf(float); 
#line 8975
extern float __cdecl atan2f(float, float); 
#line 8976
extern float __cdecl cosf(float); 
#line 8977
extern float __cdecl sinf(float); 
#line 8978
extern float __cdecl tanf(float); 
#line 8979
extern float __cdecl coshf(float); 
#line 8980
extern float __cdecl sinhf(float); 
#line 8981
extern float __cdecl tanhf(float); 
#line 8982
extern float __cdecl expf(float); 
#line 8983
extern float __cdecl logf(float); 
#line 8984
extern float __cdecl log10f(float); 
#line 8985
extern float __cdecl modff(float, float *); 
#line 8986
extern float __cdecl powf(float, float); 
#line 8987
extern float __cdecl sqrtf(float); 
#line 8988
extern float __cdecl ceilf(float); 
#line 8989
extern float __cdecl floorf(float); 
#line 8990
extern float __cdecl fmodf(float, float); 
#line 10544 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
}
#line 10547
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 23
struct _exception { 
#line 25
int type; 
#line 26
char *name; 
#line 27
double arg1; 
#line 28
double arg2; 
#line 29
double retval; 
#line 30
}; 
#line 37
struct _complex { 
#line 39
double x, y; 
#line 40
}; 
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
typedef float float_t; 
#line 60
typedef double double_t; 
#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
extern const double _HUGE; 
#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
void __cdecl _fperrraise(int _Except); 
#line 171
short __cdecl _dclass(double _X); 
#line 172
short __cdecl _ldclass(long double _X); 
#line 173
short __cdecl _fdclass(float _X); 
#line 175
int __cdecl _dsign(double _X); 
#line 176
int __cdecl _ldsign(long double _X); 
#line 177
int __cdecl _fdsign(float _X); 
#line 179
int __cdecl _dpcomp(double _X, double _Y); 
#line 180
int __cdecl _ldpcomp(long double _X, long double _Y); 
#line 181
int __cdecl _fdpcomp(float _X, float _Y); 
#line 183
short __cdecl _dtest(double * _Px); 
#line 184
short __cdecl _ldtest(long double * _Px); 
#line 185
short __cdecl _fdtest(float * _Px); 
#line 187
short __cdecl _d_int(double * _Px, short _Xexp); 
#line 188
short __cdecl _ld_int(long double * _Px, short _Xexp); 
#line 189
short __cdecl _fd_int(float * _Px, short _Xexp); 
#line 191
short __cdecl _dscale(double * _Px, long _Lexp); 
#line 192
short __cdecl _ldscale(long double * _Px, long _Lexp); 
#line 193
short __cdecl _fdscale(float * _Px, long _Lexp); 
#line 195
short __cdecl _dunscale(short * _Pex, double * _Px); 
#line 196
short __cdecl _ldunscale(short * _Pex, long double * _Px); 
#line 197
short __cdecl _fdunscale(short * _Pex, float * _Px); 
#line 199
short __cdecl _dexp(double * _Px, double _Y, long _Eoff); 
#line 200
short __cdecl _ldexp(long double * _Px, long double _Y, long _Eoff); 
#line 201
short __cdecl _fdexp(float * _Px, float _Y, long _Eoff); 
#line 203
short __cdecl _dnorm(unsigned short * _Ps); 
#line 204
short __cdecl _fdnorm(unsigned short * _Ps); 
#line 206
double __cdecl _dpoly(double _X, const double * _Tab, int _N); 
#line 207
long double __cdecl _ldpoly(long double _X, const long double * _Tab, int _N); 
#line 208
float __cdecl _fdpoly(float _X, const float * _Tab, int _N); 
#line 210
double __cdecl _dlog(double _X, int _Baseflag); 
#line 211
long double __cdecl _ldlog(long double _X, int _Baseflag); 
#line 212
float __cdecl _fdlog(float _X, int _Baseflag); 
#line 214
double __cdecl _dsin(double _X, unsigned _Qoff); 
#line 215
long double __cdecl _ldsin(long double _X, unsigned _Qoff); 
#line 216
float __cdecl _fdsin(float _X, unsigned _Qoff); 
#line 223
typedef 
#line 220
union { 
#line 221
unsigned short _Sh[4]; 
#line 222
double _Val; 
#line 223
} _double_val; 
#line 230
typedef 
#line 227
union { 
#line 228
unsigned short _Sh[2]; 
#line 229
float _Val; 
#line 230
} _float_val; 
#line 237
typedef 
#line 234
union { 
#line 235
unsigned short _Sh[4]; 
#line 236
long double _Val; 
#line 237
} _ldouble_val; 
#line 245
typedef 
#line 240
union { 
#line 241
unsigned short _Word[4]; 
#line 242
float _Float; 
#line 243
double _Double; 
#line 244
long double _Long_double; 
#line 245
} _float_const; 
#line 247
extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C; 
#line 248
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C; 
#line 249
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C; 
#line 251
extern const _float_const _Eps_C, _Rteps_C; 
#line 252
extern const _float_const _FEps_C, _FRteps_C; 
#line 253
extern const _float_const _LEps_C, _LRteps_C; 
#line 255
extern const double _Zero_C, _Xbig_C; 
#line 256
extern const float _FZero_C, _FXbig_C; 
#line 257
extern const long double _LZero_C, _LXbig_C; 
#line 286
extern "C++" {
#line 288
inline int fpclassify(float _X) throw() 
#line 289
{ 
#line 290
return _fdtest(&_X); 
#line 291
} 
#line 293
inline int fpclassify(double _X) throw() 
#line 294
{ 
#line 295
return _dtest(&_X); 
#line 296
} 
#line 298
inline int fpclassify(long double _X) throw() 
#line 299
{ 
#line 300
return _ldtest(&_X); 
#line 301
} 
#line 303
inline bool signbit(float _X) throw() 
#line 304
{ 
#line 305
return _fdsign(_X) != 0; 
#line 306
} 
#line 308
inline bool signbit(double _X) throw() 
#line 309
{ 
#line 310
return _dsign(_X) != 0; 
#line 311
} 
#line 313
inline bool signbit(long double _X) throw() 
#line 314
{ 
#line 315
return _ldsign(_X) != 0; 
#line 316
} 
#line 318
inline int _fpcomp(float _X, float _Y) throw() 
#line 319
{ 
#line 320
return _fdpcomp(_X, _Y); 
#line 321
} 
#line 323
inline int _fpcomp(double _X, double _Y) throw() 
#line 324
{ 
#line 325
return _dpcomp(_X, _Y); 
#line 326
} 
#line 328
inline int _fpcomp(long double _X, long double _Y) throw() 
#line 329
{ 
#line 330
return _ldpcomp(_X, _Y); 
#line 331
} 
#line 333
template< class _Trc, class _Tre> struct _Combined_type { 
#line 335
typedef float _Type; 
#line 336
}; 
#line 338
template<> struct _Combined_type< float, double>  { 
#line 340
typedef double _Type; 
#line 341
}; 
#line 343
template<> struct _Combined_type< float, long double>  { 
#line 345
typedef long double _Type; 
#line 346
}; 
#line 348
template< class _Ty, class _T2> struct _Real_widened { 
#line 350
typedef long double _Type; 
#line 351
}; 
#line 353
template<> struct _Real_widened< float, float>  { 
#line 355
typedef float _Type; 
#line 356
}; 
#line 358
template<> struct _Real_widened< float, double>  { 
#line 360
typedef double _Type; 
#line 361
}; 
#line 363
template<> struct _Real_widened< double, float>  { 
#line 365
typedef double _Type; 
#line 366
}; 
#line 368
template<> struct _Real_widened< double, double>  { 
#line 370
typedef double _Type; 
#line 371
}; 
#line 373
template< class _Ty> struct _Real_type { 
#line 375
typedef double _Type; 
#line 376
}; 
#line 378
template<> struct _Real_type< float>  { 
#line 380
typedef float _Type; 
#line 381
}; 
#line 383
template<> struct _Real_type< long double>  { 
#line 385
typedef long double _Type; 
#line 386
}; 
#line 388
template < class _T1, class _T2 >
      inline int _fpcomp ( _T1 _X, _T2 _Y ) throw ( )
    {
        typedef typename _Combined_type < float,
            typename _Real_widened <
            typename _Real_type < _T1 > :: _Type,
            typename _Real_type < _T2 > :: _Type > :: _Type > :: _Type _Tw;
        return _fpcomp ( ( _Tw ) _X, ( _Tw ) _Y );
    }
#line 398
template < class _Ty >
      inline bool isfinite ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) <= 0;
    }
#line 404
template < class _Ty >
      inline bool isinf ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == 1;
    }
#line 410
template < class _Ty >
      inline bool isnan ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == 2;
    }
#line 416
template < class _Ty >
      inline bool isnormal ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == ( - 1 );
    }
#line 422
template < class _Ty1, class _Ty2 >
      inline bool isgreater ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & 4 ) != 0;
    }
#line 428
template < class _Ty1, class _Ty2 >
      inline bool isgreaterequal ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 2 | 4 ) ) != 0;
    }
#line 434
template < class _Ty1, class _Ty2 >
      inline bool isless ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & 1 ) != 0;
    }
#line 440
template < class _Ty1, class _Ty2 >
      inline bool islessequal ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 1 | 2 ) ) != 0;
    }
#line 446
template < class _Ty1, class _Ty2 >
      inline bool islessgreater ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 1 | 4 ) ) != 0;
    }
#line 452
template < class _Ty1, class _Ty2 >
      inline bool isunordered ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return _fpcomp ( _X, _Y ) == 0;
    }
#line 457
}
#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
int __cdecl abs(int _X); 
#line 465
long __cdecl labs(long _X); 
#line 466
__int64 __cdecl llabs(__int64 _X); 
#line 468
double __cdecl acos(double _X); 
#line 469
double __cdecl asin(double _X); 
#line 470
double __cdecl atan(double _X); 
#line 471
double __cdecl atan2(double _Y, double _X); 
#line 473
double __cdecl cos(double _X); 
#line 474
double __cdecl cosh(double _X); 
#line 475
double __cdecl exp(double _X); 
#line 476
double __cdecl fabs(double _X); 
#line 477
double __cdecl fmod(double _X, double _Y); 
#line 478
double __cdecl log(double _X); 
#line 479
double __cdecl log10(double _X); 
#line 480
double __cdecl pow(double _X, double _Y); 
#line 481
double __cdecl sin(double _X); 
#line 482
double __cdecl sinh(double _X); 
#line 483
double __cdecl sqrt(double _X); 
#line 484
double __cdecl tan(double _X); 
#line 485
double __cdecl tanh(double _X); 
#line 487
double __cdecl acosh(double _X); 
#line 488
double __cdecl asinh(double _X); 
#line 489
double __cdecl atanh(double _X); 
#line 490
double __cdecl atof(const char * _String); 
#line 491
double __cdecl _atof_l(const char * _String, _locale_t _Locale); 
#line 492
double __cdecl _cabs(_complex _Complex_value); 
#line 493
double __cdecl cbrt(double _X); 
#line 494
double __cdecl ceil(double _X); 
#line 495
double __cdecl _chgsign(double _X); 
#line 496
double __cdecl copysign(double _Number, double _Sign); 
#line 497
double __cdecl _copysign(double _Number, double _Sign); 
#line 498
double __cdecl erf(double _X); 
#line 499
double __cdecl erfc(double _X); 
#line 500
double __cdecl exp2(double _X); 
#line 501
double __cdecl expm1(double _X); 
#line 502
double __cdecl fdim(double _X, double _Y); 
#line 503
double __cdecl floor(double _X); 
#line 504
double __cdecl fma(double _X, double _Y, double _Z); 
#line 505
double __cdecl fmax(double _X, double _Y); 
#line 506
double __cdecl fmin(double _X, double _Y); 
#line 507
double __cdecl frexp(double _X, int * _Y); 
#line 508
double __cdecl hypot(double _X, double _Y); 
#line 509
double __cdecl _hypot(double _X, double _Y); 
#line 510
int __cdecl ilogb(double _X); 
#line 511
double __cdecl ldexp(double _X, int _Y); 
#line 512
double __cdecl lgamma(double _X); 
#line 513
__int64 __cdecl llrint(double _X); 
#line 514
__int64 __cdecl llround(double _X); 
#line 515
double __cdecl log1p(double _X); 
#line 516
double __cdecl log2(double _X); 
#line 517
double __cdecl logb(double _X); 
#line 518
long __cdecl lrint(double _X); 
#line 519
long __cdecl lround(double _X); 
#line 521
int __cdecl _matherr(_exception * _Except); 
#line 523
double __cdecl modf(double _X, double * _Y); 
#line 524
double __cdecl nan(const char * _X); 
#line 525
double __cdecl nearbyint(double _X); 
#line 526
double __cdecl nextafter(double _X, double _Y); 
#line 527
double __cdecl nexttoward(double _X, long double _Y); 
#line 528
double __cdecl remainder(double _X, double _Y); 
#line 529
double __cdecl remquo(double _X, double _Y, int * _Z); 
#line 530
double __cdecl rint(double _X); 
#line 531
double __cdecl round(double _X); 
#line 532
double __cdecl scalbln(double _X, long _Y); 
#line 533
double __cdecl scalbn(double _X, int _Y); 
#line 534
double __cdecl tgamma(double _X); 
#line 535
double __cdecl trunc(double _X); 
#line 536
double __cdecl _j0(double _X); 
#line 537
double __cdecl _j1(double _X); 
#line 538
double __cdecl _jn(int _X, double _Y); 
#line 539
double __cdecl _y0(double _X); 
#line 540
double __cdecl _y1(double _X); 
#line 541
double __cdecl _yn(int _X, double _Y); 
#line 543
float __cdecl acoshf(float _X); 
#line 544
float __cdecl asinhf(float _X); 
#line 545
float __cdecl atanhf(float _X); 
#line 546
float __cdecl cbrtf(float _X); 
#line 547
float __cdecl _chgsignf(float _X); 
#line 548
float __cdecl copysignf(float _Number, float _Sign); 
#line 549
float __cdecl _copysignf(float _Number, float _Sign); 
#line 550
float __cdecl erff(float _X); 
#line 551
float __cdecl erfcf(float _X); 
#line 552
float __cdecl expm1f(float _X); 
#line 553
float __cdecl exp2f(float _X); 
#line 554
float __cdecl fdimf(float _X, float _Y); 
#line 555
float __cdecl fmaf(float _X, float _Y, float _Z); 
#line 556
float __cdecl fmaxf(float _X, float _Y); 
#line 557
float __cdecl fminf(float _X, float _Y); 
#line 558
float __cdecl _hypotf(float _X, float _Y); 
#line 559
int __cdecl ilogbf(float _X); 
#line 560
float __cdecl lgammaf(float _X); 
#line 561
__int64 __cdecl llrintf(float _X); 
#line 562
__int64 __cdecl llroundf(float _X); 
#line 563
float __cdecl log1pf(float _X); 
#line 564
float __cdecl log2f(float _X); 
#line 565
float __cdecl logbf(float _X); 
#line 566
long __cdecl lrintf(float _X); 
#line 567
long __cdecl lroundf(float _X); 
#line 568
float __cdecl nanf(const char * _X); 
#line 569
float __cdecl nearbyintf(float _X); 
#line 570
float __cdecl nextafterf(float _X, float _Y); 
#line 571
float __cdecl nexttowardf(float _X, long double _Y); 
#line 572
float __cdecl remainderf(float _X, float _Y); 
#line 573
float __cdecl remquof(float _X, float _Y, int * _Z); 
#line 574
float __cdecl rintf(float _X); 
#line 575
float __cdecl roundf(float _X); 
#line 576
float __cdecl scalblnf(float _X, long _Y); 
#line 577
float __cdecl scalbnf(float _X, int _Y); 
#line 578
float __cdecl tgammaf(float _X); 
#line 579
float __cdecl truncf(float _X); 
#line 589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
float __cdecl _logbf(float _X); 
#line 590
float __cdecl _nextafterf(float _X, float _Y); 
#line 591
int __cdecl _finitef(float _X); 
#line 592
int __cdecl _isnanf(float _X); 
#line 593
int __cdecl _fpclassf(float _X); 
#line 595
int __cdecl _set_FMA3_enable(int _Flag); 
#line 596
int __cdecl _get_FMA3_enable(); 
#line 609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
float __cdecl acosf(float _X); 
#line 610
float __cdecl asinf(float _X); 
#line 611
float __cdecl atan2f(float _Y, float _X); 
#line 612
float __cdecl atanf(float _X); 
#line 613
float __cdecl ceilf(float _X); 
#line 614
float __cdecl cosf(float _X); 
#line 615
float __cdecl coshf(float _X); 
#line 616
float __cdecl expf(float _X); 
#line 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
__inline float __cdecl fabsf(float _X) 
#line 669
{ 
#line 670
return (float)fabs(_X); 
#line 671
} 
#line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
float __cdecl floorf(float _X); 
#line 678
float __cdecl fmodf(float _X, float _Y); 
#line 694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
__inline float __cdecl frexpf(float _X, int *_Y) 
#line 695
{ 
#line 696
return (float)frexp(_X, _Y); 
#line 697
} 
#line 699
__inline float __cdecl hypotf(float _X, float _Y) 
#line 700
{ 
#line 701
return _hypotf(_X, _Y); 
#line 702
} 
#line 704
__inline float __cdecl ldexpf(float _X, int _Y) 
#line 705
{ 
#line 706
return (float)ldexp(_X, _Y); 
#line 707
} 
#line 711
float __cdecl log10f(float _X); 
#line 712
float __cdecl logf(float _X); 
#line 713
float __cdecl modff(float _X, float * _Y); 
#line 714
float __cdecl powf(float _X, float _Y); 
#line 715
float __cdecl sinf(float _X); 
#line 716
float __cdecl sinhf(float _X); 
#line 717
float __cdecl sqrtf(float _X); 
#line 718
float __cdecl tanf(float _X); 
#line 719
float __cdecl tanhf(float _X); 
#line 773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
long double __cdecl acoshl(long double _X); 
#line 775
__inline long double __cdecl acosl(long double _X) 
#line 776
{ 
#line 777
return acos((double)_X); 
#line 778
} 
#line 780
long double __cdecl asinhl(long double _X); 
#line 782
__inline long double __cdecl asinl(long double _X) 
#line 783
{ 
#line 784
return asin((double)_X); 
#line 785
} 
#line 787
__inline long double __cdecl atan2l(long double _Y, long double _X) 
#line 788
{ 
#line 789
return atan2((double)_Y, (double)_X); 
#line 790
} 
#line 792
long double __cdecl atanhl(long double _X); 
#line 794
__inline long double __cdecl atanl(long double _X) 
#line 795
{ 
#line 796
return atan((double)_X); 
#line 797
} 
#line 799
long double __cdecl cbrtl(long double _X); 
#line 801
__inline long double __cdecl ceill(long double _X) 
#line 802
{ 
#line 803
return ceil((double)_X); 
#line 804
} 
#line 806
__inline long double __cdecl _chgsignl(long double _X) 
#line 807
{ 
#line 808
return _chgsign((double)_X); 
#line 809
} 
#line 811
long double __cdecl copysignl(long double _Number, long double _Sign); 
#line 813
__inline long double __cdecl _copysignl(long double _Number, long double _Sign) 
#line 814
{ 
#line 815
return _copysign((double)_Number, (double)_Sign); 
#line 816
} 
#line 818
__inline long double __cdecl coshl(long double _X) 
#line 819
{ 
#line 820
return cosh((double)_X); 
#line 821
} 
#line 823
__inline long double __cdecl cosl(long double _X) 
#line 824
{ 
#line 825
return cos((double)_X); 
#line 826
} 
#line 828
long double __cdecl erfl(long double _X); 
#line 829
long double __cdecl erfcl(long double _X); 
#line 831
__inline long double __cdecl expl(long double _X) 
#line 832
{ 
#line 833
return exp((double)_X); 
#line 834
} 
#line 836
long double __cdecl exp2l(long double _X); 
#line 837
long double __cdecl expm1l(long double _X); 
#line 839
__inline long double __cdecl fabsl(long double _X) 
#line 840
{ 
#line 841
return fabs((double)_X); 
#line 842
} 
#line 844
long double __cdecl fdiml(long double _X, long double _Y); 
#line 846
__inline long double __cdecl floorl(long double _X) 
#line 847
{ 
#line 848
return floor((double)_X); 
#line 849
} 
#line 851
long double __cdecl fmal(long double _X, long double _Y, long double _Z); 
#line 852
long double __cdecl fmaxl(long double _X, long double _Y); 
#line 853
long double __cdecl fminl(long double _X, long double _Y); 
#line 855
__inline long double __cdecl fmodl(long double _X, long double _Y) 
#line 856
{ 
#line 857
return fmod((double)_X, (double)_Y); 
#line 858
} 
#line 860
__inline long double __cdecl frexpl(long double _X, int *_Y) 
#line 861
{ 
#line 862
return frexp((double)_X, _Y); 
#line 863
} 
#line 865
int __cdecl ilogbl(long double _X); 
#line 867
__inline long double __cdecl _hypotl(long double _X, long double _Y) 
#line 868
{ 
#line 869
return _hypot((double)_X, (double)_Y); 
#line 870
} 
#line 872
__inline long double __cdecl hypotl(long double _X, long double _Y) 
#line 873
{ 
#line 874
return _hypot((double)_X, (double)_Y); 
#line 875
} 
#line 877
__inline long double __cdecl ldexpl(long double _X, int _Y) 
#line 878
{ 
#line 879
return ldexp((double)_X, _Y); 
#line 880
} 
#line 882
long double __cdecl lgammal(long double _X); 
#line 883
__int64 __cdecl llrintl(long double _X); 
#line 884
__int64 __cdecl llroundl(long double _X); 
#line 886
__inline long double __cdecl logl(long double _X) 
#line 887
{ 
#line 888
return log((double)_X); 
#line 889
} 
#line 891
__inline long double __cdecl log10l(long double _X) 
#line 892
{ 
#line 893
return log10((double)_X); 
#line 894
} 
#line 896
long double __cdecl log1pl(long double _X); 
#line 897
long double __cdecl log2l(long double _X); 
#line 898
long double __cdecl logbl(long double _X); 
#line 899
long __cdecl lrintl(long double _X); 
#line 900
long __cdecl lroundl(long double _X); 
#line 902
__inline long double __cdecl modfl(long double _X, long double *_Y) 
#line 903
{ 
#line 904
double _F, _I; 
#line 905
_F = modf((double)_X, &_I); 
#line 906
(*_Y) = _I; 
#line 907
return _F; 
#line 908
} 
#line 910
long double __cdecl nanl(const char * _X); 
#line 911
long double __cdecl nearbyintl(long double _X); 
#line 912
long double __cdecl nextafterl(long double _X, long double _Y); 
#line 913
long double __cdecl nexttowardl(long double _X, long double _Y); 
#line 915
__inline long double __cdecl powl(long double _X, long double _Y) 
#line 916
{ 
#line 917
return pow((double)_X, (double)_Y); 
#line 918
} 
#line 920
long double __cdecl remainderl(long double _X, long double _Y); 
#line 921
long double __cdecl remquol(long double _X, long double _Y, int * _Z); 
#line 922
long double __cdecl rintl(long double _X); 
#line 923
long double __cdecl roundl(long double _X); 
#line 924
long double __cdecl scalblnl(long double _X, long _Y); 
#line 925
long double __cdecl scalbnl(long double _X, int _Y); 
#line 927
__inline long double __cdecl sinhl(long double _X) 
#line 928
{ 
#line 929
return sinh((double)_X); 
#line 930
} 
#line 932
__inline long double __cdecl sinl(long double _X) 
#line 933
{ 
#line 934
return sin((double)_X); 
#line 935
} 
#line 937
__inline long double __cdecl sqrtl(long double _X) 
#line 938
{ 
#line 939
return sqrt((double)_X); 
#line 940
} 
#line 942
__inline long double __cdecl tanhl(long double _X) 
#line 943
{ 
#line 944
return tanh((double)_X); 
#line 945
} 
#line 947
__inline long double __cdecl tanl(long double _X) 
#line 948
{ 
#line 949
return tan((double)_X); 
#line 950
} 
#line 952
long double __cdecl tgammal(long double _X); 
#line 953
long double __cdecl truncl(long double _X); 
#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
extern double HUGE; 
#line 979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
double __cdecl j0(double _X); 
#line 980
double __cdecl j1(double _X); 
#line 981
double __cdecl jn(int _X, double _Y); 
#line 982
double __cdecl y0(double _X); 
#line 983
double __cdecl y1(double _X); 
#line 984
double __cdecl yn(int _X, double _Y); 
#line 989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
}__pragma( pack ( pop )) 
#line 991
#pragma warning(pop)
#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"
#pragma external_header(pop)
#line 10548 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 59
_calloc_base(size_t _Count, size_t _Size); 
#line 65
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 66
calloc(size_t _Count, size_t _Size); 
#line 72
int __cdecl _callnewh(size_t _Size); 
#line 77
__declspec(allocator) void *__cdecl 
#line 78
_expand(void * _Block, size_t _Size); 
#line 84
void __cdecl _free_base(void * _Block); 
#line 89
void __cdecl free(void * _Block); 
#line 94
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 95
_malloc_base(size_t _Size); 
#line 100
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 101
malloc(size_t _Size); 
#line 107
size_t __cdecl _msize_base(void * _Block); 
#line 113
size_t __cdecl _msize(void * _Block); 
#line 118
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 119
_realloc_base(void * _Block, size_t _Size); 
#line 125
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 126
realloc(void * _Block, size_t _Size); 
#line 132
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 133
_recalloc_base(void * _Block, size_t _Count, size_t _Size); 
#line 140
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 141
_recalloc(void * _Block, size_t _Count, size_t _Size); 
#line 148
void __cdecl _aligned_free(void * _Block); 
#line 153
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 154
_aligned_malloc(size_t _Size, size_t _Alignment); 
#line 160
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 161
_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset); 
#line 169
size_t __cdecl _aligned_msize(void * _Block, size_t _Alignment, size_t _Offset); 
#line 176
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 177
_aligned_offset_realloc(void * _Block, size_t _Size, size_t _Alignment, size_t _Offset); 
#line 185
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 186
_aligned_offset_recalloc(void * _Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset); 
#line 195
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 196
_aligned_realloc(void * _Block, size_t _Size, size_t _Alignment); 
#line 203
__declspec(allocator) __declspec(restrict) void *__cdecl 
#line 204
_aligned_recalloc(void * _Block, size_t _Count, size_t _Size, size_t _Alignment); 
#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"
}__pragma( pack ( pop )) 
#line 234
#pragma warning(pop)
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 20
__pragma( pack ( push, 8 )) extern "C" {
#line 23
typedef int (__cdecl *_CoreCrtSecureSearchSortCompareFunction)(void *, const void *, const void *); 
#line 24
typedef int (__cdecl *_CoreCrtNonSecureSearchSortCompareFunction)(const void *, const void *); 
#line 30
void *__cdecl bsearch_s(const void * _Key, const void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 39
void __cdecl qsort_s(void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"
void *__cdecl bsearch(const void * _Key, const void * _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 60
void __cdecl qsort(void * _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 68
void *__cdecl _lfind_s(const void * _Key, const void * _Base, unsigned * _NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 78
void *__cdecl _lfind(const void * _Key, const void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 87
void *__cdecl _lsearch_s(const void * _Key, void * _Base, unsigned * _NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 97
void *__cdecl _lsearch(const void * _Key, void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"
void *__cdecl lfind(const void * _Key, const void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 204
void *__cdecl lsearch(const void * _Key, void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"
}__pragma( pack ( pop )) 
#line 218
#pragma warning(pop)
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 54
errno_t __cdecl _itow_s(int _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 61
extern "C++" {template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _itow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
__wchar_t *__cdecl _itow(int _Value, __wchar_t * _Buffer, int _Radix); 
#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
errno_t __cdecl _ltow_s(long _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 84
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ltow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
__wchar_t *__cdecl _ltow(long _Value, __wchar_t * _Buffer, int _Radix); 
#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
errno_t __cdecl _ultow_s(unsigned long _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 106
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ultow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
__wchar_t *__cdecl _ultow(unsigned long _Value, __wchar_t * _Buffer, int _Radix); 
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
double __cdecl wcstod(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 127
double __cdecl _wcstod_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 134
long __cdecl wcstol(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 141
long __cdecl _wcstol_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 149
__int64 __cdecl wcstoll(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 156
__int64 __cdecl _wcstoll_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 164
unsigned long __cdecl wcstoul(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 171
unsigned long __cdecl _wcstoul_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 179
unsigned __int64 __cdecl wcstoull(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 186
unsigned __int64 __cdecl _wcstoull_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 194
long double __cdecl wcstold(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 200
long double __cdecl _wcstold_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 207
float __cdecl wcstof(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 213
float __cdecl _wcstof_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 220
double __cdecl _wtof(const __wchar_t * _String); 
#line 225
double __cdecl _wtof_l(const __wchar_t * _String, _locale_t _Locale); 
#line 231
int __cdecl _wtoi(const __wchar_t * _String); 
#line 236
int __cdecl _wtoi_l(const __wchar_t * _String, _locale_t _Locale); 
#line 242
long __cdecl _wtol(const __wchar_t * _String); 
#line 247
long __cdecl _wtol_l(const __wchar_t * _String, _locale_t _Locale); 
#line 253
__int64 __cdecl _wtoll(const __wchar_t * _String); 
#line 258
__int64 __cdecl _wtoll_l(const __wchar_t * _String, _locale_t _Locale); 
#line 264
errno_t __cdecl _i64tow_s(__int64 _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 272
__wchar_t *__cdecl _i64tow(__int64 _Value, __wchar_t * _Buffer, int _Radix); 
#line 279
errno_t __cdecl _ui64tow_s(unsigned __int64 _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 287
__wchar_t *__cdecl _ui64tow(unsigned __int64 _Value, __wchar_t * _Buffer, int _Radix); 
#line 294
__int64 __cdecl _wtoi64(const __wchar_t * _String); 
#line 299
__int64 __cdecl _wtoi64_l(const __wchar_t * _String, _locale_t _Locale); 
#line 305
__int64 __cdecl _wcstoi64(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 312
__int64 __cdecl _wcstoi64_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 320
unsigned __int64 __cdecl _wcstoui64(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 327
unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 339
__declspec(allocator) __wchar_t *__cdecl _wfullpath(__wchar_t * _Buffer, const __wchar_t * _Path, size_t _BufferCount); 
#line 348
errno_t __cdecl _wmakepath_s(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); 
#line 357
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Drive, wchar_t const * _Dir, wchar_t const * _Filename, wchar_t const * _Ext ) throw ( ) { return _wmakepath_s ( _Buffer, _Size, _Drive, _Dir, _Filename, _Ext ); }}
#line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
void __cdecl _wmakepath(__wchar_t * _Buffer, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); 
#line 375 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
void __cdecl _wperror(const __wchar_t * _ErrorMessage); 
#line 380
void __cdecl _wsplitpath(const __wchar_t * _FullPath, __wchar_t * _Drive, __wchar_t * _Dir, __wchar_t * _Filename, __wchar_t * _Ext); 
#line 388
errno_t __cdecl _wsplitpath_s(const __wchar_t * _FullPath, __wchar_t * _Drive, size_t _DriveCount, __wchar_t * _Dir, size_t _DirCount, __wchar_t * _Filename, size_t _FilenameCount, __wchar_t * _Ext, size_t _ExtCount); 
#line 400
extern "C++" {template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( wchar_t const * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }}
#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
errno_t __cdecl _wdupenv_s(__wchar_t ** _Buffer, size_t * _BufferCount, const __wchar_t * _VarName); 
#line 418
__wchar_t *__cdecl _wgetenv(const __wchar_t * _VarName); 
#line 424
errno_t __cdecl _wgetenv_s(size_t * _RequiredCount, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _VarName); 
#line 431
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _RequiredCount, wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _VarName ) throw ( ) { return _wgetenv_s ( _RequiredCount, _Buffer, _Size, _VarName ); }}
#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
int __cdecl _wputenv(const __wchar_t * _EnvString); 
#line 445
errno_t __cdecl _wputenv_s(const __wchar_t * _Name, const __wchar_t * _Value); 
#line 450
errno_t __cdecl _wsearchenv_s(const __wchar_t * _Filename, const __wchar_t * _VarName, __wchar_t * _Buffer, size_t _BufferCount); 
#line 457
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( wchar_t const * _Filename, wchar_t const * _VarName, wchar_t ( & _ResultPath ) [ _Size ] ) throw ( ) { return _wsearchenv_s ( _Filename, _VarName, _ResultPath, _Size ); }}
#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
void __cdecl _wsearchenv(const __wchar_t * _Filename, const __wchar_t * _VarName, __wchar_t * _ResultPath); 
#line 471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
int __cdecl _wsystem(const __wchar_t * _Command); 
#line 479 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"
}__pragma( pack ( pop )) 
#line 481
#pragma warning(pop)
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 22
__pragma( pack ( push, 8 )) extern "C" {
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
void __cdecl _swab(char * _Buf1, char * _Buf2, int _SizeInBytes); 
#line 56
__declspec(noreturn) void __cdecl exit(int _Code); 
#line 57
__declspec(noreturn) void __cdecl _exit(int _Code); 
#line 58
__declspec(noreturn) void __cdecl _Exit(int _Code); 
#line 59
__declspec(noreturn) void __cdecl quick_exit(int _Code); 
#line 60
__declspec(noreturn) void __cdecl abort(); 
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
unsigned __cdecl _set_abort_behavior(unsigned _Flags, unsigned _Mask); 
#line 77
typedef int (__cdecl *_onexit_t)(void); 
#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
int __cdecl atexit(void (__cdecl *)(void)); 
#line 145
_onexit_t __cdecl _onexit(_onexit_t _Func); 
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
int __cdecl at_quick_exit(void (__cdecl *)(void)); 
#line 159
typedef void (__cdecl *_purecall_handler)(void); 
#line 162
typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); 
#line 171
_purecall_handler __cdecl _set_purecall_handler(_purecall_handler _Handler); 
#line 175
_purecall_handler __cdecl _get_purecall_handler(); 
#line 178
_invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler _Handler); 
#line 182
_invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); 
#line 184
_invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler); 
#line 188
_invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(); 
#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
int __cdecl _set_error_mode(int _Mode); 
#line 217
int *__cdecl _errno(); 
#line 220
errno_t __cdecl _set_errno(int _Value); 
#line 221
errno_t __cdecl _get_errno(int * _Value); 
#line 223
unsigned long *__cdecl __doserrno(); 
#line 226
errno_t __cdecl _set_doserrno(unsigned long _Value); 
#line 227
errno_t __cdecl _get_doserrno(unsigned long * _Value); 
#line 230
char **__cdecl __sys_errlist(); 
#line 233
int *__cdecl __sys_nerr(); 
#line 236
void __cdecl perror(const char * _ErrMsg); 
#line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char **__cdecl __p__pgmptr(); 
#line 243
__wchar_t **__cdecl __p__wpgmptr(); 
#line 244
int *__cdecl __p__fmode(); 
#line 259 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
errno_t __cdecl _get_pgmptr(char ** _Value); 
#line 262
errno_t __cdecl _get_wpgmptr(__wchar_t ** _Value); 
#line 264
errno_t __cdecl _set_fmode(int _Mode); 
#line 266
errno_t __cdecl _get_fmode(int * _PMode); 
#line 279
typedef 
#line 275
struct _div_t { 
#line 277
int quot; 
#line 278
int rem; 
#line 279
} div_t; 
#line 285
typedef 
#line 281
struct _ldiv_t { 
#line 283
long quot; 
#line 284
long rem; 
#line 285
} ldiv_t; 
#line 291
typedef 
#line 287
struct _lldiv_t { 
#line 289
__int64 quot; 
#line 290
__int64 rem; 
#line 291
} lldiv_t; 
#line 293
int __cdecl abs(int _Number); 
#line 294
long __cdecl labs(long _Number); 
#line 295
__int64 __cdecl llabs(__int64 _Number); 
#line 296
__int64 __cdecl _abs64(__int64 _Number); 
#line 298
unsigned short __cdecl _byteswap_ushort(unsigned short _Number); 
#line 299
unsigned long __cdecl _byteswap_ulong(unsigned long _Number); 
#line 300
unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Number); 
#line 302
div_t __cdecl div(int _Numerator, int _Denominator); 
#line 303
ldiv_t __cdecl ldiv(long _Numerator, long _Denominator); 
#line 304
lldiv_t __cdecl lldiv(__int64 _Numerator, __int64 _Denominator); 
#line 308
#pragma warning(push)
#pragma warning(disable: 6540)
#line 311
unsigned __cdecl _rotl(unsigned _Value, int _Shift); 
#line 317
unsigned long __cdecl _lrotl(unsigned long _Value, int _Shift); 
#line 322
unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift); 
#line 327
unsigned __cdecl _rotr(unsigned _Value, int _Shift); 
#line 333
unsigned long __cdecl _lrotr(unsigned long _Value, int _Shift); 
#line 338
unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift); 
#line 343
#pragma warning(pop)
#line 350
void __cdecl srand(unsigned _Seed); 
#line 352
int __cdecl rand(); 
#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
extern "C++" {
#line 363
inline long abs(const long _X) throw() 
#line 364
{ 
#line 365
return labs(_X); 
#line 366
} 
#line 368
inline __int64 abs(const __int64 _X) throw() 
#line 369
{ 
#line 370
return llabs(_X); 
#line 371
} 
#line 373
inline ldiv_t div(const long _A1, const long _A2) throw() 
#line 374
{ 
#line 375
return ldiv(_A1, _A2); 
#line 376
} 
#line 378
inline lldiv_t div(const __int64 _A1, const __int64 _A2) throw() 
#line 379
{ 
#line 380
return lldiv(_A1, _A2); 
#line 381
} 
#line 382
}
#line 394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma pack ( push, 4 )
#line 398
typedef 
#line 396
struct { 
#line 397
unsigned char ld[10]; 
#line 398
} _LDOUBLE; 
#pragma pack ( pop )
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
typedef 
#line 416
struct { 
#line 417
double x; 
#line 418
} _CRT_DOUBLE; 
#line 423
typedef 
#line 421
struct { 
#line 422
float f; 
#line 423
} _CRT_FLOAT; 
#line 432
typedef 
#line 430
struct { 
#line 431
long double x; 
#line 432
} _LONGDOUBLE; 
#line 436
#pragma pack ( push, 4 )
#line 440
typedef 
#line 438
struct { 
#line 439
unsigned char ld12[12]; 
#line 440
} _LDBL12; 
#pragma pack ( pop )
#line 450
double __cdecl atof(const char * _String); 
#line 451
int __cdecl atoi(const char * _String); 
#line 452
long __cdecl atol(const char * _String); 
#line 453
__int64 __cdecl atoll(const char * _String); 
#line 454
__int64 __cdecl _atoi64(const char * _String); 
#line 456
double __cdecl _atof_l(const char * _String, _locale_t _Locale); 
#line 457
int __cdecl _atoi_l(const char * _String, _locale_t _Locale); 
#line 458
long __cdecl _atol_l(const char * _String, _locale_t _Locale); 
#line 459
__int64 __cdecl _atoll_l(const char * _String, _locale_t _Locale); 
#line 460
__int64 __cdecl _atoi64_l(const char * _String, _locale_t _Locale); 
#line 462
int __cdecl _atoflt(_CRT_FLOAT * _Result, const char * _String); 
#line 463
int __cdecl _atodbl(_CRT_DOUBLE * _Result, char * _String); 
#line 464
int __cdecl _atoldbl(_LDOUBLE * _Result, char * _String); 
#line 467
int __cdecl _atoflt_l(_CRT_FLOAT * _Result, const char * _String, _locale_t _Locale); 
#line 474
int __cdecl _atodbl_l(_CRT_DOUBLE * _Result, char * _String, _locale_t _Locale); 
#line 482
int __cdecl _atoldbl_l(_LDOUBLE * _Result, char * _String, _locale_t _Locale); 
#line 489
float __cdecl strtof(const char * _String, char ** _EndPtr); 
#line 495
float __cdecl _strtof_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 502
double __cdecl strtod(const char * _String, char ** _EndPtr); 
#line 508
double __cdecl _strtod_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 515
long double __cdecl strtold(const char * _String, char ** _EndPtr); 
#line 521
long double __cdecl _strtold_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 528
long __cdecl strtol(const char * _String, char ** _EndPtr, int _Radix); 
#line 535
long __cdecl _strtol_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 543
__int64 __cdecl strtoll(const char * _String, char ** _EndPtr, int _Radix); 
#line 550
__int64 __cdecl _strtoll_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 558
unsigned long __cdecl strtoul(const char * _String, char ** _EndPtr, int _Radix); 
#line 565
unsigned long __cdecl _strtoul_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 573
unsigned __int64 __cdecl strtoull(const char * _String, char ** _EndPtr, int _Radix); 
#line 580
unsigned __int64 __cdecl _strtoull_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 588
__int64 __cdecl _strtoi64(const char * _String, char ** _EndPtr, int _Radix); 
#line 595
__int64 __cdecl _strtoi64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 603
unsigned __int64 __cdecl _strtoui64(const char * _String, char ** _EndPtr, int _Radix); 
#line 610
unsigned __int64 __cdecl _strtoui64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 626
errno_t __cdecl _itoa_s(int _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 633
extern "C++" {template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _itoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char *__cdecl _itoa(int _Value, char * _Buffer, int _Radix); 
#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
errno_t __cdecl _ltoa_s(long _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 657
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ltoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char *__cdecl _ltoa(long _Value, char * _Buffer, int _Radix); 
#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
errno_t __cdecl _ultoa_s(unsigned long _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 680
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ultoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char *__cdecl _ultoa(unsigned long _Value, char * _Buffer, int _Radix); 
#line 696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
errno_t __cdecl _i64toa_s(__int64 _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 705
char *__cdecl _i64toa(__int64 _Value, char * _Buffer, int _Radix); 
#line 713
errno_t __cdecl _ui64toa_s(unsigned __int64 _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 721
char *__cdecl _ui64toa(unsigned __int64 _Value, char * _Buffer, int _Radix); 
#line 741
errno_t __cdecl _ecvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 750
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _DigitCount, int * _PtDec, int * _PtSign ) throw ( ) { return _ecvt_s ( _Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign ); }}
#line 760 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char *__cdecl _ecvt(double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 769
errno_t __cdecl _fcvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 778
extern "C++" {template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign ) throw ( ) { return _fcvt_s ( _Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign ); }}
#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char *__cdecl _fcvt(double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 798
errno_t __cdecl _gcvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _DigitCount); 
#line 805
extern "C++" {template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _DigitCount ) throw ( ) { return _gcvt_s ( _Buffer, _Size, _Value, _DigitCount ); }}
#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char *__cdecl _gcvt(double _Value, int _DigitCount, char * _Buffer); 
#line 843 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
int __cdecl ___mb_cur_max_func(); 
#line 846
int __cdecl ___mb_cur_max_l_func(_locale_t _Locale); 
#line 852 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
int __cdecl mblen(const char * _Ch, size_t _MaxCount); 
#line 858
int __cdecl _mblen_l(const char * _Ch, size_t _MaxCount, _locale_t _Locale); 
#line 866
size_t __cdecl _mbstrlen(const char * _String); 
#line 872
size_t __cdecl _mbstrlen_l(const char * _String, _locale_t _Locale); 
#line 879
size_t __cdecl _mbstrnlen(const char * _String, size_t _MaxCount); 
#line 886
size_t __cdecl _mbstrnlen_l(const char * _String, size_t _MaxCount, _locale_t _Locale); 
#line 893
int __cdecl mbtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes); 
#line 900
int __cdecl _mbtowc_l(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale); 
#line 908
errno_t __cdecl mbstowcs_s(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount); 
#line 916
extern "C++" {template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], char const * _Source, size_t _MaxCount ) throw ( ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }}
#line 924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
size_t __cdecl mbstowcs(__wchar_t * _Dest, const char * _Source, size_t _MaxCount); 
#line 932 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
errno_t __cdecl _mbstowcs_s_l(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount, _locale_t _Locale); 
#line 941
extern "C++" {template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], char const * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }}
#line 950 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
size_t __cdecl _mbstowcs_l(__wchar_t * _Dest, const char * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
int __cdecl wctomb(char * _MbCh, __wchar_t _WCh); 
#line 969
int __cdecl _wctomb_l(char * _MbCh, __wchar_t _WCh, _locale_t _Locale); 
#line 978
errno_t __cdecl wctomb_s(int * _SizeConverted, char * _MbCh, rsize_t _SizeInBytes, __wchar_t _WCh); 
#line 988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
errno_t __cdecl _wctomb_s_l(int * _SizeConverted, char * _MbCh, size_t _SizeInBytes, __wchar_t _WCh, _locale_t _Locale); 
#line 996
errno_t __cdecl wcstombs_s(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes); 
#line 1004
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], wchar_t const * _Source, size_t _MaxCount ) throw ( ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }}
#line 1012 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
size_t __cdecl wcstombs(char * _Dest, const __wchar_t * _Source, size_t _MaxCount); 
#line 1020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
errno_t __cdecl _wcstombs_s_l(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes, _locale_t _Locale); 
#line 1029
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], wchar_t const * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }}
#line 1038 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
size_t __cdecl _wcstombs_l(char * _Dest, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 1068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
__declspec(allocator) char *__cdecl _fullpath(char * _Buffer, const char * _Path, size_t _BufferCount); 
#line 1077
errno_t __cdecl _makepath_s(char * _Buffer, size_t _BufferCount, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); 
#line 1086
extern "C++" {template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Buffer ) [ _Size ], char const * _Drive, char const * _Dir, char const * _Filename, char const * _Ext ) throw ( ) { return _makepath_s ( _Buffer, _Size, _Drive, _Dir, _Filename, _Ext ); }}
#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
void __cdecl _makepath(char * _Buffer, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); 
#line 1105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
void __cdecl _splitpath(const char * _FullPath, char * _Drive, char * _Dir, char * _Filename, char * _Ext); 
#line 1114
errno_t __cdecl _splitpath_s(const char * _FullPath, char * _Drive, size_t _DriveCount, char * _Dir, size_t _DirCount, char * _Filename, size_t _FilenameCount, char * _Ext, size_t _ExtCount); 
#line 1126
extern "C++" {template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( char const * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }}
#line 1132
errno_t __cdecl getenv_s(size_t * _RequiredCount, char * _Buffer, rsize_t _BufferCount, const char * _VarName); 
#line 1144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
int *__cdecl __p___argc(); 
#line 1145
char ***__cdecl __p___argv(); 
#line 1146
__wchar_t ***__cdecl __p___wargv(); 
#line 1158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char ***__cdecl __p__environ(); 
#line 1159
__wchar_t ***__cdecl __p__wenviron(); 
#line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
char *__cdecl getenv(const char * _VarName); 
#line 1188
extern "C++" {template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _RequiredCount, char ( & _Buffer ) [ _Size ], char const * _VarName ) throw ( ) { return getenv_s ( _RequiredCount, _Buffer, _Size, _VarName ); }}
#line 1201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
errno_t __cdecl _dupenv_s(char ** _Buffer, size_t * _BufferCount, const char * _VarName); 
#line 1211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
int __cdecl system(const char * _Command); 
#line 1217
#pragma warning(push)
#pragma warning(disable: 6540)
#line 1221
int __cdecl _putenv(const char * _EnvString); 
#line 1226
errno_t __cdecl _putenv_s(const char * _Name, const char * _Value); 
#line 1231
#pragma warning(pop)
#line 1233
errno_t __cdecl _searchenv_s(const char * _Filename, const char * _VarName, char * _Buffer, size_t _BufferCount); 
#line 1240
extern "C++" {template < size_t _Size > inline errno_t __cdecl _searchenv_s ( char const * _Filename, char const * _VarName, char ( & _Buffer ) [ _Size ] ) throw ( ) { return _searchenv_s ( _Filename, _VarName, _Buffer, _Size ); }}
#line 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
void __cdecl _searchenv(const char * _Filename, const char * _VarName, char * _Buffer); 
#line 1255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode in" "stead. See online help for details.")) void __cdecl 
#line 1256
_seterrormode(int _Mode); 
#line 1260
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. S" "ee online help for details.")) void __cdecl 
#line 1261
_beep(unsigned _Frequency, unsigned _Duration); 
#line 1266
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. " "See online help for details.")) void __cdecl 
#line 1267
_sleep(unsigned long _Duration); 
#line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
#line 1293
char *__cdecl ecvt(double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 1301
char *__cdecl fcvt(double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 1309
char *__cdecl gcvt(double _Value, int _DigitCount, char * _DstBuf); 
#line 1316
char *__cdecl itoa(int _Value, char * _Buffer, int _Radix); 
#line 1323
char *__cdecl ltoa(long _Value, char * _Buffer, int _Radix); 
#line 1331
void __cdecl swab(char * _Buf1, char * _Buf2, int _SizeInBytes); 
#line 1338
char *__cdecl ultoa(unsigned long _Value, char * _Buffer, int _Radix); 
#line 1347
int __cdecl putenv(const char * _EnvString); 
#line 1351
#pragma warning(pop)
#line 1353
_onexit_t __cdecl onexit(_onexit_t _Func); 
#line 1359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
}__pragma( pack ( pop )) 
#line 1361
#pragma warning(pop)
#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(pop)
#line 10551 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#pragma external_header(push)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
#pragma external_header(push)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma external_header(push)
#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#pragma external_header(push)
#line 591 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"
#pragma external_header(pop)
#line 1462 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"
#pragma external_header(push)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new_debug.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#pragma warning(disable: 4985)
#line 17
extern "C++" {
#line 19
#pragma pack ( push, 8 )
#line 33
namespace std { 
#line 35
struct nothrow_t { 
#line 36
explicit nothrow_t() = default;
#line 37
}; 
#line 42
extern const nothrow_t nothrow; 
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"
}
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"
[[nodiscard]] __declspec(allocator) void *__cdecl 
#line 48
operator new(size_t _Size); 
#line 52
[[nodiscard]] __declspec(allocator) void *__cdecl 
#line 53
operator new(size_t _Size, const std::nothrow_t &) noexcept; 
#line 58
[[nodiscard]] __declspec(allocator) void *__cdecl 
#line 59
operator new[](size_t _Size); 
#line 63
[[nodiscard]] __declspec(allocator) void *__cdecl 
#line 64
operator new[](size_t _Size, const std::nothrow_t &) noexcept; 
#line 69
void __cdecl operator delete(void * _Block) noexcept; 
#line 73
void __cdecl operator delete(void * _Block, const std::nothrow_t &) noexcept; 
#line 78
void __cdecl operator delete[](void * _Block) noexcept; 
#line 82
void __cdecl operator delete[](void * _Block, const std::nothrow_t &) noexcept; 
#line 87
void __cdecl operator delete(void * _Block, size_t _Size) noexcept; 
#line 92
void __cdecl operator delete[](void * _Block, size_t _Size) noexcept; 
#line 160
#pragma warning(push)
#pragma warning(disable: 4577)
#pragma warning(disable: 4514)
#line 165
[[nodiscard]] inline void *__cdecl 
#line 166
operator new(size_t _Size, void *_Where) noexcept 
#line 167
{ 
#line 168
(void)_Size; 
#line 169
return _Where; 
#line 170
} 
#line 172
inline void __cdecl operator delete(void *, void *) noexcept 
#line 173
{ 
#line 175
} 
#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"
[[nodiscard]] inline void *__cdecl 
#line 181
operator new[](size_t _Size, void *
#line 182
_Where) noexcept 
#line 183
{ 
#line 184
(void)_Size; 
#line 185
return _Where; 
#line 186
} 
#line 188
inline void __cdecl operator delete[](void *, void *) noexcept 
#line 189
{ 
#line 190
} 
#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"
}
#line 192
#pragma warning(pop)
#line 196
#pragma pack ( pop )
#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"
#pragma warning(pop)
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new_debug.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 16
extern "C++" {
#line 18
#pragma pack ( push, 8 )
#line 25
[[nodiscard]] 
#line 26
__declspec(allocator) void *__cdecl operator new(size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 33
[[nodiscard]] 
#line 34
__declspec(allocator) void *__cdecl operator new[](size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 41
void __cdecl operator delete(void * _Block, int _BlockUse, const char * _FileName, int _LineNumber) noexcept; 
#line 48
void __cdecl operator delete[](void * _Block, int _BlockUse, const char * _FileName, int _LineNumber) noexcept; 
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new_debug.h"
}
#line 59
#pragma pack ( pop )
#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new_debug.h"
#pragma warning(pop)
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 23
typedef void *_HFILE; 
#line 49
typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); 
#line 50
typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); 
#line 56
typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); 
#line 112
typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); 
#line 118
struct _CrtMemBlockHeader; 
#line 127
typedef 
#line 120
struct _CrtMemState { 
#line 122
_CrtMemBlockHeader *pBlockHeader; 
#line 123
size_t lCounts[5]; 
#line 124
size_t lSizes[5]; 
#line 125
size_t lHighWaterCount; 
#line 126
size_t lTotalCount; 
#line 127
} _CrtMemState; 
#line 813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"
}__pragma( pack ( pop )) 
#line 815
#pragma warning(pop)
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma external_header(push)
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1900")
#line 138 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MT_StaticRelease")
#line 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma external_header(push)
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"
#pragma comment(lib, "libcpmt")
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"
#pragma external_header(pop)
#line 344 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
namespace std { 
#line 345
enum _Uninitialized { 
#line 346
_Noinit
#line 347
}; 
#line 349
class _Lockit { 
#line 365
public: __thiscall _Lockit() noexcept; 
#line 366
explicit __thiscall _Lockit(int) noexcept; 
#line 367
__thiscall ~_Lockit() noexcept; 
#line 370 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
static void __cdecl _Lockit_ctor(int) noexcept; 
#line 371
static void __cdecl _Lockit_dtor(int) noexcept; 
#line 374
private: static void __cdecl _Lockit_ctor(_Lockit *) noexcept; 
#line 375
static void __cdecl _Lockit_ctor(_Lockit *, int) noexcept; 
#line 376
static void __cdecl _Lockit_dtor(_Lockit *) noexcept; 
#line 379
public: _Lockit(const _Lockit &) = delete;
#line 380
_Lockit &operator=(const _Lockit &) = delete;
#line 383
private: int _Locktype; 
#line 384
}; 
#line 459 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
class _Init_locks { 
#line 471
public: __thiscall _Init_locks() noexcept; 
#line 472
__thiscall ~_Init_locks() noexcept; 
#line 476 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
private: static void __cdecl _Init_locks_ctor(_Init_locks *) noexcept; 
#line 477
static void __cdecl _Init_locks_dtor(_Init_locks *) noexcept; 
#line 478
}; 
#line 516 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
}
#line 525 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 529 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"
#pragma external_header(push)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 23
[[nodiscard]] inline double abs(double _Xx) noexcept { 
#line 24
return ::fabs(_Xx); 
#line 25
} 
#line 27
[[nodiscard]] inline float abs(float _Xx) noexcept { 
#line 28
return ::fabsf(_Xx); 
#line 29
} 
#line 31
[[nodiscard]] inline long double abs(long double _Xx) noexcept { 
#line 32
return ::fabsl(_Xx); 
#line 33
} 
#line 35
namespace std { 
#line 36
using ::size_t;
#line 37
using ::div_t;
#line 38
using ::ldiv_t;
#line 39
using ::abort;
#line 40
using ::abs;
#line 41
using ::atexit;
#line 42
using ::atof;
#line 43
using ::atoi;
#line 44
using ::atol;
#line 45
using ::bsearch;
#line 46
using ::calloc;
#line 47
using ::div;
#line 48
using ::exit;
#line 49
using ::free;
#line 50
using ::labs;
#line 51
using ::ldiv;
#line 52
using ::malloc;
#line 53
using ::mblen;
#line 54
using ::mbstowcs;
#line 55
using ::mbtowc;
#line 56
using ::qsort;
#line 57
using ::rand;
#line 58
using ::realloc;
#line 59
using ::srand;
#line 60
using ::strtod;
#line 61
using ::strtol;
#line 62
using ::strtoul;
#line 63
using ::wcstombs;
#line 64
using ::wctomb;
#line 66
using ::lldiv_t;
#line 69
using ::getenv;
#line 70
using ::system;
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"
using ::atoll;
#line 74
using ::llabs;
#line 75
using ::lldiv;
#line 76
using ::strtof;
#line 77
using ::strtold;
#line 78
using ::strtoll;
#line 79
using ::strtoull;
#line 81
using ::_Exit;
#line 82
using ::at_quick_exit;
#line 83
using ::quick_exit;
#line 84
}
#line 88
#pragma warning(pop)
#pragma pack ( pop )
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 19
namespace std { 
#line 20
template < class _Ty, _Ty _Val >
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type = integral_constant;

    constexpr operator value_type ( ) const noexcept {
        return value;
    }

    [ [ nodiscard ] ] constexpr value_type operator ( ) ( ) const noexcept {
        return value;
    }
};
#line 36
template< bool _Val> using bool_constant = integral_constant< bool, _Val> ; 
#line 39
using true_type = bool_constant< true> ; 
#line 40
using false_type = bool_constant< false> ; 
#line 42
template< bool _Test, class _Ty = void> 
#line 43
struct enable_if { }; 
#line 45
template< class _Ty> 
#line 46
struct enable_if< true, _Ty>  { 
#line 47
using type = _Ty; 
#line 48
}; 
#line 50
template< bool _Test, class _Ty = void> using enable_if_t = typename enable_if< _Test, _Ty> ::type; 
#line 53
template< bool _Test, class _Ty1, class _Ty2> 
#line 54
struct conditional { 
#line 55
using type = _Ty1; 
#line 56
}; 
#line 58
template< class _Ty1, class _Ty2> 
#line 59
struct conditional< false, _Ty1, _Ty2>  { 
#line 60
using type = _Ty2; 
#line 61
}; 
#line 63
template< bool _Test, class _Ty1, class _Ty2> using conditional_t = typename conditional< _Test, _Ty1, _Ty2> ::type; 
#line 73
template< class , class > constexpr bool 
#line 74
is_same_v = false; 
#line 75
template< class _Ty> constexpr bool 
#line 76
is_same_v< _Ty, _Ty>  = true; 
#line 78
template< class _Ty1, class _Ty2> 
#line 79
struct is_same : public bool_constant< is_same_v< _Ty1, _Ty2> >  { }; 
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"
template< class _Ty> 
#line 83
struct remove_const { 
#line 84
using type = _Ty; 
#line 85
}; 
#line 87
template< class _Ty> 
#line 88
struct remove_const< const _Ty>  { 
#line 89
using type = _Ty; 
#line 90
}; 
#line 92
template< class _Ty> using remove_const_t = typename remove_const< _Ty> ::type; 
#line 95
template< class _Ty> 
#line 96
struct remove_volatile { 
#line 97
using type = _Ty; 
#line 98
}; 
#line 100
template< class _Ty> 
#line 101
struct remove_volatile< volatile _Ty>  { 
#line 102
using type = _Ty; 
#line 103
}; 
#line 105
template< class _Ty> using remove_volatile_t = typename remove_volatile< _Ty> ::type; 
#line 108
template< class _Ty> 
#line 109
struct remove_cv { 
#line 110
using type = _Ty; 
#line 112
template< template< class >  class _Fn> using _Apply = _Fn< _Ty> ; 
#line 114
}; 
#line 116
template< class _Ty> 
#line 117
struct remove_cv< const _Ty>  { 
#line 118
using type = _Ty; 
#line 120
template< template< class >  class _Fn> using _Apply = const _Fn< _Ty> ; 
#line 122
}; 
#line 124
template< class _Ty> 
#line 125
struct remove_cv< volatile _Ty>  { 
#line 126
using type = _Ty; 
#line 128
template< template< class >  class _Fn> using _Apply = volatile _Fn< _Ty> ; 
#line 130
}; 
#line 132
template< class _Ty> 
#line 133
struct remove_cv< const volatile _Ty>  { 
#line 134
using type = _Ty; 
#line 136
template< template< class >  class _Fn> using _Apply = const volatile _Fn< _Ty> ; 
#line 138
}; 
#line 140
template< class _Ty> using remove_cv_t = typename remove_cv< _Ty> ::type; 
#line 143
template< bool _First_value, class _First, class ..._Rest> 
#line 144
struct _Disjunction { 
#line 145
using type = _First; 
#line 146
}; 
#line 148
template< class _False, class _Next, class ..._Rest> 
#line 149
struct _Disjunction< false, _False, _Next, _Rest...>  { 
#line 150
using type = typename std::_Disjunction< _Next::value, _Next, _Rest...> ::type; 
#line 151
}; 
#line 153
template< class ..._Traits> 
#line 154
struct disjunction : public false_type { }; 
#line 156
template< class _First, class ..._Rest> 
#line 157
struct disjunction< _First, _Rest...>  : public _Disjunction< _First::value, _First, _Rest...> ::type { 
#line 159
}; 
#line 161
template< class ..._Traits> constexpr bool 
#line 162
disjunction_v = (disjunction< _Traits...> ::value); 
#line 164
template< class _Ty, class ..._Types> constexpr bool 
#line 165
_Is_any_of_v = disjunction_v< is_same< _Ty, _Types> ...> ; 
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"
template< class _Ty> constexpr bool 
#line 175
is_integral_v = _Is_any_of_v< remove_cv_t< _Ty> , bool, char, signed char, unsigned char, __wchar_t, char16_t, char32_t, short, unsigned short, int, unsigned, long, unsigned long, __int64, unsigned __int64> ; 
#line 182
template< class _Ty> 
#line 183
struct is_integral : public bool_constant< is_integral_v< _Ty> >  { }; 
#line 185
template< class _Ty> constexpr bool 
#line 186
is_floating_point_v = _Is_any_of_v< remove_cv_t< _Ty> , float, double, long double> ; 
#line 188
template< class _Ty> 
#line 189
struct is_floating_point : public bool_constant< is_floating_point_v< _Ty> >  { }; 
#line 191
template< class _Ty> constexpr bool 
#line 192
is_arithmetic_v = is_integral_v< _Ty>  || is_floating_point_v< _Ty> ; 
#line 195
template< class _Ty> 
#line 196
struct is_arithmetic : public bool_constant< is_arithmetic_v< _Ty> >  { }; 
#line 198
template< class _Ty> 
#line 199
struct remove_reference { 
#line 200
using type = _Ty; 
#line 201
using _Const_thru_ref_type = const _Ty; 
#line 202
}; 
#line 204
template< class _Ty> 
#line 205
struct remove_reference< _Ty &>  { 
#line 206
using type = _Ty; 
#line 207
using _Const_thru_ref_type = const _Ty &; 
#line 208
}; 
#line 210
template< class _Ty> 
#line 211
struct remove_reference< _Ty &&>  { 
#line 212
using type = _Ty; 
#line 213
using _Const_thru_ref_type = const _Ty &&; 
#line 214
}; 
#line 216
template< class _Ty> using remove_reference_t = typename remove_reference< _Ty> ::type; 
#line 219
template< class _Ty> using _Const_thru_ref = typename remove_reference< _Ty> ::_Const_thru_ref_type; 
#line 222
template< class _Ty> using _Remove_cvref_t = remove_cv_t< remove_reference_t< _Ty> > ; 
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"
}
#line 238
#pragma warning(pop)
#pragma pack ( pop )
#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"
#pragma external_header(pop)
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 36
[[nodiscard]] inline float acos(float _Xx) noexcept { 
#line 37
return ::acosf(_Xx); 
#line 38
} 
#line 40
[[nodiscard]] inline float acosh(float _Xx) noexcept { 
#line 41
return ::acoshf(_Xx); 
#line 42
} 
#line 44
[[nodiscard]] inline float asin(float _Xx) noexcept { 
#line 45
return ::asinf(_Xx); 
#line 46
} 
#line 48
[[nodiscard]] inline float asinh(float _Xx) noexcept { 
#line 49
return ::asinhf(_Xx); 
#line 50
} 
#line 52
[[nodiscard]] inline float atan(float _Xx) noexcept { 
#line 53
return ::atanf(_Xx); 
#line 54
} 
#line 56
[[nodiscard]] inline float atanh(float _Xx) noexcept { 
#line 57
return ::atanhf(_Xx); 
#line 58
} 
#line 60
[[nodiscard]] inline float atan2(float _Yx, float _Xx) noexcept { 
#line 61
return ::atan2f(_Yx, _Xx); 
#line 62
} 
#line 64
[[nodiscard]] inline float cbrt(float _Xx) noexcept { 
#line 65
return ::cbrtf(_Xx); 
#line 66
} 
#line 68
[[nodiscard]] inline float ceil(float _Xx) noexcept { 
#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::ceilf(_Xx); 
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 78
[[nodiscard]] inline float copysign(float _Number, float _Sign) noexcept { 
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::copysignf(_Number, _Sign); 
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 88
[[nodiscard]] inline float cos(float _Xx) noexcept { 
#line 89
return ::cosf(_Xx); 
#line 90
} 
#line 92
[[nodiscard]] inline float cosh(float _Xx) noexcept { 
#line 93
return ::coshf(_Xx); 
#line 94
} 
#line 96
[[nodiscard]] inline float erf(float _Xx) noexcept { 
#line 97
return ::erff(_Xx); 
#line 98
} 
#line 100
[[nodiscard]] inline float erfc(float _Xx) noexcept { 
#line 101
return ::erfcf(_Xx); 
#line 102
} 
#line 104
[[nodiscard]] inline float exp(float _Xx) noexcept { 
#line 105
return ::expf(_Xx); 
#line 106
} 
#line 108
[[nodiscard]] inline float exp2(float _Xx) noexcept { 
#line 109
return ::exp2f(_Xx); 
#line 110
} 
#line 112
[[nodiscard]] inline float expm1(float _Xx) noexcept { 
#line 113
return ::expm1f(_Xx); 
#line 114
} 
#line 116
[[nodiscard]] inline float fabs(float _Xx) noexcept { 
#line 117
return ::fabsf(_Xx); 
#line 118
} 
#line 120
[[nodiscard]] inline float fdim(float _Xx, float _Yx) noexcept { 
#line 121
return ::fdimf(_Xx, _Yx); 
#line 122
} 
#line 124
[[nodiscard]] inline float floor(float _Xx) noexcept { 
#line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::floorf(_Xx); 
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 134
[[nodiscard]] inline float fma(float _Xx, float _Yx, float _Zx) noexcept { 
#line 135
return ::fmaf(_Xx, _Yx, _Zx); 
#line 136
} 
#line 138
[[nodiscard]] inline float fmax(float _Xx, float _Yx) noexcept { 
#line 139
return ::fmaxf(_Xx, _Yx); 
#line 140
} 
#line 142
[[nodiscard]] inline float fmin(float _Xx, float _Yx) noexcept { 
#line 143
return ::fminf(_Xx, _Yx); 
#line 144
} 
#line 146
[[nodiscard]] inline float fmod(float _Xx, float _Yx) noexcept { 
#line 147
return ::fmodf(_Xx, _Yx); 
#line 148
} 
#line 150
inline float frexp(float _Xx, int *_Yx) noexcept { 
#line 151
return ::frexpf(_Xx, _Yx); 
#line 152
} 
#line 154
[[nodiscard]] inline float hypot(float _Xx, float _Yx) noexcept { 
#line 155
return ::hypotf(_Xx, _Yx); 
#line 156
} 
#line 158
[[nodiscard]] inline int ilogb(float _Xx) noexcept { 
#line 159
return ::ilogbf(_Xx); 
#line 160
} 
#line 162
[[nodiscard]] inline float ldexp(float _Xx, int _Yx) noexcept { 
#line 163
return ::ldexpf(_Xx, _Yx); 
#line 164
} 
#line 166
[[nodiscard]] inline float lgamma(float _Xx) noexcept { 
#line 167
return ::lgammaf(_Xx); 
#line 168
} 
#line 170
[[nodiscard]] inline __int64 llrint(float _Xx) noexcept { 
#line 171
return ::llrintf(_Xx); 
#line 172
} 
#line 174
[[nodiscard]] inline __int64 llround(float _Xx) noexcept { 
#line 175
return ::llroundf(_Xx); 
#line 176
} 
#line 178
[[nodiscard]] inline float log(float _Xx) noexcept { 
#line 179
return ::logf(_Xx); 
#line 180
} 
#line 182
[[nodiscard]] inline float log10(float _Xx) noexcept { 
#line 183
return ::log10f(_Xx); 
#line 184
} 
#line 186
[[nodiscard]] inline float log1p(float _Xx) noexcept { 
#line 187
return ::log1pf(_Xx); 
#line 188
} 
#line 190
[[nodiscard]] inline float log2(float _Xx) noexcept { 
#line 191
return ::log2f(_Xx); 
#line 192
} 
#line 194
[[nodiscard]] inline float logb(float _Xx) noexcept { 
#line 195
return ::logbf(_Xx); 
#line 196
} 
#line 198
[[nodiscard]] inline long lrint(float _Xx) noexcept { 
#line 199
return ::lrintf(_Xx); 
#line 200
} 
#line 202
[[nodiscard]] inline long lround(float _Xx) noexcept { 
#line 203
return ::lroundf(_Xx); 
#line 204
} 
#line 206
inline float modf(float _Xx, float *_Yx) noexcept { 
#line 207
return ::modff(_Xx, _Yx); 
#line 208
} 
#line 210
[[nodiscard]] inline float nearbyint(float _Xx) noexcept { 
#line 211
return ::nearbyintf(_Xx); 
#line 212
} 
#line 214
[[nodiscard]] inline float nextafter(float _Xx, float _Yx) noexcept { 
#line 215
return ::nextafterf(_Xx, _Yx); 
#line 216
} 
#line 218
[[nodiscard]] inline float nexttoward(float _Xx, long double _Yx) noexcept { 
#line 219
return ::nexttowardf(_Xx, _Yx); 
#line 220
} 
#line 222
[[nodiscard]] inline float pow(float _Xx, float _Yx) noexcept { 
#line 223
return ::powf(_Xx, _Yx); 
#line 224
} 
#line 226
[[nodiscard]] inline float remainder(float _Xx, float _Yx) noexcept { 
#line 227
return ::remainderf(_Xx, _Yx); 
#line 228
} 
#line 230
inline float remquo(float _Xx, float _Yx, int *_Zx) noexcept { 
#line 231
return ::remquof(_Xx, _Yx, _Zx); 
#line 232
} 
#line 234
[[nodiscard]] inline float rint(float _Xx) noexcept { 
#line 235
return ::rintf(_Xx); 
#line 236
} 
#line 238
[[nodiscard]] inline float round(float _Xx) noexcept { 
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::roundf(_Xx); 
#line 246 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 248
[[nodiscard]] inline float scalbln(float _Xx, long _Yx) noexcept { 
#line 249
return ::scalblnf(_Xx, _Yx); 
#line 250
} 
#line 252
[[nodiscard]] inline float scalbn(float _Xx, int _Yx) noexcept { 
#line 253
return ::scalbnf(_Xx, _Yx); 
#line 254
} 
#line 256
[[nodiscard]] inline float sin(float _Xx) noexcept { 
#line 257
return ::sinf(_Xx); 
#line 258
} 
#line 260
[[nodiscard]] inline float sinh(float _Xx) noexcept { 
#line 261
return ::sinhf(_Xx); 
#line 262
} 
#line 264
[[nodiscard]] inline float sqrt(float _Xx) noexcept { 
#line 265
return ::sqrtf(_Xx); 
#line 266
} 
#line 268
[[nodiscard]] inline float tan(float _Xx) noexcept { 
#line 269
return ::tanf(_Xx); 
#line 270
} 
#line 272
[[nodiscard]] inline float tanh(float _Xx) noexcept { 
#line 273
return ::tanhf(_Xx); 
#line 274
} 
#line 276
[[nodiscard]] inline float tgamma(float _Xx) noexcept { 
#line 277
return ::tgammaf(_Xx); 
#line 278
} 
#line 280
[[nodiscard]] inline float trunc(float _Xx) noexcept { 
#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::truncf(_Xx); 
#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 290
[[nodiscard]] inline long double acos(long double _Xx) noexcept { 
#line 291
return ::acosl(_Xx); 
#line 292
} 
#line 294
[[nodiscard]] inline long double acosh(long double _Xx) noexcept { 
#line 295
return ::acoshl(_Xx); 
#line 296
} 
#line 298
[[nodiscard]] inline long double asin(long double _Xx) noexcept { 
#line 299
return ::asinl(_Xx); 
#line 300
} 
#line 302
[[nodiscard]] inline long double asinh(long double _Xx) noexcept { 
#line 303
return ::asinhl(_Xx); 
#line 304
} 
#line 306
[[nodiscard]] inline long double atan(long double _Xx) noexcept { 
#line 307
return ::atanl(_Xx); 
#line 308
} 
#line 310
[[nodiscard]] inline long double atanh(long double _Xx) noexcept { 
#line 311
return ::atanhl(_Xx); 
#line 312
} 
#line 314
[[nodiscard]] inline long double atan2(long double _Yx, long double _Xx) noexcept 
#line 315
{ 
#line 316
return ::atan2l(_Yx, _Xx); 
#line 317
} 
#line 319
[[nodiscard]] inline long double cbrt(long double _Xx) noexcept { 
#line 320
return ::cbrtl(_Xx); 
#line 321
} 
#line 323
[[nodiscard]] inline long double ceil(long double _Xx) noexcept { 
#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::ceill(_Xx); 
#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 333
[[nodiscard]] inline long double copysign(long double _Number, long double _Sign) noexcept 
#line 334
{ 
#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::copysignl(_Number, _Sign); 
#line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 344
[[nodiscard]] inline long double cos(long double _Xx) noexcept { 
#line 345
return ::cosl(_Xx); 
#line 346
} 
#line 348
[[nodiscard]] inline long double cosh(long double _Xx) noexcept { 
#line 349
return ::coshl(_Xx); 
#line 350
} 
#line 352
[[nodiscard]] inline long double erf(long double _Xx) noexcept { 
#line 353
return ::erfl(_Xx); 
#line 354
} 
#line 356
[[nodiscard]] inline long double erfc(long double _Xx) noexcept { 
#line 357
return ::erfcl(_Xx); 
#line 358
} 
#line 360
[[nodiscard]] inline long double exp(long double _Xx) noexcept { 
#line 361
return ::expl(_Xx); 
#line 362
} 
#line 364
[[nodiscard]] inline long double exp2(long double _Xx) noexcept { 
#line 365
return ::exp2l(_Xx); 
#line 366
} 
#line 368
[[nodiscard]] inline long double expm1(long double _Xx) noexcept { 
#line 369
return ::expm1l(_Xx); 
#line 370
} 
#line 372
[[nodiscard]] inline long double fabs(long double _Xx) noexcept { 
#line 373
return ::fabsl(_Xx); 
#line 374
} 
#line 376
[[nodiscard]] inline long double fdim(long double _Xx, long double _Yx) noexcept 
#line 377
{ 
#line 378
return ::fdiml(_Xx, _Yx); 
#line 379
} 
#line 381
[[nodiscard]] inline long double floor(long double _Xx) noexcept { 
#line 387 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::floorl(_Xx); 
#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 391
[[nodiscard]] inline long double fma(long double 
#line 392
_Xx, long double _Yx, long double _Zx) noexcept { 
#line 393
return ::fmal(_Xx, _Yx, _Zx); 
#line 394
} 
#line 396
[[nodiscard]] inline long double fmax(long double _Xx, long double _Yx) noexcept 
#line 397
{ 
#line 398
return ::fmaxl(_Xx, _Yx); 
#line 399
} 
#line 401
[[nodiscard]] inline long double fmin(long double _Xx, long double _Yx) noexcept 
#line 402
{ 
#line 403
return ::fminl(_Xx, _Yx); 
#line 404
} 
#line 406
[[nodiscard]] inline long double fmod(long double _Xx, long double _Yx) noexcept 
#line 407
{ 
#line 408
return ::fmodl(_Xx, _Yx); 
#line 409
} 
#line 411
inline long double frexp(long double _Xx, int *_Yx) noexcept { 
#line 412
return ::frexpl(_Xx, _Yx); 
#line 413
} 
#line 415
[[nodiscard]] inline long double hypot(long double _Xx, long double _Yx) noexcept 
#line 416
{ 
#line 417
return ::hypotl(_Xx, _Yx); 
#line 418
} 
#line 420
[[nodiscard]] inline int ilogb(long double _Xx) noexcept { 
#line 421
return ::ilogbl(_Xx); 
#line 422
} 
#line 424
[[nodiscard]] inline long double ldexp(long double _Xx, int _Yx) noexcept { 
#line 425
return ::ldexpl(_Xx, _Yx); 
#line 426
} 
#line 428
[[nodiscard]] inline long double lgamma(long double _Xx) noexcept { 
#line 429
return ::lgammal(_Xx); 
#line 430
} 
#line 432
[[nodiscard]] inline __int64 llrint(long double _Xx) noexcept { 
#line 433
return ::llrintl(_Xx); 
#line 434
} 
#line 436
[[nodiscard]] inline __int64 llround(long double _Xx) noexcept { 
#line 437
return ::llroundl(_Xx); 
#line 438
} 
#line 440
[[nodiscard]] inline long double log(long double _Xx) noexcept { 
#line 441
return ::logl(_Xx); 
#line 442
} 
#line 444
[[nodiscard]] inline long double log10(long double _Xx) noexcept { 
#line 445
return ::log10l(_Xx); 
#line 446
} 
#line 448
[[nodiscard]] inline long double log1p(long double _Xx) noexcept { 
#line 449
return ::log1pl(_Xx); 
#line 450
} 
#line 452
[[nodiscard]] inline long double log2(long double _Xx) noexcept { 
#line 453
return ::log2l(_Xx); 
#line 454
} 
#line 456
[[nodiscard]] inline long double logb(long double _Xx) noexcept { 
#line 457
return ::logbl(_Xx); 
#line 458
} 
#line 460
[[nodiscard]] inline long lrint(long double _Xx) noexcept { 
#line 461
return ::lrintl(_Xx); 
#line 462
} 
#line 464
[[nodiscard]] inline long lround(long double _Xx) noexcept { 
#line 465
return ::lroundl(_Xx); 
#line 466
} 
#line 468
inline long double modf(long double _Xx, long double *_Yx) noexcept { 
#line 469
return ::modfl(_Xx, _Yx); 
#line 470
} 
#line 472
[[nodiscard]] inline long double nearbyint(long double _Xx) noexcept { 
#line 473
return ::nearbyintl(_Xx); 
#line 474
} 
#line 476
[[nodiscard]] inline long double nextafter(long double _Xx, long double _Yx) noexcept 
#line 477
{ 
#line 478
return ::nextafterl(_Xx, _Yx); 
#line 479
} 
#line 481
[[nodiscard]] inline long double nexttoward(long double _Xx, long double _Yx) noexcept 
#line 482
{ 
#line 483
return ::nexttowardl(_Xx, _Yx); 
#line 484
} 
#line 486
[[nodiscard]] inline long double pow(long double _Xx, long double _Yx) noexcept 
#line 487
{ 
#line 488
return ::powl(_Xx, _Yx); 
#line 489
} 
#line 491
[[nodiscard]] inline long double remainder(long double _Xx, long double _Yx) noexcept 
#line 492
{ 
#line 493
return ::remainderl(_Xx, _Yx); 
#line 494
} 
#line 496
inline long double remquo(long double _Xx, long double _Yx, int *_Zx) noexcept { 
#line 497
return ::remquol(_Xx, _Yx, _Zx); 
#line 498
} 
#line 500
[[nodiscard]] inline long double rint(long double _Xx) noexcept { 
#line 501
return ::rintl(_Xx); 
#line 502
} 
#line 504
[[nodiscard]] inline long double round(long double _Xx) noexcept { 
#line 510 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::roundl(_Xx); 
#line 512 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 514
[[nodiscard]] inline long double scalbln(long double _Xx, long _Yx) noexcept { 
#line 515
return ::scalblnl(_Xx, _Yx); 
#line 516
} 
#line 518
[[nodiscard]] inline long double scalbn(long double _Xx, int _Yx) noexcept { 
#line 519
return ::scalbnl(_Xx, _Yx); 
#line 520
} 
#line 522
[[nodiscard]] inline long double sin(long double _Xx) noexcept { 
#line 523
return ::sinl(_Xx); 
#line 524
} 
#line 526
[[nodiscard]] inline long double sinh(long double _Xx) noexcept { 
#line 527
return ::sinhl(_Xx); 
#line 528
} 
#line 530
[[nodiscard]] inline long double sqrt(long double _Xx) noexcept { 
#line 531
return ::sqrtl(_Xx); 
#line 532
} 
#line 534
[[nodiscard]] inline long double tan(long double _Xx) noexcept { 
#line 535
return ::tanl(_Xx); 
#line 536
} 
#line 538
[[nodiscard]] inline long double tanh(long double _Xx) noexcept { 
#line 539
return ::tanhl(_Xx); 
#line 540
} 
#line 542
[[nodiscard]] inline long double tgamma(long double _Xx) noexcept { 
#line 543
return ::tgammal(_Xx); 
#line 544
} 
#line 546
[[nodiscard]] inline long double trunc(long double _Xx) noexcept { 
#line 552 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
return ::truncl(_Xx); 
#line 554 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
} 
#line 557
namespace std { 
#line 558
template< class _Ty1, class _Ty2> using _Common_float_type_t = conditional_t< is_same_v< _Ty1, long double>  || is_same_v< _Ty2, long double> , long double, conditional_t< is_same_v< _Ty1, float>  && is_same_v< _Ty2, float> , float, double> > ; 
#line 562
}
#line 564
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 >
double frexp ( _Ty _Value, int * const _Exp ) noexcept {
    return :: frexp ( static_cast < double > ( _Value ), _Exp );
}
#line 569
template < class _Ty1, class _Ty2, class _Ty3,
    :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > && :: std :: is_arithmetic_v < _Ty3 >, int > = 0 >
[ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, :: std :: _Common_float_type_t < _Ty2, _Ty3 > > fma (
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right ) noexcept {
    using _Common = :: std :: _Common_float_type_t < _Ty1, :: std :: _Common_float_type_t < _Ty2, _Ty3 >>;
    if constexpr ( :: std :: is_same_v < _Common, float > ) {
        return :: fmaf ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Middle ), static_cast < _Common > ( _Right ) );
    } else if constexpr ( :: std :: is_same_v < _Common, double > ) {
        return :: fma ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Middle ), static_cast < _Common > ( _Right ) );
    } else {
        return :: fmal ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Middle ), static_cast < _Common > ( _Right ) );
    }
}
#line 583
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 >
:: std :: _Common_float_type_t < _Ty1, _Ty2 > remquo ( _Ty1 _Left, _Ty2 _Right, int * _Pquo ) noexcept {
    using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >;
    if constexpr ( :: std :: is_same_v < _Common, float > ) {
        return :: remquof ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ), _Pquo );
    } else if constexpr ( :: std :: is_same_v < _Common, double > ) {
        return :: remquo ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ), _Pquo );
    } else {
        return :: remquol ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ), _Pquo );
    }
}
#line 637 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double acos ( _Ty _Left ) noexcept { return :: acos ( static_cast < double > ( _Left ) ); }
#line 638
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double asin ( _Ty _Left ) noexcept { return :: asin ( static_cast < double > ( _Left ) ); }
#line 639
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double atan ( _Ty _Left ) noexcept { return :: atan ( static_cast < double > ( _Left ) ); }
#line 640
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > atan2 ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: atan2 ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 641
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double cos ( _Ty _Left ) noexcept { return :: cos ( static_cast < double > ( _Left ) ); }
#line 642
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double sin ( _Ty _Left ) noexcept { return :: sin ( static_cast < double > ( _Left ) ); }
#line 643
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double tan ( _Ty _Left ) noexcept { return :: tan ( static_cast < double > ( _Left ) ); }
#line 644
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double acosh ( _Ty _Left ) noexcept { return :: acosh ( static_cast < double > ( _Left ) ); }
#line 645
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double asinh ( _Ty _Left ) noexcept { return :: asinh ( static_cast < double > ( _Left ) ); }
#line 646
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double atanh ( _Ty _Left ) noexcept { return :: atanh ( static_cast < double > ( _Left ) ); }
#line 647
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double cosh ( _Ty _Left ) noexcept { return :: cosh ( static_cast < double > ( _Left ) ); }
#line 648
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double sinh ( _Ty _Left ) noexcept { return :: sinh ( static_cast < double > ( _Left ) ); }
#line 649
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double tanh ( _Ty _Left ) noexcept { return :: tanh ( static_cast < double > ( _Left ) ); }
#line 650
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double exp ( _Ty _Left ) noexcept { return :: exp ( static_cast < double > ( _Left ) ); }
#line 651
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double exp2 ( _Ty _Left ) noexcept { return :: exp2 ( static_cast < double > ( _Left ) ); }
#line 652
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double expm1 ( _Ty _Left ) noexcept { return :: expm1 ( static_cast < double > ( _Left ) ); }
#line 654
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] int ilogb ( _Ty _Left ) noexcept { return :: ilogb ( static_cast < double > ( _Left ) ); }
#line 655
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double ldexp ( _Ty _Left, int _Arg2 ) noexcept { return :: ldexp ( static_cast < double > ( _Left ), _Arg2 ); }
#line 656
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double log ( _Ty _Left ) noexcept { return :: log ( static_cast < double > ( _Left ) ); }
#line 657
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double log10 ( _Ty _Left ) noexcept { return :: log10 ( static_cast < double > ( _Left ) ); }
#line 658
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double log1p ( _Ty _Left ) noexcept { return :: log1p ( static_cast < double > ( _Left ) ); }
#line 659
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double log2 ( _Ty _Left ) noexcept { return :: log2 ( static_cast < double > ( _Left ) ); }
#line 660
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double logb ( _Ty _Left ) noexcept { return :: logb ( static_cast < double > ( _Left ) ); }
#line 662
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double scalbn ( _Ty _Left, int _Arg2 ) noexcept { return :: scalbn ( static_cast < double > ( _Left ), _Arg2 ); }
#line 663
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double scalbln ( _Ty _Left, long _Arg2 ) noexcept { return :: scalbln ( static_cast < double > ( _Left ), _Arg2 ); }
#line 664
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double cbrt ( _Ty _Left ) noexcept { return :: cbrt ( static_cast < double > ( _Left ) ); }
#line 666
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double fabs ( _Ty _Left ) noexcept { return :: fabs ( static_cast < double > ( _Left ) ); }
#line 667
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > hypot ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: hypot ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 669
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > pow ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: pow ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 670
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double sqrt ( _Ty _Left ) noexcept { return :: sqrt ( static_cast < double > ( _Left ) ); }
#line 671
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double erf ( _Ty _Left ) noexcept { return :: erf ( static_cast < double > ( _Left ) ); }
#line 672
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double erfc ( _Ty _Left ) noexcept { return :: erfc ( static_cast < double > ( _Left ) ); }
#line 673
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double lgamma ( _Ty _Left ) noexcept { return :: lgamma ( static_cast < double > ( _Left ) ); }
#line 674
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double tgamma ( _Ty _Left ) noexcept { return :: tgamma ( static_cast < double > ( _Left ) ); }
#line 675
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double ceil ( _Ty _Left ) noexcept { return :: ceil ( static_cast < double > ( _Left ) ); }
#line 676
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double floor ( _Ty _Left ) noexcept { return :: floor ( static_cast < double > ( _Left ) ); }
#line 677
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double nearbyint ( _Ty _Left ) noexcept { return :: nearbyint ( static_cast < double > ( _Left ) ); }
#line 678
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double rint ( _Ty _Left ) noexcept { return :: rint ( static_cast < double > ( _Left ) ); }
#line 679
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] long lrint ( _Ty _Left ) noexcept { return :: lrint ( static_cast < double > ( _Left ) ); }
#line 680
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] long long llrint ( _Ty _Left ) noexcept { return :: llrint ( static_cast < double > ( _Left ) ); }
#line 681
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double round ( _Ty _Left ) noexcept { return :: round ( static_cast < double > ( _Left ) ); }
#line 682
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] long lround ( _Ty _Left ) noexcept { return :: lround ( static_cast < double > ( _Left ) ); }
#line 683
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] long long llround ( _Ty _Left ) noexcept { return :: llround ( static_cast < double > ( _Left ) ); }
#line 684
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double trunc ( _Ty _Left ) noexcept { return :: trunc ( static_cast < double > ( _Left ) ); }
#line 685
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmod ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: fmod ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 686
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > remainder ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: remainder ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 688
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > copysign ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: copysign ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 690
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > nextafter ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: nextafter ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 691
template < class _Ty, :: std :: enable_if_t < :: std :: is_integral_v < _Ty >, int > = 0 > [ [ nodiscard ] ] double nexttoward ( _Ty _Left, long double _Arg2 ) noexcept { return :: nexttoward ( static_cast < double > ( _Left ), _Arg2 ); }
#line 692
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > fdim ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: fdim ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 693
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmax ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: fmax ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 694
template < class _Ty1, class _Ty2, :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >, int > = 0 > [ [ nodiscard ] ] :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmin ( _Ty1 _Left, _Ty2 _Right ) noexcept { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return :: fmin ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ); }
#line 711
namespace std { 
#line 712
using ::abs;
#line 713
using ::acos;
#line 714
using ::asin;
#line 715
using ::atan;
#line 716
using ::atan2;
#line 717
using ::ceil;
#line 718
using ::cos;
#line 719
using ::cosh;
#line 720
using ::exp;
#line 721
using ::fabs;
#line 722
using ::floor;
#line 723
using ::fmod;
#line 724
using ::frexp;
#line 725
using ::ldexp;
#line 726
using ::log;
#line 727
using ::log10;
#line 728
using ::modf;
#line 729
using ::pow;
#line 730
using ::sin;
#line 731
using ::sinh;
#line 732
using ::sqrt;
#line 733
using ::tan;
#line 734
using ::tanh;
#line 736
using ::acosf;
#line 737
using ::asinf;
#line 738
using ::atanf;
#line 739
using ::atan2f;
#line 740
using ::ceilf;
#line 741
using ::cosf;
#line 742
using ::coshf;
#line 743
using ::expf;
#line 744
using ::fabsf;
#line 745
using ::floorf;
#line 746
using ::fmodf;
#line 747
using ::frexpf;
#line 748
using ::ldexpf;
#line 749
using ::logf;
#line 750
using ::log10f;
#line 751
using ::modff;
#line 752
using ::powf;
#line 753
using ::sinf;
#line 754
using ::sinhf;
#line 755
using ::sqrtf;
#line 756
using ::tanf;
#line 757
using ::tanhf;
#line 759
using ::acosl;
#line 760
using ::asinl;
#line 761
using ::atanl;
#line 762
using ::atan2l;
#line 763
using ::ceill;
#line 764
using ::cosl;
#line 765
using ::coshl;
#line 766
using ::expl;
#line 767
using ::fabsl;
#line 768
using ::floorl;
#line 769
using ::fmodl;
#line 770
using ::frexpl;
#line 771
using ::ldexpl;
#line 772
using ::logl;
#line 773
using ::log10l;
#line 774
using ::modfl;
#line 775
using ::powl;
#line 776
using ::sinl;
#line 777
using ::sinhl;
#line 778
using ::sqrtl;
#line 779
using ::tanl;
#line 780
using ::tanhl;
#line 782
using ::float_t;
#line 783
using ::double_t;
#line 785
using ::acosh;
#line 786
using ::asinh;
#line 787
using ::atanh;
#line 788
using ::cbrt;
#line 789
using ::erf;
#line 790
using ::erfc;
#line 791
using ::expm1;
#line 792
using ::exp2;
#line 793
using ::hypot;
#line 794
using ::ilogb;
#line 795
using ::lgamma;
#line 796
using ::log1p;
#line 797
using ::log2;
#line 798
using ::logb;
#line 799
using ::llrint;
#line 800
using ::lrint;
#line 801
using ::nearbyint;
#line 802
using ::rint;
#line 803
using ::llround;
#line 804
using ::lround;
#line 805
using ::fdim;
#line 806
using ::fma;
#line 807
using ::fmax;
#line 808
using ::fmin;
#line 809
using ::round;
#line 810
using ::trunc;
#line 811
using ::remainder;
#line 812
using ::remquo;
#line 813
using ::copysign;
#line 814
using ::nan;
#line 815
using ::nextafter;
#line 816
using ::scalbn;
#line 817
using ::scalbln;
#line 818
using ::nexttoward;
#line 819
using ::tgamma;
#line 821
using ::acoshf;
#line 822
using ::asinhf;
#line 823
using ::atanhf;
#line 824
using ::cbrtf;
#line 825
using ::erff;
#line 826
using ::erfcf;
#line 827
using ::expm1f;
#line 828
using ::exp2f;
#line 829
using ::hypotf;
#line 830
using ::ilogbf;
#line 831
using ::lgammaf;
#line 832
using ::log1pf;
#line 833
using ::log2f;
#line 834
using ::logbf;
#line 835
using ::llrintf;
#line 836
using ::lrintf;
#line 837
using ::nearbyintf;
#line 838
using ::rintf;
#line 839
using ::llroundf;
#line 840
using ::lroundf;
#line 841
using ::fdimf;
#line 842
using ::fmaf;
#line 843
using ::fmaxf;
#line 844
using ::fminf;
#line 845
using ::roundf;
#line 846
using ::truncf;
#line 847
using ::remainderf;
#line 848
using ::remquof;
#line 849
using ::copysignf;
#line 850
using ::nanf;
#line 851
using ::nextafterf;
#line 852
using ::scalbnf;
#line 853
using ::scalblnf;
#line 854
using ::nexttowardf;
#line 855
using ::tgammaf;
#line 857
using ::acoshl;
#line 858
using ::asinhl;
#line 859
using ::atanhl;
#line 860
using ::cbrtl;
#line 861
using ::erfl;
#line 862
using ::erfcl;
#line 863
using ::expm1l;
#line 864
using ::exp2l;
#line 865
using ::hypotl;
#line 866
using ::ilogbl;
#line 867
using ::lgammal;
#line 868
using ::log1pl;
#line 869
using ::log2l;
#line 870
using ::logbl;
#line 871
using ::llrintl;
#line 872
using ::lrintl;
#line 873
using ::nearbyintl;
#line 874
using ::rintl;
#line 875
using ::llroundl;
#line 876
using ::lroundl;
#line 877
using ::fdiml;
#line 878
using ::fmal;
#line 879
using ::fmaxl;
#line 880
using ::fminl;
#line 881
using ::roundl;
#line 882
using ::truncl;
#line 883
using ::remainderl;
#line 884
using ::remquol;
#line 885
using ::copysignl;
#line 886
using ::nanl;
#line 887
using ::nextafterl;
#line 888
using ::scalbnl;
#line 889
using ::scalblnl;
#line 890
using ::nexttowardl;
#line 891
using ::tgammal;
#line 893
using ::fpclassify;
#line 894
using ::signbit;
#line 895
using ::isfinite;
#line 896
using ::isinf;
#line 897
using ::isnan;
#line 898
using ::isnormal;
#line 899
using ::isgreater;
#line 900
using ::isgreaterequal;
#line 901
using ::isless;
#line 902
using ::islessequal;
#line 903
using ::islessgreater;
#line 904
using ::isunordered;
#line 905
}
#line 1332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
#pragma warning(pop)
#pragma pack ( pop )
#line 1337 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
#pragma external_header(pop)
#line 10832 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern "C" double __cdecl _hypot(double x, double y); 
#line 10833
extern "C" float __cdecl _hypotf(float x, float y); 
#line 10843 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline bool signbit(long double) throw(); 
#line 10844
extern "C" int _ldsign(long double); 
#line 10887 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline bool signbit(double) throw(); 
#line 10888
extern "C" int _dsign(double); 
#line 10932 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline bool signbit(float) throw(); 
#line 10933
extern "C" int _fdsign(float); 
#line 10941 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isinf(long double a); 
#line 10976 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isinf(double a); 
#line 11014 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isinf(float a); 
#line 11021 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isnan(long double a); 
#line 11054 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isnan(double a); 
#line 11090 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isnan(float a); 
#line 11097 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isfinite(long double a); 
#line 11134 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isfinite(double a); 
#line 11170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline bool isfinite(float a); 
#line 11178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
template< class T> extern T _Pow_int(T, int) throw(); 
#line 11179
extern inline __int64 abs(__int64) throw(); 
#line 11260 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline long __cdecl abs(long) throw(); 
#line 11264 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline float __cdecl abs(float) throw(); 
#line 11265
extern inline double __cdecl abs(double) throw(); 
#line 11266
extern inline float __cdecl fabs(float) throw(); 
#line 11267
extern inline float __cdecl ceil(float) throw(); 
#line 11268
extern inline float __cdecl floor(float) throw(); 
#line 11269
extern inline float __cdecl sqrt(float) throw(); 
#line 11270
extern inline float __cdecl pow(float, float) throw(); 
#line 11299 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
template< class _Ty1, class _Ty2, std::enable_if_t< std::is_arithmetic_v< _Ty1>  && std::is_arithmetic_v< _Ty2> , int>  > [[nodiscard]] std::_Common_float_type_t< _Ty1, _Ty2>  __cdecl pow(_Ty1 _Left, _Ty2 _Right) noexcept; 
#line 11306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline float __cdecl log(float) throw(); 
#line 11307
extern inline float __cdecl log10(float) throw(); 
#line 11308
extern inline float __cdecl fmod(float, float) throw(); 
#line 11309
extern inline float __cdecl modf(float, float *) throw(); 
#line 11310
extern inline float __cdecl exp(float) throw(); 
#line 11311
extern inline float __cdecl frexp(float, int *) throw(); 
#line 11312
extern inline float __cdecl ldexp(float, int) throw(); 
#line 11313
extern inline float __cdecl asin(float) throw(); 
#line 11314
extern inline float __cdecl sin(float) throw(); 
#line 11315
extern inline float __cdecl sinh(float) throw(); 
#line 11316
extern inline float __cdecl acos(float) throw(); 
#line 11317
extern inline float __cdecl cos(float) throw(); 
#line 11318
extern inline float __cdecl cosh(float) throw(); 
#line 11319
extern inline float __cdecl atan(float) throw(); 
#line 11320
extern inline float __cdecl atan2(float, float) throw(); 
#line 11321
extern inline float __cdecl tan(float) throw(); 
#line 11322
extern inline float __cdecl tanh(float) throw(); 
#line 11545 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern inline float __cdecl logb(float) throw(); 
#line 11546
extern inline int __cdecl ilogb(float) throw(); 
#line 11547
extern float __cdecl scalbn(float, float) throw(); 
#line 11548
extern inline float __cdecl scalbln(float, long) throw(); 
#line 11549
extern inline float __cdecl exp2(float) throw(); 
#line 11550
extern inline float __cdecl expm1(float) throw(); 
#line 11551
extern inline float __cdecl log2(float) throw(); 
#line 11552
extern inline float __cdecl log1p(float) throw(); 
#line 11553
extern inline float __cdecl acosh(float) throw(); 
#line 11554
extern inline float __cdecl asinh(float) throw(); 
#line 11555
extern inline float __cdecl atanh(float) throw(); 
#line 11556
extern inline float __cdecl hypot(float, float) throw(); 
#line 11557
extern inline float __cdecl cbrt(float) throw(); 
#line 11558
extern inline float __cdecl erf(float) throw(); 
#line 11559
extern inline float __cdecl erfc(float) throw(); 
#line 11560
extern inline float __cdecl lgamma(float) throw(); 
#line 11561
extern inline float __cdecl tgamma(float) throw(); 
#line 11562
extern inline float __cdecl copysign(float, float) throw(); 
#line 11563
extern inline float __cdecl nextafter(float, float) throw(); 
#line 11564
extern inline float __cdecl remainder(float, float) throw(); 
#line 11565
extern inline float __cdecl remquo(float, float, int *) throw(); 
#line 11566
extern inline float __cdecl round(float) throw(); 
#line 11567
extern inline long __cdecl lround(float) throw(); 
#line 11568
extern inline __int64 __cdecl llround(float) throw(); 
#line 11569
extern inline float __cdecl trunc(float) throw(); 
#line 11570
extern inline float __cdecl rint(float) throw(); 
#line 11571
extern inline long __cdecl lrint(float) throw(); 
#line 11572
extern inline __int64 __cdecl llrint(float) throw(); 
#line 11573
extern inline float __cdecl nearbyint(float) throw(); 
#line 11574
extern inline float __cdecl fdim(float, float) throw(); 
#line 11575
extern inline float __cdecl fma(float, float, float) throw(); 
#line 11576
extern inline float __cdecl fmax(float, float) throw(); 
#line 11577
extern inline float __cdecl fmin(float, float) throw(); 
#line 11580 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static inline float exp10(const float a); 
#line 11582
static inline float rsqrt(const float a); 
#line 11584
static inline float rcbrt(const float a); 
#line 11586
static inline float sinpi(const float a); 
#line 11588
static inline float cospi(const float a); 
#line 11590
static inline void sincospi(const float a, float *const sptr, float *const cptr); 
#line 11592
static inline void sincos(const float a, float *const sptr, float *const cptr); 
#line 11594
static inline float j0(const float a); 
#line 11596
static inline float j1(const float a); 
#line 11598
static inline float jn(const int n, const float a); 
#line 11600
static inline float y0(const float a); 
#line 11602
static inline float y1(const float a); 
#line 11604
static inline float yn(const int n, const float a); 
#line 11606
static inline float cyl_bessel_i0(const float a); 
#line 11608
static inline float cyl_bessel_i1(const float a); 
#line 11610
static inline float erfinv(const float a); 
#line 11612
static inline float erfcinv(const float a); 
#line 11614
static inline float normcdfinv(const float a); 
#line 11616
static inline float normcdf(const float a); 
#line 11618
static inline float erfcx(const float a); 
#line 11620
static inline double copysign(const double a, const float b); 
#line 11622
static inline double copysign(const float a, const double b); 
#line 11630
static inline unsigned min(const unsigned a, const unsigned b); 
#line 11638
static inline unsigned min(const int a, const unsigned b); 
#line 11646
static inline unsigned min(const unsigned a, const int b); 
#line 11654
static inline long min(const long a, const long b); 
#line 11662
static inline unsigned long min(const unsigned long a, const unsigned long b); 
#line 11670
static inline unsigned long min(const long a, const unsigned long b); 
#line 11678
static inline unsigned long min(const unsigned long a, const long b); 
#line 11686
static inline __int64 min(const __int64 a, const __int64 b); 
#line 11694
static inline unsigned __int64 min(const unsigned __int64 a, const unsigned __int64 b); 
#line 11702
static inline unsigned __int64 min(const __int64 a, const unsigned __int64 b); 
#line 11710
static inline unsigned __int64 min(const unsigned __int64 a, const __int64 b); 
#line 11721
static inline float min(const float a, const float b); 
#line 11732
static inline double min(const double a, const double b); 
#line 11742
static inline double min(const float a, const double b); 
#line 11752
static inline double min(const double a, const float b); 
#line 11760
static inline unsigned max(const unsigned a, const unsigned b); 
#line 11768
static inline unsigned max(const int a, const unsigned b); 
#line 11776
static inline unsigned max(const unsigned a, const int b); 
#line 11784
static inline long max(const long a, const long b); 
#line 11792
static inline unsigned long max(const unsigned long a, const unsigned long b); 
#line 11800
static inline unsigned long max(const long a, const unsigned long b); 
#line 11808
static inline unsigned long max(const unsigned long a, const long b); 
#line 11816
static inline __int64 max(const __int64 a, const __int64 b); 
#line 11824
static inline unsigned __int64 max(const unsigned __int64 a, const unsigned __int64 b); 
#line 11832
static inline unsigned __int64 max(const __int64 a, const unsigned __int64 b); 
#line 11840
static inline unsigned __int64 max(const unsigned __int64 a, const __int64 b); 
#line 11851
static inline float max(const float a, const float b); 
#line 11862
static inline double max(const double a, const double b); 
#line 11872
static inline double max(const float a, const double b); 
#line 11882
static inline double max(const double a, const float b); 
#line 11893
extern "C" {
#line 11894
inline void *__nv_aligned_device_malloc(size_t size, size_t align) {int volatile ___ = 1;(void)size;(void)align;::exit(___);}
#if 0
#line 11895
{ 
#line 11896
void *__nv_aligned_device_malloc_impl(size_t, size_t); 
#line 11897
return __nv_aligned_device_malloc_impl(size, align); 
#line 11898
} 
#endif
#line 11899 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
}
#line 433 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isinf(const long double a) 
#line 434
{ 
#line 438 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isinf< long double> (a); 
#line 440 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 449 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isinf(const double a) 
#line 450
{ 
#line 454 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isinf< double> (a); 
#line 456 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 465 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isinf(const float a) 
#line 466
{ 
#line 470 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isinf< float> (a); 
#line 472 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 481 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isnan(const long double a) 
#line 482
{ 
#line 486 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isnan< long double> (a); 
#line 488 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 497 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isnan(const double a) 
#line 498
{ 
#line 502 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isnan< double> (a); 
#line 504 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 513 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isnan(const float a) 
#line 514
{ 
#line 518 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isnan< float> (a); 
#line 520 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 529 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(const long double a) 
#line 530
{ 
#line 534 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isfinite< long double> (a); 
#line 536 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 545 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(const double a) 
#line 546
{ 
#line 550 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isfinite< double> (a); 
#line 552 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 561 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(const float a) 
#line 562
{ 
#line 566 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
return isfinite< float> (a); 
#line 568 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
} 
#line 758 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static inline float exp10(const float a) 
#line 759
{ 
#line 760
return exp10f(a); 
#line 761
} 
#line 763
static inline float rsqrt(const float a) 
#line 764
{ 
#line 765
return rsqrtf(a); 
#line 766
} 
#line 768
static inline float rcbrt(const float a) 
#line 769
{ 
#line 770
return rcbrtf(a); 
#line 771
} 
#line 773
static inline float sinpi(const float a) 
#line 774
{ 
#line 775
return sinpif(a); 
#line 776
} 
#line 778
static inline float cospi(const float a) 
#line 779
{ 
#line 780
return cospif(a); 
#line 781
} 
#line 783
static inline void sincospi(const float a, float *const sptr, float *const cptr) 
#line 784
{ 
#line 785
sincospif(a, sptr, cptr); 
#line 786
} 
#line 788
static inline void sincos(const float a, float *const sptr, float *const cptr) 
#line 789
{ 
#line 790
sincosf(a, sptr, cptr); 
#line 791
} 
#line 793
static inline float j0(const float a) 
#line 794
{ 
#line 795
return j0f(a); 
#line 796
} 
#line 798
static inline float j1(const float a) 
#line 799
{ 
#line 800
return j1f(a); 
#line 801
} 
#line 803
static inline float jn(const int n, const float a) 
#line 804
{ 
#line 805
return jnf(n, a); 
#line 806
} 
#line 808
static inline float y0(const float a) 
#line 809
{ 
#line 810
return y0f(a); 
#line 811
} 
#line 813
static inline float y1(const float a) 
#line 814
{ 
#line 815
return y1f(a); 
#line 816
} 
#line 818
static inline float yn(const int n, const float a) 
#line 819
{ 
#line 820
return ynf(n, a); 
#line 821
} 
#line 823
static inline float cyl_bessel_i0(const float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 824
{ 
#line 825
return cyl_bessel_i0f(a); 
#line 826
} 
#endif
#line 828 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static inline float cyl_bessel_i1(const float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 829
{ 
#line 830
return cyl_bessel_i1f(a); 
#line 831
} 
#endif
#line 833 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static inline float erfinv(const float a) 
#line 834
{ 
#line 835
return erfinvf(a); 
#line 836
} 
#line 838
static inline float erfcinv(const float a) 
#line 839
{ 
#line 840
return erfcinvf(a); 
#line 841
} 
#line 843
static inline float normcdfinv(const float a) 
#line 844
{ 
#line 845
return normcdfinvf(a); 
#line 846
} 
#line 848
static inline float normcdf(const float a) 
#line 849
{ 
#line 850
return normcdff(a); 
#line 851
} 
#line 853
static inline float erfcx(const float a) 
#line 854
{ 
#line 855
return erfcxf(a); 
#line 856
} 
#line 858
static inline double copysign(const double a, const float b) 
#line 859
{ 
#line 860
return copysign(a, static_cast< double>(b)); 
#line 861
} 
#line 863
static inline double copysign(const float a, const double b) 
#line 864
{ 
#line 865
return copysign(static_cast< double>(a), b); 
#line 866
} 
#line 868
static inline unsigned min(const unsigned a, const unsigned b) 
#line 869
{ 
#line 870
return umin(a, b); 
#line 871
} 
#line 873
static inline unsigned min(const int a, const unsigned b) 
#line 874
{ 
#line 875
return umin(static_cast< unsigned>(a), b); 
#line 876
} 
#line 878
static inline unsigned min(const unsigned a, const int b) 
#line 879
{ 
#line 880
return umin(a, static_cast< unsigned>(b)); 
#line 881
} 
#line 883
static inline long min(const long a, const long b) 
#line 884
{ 
#line 885
long retval; 
#line 888
#pragma warning (disable: 4127)
#line 891 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 893
#pragma warning (default: 4127)
#line 895 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
retval = (static_cast< long>(min(static_cast< int>(a), static_cast< int>(b)))); 
#line 896
} else { 
#line 897
retval = (static_cast< long>(llmin(static_cast< __int64>(a), static_cast< __int64>(b)))); 
#line 898
}  
#line 899
return retval; 
#line 900
} 
#line 902
static inline unsigned long min(const unsigned long a, const unsigned long b) 
#line 903
{ 
#line 904
unsigned long retval; 
#line 906
#pragma warning (disable: 4127)
#line 908 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 910
#pragma warning (default: 4127)
#line 912 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 913
} else { 
#line 914
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 915
}  
#line 916
return retval; 
#line 917
} 
#line 919
static inline unsigned long min(const long a, const unsigned long b) 
#line 920
{ 
#line 921
unsigned long retval; 
#line 923
#pragma warning (disable: 4127)
#line 925 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 927
#pragma warning (default: 4127)
#line 929 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 930
} else { 
#line 931
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 932
}  
#line 933
return retval; 
#line 934
} 
#line 936
static inline unsigned long min(const unsigned long a, const long b) 
#line 937
{ 
#line 938
unsigned long retval; 
#line 940
#pragma warning (disable: 4127)
#line 942 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 944
#pragma warning (default: 4127)
#line 946 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 947
} else { 
#line 948
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 949
}  
#line 950
return retval; 
#line 951
} 
#line 953
static inline __int64 min(const __int64 a, const __int64 b) 
#line 954
{ 
#line 955
return llmin(a, b); 
#line 956
} 
#line 958
static inline unsigned __int64 min(const unsigned __int64 a, const unsigned __int64 b) 
#line 959
{ 
#line 960
return ullmin(a, b); 
#line 961
} 
#line 963
static inline unsigned __int64 min(const __int64 a, const unsigned __int64 b) 
#line 964
{ 
#line 965
return ullmin(static_cast< unsigned __int64>(a), b); 
#line 966
} 
#line 968
static inline unsigned __int64 min(const unsigned __int64 a, const __int64 b) 
#line 969
{ 
#line 970
return ullmin(a, static_cast< unsigned __int64>(b)); 
#line 971
} 
#line 973
static inline float min(const float a, const float b) 
#line 974
{ 
#line 975
return fminf(a, b); 
#line 976
} 
#line 978
static inline double min(const double a, const double b) 
#line 979
{ 
#line 980
return fmin(a, b); 
#line 981
} 
#line 983
static inline double min(const float a, const double b) 
#line 984
{ 
#line 985
return fmin(static_cast< double>(a), b); 
#line 986
} 
#line 988
static inline double min(const double a, const float b) 
#line 989
{ 
#line 990
return fmin(a, static_cast< double>(b)); 
#line 991
} 
#line 993
static inline unsigned max(const unsigned a, const unsigned b) 
#line 994
{ 
#line 995
return umax(a, b); 
#line 996
} 
#line 998
static inline unsigned max(const int a, const unsigned b) 
#line 999
{ 
#line 1000
return umax(static_cast< unsigned>(a), b); 
#line 1001
} 
#line 1003
static inline unsigned max(const unsigned a, const int b) 
#line 1004
{ 
#line 1005
return umax(a, static_cast< unsigned>(b)); 
#line 1006
} 
#line 1008
static inline long max(const long a, const long b) 
#line 1009
{ 
#line 1010
long retval; 
#line 1013
#pragma warning (disable: 4127)
#line 1015 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 1017
#pragma warning (default: 4127)
#line 1019 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
retval = (static_cast< long>(max(static_cast< int>(a), static_cast< int>(b)))); 
#line 1020
} else { 
#line 1021
retval = (static_cast< long>(llmax(static_cast< __int64>(a), static_cast< __int64>(b)))); 
#line 1022
}  
#line 1023
return retval; 
#line 1024
} 
#line 1026
static inline unsigned long max(const unsigned long a, const unsigned long b) 
#line 1027
{ 
#line 1028
unsigned long retval; 
#line 1030
#pragma warning (disable: 4127)
#line 1032 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1034
#pragma warning (default: 4127)
#line 1036 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 1037
} else { 
#line 1038
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 1039
}  
#line 1040
return retval; 
#line 1041
} 
#line 1043
static inline unsigned long max(const long a, const unsigned long b) 
#line 1044
{ 
#line 1045
unsigned long retval; 
#line 1047
#pragma warning (disable: 4127)
#line 1049 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1051
#pragma warning (default: 4127)
#line 1053 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 1054
} else { 
#line 1055
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 1056
}  
#line 1057
return retval; 
#line 1058
} 
#line 1060
static inline unsigned long max(const unsigned long a, const long b) 
#line 1061
{ 
#line 1062
unsigned long retval; 
#line 1064
#pragma warning (disable: 4127)
#line 1066 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1068
#pragma warning (default: 4127)
#line 1070 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
#line 1071
} else { 
#line 1072
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned __int64>(a), static_cast< unsigned __int64>(b)))); 
#line 1073
}  
#line 1074
return retval; 
#line 1075
} 
#line 1077
static inline __int64 max(const __int64 a, const __int64 b) 
#line 1078
{ 
#line 1079
return llmax(a, b); 
#line 1080
} 
#line 1082
static inline unsigned __int64 max(const unsigned __int64 a, const unsigned __int64 b) 
#line 1083
{ 
#line 1084
return ullmax(a, b); 
#line 1085
} 
#line 1087
static inline unsigned __int64 max(const __int64 a, const unsigned __int64 b) 
#line 1088
{ 
#line 1089
return ullmax(static_cast< unsigned __int64>(a), b); 
#line 1090
} 
#line 1092
static inline unsigned __int64 max(const unsigned __int64 a, const __int64 b) 
#line 1093
{ 
#line 1094
return ullmax(a, static_cast< unsigned __int64>(b)); 
#line 1095
} 
#line 1097
static inline float max(const float a, const float b) 
#line 1098
{ 
#line 1099
return fmaxf(a, b); 
#line 1100
} 
#line 1102
static inline double max(const double a, const double b) 
#line 1103
{ 
#line 1104
return fmax(a, b); 
#line 1105
} 
#line 1107
static inline double max(const float a, const double b) 
#line 1108
{ 
#line 1109
return fmax(static_cast< double>(a), b); 
#line 1110
} 
#line 1112
static inline double max(const double a, const float b) 
#line 1113
{ 
#line 1114
return fmax(a, static_cast< double>(b)); 
#line 1115
} 
#line 1121
#pragma warning(disable : 4211)
#line 1126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static inline int min(const int a, const int b) 
#line 1127
{ 
#line 1128
return (a < b) ? a : b; 
#line 1129
} 
#line 1131
static inline unsigned umin(const unsigned a, const unsigned b) 
#line 1132
{ 
#line 1133
return (a < b) ? a : b; 
#line 1134
} 
#line 1136
static inline __int64 llmin(const __int64 a, const __int64 b) 
#line 1137
{ 
#line 1138
return (a < b) ? a : b; 
#line 1139
} 
#line 1141
static inline unsigned __int64 ullmin(const unsigned __int64 a, const unsigned __int64 
#line 1142
b) 
#line 1143
{ 
#line 1144
return (a < b) ? a : b; 
#line 1145
} 
#line 1147
static inline int max(const int a, const int b) 
#line 1148
{ 
#line 1149
return (a > b) ? a : b; 
#line 1150
} 
#line 1152
static inline unsigned umax(const unsigned a, const unsigned b) 
#line 1153
{ 
#line 1154
return (a > b) ? a : b; 
#line 1155
} 
#line 1157
static inline __int64 llmax(const __int64 a, const __int64 b) 
#line 1158
{ 
#line 1159
return (a > b) ? a : b; 
#line 1160
} 
#line 1162
static inline unsigned __int64 ullmax(const unsigned __int64 a, const unsigned __int64 
#line 1163
b) 
#line 1164
{ 
#line 1165
return (a > b) ? a : b; 
#line 1166
} 
#line 1169
#pragma warning(default: 4211)
#line 74 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"
template< class T, int dim = 1> 
#line 75
struct surface : public surfaceReference { 
#line 78
surface() 
#line 79
{ 
#line 80
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 81
} 
#line 83
surface(::cudaChannelFormatDesc desc) 
#line 84
{ 
#line 85
(channelDesc) = desc; 
#line 86
} 
#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"
}; 
#line 90
template< int dim> 
#line 91
struct surface< void, dim>  : public surfaceReference { 
#line 94
surface() 
#line 95
{ 
#line 96
(channelDesc) = cudaCreateChannelDesc< void> (); 
#line 97
} 
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"
}; 
#line 74 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
#line 75
struct texture : public textureReference { 
#line 78
texture(int norm = 0, ::cudaTextureFilterMode 
#line 79
fMode = cudaFilterModePoint, ::cudaTextureAddressMode 
#line 80
aMode = cudaAddressModeClamp) 
#line 81
{ 
#line 82
(normalized) = norm; 
#line 83
(filterMode) = fMode; 
#line 84
((addressMode)[0]) = aMode; 
#line 85
((addressMode)[1]) = aMode; 
#line 86
((addressMode)[2]) = aMode; 
#line 87
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 88
(sRGB) = 0; 
#line 89
} 
#line 91
texture(int norm, ::cudaTextureFilterMode 
#line 92
fMode, ::cudaTextureAddressMode 
#line 93
aMode, ::cudaChannelFormatDesc 
#line 94
desc) 
#line 95
{ 
#line 96
(normalized) = norm; 
#line 97
(filterMode) = fMode; 
#line 98
((addressMode)[0]) = aMode; 
#line 99
((addressMode)[1]) = aMode; 
#line 100
((addressMode)[2]) = aMode; 
#line 101
(channelDesc) = desc; 
#line 102
(sRGB) = 0; 
#line 103
} 
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"
}; 
#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
extern "C" {
#line 3207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
}
#line 3229 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
__declspec(deprecated("mulhi() is deprecated in favor of __mulhi() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning).")) static __inline int mulhi(const int a, const int b); 
#line 3231
__declspec(deprecated("mulhi() is deprecated in favor of __mulhi() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning).")) static __inline unsigned mulhi(const unsigned a, const unsigned b); 
#line 3233
__declspec(deprecated("mulhi() is deprecated in favor of __mulhi() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning).")) static __inline unsigned mulhi(const int a, const unsigned b); 
#line 3235
__declspec(deprecated("mulhi() is deprecated in favor of __mulhi() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning).")) static __inline unsigned mulhi(const unsigned a, const int b); 
#line 3237
__declspec(deprecated("mul64hi() is deprecated in favor of __mul64hi() and may be removed in a future release (Use -Wno-deprecated-declarations to supp" "ress this warning).")) static __inline __int64 mul64hi(const __int64 a, const __int64 b); 
#line 3239
__declspec(deprecated("mul64hi() is deprecated in favor of __mul64hi() and may be removed in a future release (Use -Wno-deprecated-declarations to supp" "ress this warning).")) static __inline unsigned __int64 mul64hi(const unsigned __int64 a, const unsigned __int64 b); 
#line 3241
__declspec(deprecated("mul64hi() is deprecated in favor of __mul64hi() and may be removed in a future release (Use -Wno-deprecated-declarations to supp" "ress this warning).")) static __inline unsigned __int64 mul64hi(const __int64 a, const unsigned __int64 b); 
#line 3243
__declspec(deprecated("mul64hi() is deprecated in favor of __mul64hi() and may be removed in a future release (Use -Wno-deprecated-declarations to supp" "ress this warning).")) static __inline unsigned __int64 mul64hi(const unsigned __int64 a, const __int64 b); 
#line 3245
__declspec(deprecated("float_as_int() is deprecated in favor of __float_as_int() and may be removed in a future release (Use -Wno-deprecated-declaratio" "ns to suppress this warning).")) static __inline int float_as_int(const float a); 
#line 3247
__declspec(deprecated("int_as_float() is deprecated in favor of __int_as_float() and may be removed in a future release (Use -Wno-deprecated-declaratio" "ns to suppress this warning).")) static __inline float int_as_float(const int a); 
#line 3249
__declspec(deprecated("float_as_uint() is deprecated in favor of __float_as_uint() and may be removed in a future release (Use -Wno-deprecated-declarat" "ions to suppress this warning).")) static __inline unsigned float_as_uint(const float a); 
#line 3251
__declspec(deprecated("uint_as_float() is deprecated in favor of __uint_as_float() and may be removed in a future release (Use -Wno-deprecated-declarat" "ions to suppress this warning).")) static __inline float uint_as_float(const unsigned a); 
#line 3253
__declspec(deprecated("saturate() is deprecated in favor of __saturatef() and may be removed in a future release (Use -Wno-deprecated-declarations to s" "uppress this warning).")) static __inline float saturate(const float a); 
#line 3255
__declspec(deprecated("mul24() is deprecated in favor of __mul24() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning).")) static __inline int mul24(const int a, const int b); 
#line 3257
__declspec(deprecated("umul24() is deprecated in favor of __umul24() and may be removed in a future release (Use -Wno-deprecated-declarations to suppre" "ss this warning).")) static __inline unsigned umul24(const unsigned a, const unsigned b); 
#line 3259
__declspec(deprecated("float2int() is deprecated in favor of __float2int_ru|_rd|_rn|_rz() and may be removed in a future release (Use -Wno-deprecated-d" "eclarations to suppress this warning).")) static __inline int float2int(const float a, const cudaRoundMode mode = cudaRoundZero); 
#line 3261
__declspec(deprecated("float2uint() is deprecated in favor of __float2uint_ru|_rd|_rn|_rz() and may be removed in a future release (Use -Wno-deprecated" "-declarations to suppress this warning).")) static __inline unsigned float2uint(const float a, const cudaRoundMode mode = cudaRoundZero); 
#line 3263
__declspec(deprecated("int2float() is deprecated in favor of __int2float_ru|_rd|_rn|_rz() and may be removed in a future release (Use -Wno-deprecated-d" "eclarations to suppress this warning).")) static __inline float int2float(const int a, const cudaRoundMode mode = cudaRoundNearest); 
#line 3265
__declspec(deprecated("uint2float() is deprecated in favor of __uint2float_ru|_rd|_rn|_rz() and may be removed in a future release (Use -Wno-deprecated" "-declarations to suppress this warning).")) static __inline float uint2float(const unsigned a, const cudaRoundMode mode = cudaRoundNearest); 
#line 90 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline int mulhi(const int a, const int b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 91
{ 
#line 92
return __mulhi(a, b); 
#line 93
} 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(const unsigned a, const unsigned b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 96
{ 
#line 97
return __umulhi(a, b); 
#line 98
} 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(const int a, const unsigned b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 101
{ 
#line 102
return __umulhi(static_cast< unsigned>(a), b); 
#line 103
} 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(const unsigned a, const int b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 106
{ 
#line 107
return __umulhi(a, static_cast< unsigned>(b)); 
#line 108
} 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline __int64 mul64hi(const __int64 a, const __int64 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 111
{ 
#line 112
return __mul64hi(a, b); 
#line 113
} 
#endif
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(const unsigned __int64 a, const unsigned __int64 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 116
{ 
#line 117
return __umul64hi(a, b); 
#line 118
} 
#endif
#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(const __int64 a, const unsigned __int64 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 121
{ 
#line 122
return __umul64hi(static_cast< unsigned __int64>(a), b); 
#line 123
} 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(const unsigned __int64 a, const __int64 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 126
{ 
#line 127
return __umul64hi(a, static_cast< unsigned __int64>(b)); 
#line 128
} 
#endif
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline int float_as_int(const float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 131
{ 
#line 132
return __float_as_int(a); 
#line 133
} 
#endif
#line 135 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline float int_as_float(const int a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 136
{ 
#line 137
return __int_as_float(a); 
#line 138
} 
#endif
#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned float_as_uint(const float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 141
{ 
#line 142
return __float_as_uint(a); 
#line 143
} 
#endif
#line 145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline float uint_as_float(const unsigned a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 146
{ 
#line 147
return __uint_as_float(a); 
#line 148
} 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline float saturate(const float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 150
{ 
#line 151
return __saturatef(a); 
#line 152
} 
#endif
#line 154 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline int mul24(const int a, const int b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 155
{ 
#line 156
return __mul24(a, b); 
#line 157
} 
#endif
#line 159 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned umul24(const unsigned a, const unsigned b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 160
{ 
#line 161
return __umul24(a, b); 
#line 162
} 
#endif
#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline int float2int(const float a, const cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 165
{ 
#line 166
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
#line 170
} 
#endif
#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline unsigned float2uint(const float a, const cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 173
{ 
#line 174
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
#line 178
} 
#endif
#line 180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline float int2float(const int a, const cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 181
{ 
#line 182
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
#line 186
} 
#endif
#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
static __inline float uint2float(const unsigned a, const cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 189
{ 
#line 190
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
#line 194
} 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicAdd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicAdd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicSub(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicSub(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicExch(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicExch(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 116
{ } 
#endif
#line 118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline float atomicExch(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 118
{ } 
#endif
#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicMin(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 120
{ } 
#endif
#line 122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicMin(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 122
{ } 
#endif
#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicMax(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicMax(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 128 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicInc(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicDec(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicAnd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 132
{ } 
#endif
#line 134 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicAnd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 134
{ } 
#endif
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicOr(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicOr(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 138
{ } 
#endif
#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicXor(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 140
{ } 
#endif
#line 142 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicXor(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline int atomicCAS(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 146 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 146
{ } 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
extern "C" {
#line 180
}
#line 189
static __inline unsigned __int64 atomicAdd(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 191 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicExch(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicCAS(unsigned __int64 *address, unsigned __int64 compare, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 195 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
__declspec(deprecated("__any() is deprecated in favor of __any_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning).")) static __inline bool any(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
#line 195
{ } 
#endif
#line 197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
__declspec(deprecated("__all() is deprecated in favor of __all_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning).")) static __inline bool all(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
#line 197
{ } 
#endif
#line 87 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"
extern "C" {
#line 1139
}
#line 1147
static __inline double fma(double a, double b, double c, cudaRoundMode mode); 
#line 1149
static __inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1151
static __inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1153
static __inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1155
static __inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1157
static __inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1159
static __inline __int64 double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1161
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1163
static __inline double ll2double(__int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1165
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1167
static __inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
#line 1169
static __inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
#line 1171
static __inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double fma(double a, double b, double c, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;::exit(___);}
#if 0
#line 94
{ 
#line 95
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
#line 99
} 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double dmul(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 102
{ 
#line 103
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
#line 107
} 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double dadd(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 110
{ 
#line 111
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
#line 115
} 
#endif
#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double dsub(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 118
{ 
#line 119
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
#line 123
} 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline int double2int(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 126
{ 
#line 127
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
#line 131
} 
#endif
#line 133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline unsigned double2uint(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 134
{ 
#line 135
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
#line 139
} 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline __int64 double2ll(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 142
{ 
#line 143
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
#line 147
} 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 150
{ 
#line 151
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
#line 155
} 
#endif
#line 157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double ll2double(__int64 a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 158
{ 
#line 159
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
#line 163
} 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 166
{ 
#line 167
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
#line 171
} 
#endif
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double int2double(int a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 174
{ 
#line 175
return (double)a; 
#line 176
} 
#endif
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double uint2double(unsigned a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 179
{ 
#line 180
return (double)a; 
#line 181
} 
#endif
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
static __inline double float2double(float a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 184
{ 
#line 185
return (double)a; 
#line 186
} 
#endif
#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"
static __inline float atomicAdd(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMin(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMax(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicAnd(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicOr(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicXor(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMin(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMax(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicAnd(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicOr(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 116
{ } 
#endif
#line 118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicXor(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 118
{ } 
#endif
#line 303 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 303
{ } 
#endif
#line 306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicAdd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 306
{ } 
#endif
#line 309 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicAdd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 309
{ } 
#endif
#line 312 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAdd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 312
{ } 
#endif
#line 315 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAdd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 315
{ } 
#endif
#line 318 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAdd_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 318
{ } 
#endif
#line 321 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAdd_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 321
{ } 
#endif
#line 324 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline float atomicAdd_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 324
{ } 
#endif
#line 327 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline float atomicAdd_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 327
{ } 
#endif
#line 330 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd_block(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 330
{ } 
#endif
#line 333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd_system(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 333
{ } 
#endif
#line 336 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicSub_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 336
{ } 
#endif
#line 339 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicSub_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 339
{ } 
#endif
#line 342 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicSub_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 342
{ } 
#endif
#line 345 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicSub_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 345
{ } 
#endif
#line 348 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicExch_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 348
{ } 
#endif
#line 351 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicExch_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 351
{ } 
#endif
#line 354 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicExch_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 354
{ } 
#endif
#line 357 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicExch_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 357
{ } 
#endif
#line 360 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicExch_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 360
{ } 
#endif
#line 363 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicExch_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 363
{ } 
#endif
#line 366 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline float atomicExch_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 366
{ } 
#endif
#line 369 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline float atomicExch_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 369
{ } 
#endif
#line 372 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicMin_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 372
{ } 
#endif
#line 375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicMin_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 375
{ } 
#endif
#line 378 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMin_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 378
{ } 
#endif
#line 381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMin_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 381
{ } 
#endif
#line 384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMin_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 384
{ } 
#endif
#line 387 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMin_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 387
{ } 
#endif
#line 390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMin_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 390
{ } 
#endif
#line 393 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMin_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 393
{ } 
#endif
#line 396 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicMax_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 396
{ } 
#endif
#line 399 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicMax_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 399
{ } 
#endif
#line 402 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMax_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 402
{ } 
#endif
#line 405 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMax_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 405
{ } 
#endif
#line 408 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMax_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 408
{ } 
#endif
#line 411 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMax_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 411
{ } 
#endif
#line 414 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMax_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 414
{ } 
#endif
#line 417 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMax_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 417
{ } 
#endif
#line 420 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicInc_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 420
{ } 
#endif
#line 423 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicInc_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 423
{ } 
#endif
#line 426 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicDec_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 426
{ } 
#endif
#line 429 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicDec_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 429
{ } 
#endif
#line 432 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicCAS_block(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 432
{ } 
#endif
#line 435 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicCAS_system(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 435
{ } 
#endif
#line 438 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicCAS_block(unsigned *address, unsigned compare, unsigned 
#line 439
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 439
{ } 
#endif
#line 442 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicCAS_system(unsigned *address, unsigned compare, unsigned 
#line 443
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 443
{ } 
#endif
#line 446 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicCAS_block(unsigned __int64 *address, unsigned __int64 
#line 447
compare, unsigned __int64 
#line 448
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 448
{ } 
#endif
#line 451 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicCAS_system(unsigned __int64 *address, unsigned __int64 
#line 452
compare, unsigned __int64 
#line 453
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 453
{ } 
#endif
#line 456 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicAnd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 456
{ } 
#endif
#line 459 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicAnd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 459
{ } 
#endif
#line 462 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicAnd_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 462
{ } 
#endif
#line 465 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicAnd_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 465
{ } 
#endif
#line 468 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAnd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 468
{ } 
#endif
#line 471 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAnd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 471
{ } 
#endif
#line 474 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAnd_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 474
{ } 
#endif
#line 477 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAnd_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 477
{ } 
#endif
#line 480 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicOr_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 480
{ } 
#endif
#line 483 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicOr_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 483
{ } 
#endif
#line 486 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicOr_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 486
{ } 
#endif
#line 489 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicOr_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 489
{ } 
#endif
#line 492 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicOr_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 492
{ } 
#endif
#line 495 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicOr_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 495
{ } 
#endif
#line 498 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicOr_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 498
{ } 
#endif
#line 501 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicOr_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 501
{ } 
#endif
#line 504 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicXor_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 504
{ } 
#endif
#line 507 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline int atomicXor_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 507
{ } 
#endif
#line 510 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicXor_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 510
{ } 
#endif
#line 513 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicXor_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 513
{ } 
#endif
#line 516 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicXor_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 516
{ } 
#endif
#line 519 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicXor_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 519
{ } 
#endif
#line 522 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicXor_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 522
{ } 
#endif
#line 525 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicXor_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 525
{ } 
#endif
#line 90 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
extern "C" {
#line 1503
}
#line 1510
__declspec(deprecated("__ballot() is deprecated in favor of __ballot_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to" " suppress this warning).")) static __inline unsigned ballot(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1510
{ } 
#endif
#line 1512 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline int syncthreads_count(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1512
{ } 
#endif
#line 1514 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_and(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1514
{ } 
#endif
#line 1516 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_or(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1516
{ } 
#endif
#line 1521 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline unsigned __isGlobal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1521
{ } 
#endif
#line 1522 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline unsigned __isShared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1522
{ } 
#endif
#line 1523 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline unsigned __isConstant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1523
{ } 
#endif
#line 1524 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline unsigned __isLocal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1524
{ } 
#endif
#line 1526 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline unsigned __isGridConstant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1526
{ } 
#endif
#line 1528 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_global(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1528
{ } 
#endif
#line 1529 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_shared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1529
{ } 
#endif
#line 1530 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_constant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1530
{ } 
#endif
#line 1531 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_local(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1531
{ } 
#endif
#line 1533 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline size_t __cvta_generic_to_grid_constant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1533
{ } 
#endif
#line 1536 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_global_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1536
{ } 
#endif
#line 1537 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_shared_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1537
{ } 
#endif
#line 1538 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_constant_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1538
{ } 
#endif
#line 1539 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_local_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1539
{ } 
#endif
#line 1541 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline void *__cvta_grid_constant_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
#line 1541
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __fns(unsigned mask, unsigned base, int offset) {int volatile ___ = 1;(void)mask;(void)base;(void)offset;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline void __barrier_sync(unsigned id) {int volatile ___ = 1;(void)id;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline void __barrier_sync_count(unsigned id, unsigned cnt) {int volatile ___ = 1;(void)id;(void)cnt;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline void __syncwarp(unsigned mask = 4294967295U) {int volatile ___ = 1;(void)mask;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline int __all_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline int __any_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline int __uni_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __ballot_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __activemask() {int volatile ___ = 1;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned __shfl(unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 120
{ } 
#endif
#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 121
{ } 
#endif
#line 122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 122
{ } 
#endif
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 125
{ } 
#endif
#line 126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 127
{ } 
#endif
#line 128 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline int __shfl_sync(unsigned mask, int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 133
{ } 
#endif
#line 134 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_sync(unsigned mask, unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 134
{ } 
#endif
#line 135 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline int __shfl_up_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_up_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 137 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline int __shfl_down_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 137
{ } 
#endif
#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_down_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 138
{ } 
#endif
#line 139 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_xor_sync(unsigned mask, unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 140
{ } 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline float __shfl_sync(unsigned mask, float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 142 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline float __shfl_up_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 143 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline float __shfl_down_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 143
{ } 
#endif
#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 148 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned __int64 __shfl(unsigned __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline __int64 __shfl(__int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 149
{ } 
#endif
#line 150 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline __int64 __shfl_up(__int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 150
{ } 
#endif
#line 151 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned __int64 __shfl_up(unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 151
{ } 
#endif
#line 152 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline __int64 __shfl_down(__int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 152
{ } 
#endif
#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned __int64 __shfl_down(unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 153
{ } 
#endif
#line 154 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline __int64 __shfl_xor(__int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 154
{ } 
#endif
#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned __int64 __shfl_xor(unsigned __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 155
{ } 
#endif
#line 156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline double __shfl(double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 156
{ } 
#endif
#line 157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline double __shfl_up(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 157
{ } 
#endif
#line 158 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline double __shfl_down(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 158
{ } 
#endif
#line 159 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline double __shfl_xor(double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 159
{ } 
#endif
#line 162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_sync(unsigned mask, __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 162
{ } 
#endif
#line 163 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_sync(unsigned mask, unsigned __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 163
{ } 
#endif
#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_up_sync(unsigned mask, __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 164
{ } 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_up_sync(unsigned mask, unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 165
{ } 
#endif
#line 166 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_down_sync(unsigned mask, __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 166
{ } 
#endif
#line 167 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_down_sync(unsigned mask, unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 167
{ } 
#endif
#line 168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_xor_sync(unsigned mask, __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 168
{ } 
#endif
#line 169 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_xor_sync(unsigned mask, unsigned __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline double __shfl_sync(unsigned mask, double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 170
{ } 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline double __shfl_up_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline double __shfl_down_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 172
{ } 
#endif
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline long __shfl(long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 178
{ } 
#endif
#line 179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline long __shfl_up(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 179
{ } 
#endif
#line 180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 180
{ } 
#endif
#line 181 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline long __shfl_down(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 181
{ } 
#endif
#line 182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 182
{ } 
#endif
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline long __shfl_xor(long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 183
{ } 
#endif
#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 184
{ } 
#endif
#line 187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline long __shfl_sync(unsigned mask, long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 187
{ } 
#endif
#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 188
{ } 
#endif
#line 189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline long __shfl_up_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 190 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 190
{ } 
#endif
#line 191 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline long __shfl_down_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 192 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 192
{ } 
#endif
#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 194 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 194
{ } 
#endif
#line 87 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 87
{ } 
#endif
#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 88
{ } 
#endif
#line 90 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 90
{ } 
#endif
#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 91
{ } 
#endif
#line 92 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 115
{ } 
#endif
#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 116
{ } 
#endif
#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 117
{ } 
#endif
#line 118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 118
{ } 
#endif
#line 119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline long __ldcg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char __ldcg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 127
{ } 
#endif
#line 128 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short __ldcg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int __ldcg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 131
{ } 
#endif
#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 132
{ } 
#endif
#line 133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 133
{ } 
#endif
#line 134 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 134
{ } 
#endif
#line 135 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 137 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 137
{ } 
#endif
#line 139 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 140
{ } 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 142 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 143 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 143
{ } 
#endif
#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 145
{ } 
#endif
#line 146 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 146
{ } 
#endif
#line 147 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 147
{ } 
#endif
#line 148 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 149
{ } 
#endif
#line 151 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float __ldcg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 151
{ } 
#endif
#line 152 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double __ldcg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 152
{ } 
#endif
#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 153
{ } 
#endif
#line 154 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 154
{ } 
#endif
#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 155
{ } 
#endif
#line 159 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline long __ldca(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 159
{ } 
#endif
#line 160 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldca(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 160
{ } 
#endif
#line 162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char __ldca(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 162
{ } 
#endif
#line 163 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline signed char __ldca(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 163
{ } 
#endif
#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short __ldca(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 164
{ } 
#endif
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int __ldca(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 165
{ } 
#endif
#line 166 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldca(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 166
{ } 
#endif
#line 167 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char2 __ldca(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 167
{ } 
#endif
#line 168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char4 __ldca(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 168
{ } 
#endif
#line 169 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short2 __ldca(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short4 __ldca(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 170
{ } 
#endif
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int2 __ldca(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int4 __ldca(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 172
{ } 
#endif
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldca(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldca(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 175
{ } 
#endif
#line 176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldca(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 176
{ } 
#endif
#line 177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldca(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldca(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 178
{ } 
#endif
#line 179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldca(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 179
{ } 
#endif
#line 180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldca(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 180
{ } 
#endif
#line 181 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldca(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 181
{ } 
#endif
#line 182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldca(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 182
{ } 
#endif
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldca(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 183
{ } 
#endif
#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldca(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 184
{ } 
#endif
#line 185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldca(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 185
{ } 
#endif
#line 187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float __ldca(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 187
{ } 
#endif
#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double __ldca(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 188
{ } 
#endif
#line 189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float2 __ldca(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 190 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float4 __ldca(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 190
{ } 
#endif
#line 191 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double2 __ldca(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 195 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline long __ldcs(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 195
{ } 
#endif
#line 196 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcs(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 196
{ } 
#endif
#line 198 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char __ldcs(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 198
{ } 
#endif
#line 199 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcs(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 199
{ } 
#endif
#line 200 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short __ldcs(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 200
{ } 
#endif
#line 201 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int __ldcs(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 201
{ } 
#endif
#line 202 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcs(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 202
{ } 
#endif
#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcs(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 203
{ } 
#endif
#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcs(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 204
{ } 
#endif
#line 205 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcs(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 205
{ } 
#endif
#line 206 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcs(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 206
{ } 
#endif
#line 207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcs(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 207
{ } 
#endif
#line 208 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcs(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 208
{ } 
#endif
#line 209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcs(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 209
{ } 
#endif
#line 211 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcs(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 211
{ } 
#endif
#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcs(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 212
{ } 
#endif
#line 213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcs(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 213
{ } 
#endif
#line 214 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcs(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 214
{ } 
#endif
#line 215 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcs(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 215
{ } 
#endif
#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcs(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 216
{ } 
#endif
#line 217 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcs(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 217
{ } 
#endif
#line 218 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcs(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 218
{ } 
#endif
#line 219 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcs(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 219
{ } 
#endif
#line 220 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcs(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 220
{ } 
#endif
#line 221 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcs(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 221
{ } 
#endif
#line 223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float __ldcs(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 223
{ } 
#endif
#line 224 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double __ldcs(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 224
{ } 
#endif
#line 225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcs(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 225
{ } 
#endif
#line 226 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcs(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 226
{ } 
#endif
#line 227 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcs(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 227
{ } 
#endif
#line 231 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline long __ldlu(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 231
{ } 
#endif
#line 232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldlu(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 232
{ } 
#endif
#line 234 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char __ldlu(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 234
{ } 
#endif
#line 235 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline signed char __ldlu(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 235
{ } 
#endif
#line 236 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short __ldlu(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 236
{ } 
#endif
#line 237 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int __ldlu(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 237
{ } 
#endif
#line 238 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldlu(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 238
{ } 
#endif
#line 239 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char2 __ldlu(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 239
{ } 
#endif
#line 240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char4 __ldlu(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 240
{ } 
#endif
#line 241 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short2 __ldlu(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 241
{ } 
#endif
#line 242 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short4 __ldlu(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 242
{ } 
#endif
#line 243 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int2 __ldlu(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 243
{ } 
#endif
#line 244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int4 __ldlu(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 244
{ } 
#endif
#line 245 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldlu(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 245
{ } 
#endif
#line 247 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldlu(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 247
{ } 
#endif
#line 248 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldlu(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 248
{ } 
#endif
#line 249 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldlu(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 249
{ } 
#endif
#line 250 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldlu(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 250
{ } 
#endif
#line 251 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldlu(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 251
{ } 
#endif
#line 252 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldlu(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 252
{ } 
#endif
#line 253 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldlu(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 253
{ } 
#endif
#line 254 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldlu(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 254
{ } 
#endif
#line 255 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldlu(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 255
{ } 
#endif
#line 256 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldlu(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 256
{ } 
#endif
#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldlu(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 257
{ } 
#endif
#line 259 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float __ldlu(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 259
{ } 
#endif
#line 260 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double __ldlu(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 260
{ } 
#endif
#line 261 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float2 __ldlu(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 261
{ } 
#endif
#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float4 __ldlu(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 262
{ } 
#endif
#line 263 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double2 __ldlu(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 263
{ } 
#endif
#line 267 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline long __ldcv(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 267
{ } 
#endif
#line 268 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcv(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 268
{ } 
#endif
#line 270 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char __ldcv(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 270
{ } 
#endif
#line 271 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcv(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 271
{ } 
#endif
#line 272 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short __ldcv(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 272
{ } 
#endif
#line 273 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int __ldcv(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 273
{ } 
#endif
#line 274 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcv(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 274
{ } 
#endif
#line 275 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcv(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 275
{ } 
#endif
#line 276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcv(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 276
{ } 
#endif
#line 277 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcv(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 277
{ } 
#endif
#line 278 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcv(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 278
{ } 
#endif
#line 279 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcv(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 279
{ } 
#endif
#line 280 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcv(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 280
{ } 
#endif
#line 281 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcv(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 281
{ } 
#endif
#line 283 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcv(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 283
{ } 
#endif
#line 284 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcv(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 284
{ } 
#endif
#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcv(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 285
{ } 
#endif
#line 286 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcv(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 286
{ } 
#endif
#line 287 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcv(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 287
{ } 
#endif
#line 288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcv(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 288
{ } 
#endif
#line 289 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcv(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 289
{ } 
#endif
#line 290 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcv(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 290
{ } 
#endif
#line 291 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcv(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 291
{ } 
#endif
#line 292 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcv(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 292
{ } 
#endif
#line 293 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcv(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 293
{ } 
#endif
#line 295 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float __ldcv(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 295
{ } 
#endif
#line 296 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double __ldcv(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 296
{ } 
#endif
#line 297 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcv(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 297
{ } 
#endif
#line 298 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcv(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 298
{ } 
#endif
#line 299 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcv(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 299
{ } 
#endif
#line 303 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 303
{ } 
#endif
#line 304 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 304
{ } 
#endif
#line 306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 306
{ } 
#endif
#line 307 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 307
{ } 
#endif
#line 308 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 308
{ } 
#endif
#line 309 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 309
{ } 
#endif
#line 310 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(__int64 *ptr, __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 310
{ } 
#endif
#line 311 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 311
{ } 
#endif
#line 312 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 312
{ } 
#endif
#line 313 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 313
{ } 
#endif
#line 314 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 314
{ } 
#endif
#line 315 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 315
{ } 
#endif
#line 316 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 316
{ } 
#endif
#line 317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 317
{ } 
#endif
#line 319 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 319
{ } 
#endif
#line 320 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 320
{ } 
#endif
#line 321 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 321
{ } 
#endif
#line 322 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(unsigned __int64 *ptr, unsigned __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 322
{ } 
#endif
#line 323 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 323
{ } 
#endif
#line 324 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 324
{ } 
#endif
#line 325 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 325
{ } 
#endif
#line 326 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 326
{ } 
#endif
#line 327 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 327
{ } 
#endif
#line 328 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 328
{ } 
#endif
#line 329 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 329
{ } 
#endif
#line 331 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 331
{ } 
#endif
#line 332 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 332
{ } 
#endif
#line 333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 333
{ } 
#endif
#line 334 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 334
{ } 
#endif
#line 335 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwb(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 335
{ } 
#endif
#line 339 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 339
{ } 
#endif
#line 340 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 340
{ } 
#endif
#line 342 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 342
{ } 
#endif
#line 343 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 343
{ } 
#endif
#line 344 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 344
{ } 
#endif
#line 345 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 345
{ } 
#endif
#line 346 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(__int64 *ptr, __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 346
{ } 
#endif
#line 347 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 347
{ } 
#endif
#line 348 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 348
{ } 
#endif
#line 349 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 349
{ } 
#endif
#line 350 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 350
{ } 
#endif
#line 351 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 351
{ } 
#endif
#line 352 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 352
{ } 
#endif
#line 353 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 353
{ } 
#endif
#line 355 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 355
{ } 
#endif
#line 356 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 356
{ } 
#endif
#line 357 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 357
{ } 
#endif
#line 358 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(unsigned __int64 *ptr, unsigned __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 358
{ } 
#endif
#line 359 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 359
{ } 
#endif
#line 360 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 360
{ } 
#endif
#line 361 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 361
{ } 
#endif
#line 362 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 362
{ } 
#endif
#line 363 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 363
{ } 
#endif
#line 364 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 364
{ } 
#endif
#line 365 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 365
{ } 
#endif
#line 367 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 367
{ } 
#endif
#line 368 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 368
{ } 
#endif
#line 369 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 369
{ } 
#endif
#line 370 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 370
{ } 
#endif
#line 371 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcg(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 371
{ } 
#endif
#line 375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 375
{ } 
#endif
#line 376 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 376
{ } 
#endif
#line 378 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 378
{ } 
#endif
#line 379 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 379
{ } 
#endif
#line 380 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 380
{ } 
#endif
#line 381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 381
{ } 
#endif
#line 382 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(__int64 *ptr, __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 382
{ } 
#endif
#line 383 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 383
{ } 
#endif
#line 384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 384
{ } 
#endif
#line 385 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 385
{ } 
#endif
#line 386 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 386
{ } 
#endif
#line 387 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 387
{ } 
#endif
#line 388 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 388
{ } 
#endif
#line 389 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 389
{ } 
#endif
#line 391 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 391
{ } 
#endif
#line 392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 392
{ } 
#endif
#line 393 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 393
{ } 
#endif
#line 394 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(unsigned __int64 *ptr, unsigned __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 394
{ } 
#endif
#line 395 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 395
{ } 
#endif
#line 396 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 396
{ } 
#endif
#line 397 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 397
{ } 
#endif
#line 398 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 398
{ } 
#endif
#line 399 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 399
{ } 
#endif
#line 400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 400
{ } 
#endif
#line 401 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 401
{ } 
#endif
#line 403 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 403
{ } 
#endif
#line 404 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 404
{ } 
#endif
#line 405 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 405
{ } 
#endif
#line 406 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 406
{ } 
#endif
#line 407 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stcs(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 407
{ } 
#endif
#line 411 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 411
{ } 
#endif
#line 412 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 412
{ } 
#endif
#line 414 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 414
{ } 
#endif
#line 415 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 415
{ } 
#endif
#line 416 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 416
{ } 
#endif
#line 417 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 417
{ } 
#endif
#line 418 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(__int64 *ptr, __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 418
{ } 
#endif
#line 419 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 419
{ } 
#endif
#line 420 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 420
{ } 
#endif
#line 421 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 421
{ } 
#endif
#line 422 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 422
{ } 
#endif
#line 423 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 423
{ } 
#endif
#line 424 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 424
{ } 
#endif
#line 425 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 425
{ } 
#endif
#line 427 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 427
{ } 
#endif
#line 428 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 428
{ } 
#endif
#line 429 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 429
{ } 
#endif
#line 430 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(unsigned __int64 *ptr, unsigned __int64 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 430
{ } 
#endif
#line 431 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 431
{ } 
#endif
#line 432 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 432
{ } 
#endif
#line 433 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 433
{ } 
#endif
#line 434 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 434
{ } 
#endif
#line 435 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 435
{ } 
#endif
#line 436 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 436
{ } 
#endif
#line 437 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 437
{ } 
#endif
#line 439 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 439
{ } 
#endif
#line 440 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 440
{ } 
#endif
#line 441 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 441
{ } 
#endif
#line 442 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 442
{ } 
#endif
#line 443 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline void __stwt(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
#line 443
{ } 
#endif
#line 460 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 460
{ } 
#endif
#line 472 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 472
{ } 
#endif
#line 485 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 485
{ } 
#endif
#line 497 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 497
{ } 
#endif
#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_lo(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 90 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_lo(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 90
{ } 
#endif
#line 92 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_lo(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_hi(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_hi(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_hi(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline int __dp4a(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp4a(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline int __dp4a(char4 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp4a(uchar4 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned __int64 value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, __int64 value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, float value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, double value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, int value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned __int64 value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, __int64 value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, float value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, double value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline void __nanosleep(unsigned ns) {int volatile ___ = 1;(void)ns;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
static __inline unsigned short atomicCAS(unsigned short *address, unsigned short compare, unsigned short val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_add_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_min_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_max_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline int __reduce_add_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline int __reduce_min_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline int __reduce_max_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_and_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_or_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
static __inline unsigned __reduce_xor_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
extern "C" {
#line 107
inline void *__nv_associate_access_property(const void *ptr, unsigned __int64 
#line 108
property) {int volatile ___ = 1;(void)ptr;(void)property;::exit(___);}
#if 0
#line 108
{ 
#line 109
extern void *__nv_associate_access_property_impl(const void *, unsigned __int64); 
#line 111
return __nv_associate_access_property_impl(ptr, property); 
#line 112
} 
#endif
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
inline void __nv_memcpy_async_shared_global_4(void *dst, const void *
#line 115
src, unsigned 
#line 116
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;::exit(___);}
#if 0
#line 116
{ 
#line 117
extern void __nv_memcpy_async_shared_global_4_impl(void *, const void *, unsigned); 
#line 120
__nv_memcpy_async_shared_global_4_impl(dst, src, src_size); 
#line 121
} 
#endif
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
inline void __nv_memcpy_async_shared_global_8(void *dst, const void *
#line 124
src, unsigned 
#line 125
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;::exit(___);}
#if 0
#line 125
{ 
#line 126
extern void __nv_memcpy_async_shared_global_8_impl(void *, const void *, unsigned); 
#line 129
__nv_memcpy_async_shared_global_8_impl(dst, src, src_size); 
#line 130
} 
#endif
#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
inline void __nv_memcpy_async_shared_global_16(void *dst, const void *
#line 133
src, unsigned 
#line 134
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;::exit(___);}
#if 0
#line 134
{ 
#line 135
extern void __nv_memcpy_async_shared_global_16_impl(void *, const void *, unsigned); 
#line 138
__nv_memcpy_async_shared_global_16_impl(dst, src, src_size); 
#line 139
} 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
}
#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline unsigned __isCtaShared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 90 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline unsigned __isClusterShared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 90
{ } 
#endif
#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline void *__cluster_map_shared_rank(const void *ptr, unsigned target_block_rank) {int volatile ___ = 1;(void)ptr;(void)target_block_rank;::exit(___);}
#if 0
#line 91
{ } 
#endif
#line 92 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline unsigned __cluster_query_shared_rank(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline uint2 __cluster_map_shared_multicast(const void *ptr, unsigned cluster_cta_mask) {int volatile ___ = 1;(void)ptr;(void)cluster_cta_mask;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline unsigned __clusterDimIsSpecified() {int volatile ___ = 1;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline dim3 __clusterDim() {int volatile ___ = 1;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline dim3 __clusterRelativeBlockIdx() {int volatile ___ = 1;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline dim3 __clusterGridDimInClusters() {int volatile ___ = 1;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline dim3 __clusterIdx() {int volatile ___ = 1;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline unsigned __clusterRelativeBlockRank() {int volatile ___ = 1;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline unsigned __clusterSizeInBlocks() {int volatile ___ = 1;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline void __cluster_barrier_arrive() {int volatile ___ = 1;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline void __cluster_barrier_wait() {int volatile ___ = 1;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
static __inline void __threadfence_cluster() {int volatile ___ = 1;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 123
__declspec(deprecated) static __forceinline void surf1Dread(T *res, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;::exit(___);}
#if 0
#line 124
{ 
#line 128
} 
#endif
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 131
__declspec(deprecated) static __forceinline T surf1Dread(::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)mode;::exit(___);}
#if 0
#line 132
{ 
#line 138
} 
#endif
#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 141
__declspec(deprecated) static __forceinline void surf1Dread(T *res, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;::exit(___);}
#if 0
#line 142
{ 
#line 146
} 
#endif
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 150
__declspec(deprecated) static __forceinline void surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;::exit(___);}
#if 0
#line 151
{ 
#line 155
} 
#endif
#line 157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 158
__declspec(deprecated) static __forceinline T surf2Dread(::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 159
{ 
#line 165
} 
#endif
#line 167 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 168
__declspec(deprecated) static __forceinline void surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 169
{ 
#line 173
} 
#endif
#line 176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 177
__declspec(deprecated) static __forceinline void surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;::exit(___);}
#if 0
#line 178
{ 
#line 182
} 
#endif
#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 185
__declspec(deprecated) static __forceinline T surf3Dread(::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 186
{ 
#line 192
} 
#endif
#line 194 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 195
__declspec(deprecated) static __forceinline void surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 196
{ 
#line 200
} 
#endif
#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 205
__declspec(deprecated) static __forceinline void surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;::exit(___);}
#if 0
#line 206
{ 
#line 210
} 
#endif
#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 213
__declspec(deprecated) static __forceinline T surf1DLayeredread(::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 214
{ 
#line 220
} 
#endif
#line 223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 224
__declspec(deprecated) static __forceinline void surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 225
{ 
#line 229
} 
#endif
#line 232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 233
__declspec(deprecated) static __forceinline void surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;::exit(___);}
#if 0
#line 234
{ 
#line 238
} 
#endif
#line 240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 241
__declspec(deprecated) static __forceinline T surf2DLayeredread(::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 242
{ 
#line 248
} 
#endif
#line 251 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 252
__declspec(deprecated) static __forceinline void surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 253
{ 
#line 257
} 
#endif
#line 260 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 261
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;::exit(___);}
#if 0
#line 262
{ 
#line 266
} 
#endif
#line 268 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 269
__declspec(deprecated) static __forceinline T surfCubemapread(::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 270
{ 
#line 277
} 
#endif
#line 279 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 280
__declspec(deprecated) static __forceinline void surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 281
{ 
#line 285
} 
#endif
#line 288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 289
__declspec(deprecated) static __forceinline void surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;::exit(___);}
#if 0
#line 290
{ 
#line 294
} 
#endif
#line 296 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 297
__declspec(deprecated) static __forceinline T surfCubemapLayeredread(::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;::exit(___);}
#if 0
#line 298
{ 
#line 304
} 
#endif
#line 306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 307
__declspec(deprecated) static __forceinline void surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;::exit(___);}
#if 0
#line 308
{ 
#line 312
} 
#endif
#line 315 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 316
__declspec(deprecated) static __forceinline void surf1Dwrite(T val, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;::exit(___);}
#if 0
#line 317
{ 
#line 321
} 
#endif
#line 323 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 324
__declspec(deprecated) static __forceinline void surf1Dwrite(T val, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;::exit(___);}
#if 0
#line 325
{ 
#line 329
} 
#endif
#line 333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 334
__declspec(deprecated) static __forceinline void surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;::exit(___);}
#if 0
#line 335
{ 
#line 339
} 
#endif
#line 341 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 342
__declspec(deprecated) static __forceinline void surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 343
{ 
#line 347
} 
#endif
#line 350 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 351
__declspec(deprecated) static __forceinline void surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;::exit(___);}
#if 0
#line 352
{ 
#line 356
} 
#endif
#line 358 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 359
__declspec(deprecated) static __forceinline void surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 360
{ 
#line 364
} 
#endif
#line 367 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 368
__declspec(deprecated) static __forceinline void surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;::exit(___);}
#if 0
#line 369
{ 
#line 373
} 
#endif
#line 375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 376
__declspec(deprecated) static __forceinline void surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 377
{ 
#line 381
} 
#endif
#line 384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 385
__declspec(deprecated) static __forceinline void surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;::exit(___);}
#if 0
#line 386
{ 
#line 390
} 
#endif
#line 392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 393
__declspec(deprecated) static __forceinline void surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 394
{ 
#line 398
} 
#endif
#line 401 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 402
__declspec(deprecated) static __forceinline void surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;::exit(___);}
#if 0
#line 403
{ 
#line 407
} 
#endif
#line 409 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 410
__declspec(deprecated) static __forceinline void surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 411
{ 
#line 415
} 
#endif
#line 419 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 420
__declspec(deprecated) static __forceinline void surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;::exit(___);}
#if 0
#line 421
{ 
#line 425
} 
#endif
#line 427 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template< class T> 
#line 428
__declspec(deprecated) static __forceinline void surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;::exit(___);}
#if 0
#line 429
{ 
#line 433
} 
#endif
#line 72 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 73
struct __nv_tex_rmet_ret { }; 
#line 75
template<> struct __nv_tex_rmet_ret< char>  { typedef char type; }; 
#line 76
template<> struct __nv_tex_rmet_ret< signed char>  { typedef signed char type; }; 
#line 77
template<> struct __nv_tex_rmet_ret< unsigned char>  { typedef unsigned char type; }; 
#line 78
template<> struct __nv_tex_rmet_ret< char1>  { typedef char1 type; }; 
#line 79
template<> struct __nv_tex_rmet_ret< uchar1>  { typedef uchar1 type; }; 
#line 80
template<> struct __nv_tex_rmet_ret< char2>  { typedef char2 type; }; 
#line 81
template<> struct __nv_tex_rmet_ret< uchar2>  { typedef uchar2 type; }; 
#line 82
template<> struct __nv_tex_rmet_ret< char4>  { typedef char4 type; }; 
#line 83
template<> struct __nv_tex_rmet_ret< uchar4>  { typedef uchar4 type; }; 
#line 85
template<> struct __nv_tex_rmet_ret< short>  { typedef short type; }; 
#line 86
template<> struct __nv_tex_rmet_ret< unsigned short>  { typedef unsigned short type; }; 
#line 87
template<> struct __nv_tex_rmet_ret< short1>  { typedef short1 type; }; 
#line 88
template<> struct __nv_tex_rmet_ret< ushort1>  { typedef ushort1 type; }; 
#line 89
template<> struct __nv_tex_rmet_ret< short2>  { typedef short2 type; }; 
#line 90
template<> struct __nv_tex_rmet_ret< ushort2>  { typedef ushort2 type; }; 
#line 91
template<> struct __nv_tex_rmet_ret< short4>  { typedef short4 type; }; 
#line 92
template<> struct __nv_tex_rmet_ret< ushort4>  { typedef ushort4 type; }; 
#line 94
template<> struct __nv_tex_rmet_ret< int>  { typedef int type; }; 
#line 95
template<> struct __nv_tex_rmet_ret< unsigned>  { typedef unsigned type; }; 
#line 96
template<> struct __nv_tex_rmet_ret< int1>  { typedef int1 type; }; 
#line 97
template<> struct __nv_tex_rmet_ret< uint1>  { typedef uint1 type; }; 
#line 98
template<> struct __nv_tex_rmet_ret< int2>  { typedef int2 type; }; 
#line 99
template<> struct __nv_tex_rmet_ret< uint2>  { typedef uint2 type; }; 
#line 100
template<> struct __nv_tex_rmet_ret< int4>  { typedef int4 type; }; 
#line 101
template<> struct __nv_tex_rmet_ret< uint4>  { typedef uint4 type; }; 
#line 104
template<> struct __nv_tex_rmet_ret< long>  { typedef long type; }; 
#line 105
template<> struct __nv_tex_rmet_ret< unsigned long>  { typedef unsigned long type; }; 
#line 106
template<> struct __nv_tex_rmet_ret< long1>  { typedef long1 type; }; 
#line 107
template<> struct __nv_tex_rmet_ret< ulong1>  { typedef ulong1 type; }; 
#line 108
template<> struct __nv_tex_rmet_ret< long2>  { typedef long2 type; }; 
#line 109
template<> struct __nv_tex_rmet_ret< ulong2>  { typedef ulong2 type; }; 
#line 110
template<> struct __nv_tex_rmet_ret< long4>  { typedef long4 type; }; 
#line 111
template<> struct __nv_tex_rmet_ret< ulong4>  { typedef ulong4 type; }; 
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template<> struct __nv_tex_rmet_ret< float>  { typedef float type; }; 
#line 114
template<> struct __nv_tex_rmet_ret< float1>  { typedef float1 type; }; 
#line 115
template<> struct __nv_tex_rmet_ret< float2>  { typedef float2 type; }; 
#line 116
template<> struct __nv_tex_rmet_ret< float4>  { typedef float4 type; }; 
#line 119
template< class T> struct __nv_tex_rmet_cast { typedef T *type; }; 
#line 121
template<> struct __nv_tex_rmet_cast< long>  { typedef int *type; }; 
#line 122
template<> struct __nv_tex_rmet_cast< unsigned long>  { typedef unsigned *type; }; 
#line 123
template<> struct __nv_tex_rmet_cast< long1>  { typedef int1 *type; }; 
#line 124
template<> struct __nv_tex_rmet_cast< ulong1>  { typedef uint1 *type; }; 
#line 125
template<> struct __nv_tex_rmet_cast< long2>  { typedef int2 *type; }; 
#line 126
template<> struct __nv_tex_rmet_cast< ulong2>  { typedef uint2 *type; }; 
#line 127
template<> struct __nv_tex_rmet_cast< long4>  { typedef int4 *type; }; 
#line 128
template<> struct __nv_tex_rmet_cast< ulong4>  { typedef uint4 *type; }; 
#line 131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 132
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex1Dfetch(texture< T, 1, cudaReadModeElementType>  t, int x) {int volatile ___ = 1;(void)t;(void)x;::exit(___);}
#if 0
#line 133
{ 
#line 139
} 
#endif
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 142
struct __nv_tex_rmnf_ret { }; 
#line 144
template<> struct __nv_tex_rmnf_ret< char>  { typedef float type; }; 
#line 145
template<> struct __nv_tex_rmnf_ret< signed char>  { typedef float type; }; 
#line 146
template<> struct __nv_tex_rmnf_ret< unsigned char>  { typedef float type; }; 
#line 147
template<> struct __nv_tex_rmnf_ret< short>  { typedef float type; }; 
#line 148
template<> struct __nv_tex_rmnf_ret< unsigned short>  { typedef float type; }; 
#line 149
template<> struct __nv_tex_rmnf_ret< char1>  { typedef float1 type; }; 
#line 150
template<> struct __nv_tex_rmnf_ret< uchar1>  { typedef float1 type; }; 
#line 151
template<> struct __nv_tex_rmnf_ret< short1>  { typedef float1 type; }; 
#line 152
template<> struct __nv_tex_rmnf_ret< ushort1>  { typedef float1 type; }; 
#line 153
template<> struct __nv_tex_rmnf_ret< char2>  { typedef float2 type; }; 
#line 154
template<> struct __nv_tex_rmnf_ret< uchar2>  { typedef float2 type; }; 
#line 155
template<> struct __nv_tex_rmnf_ret< short2>  { typedef float2 type; }; 
#line 156
template<> struct __nv_tex_rmnf_ret< ushort2>  { typedef float2 type; }; 
#line 157
template<> struct __nv_tex_rmnf_ret< char4>  { typedef float4 type; }; 
#line 158
template<> struct __nv_tex_rmnf_ret< uchar4>  { typedef float4 type; }; 
#line 159
template<> struct __nv_tex_rmnf_ret< short4>  { typedef float4 type; }; 
#line 160
template<> struct __nv_tex_rmnf_ret< ushort4>  { typedef float4 type; }; 
#line 162
template< class T> 
#line 163
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex1Dfetch(texture< T, 1, cudaReadModeNormalizedFloat>  t, int x) {int volatile ___ = 1;(void)t;(void)x;::exit(___);}
#if 0
#line 164
{ 
#line 171
} 
#endif
#line 174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 175
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex1D(texture< T, 1, cudaReadModeElementType>  t, float x) {int volatile ___ = 1;(void)t;(void)x;::exit(___);}
#if 0
#line 176
{ 
#line 182
} 
#endif
#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 185
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex1D(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x) {int volatile ___ = 1;(void)t;(void)x;::exit(___);}
#if 0
#line 186
{ 
#line 193
} 
#endif
#line 197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 198
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex2D(texture< T, 2, cudaReadModeElementType>  t, float x, float y) {int volatile ___ = 1;(void)t;(void)x;(void)y;::exit(___);}
#if 0
#line 199
{ 
#line 206
} 
#endif
#line 208 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 209
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex2D(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y) {int volatile ___ = 1;(void)t;(void)x;(void)y;::exit(___);}
#if 0
#line 210
{ 
#line 217
} 
#endif
#line 221 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 222
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex1DLayered(texture< T, 241, cudaReadModeElementType>  t, float x, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)layer;::exit(___);}
#if 0
#line 223
{ 
#line 229
} 
#endif
#line 231 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 232
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex1DLayered(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)layer;::exit(___);}
#if 0
#line 233
{ 
#line 240
} 
#endif
#line 244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 245
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex2DLayered(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 246
{ 
#line 252
} 
#endif
#line 254 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 255
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex2DLayered(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 256
{ 
#line 263
} 
#endif
#line 266 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 267
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex3D(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 268
{ 
#line 274
} 
#endif
#line 276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 277
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex3D(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 278
{ 
#line 285
} 
#endif
#line 288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 289
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type texCubemap(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 290
{ 
#line 296
} 
#endif
#line 298 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 299
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type texCubemap(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 300
{ 
#line 307
} 
#endif
#line 310 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 311
struct __nv_tex2dgather_ret { }; 
#line 312
template<> struct __nv_tex2dgather_ret< char>  { typedef char4 type; }; 
#line 313
template<> struct __nv_tex2dgather_ret< signed char>  { typedef char4 type; }; 
#line 314
template<> struct __nv_tex2dgather_ret< char1>  { typedef char4 type; }; 
#line 315
template<> struct __nv_tex2dgather_ret< char2>  { typedef char4 type; }; 
#line 316
template<> struct __nv_tex2dgather_ret< char3>  { typedef char4 type; }; 
#line 317
template<> struct __nv_tex2dgather_ret< char4>  { typedef char4 type; }; 
#line 318
template<> struct __nv_tex2dgather_ret< unsigned char>  { typedef uchar4 type; }; 
#line 319
template<> struct __nv_tex2dgather_ret< uchar1>  { typedef uchar4 type; }; 
#line 320
template<> struct __nv_tex2dgather_ret< uchar2>  { typedef uchar4 type; }; 
#line 321
template<> struct __nv_tex2dgather_ret< uchar3>  { typedef uchar4 type; }; 
#line 322
template<> struct __nv_tex2dgather_ret< uchar4>  { typedef uchar4 type; }; 
#line 324
template<> struct __nv_tex2dgather_ret< short>  { typedef short4 type; }; 
#line 325
template<> struct __nv_tex2dgather_ret< short1>  { typedef short4 type; }; 
#line 326
template<> struct __nv_tex2dgather_ret< short2>  { typedef short4 type; }; 
#line 327
template<> struct __nv_tex2dgather_ret< short3>  { typedef short4 type; }; 
#line 328
template<> struct __nv_tex2dgather_ret< short4>  { typedef short4 type; }; 
#line 329
template<> struct __nv_tex2dgather_ret< unsigned short>  { typedef ushort4 type; }; 
#line 330
template<> struct __nv_tex2dgather_ret< ushort1>  { typedef ushort4 type; }; 
#line 331
template<> struct __nv_tex2dgather_ret< ushort2>  { typedef ushort4 type; }; 
#line 332
template<> struct __nv_tex2dgather_ret< ushort3>  { typedef ushort4 type; }; 
#line 333
template<> struct __nv_tex2dgather_ret< ushort4>  { typedef ushort4 type; }; 
#line 335
template<> struct __nv_tex2dgather_ret< int>  { typedef int4 type; }; 
#line 336
template<> struct __nv_tex2dgather_ret< int1>  { typedef int4 type; }; 
#line 337
template<> struct __nv_tex2dgather_ret< int2>  { typedef int4 type; }; 
#line 338
template<> struct __nv_tex2dgather_ret< int3>  { typedef int4 type; }; 
#line 339
template<> struct __nv_tex2dgather_ret< int4>  { typedef int4 type; }; 
#line 340
template<> struct __nv_tex2dgather_ret< unsigned>  { typedef uint4 type; }; 
#line 341
template<> struct __nv_tex2dgather_ret< uint1>  { typedef uint4 type; }; 
#line 342
template<> struct __nv_tex2dgather_ret< uint2>  { typedef uint4 type; }; 
#line 343
template<> struct __nv_tex2dgather_ret< uint3>  { typedef uint4 type; }; 
#line 344
template<> struct __nv_tex2dgather_ret< uint4>  { typedef uint4 type; }; 
#line 346
template<> struct __nv_tex2dgather_ret< float>  { typedef float4 type; }; 
#line 347
template<> struct __nv_tex2dgather_ret< float1>  { typedef float4 type; }; 
#line 348
template<> struct __nv_tex2dgather_ret< float2>  { typedef float4 type; }; 
#line 349
template<> struct __nv_tex2dgather_ret< float3>  { typedef float4 type; }; 
#line 350
template<> struct __nv_tex2dgather_ret< float4>  { typedef float4 type; }; 
#line 352
template< class T> static __forceinline typename __nv_tex2dgather_ret< T> ::type 
#line 353
tex2Dgather(texture< T, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 354
{ 
#line 361
} 
#endif
#line 364 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> struct __nv_tex2dgather_rmnf_ret { }; 
#line 365
template<> struct __nv_tex2dgather_rmnf_ret< char>  { typedef float4 type; }; 
#line 366
template<> struct __nv_tex2dgather_rmnf_ret< signed char>  { typedef float4 type; }; 
#line 367
template<> struct __nv_tex2dgather_rmnf_ret< unsigned char>  { typedef float4 type; }; 
#line 368
template<> struct __nv_tex2dgather_rmnf_ret< char1>  { typedef float4 type; }; 
#line 369
template<> struct __nv_tex2dgather_rmnf_ret< uchar1>  { typedef float4 type; }; 
#line 370
template<> struct __nv_tex2dgather_rmnf_ret< char2>  { typedef float4 type; }; 
#line 371
template<> struct __nv_tex2dgather_rmnf_ret< uchar2>  { typedef float4 type; }; 
#line 372
template<> struct __nv_tex2dgather_rmnf_ret< char3>  { typedef float4 type; }; 
#line 373
template<> struct __nv_tex2dgather_rmnf_ret< uchar3>  { typedef float4 type; }; 
#line 374
template<> struct __nv_tex2dgather_rmnf_ret< char4>  { typedef float4 type; }; 
#line 375
template<> struct __nv_tex2dgather_rmnf_ret< uchar4>  { typedef float4 type; }; 
#line 376
template<> struct __nv_tex2dgather_rmnf_ret< signed short>  { typedef float4 type; }; 
#line 377
template<> struct __nv_tex2dgather_rmnf_ret< unsigned short>  { typedef float4 type; }; 
#line 378
template<> struct __nv_tex2dgather_rmnf_ret< short1>  { typedef float4 type; }; 
#line 379
template<> struct __nv_tex2dgather_rmnf_ret< ushort1>  { typedef float4 type; }; 
#line 380
template<> struct __nv_tex2dgather_rmnf_ret< short2>  { typedef float4 type; }; 
#line 381
template<> struct __nv_tex2dgather_rmnf_ret< ushort2>  { typedef float4 type; }; 
#line 382
template<> struct __nv_tex2dgather_rmnf_ret< short3>  { typedef float4 type; }; 
#line 383
template<> struct __nv_tex2dgather_rmnf_ret< ushort3>  { typedef float4 type; }; 
#line 384
template<> struct __nv_tex2dgather_rmnf_ret< short4>  { typedef float4 type; }; 
#line 385
template<> struct __nv_tex2dgather_rmnf_ret< ushort4>  { typedef float4 type; }; 
#line 387
template< class T> static __forceinline typename __nv_tex2dgather_rmnf_ret< T> ::type 
#line 388
tex2Dgather(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 389
{ 
#line 396
} 
#endif
#line 400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 401
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex1DLod(texture< T, 1, cudaReadModeElementType>  t, float x, float level) {int volatile ___ = 1;(void)t;(void)x;(void)level;::exit(___);}
#if 0
#line 402
{ 
#line 408
} 
#endif
#line 410 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 411
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex1DLod(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float level) {int volatile ___ = 1;(void)t;(void)x;(void)level;::exit(___);}
#if 0
#line 412
{ 
#line 419
} 
#endif
#line 422 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 423
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex2DLod(texture< T, 2, cudaReadModeElementType>  t, float x, float y, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 424
{ 
#line 430
} 
#endif
#line 432 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 433
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex2DLod(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 434
{ 
#line 441
} 
#endif
#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 445
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex1DLayeredLod(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 446
{ 
#line 452
} 
#endif
#line 454 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 455
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex1DLayeredLod(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 456
{ 
#line 463
} 
#endif
#line 466 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 467
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex2DLayeredLod(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 468
{ 
#line 474
} 
#endif
#line 476 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 477
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex2DLayeredLod(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 478
{ 
#line 485
} 
#endif
#line 488 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 489
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex3DLod(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 490
{ 
#line 496
} 
#endif
#line 498 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 499
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex3DLod(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 500
{ 
#line 507
} 
#endif
#line 510 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 511
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type texCubemapLod(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 512
{ 
#line 518
} 
#endif
#line 520 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 521
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type texCubemapLod(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 522
{ 
#line 529
} 
#endif
#line 533 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 534
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type texCubemapLayered(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 535
{ 
#line 541
} 
#endif
#line 543 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 544
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayered(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 545
{ 
#line 552
} 
#endif
#line 556 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 557
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type texCubemapLayeredLod(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 558
{ 
#line 564
} 
#endif
#line 566 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 567
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayeredLod(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 568
{ 
#line 575
} 
#endif
#line 579 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 580
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type texCubemapGrad(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 581
{ 
#line 587
} 
#endif
#line 589 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 590
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type texCubemapGrad(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 591
{ 
#line 598
} 
#endif
#line 602 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 603
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type texCubemapLayeredGrad(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 604
{ 
#line 610
} 
#endif
#line 612 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 613
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayeredGrad(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 614
{ 
#line 621
} 
#endif
#line 625 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 626
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex1DGrad(texture< T, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 627
{ 
#line 633
} 
#endif
#line 635 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 636
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex1DGrad(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 637
{ 
#line 644
} 
#endif
#line 648 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 649
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex2DGrad(texture< T, 2, cudaReadModeElementType>  t, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 650
{ 
#line 656
} 
#endif
#line 658 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 659
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex2DGrad(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 660
{ 
#line 667
} 
#endif
#line 670 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 671
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex1DLayeredGrad(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 672
{ 
#line 678
} 
#endif
#line 680 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 681
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex1DLayeredGrad(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 682
{ 
#line 689
} 
#endif
#line 692 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 693
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex2DLayeredGrad(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 694
{ 
#line 700
} 
#endif
#line 702 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 703
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex2DLayeredGrad(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 704
{ 
#line 711
} 
#endif
#line 714 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 715
__declspec(deprecated) static __forceinline typename __nv_tex_rmet_ret< T> ::type tex3DGrad(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 716
{ 
#line 722
} 
#endif
#line 724 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template< class T> 
#line 725
__declspec(deprecated) static __forceinline typename __nv_tex_rmnf_ret< T> ::type tex3DGrad(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 726
{ 
#line 733
} 
#endif
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> struct __nv_itex_trait { }; 
#line 65
template<> struct __nv_itex_trait< char>  { typedef void type; }; 
#line 66
template<> struct __nv_itex_trait< signed char>  { typedef void type; }; 
#line 67
template<> struct __nv_itex_trait< char1>  { typedef void type; }; 
#line 68
template<> struct __nv_itex_trait< char2>  { typedef void type; }; 
#line 69
template<> struct __nv_itex_trait< char4>  { typedef void type; }; 
#line 70
template<> struct __nv_itex_trait< unsigned char>  { typedef void type; }; 
#line 71
template<> struct __nv_itex_trait< uchar1>  { typedef void type; }; 
#line 72
template<> struct __nv_itex_trait< uchar2>  { typedef void type; }; 
#line 73
template<> struct __nv_itex_trait< uchar4>  { typedef void type; }; 
#line 74
template<> struct __nv_itex_trait< short>  { typedef void type; }; 
#line 75
template<> struct __nv_itex_trait< short1>  { typedef void type; }; 
#line 76
template<> struct __nv_itex_trait< short2>  { typedef void type; }; 
#line 77
template<> struct __nv_itex_trait< short4>  { typedef void type; }; 
#line 78
template<> struct __nv_itex_trait< unsigned short>  { typedef void type; }; 
#line 79
template<> struct __nv_itex_trait< ushort1>  { typedef void type; }; 
#line 80
template<> struct __nv_itex_trait< ushort2>  { typedef void type; }; 
#line 81
template<> struct __nv_itex_trait< ushort4>  { typedef void type; }; 
#line 82
template<> struct __nv_itex_trait< int>  { typedef void type; }; 
#line 83
template<> struct __nv_itex_trait< int1>  { typedef void type; }; 
#line 84
template<> struct __nv_itex_trait< int2>  { typedef void type; }; 
#line 85
template<> struct __nv_itex_trait< int4>  { typedef void type; }; 
#line 86
template<> struct __nv_itex_trait< unsigned>  { typedef void type; }; 
#line 87
template<> struct __nv_itex_trait< uint1>  { typedef void type; }; 
#line 88
template<> struct __nv_itex_trait< uint2>  { typedef void type; }; 
#line 89
template<> struct __nv_itex_trait< uint4>  { typedef void type; }; 
#line 91
template<> struct __nv_itex_trait< long>  { typedef void type; }; 
#line 92
template<> struct __nv_itex_trait< long1>  { typedef void type; }; 
#line 93
template<> struct __nv_itex_trait< long2>  { typedef void type; }; 
#line 94
template<> struct __nv_itex_trait< long4>  { typedef void type; }; 
#line 95
template<> struct __nv_itex_trait< unsigned long>  { typedef void type; }; 
#line 96
template<> struct __nv_itex_trait< ulong1>  { typedef void type; }; 
#line 97
template<> struct __nv_itex_trait< ulong2>  { typedef void type; }; 
#line 98
template<> struct __nv_itex_trait< ulong4>  { typedef void type; }; 
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template<> struct __nv_itex_trait< float>  { typedef void type; }; 
#line 101
template<> struct __nv_itex_trait< float1>  { typedef void type; }; 
#line 102
template<> struct __nv_itex_trait< float2>  { typedef void type; }; 
#line 103
template<> struct __nv_itex_trait< float4>  { typedef void type; }; 
#line 107
template< class T> static typename __nv_itex_trait< T> ::type 
#line 108
tex1Dfetch(T *ptr, ::cudaTextureObject_t obj, int x) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;::exit(___);}
#if 0
#line 109
{ 
#line 113
} 
#endif
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 116
tex1Dfetch(::cudaTextureObject_t texObject, int x) {int volatile ___ = 1;(void)texObject;(void)x;::exit(___);}
#if 0
#line 117
{ 
#line 123
} 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 126
tex1D(T *ptr, ::cudaTextureObject_t obj, float x) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;::exit(___);}
#if 0
#line 127
{ 
#line 131
} 
#endif
#line 134 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 135
tex1D(::cudaTextureObject_t texObject, float x) {int volatile ___ = 1;(void)texObject;(void)x;::exit(___);}
#if 0
#line 136
{ 
#line 142
} 
#endif
#line 145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 146
tex2D(T *ptr, ::cudaTextureObject_t obj, float x, float y) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;::exit(___);}
#if 0
#line 147
{ 
#line 151
} 
#endif
#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 154
tex2D(::cudaTextureObject_t texObject, float x, float y) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;::exit(___);}
#if 0
#line 155
{ 
#line 161
} 
#endif
#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 165
tex2D(T *ptr, ::cudaTextureObject_t obj, float x, float y, bool *
#line 166
isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)isResident;::exit(___);}
#if 0
#line 167
{ 
#line 173
} 
#endif
#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 176
tex2D(::cudaTextureObject_t texObject, float x, float y, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)isResident;::exit(___);}
#if 0
#line 177
{ 
#line 183
} 
#endif
#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 189
tex3D(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 190
{ 
#line 194
} 
#endif
#line 196 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 197
tex3D(::cudaTextureObject_t texObject, float x, float y, float z) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 198
{ 
#line 204
} 
#endif
#line 207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 208
tex3D(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, bool *
#line 209
isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)isResident;::exit(___);}
#if 0
#line 210
{ 
#line 216
} 
#endif
#line 218 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 219
tex3D(::cudaTextureObject_t texObject, float x, float y, float z, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)isResident;::exit(___);}
#if 0
#line 220
{ 
#line 226
} 
#endif
#line 230 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 231
tex1DLayered(T *ptr, ::cudaTextureObject_t obj, float x, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;::exit(___);}
#if 0
#line 232
{ 
#line 236
} 
#endif
#line 238 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 239
tex1DLayered(::cudaTextureObject_t texObject, float x, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;::exit(___);}
#if 0
#line 240
{ 
#line 246
} 
#endif
#line 248 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 249
tex2DLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 250
{ 
#line 254
} 
#endif
#line 256 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 257
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 258
{ 
#line 264
} 
#endif
#line 267 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 268
tex2DLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)isResident;::exit(___);}
#if 0
#line 269
{ 
#line 275
} 
#endif
#line 277 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 278
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)isResident;::exit(___);}
#if 0
#line 279
{ 
#line 285
} 
#endif
#line 289 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 290
texCubemap(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 291
{ 
#line 295
} 
#endif
#line 298 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 299
texCubemap(::cudaTextureObject_t texObject, float x, float y, float z) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 300
{ 
#line 306
} 
#endif
#line 309 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 310
texCubemapLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 311
{ 
#line 315
} 
#endif
#line 317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 318
texCubemapLayered(::cudaTextureObject_t texObject, float x, float y, float z, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 319
{ 
#line 325
} 
#endif
#line 327 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 328
tex2Dgather(T *ptr, ::cudaTextureObject_t obj, float x, float y, int comp = 0) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 329
{ 
#line 333
} 
#endif
#line 335 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 336
tex2Dgather(::cudaTextureObject_t to, float x, float y, int comp = 0) {int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 337
{ 
#line 343
} 
#endif
#line 346 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 347
tex2Dgather(T *ptr, ::cudaTextureObject_t obj, float x, float y, bool *isResident, int comp = 0) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)isResident;(void)comp;::exit(___);}
#if 0
#line 348
{ 
#line 354
} 
#endif
#line 356 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 357
tex2Dgather(::cudaTextureObject_t to, float x, float y, bool *isResident, int comp = 0) {int volatile ___ = 1;(void)to;(void)x;(void)y;(void)isResident;(void)comp;::exit(___);}
#if 0
#line 358
{ 
#line 364
} 
#endif
#line 368 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 369
tex1DLod(T *ptr, ::cudaTextureObject_t obj, float x, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)level;::exit(___);}
#if 0
#line 370
{ 
#line 374
} 
#endif
#line 376 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 377
tex1DLod(::cudaTextureObject_t texObject, float x, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)level;::exit(___);}
#if 0
#line 378
{ 
#line 384
} 
#endif
#line 387 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 388
tex2DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 389
{ 
#line 393
} 
#endif
#line 395 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 396
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 397
{ 
#line 403
} 
#endif
#line 407 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 408
tex2DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float level, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;(void)isResident;::exit(___);}
#if 0
#line 409
{ 
#line 415
} 
#endif
#line 417 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 418
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;(void)isResident;::exit(___);}
#if 0
#line 419
{ 
#line 425
} 
#endif
#line 430 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 431
tex3DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 432
{ 
#line 436
} 
#endif
#line 438 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 439
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 440
{ 
#line 446
} 
#endif
#line 449 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 450
tex3DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;(void)isResident;::exit(___);}
#if 0
#line 451
{ 
#line 457
} 
#endif
#line 459 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 460
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;(void)isResident;::exit(___);}
#if 0
#line 461
{ 
#line 467
} 
#endif
#line 472 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 473
tex1DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 474
{ 
#line 478
} 
#endif
#line 480 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 481
tex1DLayeredLod(::cudaTextureObject_t texObject, float x, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 482
{ 
#line 488
} 
#endif
#line 491 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 492
tex2DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 493
{ 
#line 497
} 
#endif
#line 499 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 500
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 501
{ 
#line 507
} 
#endif
#line 510 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 511
tex2DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, float level, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;(void)isResident;::exit(___);}
#if 0
#line 512
{ 
#line 518
} 
#endif
#line 520 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 521
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;(void)isResident;::exit(___);}
#if 0
#line 522
{ 
#line 528
} 
#endif
#line 531 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 532
texCubemapLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 533
{ 
#line 537
} 
#endif
#line 539 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 540
texCubemapLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 541
{ 
#line 547
} 
#endif
#line 550 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 551
texCubemapGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 552
{ 
#line 556
} 
#endif
#line 558 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 559
texCubemapGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 560
{ 
#line 566
} 
#endif
#line 568 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 569
texCubemapLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 570
{ 
#line 574
} 
#endif
#line 576 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 577
texCubemapLayeredLod(::cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 578
{ 
#line 584
} 
#endif
#line 586 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 587
tex1DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 588
{ 
#line 592
} 
#endif
#line 594 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 595
tex1DGrad(::cudaTextureObject_t texObject, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 596
{ 
#line 602
} 
#endif
#line 605 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 606
tex2DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 607
{ 
#line 612
} 
#endif
#line 614 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 615
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 616
{ 
#line 622
} 
#endif
#line 625 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 626
tex2DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, ::float2 dPdx, ::float2 dPdy, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 627
{ 
#line 634
} 
#endif
#line 636 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 637
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 638
{ 
#line 644
} 
#endif
#line 648 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 649
tex3DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 650
{ 
#line 654
} 
#endif
#line 656 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 657
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 658
{ 
#line 664
} 
#endif
#line 667 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 668
tex3DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 669
{ 
#line 675
} 
#endif
#line 677 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 678
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 679
{ 
#line 685
} 
#endif
#line 690 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 691
tex1DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 692
{ 
#line 696
} 
#endif
#line 698 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 699
tex1DLayeredGrad(::cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 700
{ 
#line 706
} 
#endif
#line 709 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 710
tex2DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 711
{ 
#line 715
} 
#endif
#line 717 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 718
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 719
{ 
#line 725
} 
#endif
#line 728 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 729
tex2DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy, bool *isResident) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 730
{ 
#line 736
} 
#endif
#line 738 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 739
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy, bool *isResident) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;(void)isResident;::exit(___);}
#if 0
#line 740
{ 
#line 746
} 
#endif
#line 750 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 751
texCubemapLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 752
{ 
#line 756
} 
#endif
#line 758 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 759
texCubemapLayeredGrad(::cudaTextureObject_t texObject, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 760
{ 
#line 766
} 
#endif
#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> struct __nv_isurf_trait { }; 
#line 60
template<> struct __nv_isurf_trait< char>  { typedef void type; }; 
#line 61
template<> struct __nv_isurf_trait< signed char>  { typedef void type; }; 
#line 62
template<> struct __nv_isurf_trait< char1>  { typedef void type; }; 
#line 63
template<> struct __nv_isurf_trait< unsigned char>  { typedef void type; }; 
#line 64
template<> struct __nv_isurf_trait< uchar1>  { typedef void type; }; 
#line 65
template<> struct __nv_isurf_trait< short>  { typedef void type; }; 
#line 66
template<> struct __nv_isurf_trait< short1>  { typedef void type; }; 
#line 67
template<> struct __nv_isurf_trait< unsigned short>  { typedef void type; }; 
#line 68
template<> struct __nv_isurf_trait< ushort1>  { typedef void type; }; 
#line 69
template<> struct __nv_isurf_trait< int>  { typedef void type; }; 
#line 70
template<> struct __nv_isurf_trait< int1>  { typedef void type; }; 
#line 71
template<> struct __nv_isurf_trait< unsigned>  { typedef void type; }; 
#line 72
template<> struct __nv_isurf_trait< uint1>  { typedef void type; }; 
#line 73
template<> struct __nv_isurf_trait< __int64>  { typedef void type; }; 
#line 74
template<> struct __nv_isurf_trait< longlong1>  { typedef void type; }; 
#line 75
template<> struct __nv_isurf_trait< unsigned __int64>  { typedef void type; }; 
#line 76
template<> struct __nv_isurf_trait< ulonglong1>  { typedef void type; }; 
#line 77
template<> struct __nv_isurf_trait< float>  { typedef void type; }; 
#line 78
template<> struct __nv_isurf_trait< float1>  { typedef void type; }; 
#line 80
template<> struct __nv_isurf_trait< char2>  { typedef void type; }; 
#line 81
template<> struct __nv_isurf_trait< uchar2>  { typedef void type; }; 
#line 82
template<> struct __nv_isurf_trait< short2>  { typedef void type; }; 
#line 83
template<> struct __nv_isurf_trait< ushort2>  { typedef void type; }; 
#line 84
template<> struct __nv_isurf_trait< int2>  { typedef void type; }; 
#line 85
template<> struct __nv_isurf_trait< uint2>  { typedef void type; }; 
#line 86
template<> struct __nv_isurf_trait< longlong2>  { typedef void type; }; 
#line 87
template<> struct __nv_isurf_trait< ulonglong2>  { typedef void type; }; 
#line 88
template<> struct __nv_isurf_trait< float2>  { typedef void type; }; 
#line 90
template<> struct __nv_isurf_trait< char4>  { typedef void type; }; 
#line 91
template<> struct __nv_isurf_trait< uchar4>  { typedef void type; }; 
#line 92
template<> struct __nv_isurf_trait< short4>  { typedef void type; }; 
#line 93
template<> struct __nv_isurf_trait< ushort4>  { typedef void type; }; 
#line 94
template<> struct __nv_isurf_trait< int4>  { typedef void type; }; 
#line 95
template<> struct __nv_isurf_trait< uint4>  { typedef void type; }; 
#line 96
template<> struct __nv_isurf_trait< float4>  { typedef void type; }; 
#line 99
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 100
surf1Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)mode;::exit(___);}
#if 0
#line 101
{ 
#line 105
} 
#endif
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 108
surf1Dread(::cudaSurfaceObject_t surfObject, int x, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;::exit(___);}
#if 0
#line 109
{ 
#line 115
} 
#endif
#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 118
surf2Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 119
{ 
#line 123
} 
#endif
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 126
surf2Dread(::cudaSurfaceObject_t surfObject, int x, int y, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;::exit(___);}
#if 0
#line 127
{ 
#line 133
} 
#endif
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 137
surf3Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 138
{ 
#line 142
} 
#endif
#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 145
surf3Dread(::cudaSurfaceObject_t surfObject, int x, int y, int z, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;::exit(___);}
#if 0
#line 146
{ 
#line 152
} 
#endif
#line 154 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 155
surf1DLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 156
{ 
#line 160
} 
#endif
#line 162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 163
surf1DLayeredread(::cudaSurfaceObject_t surfObject, int x, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;::exit(___);}
#if 0
#line 164
{ 
#line 170
} 
#endif
#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 173
surf2DLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 174
{ 
#line 178
} 
#endif
#line 180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 181
surf2DLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;::exit(___);}
#if 0
#line 182
{ 
#line 188
} 
#endif
#line 190 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 191
surfCubemapread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 192
{ 
#line 196
} 
#endif
#line 198 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 199
surfCubemapread(::cudaSurfaceObject_t surfObject, int x, int y, int face, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;::exit(___);}
#if 0
#line 200
{ 
#line 206
} 
#endif
#line 208 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 209
surfCubemapLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int layerface, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;::exit(___);}
#if 0
#line 210
{ 
#line 214
} 
#endif
#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 217
surfCubemapLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layerface, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;::exit(___);}
#if 0
#line 218
{ 
#line 224
} 
#endif
#line 226 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 227
surf1Dwrite(T val, ::cudaSurfaceObject_t obj, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)mode;::exit(___);}
#if 0
#line 228
{ 
#line 232
} 
#endif
#line 234 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 235
surf2Dwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 236
{ 
#line 240
} 
#endif
#line 242 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 243
surf3Dwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 244
{ 
#line 248
} 
#endif
#line 250 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 251
surf1DLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 252
{ 
#line 256
} 
#endif
#line 258 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 259
surf2DLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 260
{ 
#line 264
} 
#endif
#line 266 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 267
surfCubemapwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 268
{ 
#line 272
} 
#endif
#line 274 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 275
surfCubemapLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int layerface, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;::exit(___);}
#if 0
#line 276
{ 
#line 280
} 
#endif
#line 3309 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
extern "C" unsigned __stdcall __cudaPushCallConfiguration(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, CUstream_st * stream = 0); 
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"
extern "C" {
#line 71 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"
extern const uint3 __device_builtin_variable_threadIdx; 
#line 72
extern const uint3 __device_builtin_variable_blockIdx; 
#line 73
extern const dim3 __device_builtin_variable_blockDim; 
#line 74
extern const dim3 __device_builtin_variable_gridDim; 
#line 75
extern const int __device_builtin_variable_warpSize; 
#line 80
}
#line 205 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 206
cudaLaunchKernel(const T *
#line 207
func, ::dim3 
#line 208
gridDim, ::dim3 
#line 209
blockDim, void **
#line 210
args, ::size_t 
#line 211
sharedMem = 0, ::cudaStream_t 
#line 212
stream = 0) 
#line 214
{ 
#line 215
return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 216
} 
#line 339 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 340
cudaLaunchCooperativeKernel(const T *
#line 341
func, ::dim3 
#line 342
gridDim, ::dim3 
#line 343
blockDim, void **
#line 344
args, ::size_t 
#line 345
sharedMem = 0, ::cudaStream_t 
#line 346
stream = 0) 
#line 348
{ 
#line 349
return ::cudaLaunchCooperativeKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 350
} 
#line 383
static __inline cudaError_t cudaEventCreate(cudaEvent_t *
#line 384
event, unsigned 
#line 385
flags) 
#line 387
{ 
#line 388
return ::cudaEventCreateWithFlags(event, flags); 
#line 389
} 
#line 448
static __inline cudaError_t cudaMallocHost(void **
#line 449
ptr, size_t 
#line 450
size, unsigned 
#line 451
flags) 
#line 453
{ 
#line 454
return ::cudaHostAlloc(ptr, size, flags); 
#line 455
} 
#line 457
template< class T> static __inline ::cudaError_t 
#line 458
cudaHostAlloc(T **
#line 459
ptr, ::size_t 
#line 460
size, unsigned 
#line 461
flags) 
#line 463
{ 
#line 464
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
#line 465
} 
#line 467
template< class T> static __inline ::cudaError_t 
#line 468
cudaHostGetDevicePointer(T **
#line 469
pDevice, void *
#line 470
pHost, unsigned 
#line 471
flags) 
#line 473
{ 
#line 474
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
#line 475
} 
#line 577
template< class T> static __inline ::cudaError_t 
#line 578
cudaMallocManaged(T **
#line 579
devPtr, ::size_t 
#line 580
size, unsigned 
#line 581
flags = 1) 
#line 583
{ 
#line 584
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
#line 585
} 
#line 667
template< class T> static __inline ::cudaError_t 
#line 668
cudaStreamAttachMemAsync(::cudaStream_t 
#line 669
stream, T *
#line 670
devPtr, ::size_t 
#line 671
length = 0, unsigned 
#line 672
flags = 4) 
#line 674
{ 
#line 675
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
#line 676
} 
#line 678
template< class T> __inline ::cudaError_t 
#line 679
cudaMalloc(T **
#line 680
devPtr, ::size_t 
#line 681
size) 
#line 683
{ 
#line 684
return ::cudaMalloc((void **)((void *)devPtr), size); 
#line 685
} 
#line 687
template< class T> static __inline ::cudaError_t 
#line 688
cudaMallocHost(T **
#line 689
ptr, ::size_t 
#line 690
size, unsigned 
#line 691
flags = 0) 
#line 693
{ 
#line 694
return cudaMallocHost((void **)((void *)ptr), size, flags); 
#line 695
} 
#line 697
template< class T> static __inline ::cudaError_t 
#line 698
cudaMallocPitch(T **
#line 699
devPtr, ::size_t *
#line 700
pitch, ::size_t 
#line 701
width, ::size_t 
#line 702
height) 
#line 704
{ 
#line 705
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
#line 706
} 
#line 717
static __inline cudaError_t cudaMallocAsync(void **
#line 718
ptr, size_t 
#line 719
size, cudaMemPool_t 
#line 720
memPool, cudaStream_t 
#line 721
stream) 
#line 723
{ 
#line 724
return ::cudaMallocFromPoolAsync(ptr, size, memPool, stream); 
#line 725
} 
#line 727
template< class T> static __inline ::cudaError_t 
#line 728
cudaMallocAsync(T **
#line 729
ptr, ::size_t 
#line 730
size, ::cudaMemPool_t 
#line 731
memPool, ::cudaStream_t 
#line 732
stream) 
#line 734
{ 
#line 735
return ::cudaMallocFromPoolAsync((void **)((void *)ptr), size, memPool, stream); 
#line 736
} 
#line 738
template< class T> static __inline ::cudaError_t 
#line 739
cudaMallocAsync(T **
#line 740
ptr, ::size_t 
#line 741
size, ::cudaStream_t 
#line 742
stream) 
#line 744
{ 
#line 745
return ::cudaMallocAsync((void **)((void *)ptr), size, stream); 
#line 746
} 
#line 748
template< class T> static __inline ::cudaError_t 
#line 749
cudaMallocFromPoolAsync(T **
#line 750
ptr, ::size_t 
#line 751
size, ::cudaMemPool_t 
#line 752
memPool, ::cudaStream_t 
#line 753
stream) 
#line 755
{ 
#line 756
return ::cudaMallocFromPoolAsync((void **)((void *)ptr), size, memPool, stream); 
#line 757
} 
#line 796
template< class T> static __inline ::cudaError_t 
#line 797
cudaMemcpyToSymbol(const T &
#line 798
symbol, const void *
#line 799
src, ::size_t 
#line 800
count, ::size_t 
#line 801
offset = 0, ::cudaMemcpyKind 
#line 802
kind = cudaMemcpyHostToDevice) 
#line 804
{ 
#line 805
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
#line 806
} 
#line 850
template< class T> static __inline ::cudaError_t 
#line 851
cudaMemcpyToSymbolAsync(const T &
#line 852
symbol, const void *
#line 853
src, ::size_t 
#line 854
count, ::size_t 
#line 855
offset = 0, ::cudaMemcpyKind 
#line 856
kind = cudaMemcpyHostToDevice, ::cudaStream_t 
#line 857
stream = 0) 
#line 859
{ 
#line 860
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
#line 861
} 
#line 898
template< class T> static __inline ::cudaError_t 
#line 899
cudaMemcpyFromSymbol(void *
#line 900
dst, const T &
#line 901
symbol, ::size_t 
#line 902
count, ::size_t 
#line 903
offset = 0, ::cudaMemcpyKind 
#line 904
kind = cudaMemcpyDeviceToHost) 
#line 906
{ 
#line 907
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
#line 908
} 
#line 952
template< class T> static __inline ::cudaError_t 
#line 953
cudaMemcpyFromSymbolAsync(void *
#line 954
dst, const T &
#line 955
symbol, ::size_t 
#line 956
count, ::size_t 
#line 957
offset = 0, ::cudaMemcpyKind 
#line 958
kind = cudaMemcpyDeviceToHost, ::cudaStream_t 
#line 959
stream = 0) 
#line 961
{ 
#line 962
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
#line 963
} 
#line 1021
template< class T> static __inline ::cudaError_t 
#line 1022
cudaGraphAddMemcpyNodeToSymbol(::cudaGraphNode_t *
#line 1023
pGraphNode, ::cudaGraph_t 
#line 1024
graph, const ::cudaGraphNode_t *
#line 1025
pDependencies, ::size_t 
#line 1026
numDependencies, const T &
#line 1027
symbol, const void *
#line 1028
src, ::size_t 
#line 1029
count, ::size_t 
#line 1030
offset, ::cudaMemcpyKind 
#line 1031
kind) 
#line 1032
{ 
#line 1033
return ::cudaGraphAddMemcpyNodeToSymbol(pGraphNode, graph, pDependencies, numDependencies, (const void *)(&symbol), src, count, offset, kind); 
#line 1034
} 
#line 1092
template< class T> static __inline ::cudaError_t 
#line 1093
cudaGraphAddMemcpyNodeFromSymbol(::cudaGraphNode_t *
#line 1094
pGraphNode, ::cudaGraph_t 
#line 1095
graph, const ::cudaGraphNode_t *
#line 1096
pDependencies, ::size_t 
#line 1097
numDependencies, void *
#line 1098
dst, const T &
#line 1099
symbol, ::size_t 
#line 1100
count, ::size_t 
#line 1101
offset, ::cudaMemcpyKind 
#line 1102
kind) 
#line 1103
{ 
#line 1104
return ::cudaGraphAddMemcpyNodeFromSymbol(pGraphNode, graph, pDependencies, numDependencies, dst, (const void *)(&symbol), count, offset, kind); 
#line 1105
} 
#line 1143
template< class T> static __inline ::cudaError_t 
#line 1144
cudaGraphMemcpyNodeSetParamsToSymbol(::cudaGraphNode_t 
#line 1145
node, const T &
#line 1146
symbol, const void *
#line 1147
src, ::size_t 
#line 1148
count, ::size_t 
#line 1149
offset, ::cudaMemcpyKind 
#line 1150
kind) 
#line 1151
{ 
#line 1152
return ::cudaGraphMemcpyNodeSetParamsToSymbol(node, (const void *)(&symbol), src, count, offset, kind); 
#line 1153
} 
#line 1191
template< class T> static __inline ::cudaError_t 
#line 1192
cudaGraphMemcpyNodeSetParamsFromSymbol(::cudaGraphNode_t 
#line 1193
node, void *
#line 1194
dst, const T &
#line 1195
symbol, ::size_t 
#line 1196
count, ::size_t 
#line 1197
offset, ::cudaMemcpyKind 
#line 1198
kind) 
#line 1199
{ 
#line 1200
return ::cudaGraphMemcpyNodeSetParamsFromSymbol(node, dst, (const void *)(&symbol), count, offset, kind); 
#line 1201
} 
#line 1249
template< class T> static __inline ::cudaError_t 
#line 1250
cudaGraphExecMemcpyNodeSetParamsToSymbol(::cudaGraphExec_t 
#line 1251
hGraphExec, ::cudaGraphNode_t 
#line 1252
node, const T &
#line 1253
symbol, const void *
#line 1254
src, ::size_t 
#line 1255
count, ::size_t 
#line 1256
offset, ::cudaMemcpyKind 
#line 1257
kind) 
#line 1258
{ 
#line 1259
return ::cudaGraphExecMemcpyNodeSetParamsToSymbol(hGraphExec, node, (const void *)(&symbol), src, count, offset, kind); 
#line 1260
} 
#line 1308
template< class T> static __inline ::cudaError_t 
#line 1309
cudaGraphExecMemcpyNodeSetParamsFromSymbol(::cudaGraphExec_t 
#line 1310
hGraphExec, ::cudaGraphNode_t 
#line 1311
node, void *
#line 1312
dst, const T &
#line 1313
symbol, ::size_t 
#line 1314
count, ::size_t 
#line 1315
offset, ::cudaMemcpyKind 
#line 1316
kind) 
#line 1317
{ 
#line 1318
return ::cudaGraphExecMemcpyNodeSetParamsFromSymbol(hGraphExec, node, dst, (const void *)(&symbol), count, offset, kind); 
#line 1319
} 
#line 1397 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 1398
cudaGetSymbolAddress(void **
#line 1399
devPtr, const T &
#line 1400
symbol) 
#line 1402
{ 
#line 1403
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
#line 1404
} 
#line 1429
template< class T> static __inline ::cudaError_t 
#line 1430
cudaGetSymbolSize(::size_t *
#line 1431
size, const T &
#line 1432
symbol) 
#line 1434
{ 
#line 1435
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
#line 1436
} 
#line 1473
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1474
__declspec(deprecated) static __inline ::cudaError_t cudaBindTexture(::size_t *
#line 1475
offset, const texture< T, dim, readMode>  &
#line 1476
tex, const void *
#line 1477
devPtr, const ::cudaChannelFormatDesc &
#line 1478
desc, ::size_t 
#line 1479
size = 4294967295U) 
#line 1481
{ 
#line 1482
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
#line 1483
} 
#line 1519
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1520
__declspec(deprecated) static __inline ::cudaError_t cudaBindTexture(::size_t *
#line 1521
offset, const texture< T, dim, readMode>  &
#line 1522
tex, const void *
#line 1523
devPtr, ::size_t 
#line 1524
size = 4294967295U) 
#line 1526
{ 
#line 1527
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
#line 1528
} 
#line 1576
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1577
__declspec(deprecated) static __inline ::cudaError_t cudaBindTexture2D(::size_t *
#line 1578
offset, const texture< T, dim, readMode>  &
#line 1579
tex, const void *
#line 1580
devPtr, const ::cudaChannelFormatDesc &
#line 1581
desc, ::size_t 
#line 1582
width, ::size_t 
#line 1583
height, ::size_t 
#line 1584
pitch) 
#line 1586
{ 
#line 1587
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
#line 1588
} 
#line 1635
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1636
__declspec(deprecated) static __inline ::cudaError_t cudaBindTexture2D(::size_t *
#line 1637
offset, const texture< T, dim, readMode>  &
#line 1638
tex, const void *
#line 1639
devPtr, ::size_t 
#line 1640
width, ::size_t 
#line 1641
height, ::size_t 
#line 1642
pitch) 
#line 1644
{ 
#line 1645
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
#line 1646
} 
#line 1678
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1679
__declspec(deprecated) static __inline ::cudaError_t cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 1680
tex, ::cudaArray_const_t 
#line 1681
array, const ::cudaChannelFormatDesc &
#line 1682
desc) 
#line 1684
{ 
#line 1685
return ::cudaBindTextureToArray(&tex, array, &desc); 
#line 1686
} 
#line 1717
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1718
__declspec(deprecated) static __inline ::cudaError_t cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 1719
tex, ::cudaArray_const_t 
#line 1720
array) 
#line 1722
{ 
#line 1723
::cudaChannelFormatDesc desc; 
#line 1724
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 1726
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
#line 1727
} 
#line 1759
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1760
__declspec(deprecated) static __inline ::cudaError_t cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1761
tex, ::cudaMipmappedArray_const_t 
#line 1762
mipmappedArray, const ::cudaChannelFormatDesc &
#line 1763
desc) 
#line 1765
{ 
#line 1766
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
#line 1767
} 
#line 1798
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1799
__declspec(deprecated) static __inline ::cudaError_t cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1800
tex, ::cudaMipmappedArray_const_t 
#line 1801
mipmappedArray) 
#line 1803
{ 
#line 1804
::cudaChannelFormatDesc desc; 
#line 1805
::cudaArray_t levelArray; 
#line 1806
::cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
#line 1808
if (err != (cudaSuccess)) { 
#line 1809
return err; 
#line 1810
}  
#line 1811
err = ::cudaGetChannelDesc(&desc, levelArray); 
#line 1813
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
#line 1814
} 
#line 1841
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1842
__declspec(deprecated) static __inline ::cudaError_t cudaUnbindTexture(const texture< T, dim, readMode>  &
#line 1843
tex) 
#line 1845
{ 
#line 1846
return ::cudaUnbindTexture(&tex); 
#line 1847
} 
#line 1877
template< class T, int dim, cudaTextureReadMode readMode> 
#line 1878
__declspec(deprecated) static __inline ::cudaError_t cudaGetTextureAlignmentOffset(::size_t *
#line 1879
offset, const texture< T, dim, readMode>  &
#line 1880
tex) 
#line 1882
{ 
#line 1883
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
#line 1884
} 
#line 1929
template< class T> static __inline ::cudaError_t 
#line 1930
cudaFuncSetCacheConfig(T *
#line 1931
func, ::cudaFuncCache 
#line 1932
cacheConfig) 
#line 1934
{ 
#line 1935
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
#line 1936
} 
#line 1938
template< class T> static __inline ::cudaError_t 
#line 1939
cudaFuncSetSharedMemConfig(T *
#line 1940
func, ::cudaSharedMemConfig 
#line 1941
config) 
#line 1943
{ 
#line 1944
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
#line 1945
} 
#line 1977 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
template< class T> __inline ::cudaError_t 
#line 1978
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
#line 1979
numBlocks, T 
#line 1980
func, int 
#line 1981
blockSize, ::size_t 
#line 1982
dynamicSMemSize) 
#line 1983
{ 
#line 1984
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
#line 1985
} 
#line 2029
template< class T> __inline ::cudaError_t 
#line 2030
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
#line 2031
numBlocks, T 
#line 2032
func, int 
#line 2033
blockSize, ::size_t 
#line 2034
dynamicSMemSize, unsigned 
#line 2035
flags) 
#line 2036
{ 
#line 2037
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
#line 2038
} 
#line 2043
class __cudaOccupancyB2DHelper { 
#line 2044
size_t n; 
#line 2046
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
#line 2047
size_t operator()(int) 
#line 2048
{ 
#line 2049
return n; 
#line 2050
} 
#line 2051
}; 
#line 2099
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 2100
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
#line 2101
minGridSize, int *
#line 2102
blockSize, T 
#line 2103
func, UnaryFunction 
#line 2104
blockSizeToDynamicSMemSize, int 
#line 2105
blockSizeLimit = 0, unsigned 
#line 2106
flags = 0) 
#line 2107
{ 
#line 2108
::cudaError_t status; 
#line 2111
int device; 
#line 2112
::cudaFuncAttributes attr; 
#line 2115
int maxThreadsPerMultiProcessor; 
#line 2116
int warpSize; 
#line 2117
int devMaxThreadsPerBlock; 
#line 2118
int multiProcessorCount; 
#line 2119
int funcMaxThreadsPerBlock; 
#line 2120
int occupancyLimit; 
#line 2121
int granularity; 
#line 2124
int maxBlockSize = 0; 
#line 2125
int numBlocks = 0; 
#line 2126
int maxOccupancy = 0; 
#line 2129
int blockSizeToTryAligned; 
#line 2130
int blockSizeToTry; 
#line 2131
int blockSizeLimitAligned; 
#line 2132
int occupancyInBlocks; 
#line 2133
int occupancyInThreads; 
#line 2134
::size_t dynamicSMemSize; 
#line 2140
if (((!minGridSize) || (!blockSize)) || (!func)) { 
#line 2141
return cudaErrorInvalidValue; 
#line 2142
}  
#line 2148
status = ::cudaGetDevice(&device); 
#line 2149
if (status != (cudaSuccess)) { 
#line 2150
return status; 
#line 2151
}  
#line 2153
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
#line 2157
if (status != (cudaSuccess)) { 
#line 2158
return status; 
#line 2159
}  
#line 2161
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
#line 2165
if (status != (cudaSuccess)) { 
#line 2166
return status; 
#line 2167
}  
#line 2169
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
#line 2173
if (status != (cudaSuccess)) { 
#line 2174
return status; 
#line 2175
}  
#line 2177
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
#line 2181
if (status != (cudaSuccess)) { 
#line 2182
return status; 
#line 2183
}  
#line 2185
status = cudaFuncGetAttributes(&attr, func); 
#line 2186
if (status != (cudaSuccess)) { 
#line 2187
return status; 
#line 2188
}  
#line 2190
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
#line 2196
occupancyLimit = maxThreadsPerMultiProcessor; 
#line 2197
granularity = warpSize; 
#line 2199
if (blockSizeLimit == 0) { 
#line 2200
blockSizeLimit = devMaxThreadsPerBlock; 
#line 2201
}  
#line 2203
if (devMaxThreadsPerBlock < blockSizeLimit) { 
#line 2204
blockSizeLimit = devMaxThreadsPerBlock; 
#line 2205
}  
#line 2207
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
#line 2208
blockSizeLimit = funcMaxThreadsPerBlock; 
#line 2209
}  
#line 2211
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
#line 2213
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
#line 2217
if (blockSizeLimit < blockSizeToTryAligned) { 
#line 2218
blockSizeToTry = blockSizeLimit; 
#line 2219
} else { 
#line 2220
blockSizeToTry = blockSizeToTryAligned; 
#line 2221
}  
#line 2223
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
#line 2225
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
#line 2232
if (status != (cudaSuccess)) { 
#line 2233
return status; 
#line 2234
}  
#line 2236
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
#line 2238
if (occupancyInThreads > maxOccupancy) { 
#line 2239
maxBlockSize = blockSizeToTry; 
#line 2240
numBlocks = occupancyInBlocks; 
#line 2241
maxOccupancy = occupancyInThreads; 
#line 2242
}  
#line 2246
if (occupancyLimit == maxOccupancy) { 
#line 2247
break; 
#line 2248
}  
#line 2249
}  
#line 2257
(*minGridSize) = (numBlocks * multiProcessorCount); 
#line 2258
(*blockSize) = maxBlockSize; 
#line 2260
return status; 
#line 2261
} 
#line 2295
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 2296
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
#line 2297
minGridSize, int *
#line 2298
blockSize, T 
#line 2299
func, UnaryFunction 
#line 2300
blockSizeToDynamicSMemSize, int 
#line 2301
blockSizeLimit = 0) 
#line 2302
{ 
#line 2303
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
#line 2304
} 
#line 2341
template< class T> static __inline ::cudaError_t 
#line 2342
cudaOccupancyMaxPotentialBlockSize(int *
#line 2343
minGridSize, int *
#line 2344
blockSize, T 
#line 2345
func, ::size_t 
#line 2346
dynamicSMemSize = 0, int 
#line 2347
blockSizeLimit = 0) 
#line 2348
{ 
#line 2349
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
#line 2350
} 
#line 2379
template< class T> static __inline ::cudaError_t 
#line 2380
cudaOccupancyAvailableDynamicSMemPerBlock(::size_t *
#line 2381
dynamicSmemSize, T 
#line 2382
func, int 
#line 2383
numBlocks, int 
#line 2384
blockSize) 
#line 2385
{ 
#line 2386
return ::cudaOccupancyAvailableDynamicSMemPerBlock(dynamicSmemSize, (const void *)func, numBlocks, blockSize); 
#line 2387
} 
#line 2438
template< class T> static __inline ::cudaError_t 
#line 2439
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
#line 2440
minGridSize, int *
#line 2441
blockSize, T 
#line 2442
func, ::size_t 
#line 2443
dynamicSMemSize = 0, int 
#line 2444
blockSizeLimit = 0, unsigned 
#line 2445
flags = 0) 
#line 2446
{ 
#line 2447
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
#line 2448
} 
#line 2482
template< class T> static __inline ::cudaError_t 
#line 2483
cudaOccupancyMaxPotentialClusterSize(int *
#line 2484
clusterSize, T *
#line 2485
func, const ::cudaLaunchConfig_t *
#line 2486
config) 
#line 2487
{ 
#line 2488
return ::cudaOccupancyMaxPotentialClusterSize(clusterSize, (const void *)func, config); 
#line 2489
} 
#line 2525
template< class T> static __inline ::cudaError_t 
#line 2526
cudaOccupancyMaxActiveClusters(int *
#line 2527
numClusters, T *
#line 2528
func, const ::cudaLaunchConfig_t *
#line 2529
config) 
#line 2530
{ 
#line 2531
return ::cudaOccupancyMaxActiveClusters(numClusters, (const void *)func, config); 
#line 2532
} 
#line 2565
template< class T> __inline ::cudaError_t 
#line 2566
cudaFuncGetAttributes(::cudaFuncAttributes *
#line 2567
attr, T *
#line 2568
entry) 
#line 2570
{ 
#line 2571
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
#line 2572
} 
#line 2627
template< class T> static __inline ::cudaError_t 
#line 2628
cudaFuncSetAttribute(T *
#line 2629
entry, ::cudaFuncAttribute 
#line 2630
attr, int 
#line 2631
value) 
#line 2633
{ 
#line 2634
return ::cudaFuncSetAttribute((const void *)entry, attr, value); 
#line 2635
} 
#line 2659
template< class T, int dim> 
#line 2660
__declspec(deprecated) static __inline ::cudaError_t cudaBindSurfaceToArray(const surface< T, dim>  &
#line 2661
surf, ::cudaArray_const_t 
#line 2662
array, const ::cudaChannelFormatDesc &
#line 2663
desc) 
#line 2665
{ 
#line 2666
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
#line 2667
} 
#line 2690
template< class T, int dim> 
#line 2691
__declspec(deprecated) static __inline ::cudaError_t cudaBindSurfaceToArray(const surface< T, dim>  &
#line 2692
surf, ::cudaArray_const_t 
#line 2693
array) 
#line 2695
{ 
#line 2696
::cudaChannelFormatDesc desc; 
#line 2697
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 2699
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
#line 2700
} 
#line 2714 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#pragma warning(pop)
#line 57 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
typedef unsigned cuuint32_t; 
#line 58
typedef unsigned __int64 cuuint64_t; 
#line 238 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
extern "C" {
#line 246 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
typedef unsigned __int64 CUdeviceptr_v2; 
#line 250 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
typedef CUdeviceptr_v2 CUdeviceptr; 
#line 252
typedef int CUdevice_v1; 
#line 253
typedef CUdevice_v1 CUdevice; 
#line 254
typedef struct CUctx_st *CUcontext; 
#line 255
typedef struct CUmod_st *CUmodule; 
#line 256
typedef CUfunc_st *CUfunction; 
#line 257
typedef struct CUarray_st *CUarray; 
#line 258
typedef struct CUmipmappedArray_st *CUmipmappedArray; 
#line 259
typedef struct CUtexref_st *CUtexref; 
#line 260
typedef struct CUsurfref_st *CUsurfref; 
#line 261
typedef CUevent_st *CUevent; 
#line 262
typedef CUstream_st *CUstream; 
#line 263
typedef struct CUgraphicsResource_st *CUgraphicsResource; 
#line 264
typedef unsigned __int64 CUtexObject_v1; 
#line 265
typedef CUtexObject_v1 CUtexObject; 
#line 266
typedef unsigned __int64 CUsurfObject_v1; 
#line 267
typedef CUsurfObject_v1 CUsurfObject; 
#line 268
typedef struct CUextMemory_st *CUexternalMemory; 
#line 269
typedef struct CUextSemaphore_st *CUexternalSemaphore; 
#line 270
typedef CUgraph_st *CUgraph; 
#line 271
typedef CUgraphNode_st *CUgraphNode; 
#line 272
typedef CUgraphExec_st *CUgraphExec; 
#line 273
typedef CUmemPoolHandle_st *CUmemoryPool; 
#line 274
typedef CUuserObject_st *CUuserObject; 
#line 293
typedef 
#line 291
struct CUipcEventHandle_st { 
#line 292
char reserved[64]; 
#line 293
} CUipcEventHandle_v1; 
#line 294
typedef CUipcEventHandle_v1 CUipcEventHandle; 
#line 301
typedef 
#line 299
struct CUipcMemHandle_st { 
#line 300
char reserved[64]; 
#line 301
} CUipcMemHandle_v1; 
#line 302
typedef CUipcMemHandle_v1 CUipcMemHandle; 
#line 309
typedef 
#line 307
enum CUipcMem_flags_enum { 
#line 308
CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1
#line 309
} CUipcMem_flags; 
#line 319
typedef 
#line 315
enum CUmemAttach_flags_enum { 
#line 316
CU_MEM_ATTACH_GLOBAL = 1, 
#line 317
CU_MEM_ATTACH_HOST, 
#line 318
CU_MEM_ATTACH_SINGLE = 4
#line 319
} CUmemAttach_flags; 
#line 338
typedef 
#line 324
enum CUctx_flags_enum { 
#line 325
CU_CTX_SCHED_AUTO, 
#line 326
CU_CTX_SCHED_SPIN, 
#line 327
CU_CTX_SCHED_YIELD, 
#line 328
CU_CTX_SCHED_BLOCKING_SYNC = 4, 
#line 329
CU_CTX_BLOCKING_SYNC = 4, 
#line 332
CU_CTX_SCHED_MASK = 7, 
#line 333
CU_CTX_MAP_HOST, 
#line 336
CU_CTX_LMEM_RESIZE_TO_MAX = 16, 
#line 337
CU_CTX_FLAGS_MASK = 31
#line 338
} CUctx_flags; 
#line 348
typedef 
#line 343
enum CUevent_sched_flags_enum { 
#line 344
CU_EVENT_SCHED_AUTO, 
#line 345
CU_EVENT_SCHED_SPIN, 
#line 346
CU_EVENT_SCHED_YIELD, 
#line 347
CU_EVENT_SCHED_BLOCKING_SYNC = 4
#line 348
} CUevent_sched_flags; 
#line 358
typedef 
#line 353
enum cl_event_flags_enum { 
#line 354
NVCL_EVENT_SCHED_AUTO, 
#line 355
NVCL_EVENT_SCHED_SPIN, 
#line 356
NVCL_EVENT_SCHED_YIELD, 
#line 357
NVCL_EVENT_SCHED_BLOCKING_SYNC = 4
#line 358
} cl_event_flags; 
#line 368
typedef 
#line 363
enum cl_context_flags_enum { 
#line 364
NVCL_CTX_SCHED_AUTO, 
#line 365
NVCL_CTX_SCHED_SPIN, 
#line 366
NVCL_CTX_SCHED_YIELD, 
#line 367
NVCL_CTX_SCHED_BLOCKING_SYNC = 4
#line 368
} cl_context_flags; 
#line 377
typedef 
#line 374
enum CUstream_flags_enum { 
#line 375
CU_STREAM_DEFAULT, 
#line 376
CU_STREAM_NON_BLOCKING
#line 377
} CUstream_flags; 
#line 407
typedef 
#line 402
enum CUevent_flags_enum { 
#line 403
CU_EVENT_DEFAULT, 
#line 404
CU_EVENT_BLOCKING_SYNC, 
#line 405
CU_EVENT_DISABLE_TIMING, 
#line 406
CU_EVENT_INTERPROCESS = 4
#line 407
} CUevent_flags; 
#line 417
typedef 
#line 412
enum CUevent_record_flags_enum { 
#line 413
CU_EVENT_RECORD_DEFAULT, 
#line 414
CU_EVENT_RECORD_EXTERNAL
#line 417
} CUevent_record_flags; 
#line 427
typedef 
#line 422
enum CUevent_wait_flags_enum { 
#line 423
CU_EVENT_WAIT_DEFAULT, 
#line 424
CU_EVENT_WAIT_EXTERNAL
#line 427
} CUevent_wait_flags; 
#line 450
typedef 
#line 432
enum CUstreamWaitValue_flags_enum { 
#line 433
CU_STREAM_WAIT_VALUE_GEQ, 
#line 436
CU_STREAM_WAIT_VALUE_EQ, 
#line 437
CU_STREAM_WAIT_VALUE_AND, 
#line 438
CU_STREAM_WAIT_VALUE_NOR, 
#line 441
CU_STREAM_WAIT_VALUE_FLUSH = (1 << 30)
#line 450
} CUstreamWaitValue_flags; 
#line 464
typedef 
#line 455
enum CUstreamWriteValue_flags_enum { 
#line 456
CU_STREAM_WRITE_VALUE_DEFAULT, 
#line 457
CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER
#line 464
} CUstreamWriteValue_flags; 
#line 477
typedef 
#line 469
enum CUstreamBatchMemOpType_enum { 
#line 470
CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1, 
#line 471
CU_STREAM_MEM_OP_WRITE_VALUE_32, 
#line 472
CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4, 
#line 473
CU_STREAM_MEM_OP_WRITE_VALUE_64, 
#line 474
CU_STREAM_MEM_OP_BARRIER, 
#line 475
CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3
#line 477
} CUstreamBatchMemOpType; 
#line 485
typedef 
#line 482
enum CUstreamMemoryBarrier_flags_enum { 
#line 483
CU_STREAM_MEMORY_BARRIER_TYPE_SYS, 
#line 484
CU_STREAM_MEMORY_BARRIER_TYPE_GPU
#line 485
} CUstreamMemoryBarrier_flags; 
#line 521
typedef 
#line 490
union CUstreamBatchMemOpParams_union { 
#line 491
CUstreamBatchMemOpType operation; 
#line 492
struct CUstreamMemOpWaitValueParams_st { 
#line 493
CUstreamBatchMemOpType operation; 
#line 494
CUdeviceptr address; 
#line 495
union { 
#line 496
cuuint32_t value; 
#line 497
cuuint64_t value64; 
#line 498
}; 
#line 499
unsigned flags; 
#line 500
CUdeviceptr alias; 
#line 501
} waitValue; 
#line 502
struct CUstreamMemOpWriteValueParams_st { 
#line 503
CUstreamBatchMemOpType operation; 
#line 504
CUdeviceptr address; 
#line 505
union { 
#line 506
cuuint32_t value; 
#line 507
cuuint64_t value64; 
#line 508
}; 
#line 509
unsigned flags; 
#line 510
CUdeviceptr alias; 
#line 511
} writeValue; 
#line 512
struct CUstreamMemOpFlushRemoteWritesParams_st { 
#line 513
CUstreamBatchMemOpType operation; 
#line 514
unsigned flags; 
#line 515
} flushRemoteWrites; 
#line 516
struct CUstreamMemOpMemoryBarrierParams_st { 
#line 517
CUstreamBatchMemOpType operation; 
#line 518
unsigned flags; 
#line 519
} memoryBarrier; 
#line 520
cuuint64_t pad[6]; 
#line 521
} CUstreamBatchMemOpParams_v1; 
#line 522
typedef CUstreamBatchMemOpParams_v1 CUstreamBatchMemOpParams; 
#line 529
typedef 
#line 524
struct CUDA_BATCH_MEM_OP_NODE_PARAMS_st { 
#line 525
CUcontext ctx; 
#line 526
unsigned count; 
#line 527
CUstreamBatchMemOpParams *paramArray; 
#line 528
unsigned flags; 
#line 529
} CUDA_BATCH_MEM_OP_NODE_PARAMS; 
#line 537
typedef 
#line 534
enum CUoccupancy_flags_enum { 
#line 535
CU_OCCUPANCY_DEFAULT, 
#line 536
CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE
#line 537
} CUoccupancy_flags; 
#line 545
typedef 
#line 542
enum CUstreamUpdateCaptureDependencies_flags_enum { 
#line 543
CU_STREAM_ADD_CAPTURE_DEPENDENCIES, 
#line 544
CU_STREAM_SET_CAPTURE_DEPENDENCIES
#line 545
} CUstreamUpdateCaptureDependencies_flags; 
#line 586
typedef 
#line 550
enum CUarray_format_enum { 
#line 551
CU_AD_FORMAT_UNSIGNED_INT8 = 1, 
#line 552
CU_AD_FORMAT_UNSIGNED_INT16, 
#line 553
CU_AD_FORMAT_UNSIGNED_INT32, 
#line 554
CU_AD_FORMAT_SIGNED_INT8 = 8, 
#line 555
CU_AD_FORMAT_SIGNED_INT16, 
#line 556
CU_AD_FORMAT_SIGNED_INT32, 
#line 557
CU_AD_FORMAT_HALF = 16, 
#line 558
CU_AD_FORMAT_FLOAT = 32, 
#line 559
CU_AD_FORMAT_NV12 = 176, 
#line 560
CU_AD_FORMAT_UNORM_INT8X1 = 192, 
#line 561
CU_AD_FORMAT_UNORM_INT8X2, 
#line 562
CU_AD_FORMAT_UNORM_INT8X4, 
#line 563
CU_AD_FORMAT_UNORM_INT16X1, 
#line 564
CU_AD_FORMAT_UNORM_INT16X2, 
#line 565
CU_AD_FORMAT_UNORM_INT16X4, 
#line 566
CU_AD_FORMAT_SNORM_INT8X1, 
#line 567
CU_AD_FORMAT_SNORM_INT8X2, 
#line 568
CU_AD_FORMAT_SNORM_INT8X4, 
#line 569
CU_AD_FORMAT_SNORM_INT16X1, 
#line 570
CU_AD_FORMAT_SNORM_INT16X2, 
#line 571
CU_AD_FORMAT_SNORM_INT16X4, 
#line 572
CU_AD_FORMAT_BC1_UNORM = 145, 
#line 573
CU_AD_FORMAT_BC1_UNORM_SRGB, 
#line 574
CU_AD_FORMAT_BC2_UNORM, 
#line 575
CU_AD_FORMAT_BC2_UNORM_SRGB, 
#line 576
CU_AD_FORMAT_BC3_UNORM, 
#line 577
CU_AD_FORMAT_BC3_UNORM_SRGB, 
#line 578
CU_AD_FORMAT_BC4_UNORM, 
#line 579
CU_AD_FORMAT_BC4_SNORM, 
#line 580
CU_AD_FORMAT_BC5_UNORM, 
#line 581
CU_AD_FORMAT_BC5_SNORM, 
#line 582
CU_AD_FORMAT_BC6H_UF16, 
#line 583
CU_AD_FORMAT_BC6H_SF16, 
#line 584
CU_AD_FORMAT_BC7_UNORM, 
#line 585
CU_AD_FORMAT_BC7_UNORM_SRGB
#line 586
} CUarray_format; 
#line 596
typedef 
#line 591
enum CUaddress_mode_enum { 
#line 592
CU_TR_ADDRESS_MODE_WRAP, 
#line 593
CU_TR_ADDRESS_MODE_CLAMP, 
#line 594
CU_TR_ADDRESS_MODE_MIRROR, 
#line 595
CU_TR_ADDRESS_MODE_BORDER
#line 596
} CUaddress_mode; 
#line 604
typedef 
#line 601
enum CUfilter_mode_enum { 
#line 602
CU_TR_FILTER_MODE_POINT, 
#line 603
CU_TR_FILTER_MODE_LINEAR
#line 604
} CUfilter_mode; 
#line 741
typedef 
#line 609
enum CUdevice_attribute_enum { 
#line 610
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1, 
#line 611
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X, 
#line 612
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y, 
#line 613
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z, 
#line 614
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X, 
#line 615
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y, 
#line 616
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z, 
#line 617
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK, 
#line 618
CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8, 
#line 619
CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY, 
#line 620
CU_DEVICE_ATTRIBUTE_WARP_SIZE, 
#line 621
CU_DEVICE_ATTRIBUTE_MAX_PITCH, 
#line 622
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, 
#line 623
CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12, 
#line 624
CU_DEVICE_ATTRIBUTE_CLOCK_RATE, 
#line 625
CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT, 
#line 626
CU_DEVICE_ATTRIBUTE_GPU_OVERLAP, 
#line 627
CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, 
#line 628
CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT, 
#line 629
CU_DEVICE_ATTRIBUTE_INTEGRATED, 
#line 630
CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, 
#line 631
CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, 
#line 632
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH, 
#line 633
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH, 
#line 634
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT, 
#line 635
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH, 
#line 636
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT, 
#line 637
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH, 
#line 638
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH, 
#line 639
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT, 
#line 640
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS, 
#line 641
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27, 
#line 642
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT, 
#line 643
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES, 
#line 644
CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT, 
#line 645
CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS, 
#line 646
CU_DEVICE_ATTRIBUTE_ECC_ENABLED, 
#line 647
CU_DEVICE_ATTRIBUTE_PCI_BUS_ID, 
#line 648
CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID, 
#line 649
CU_DEVICE_ATTRIBUTE_TCC_DRIVER, 
#line 650
CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, 
#line 651
CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH, 
#line 652
CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE, 
#line 653
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR, 
#line 654
CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, 
#line 655
CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING, 
#line 656
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH, 
#line 657
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS, 
#line 658
CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER, 
#line 659
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH, 
#line 660
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT, 
#line 661
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE, 
#line 662
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE, 
#line 663
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE, 
#line 664
CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID, 
#line 665
CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT, 
#line 666
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH, 
#line 667
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH, 
#line 668
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS, 
#line 669
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH, 
#line 670
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH, 
#line 671
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT, 
#line 672
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH, 
#line 673
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT, 
#line 674
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH, 
#line 675
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH, 
#line 676
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS, 
#line 677
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH, 
#line 678
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT, 
#line 679
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS, 
#line 680
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH, 
#line 681
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH, 
#line 682
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS, 
#line 683
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH, 
#line 684
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH, 
#line 685
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT, 
#line 686
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH, 
#line 687
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH, 
#line 688
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT, 
#line 689
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, 
#line 690
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, 
#line 691
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH, 
#line 692
CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED, 
#line 693
CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED, 
#line 694
CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED, 
#line 695
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR, 
#line 696
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR, 
#line 697
CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY, 
#line 698
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD, 
#line 699
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID, 
#line 700
CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED, 
#line 701
CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO, 
#line 702
CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS, 
#line 703
CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS, 
#line 704
CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED, 
#line 705
CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM, 
#line 706
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS, 
#line 707
CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS, 
#line 708
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR, 
#line 709
CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH, 
#line 710
CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH, 
#line 711
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN, 
#line 712
CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES, 
#line 713
CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED, 
#line 714
CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES, 
#line 715
CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST, 
#line 716
CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED, 
#line 717
CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = 102, 
#line 718
CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED, 
#line 719
CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED, 
#line 720
CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED, 
#line 721
CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR, 
#line 722
CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED, 
#line 723
CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE, 
#line 724
CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE, 
#line 725
CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED, 
#line 726
CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK, 
#line 727
CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED, 
#line 728
CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED, 
#line 729
CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED, 
#line 730
CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED, 
#line 731
CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED, 
#line 732
CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS, 
#line 733
CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING, 
#line 734
CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES, 
#line 735
CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH, 
#line 736
CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED, 
#line 737
CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V2, 
#line 738
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2, 
#line 739
CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED, 
#line 740
CU_DEVICE_ATTRIBUTE_MAX
#line 741
} CUdevice_attribute; 
#line 757
typedef 
#line 746
struct CUdevprop_st { 
#line 747
int maxThreadsPerBlock; 
#line 748
int maxThreadsDim[3]; 
#line 749
int maxGridSize[3]; 
#line 750
int sharedMemPerBlock; 
#line 751
int totalConstantMemory; 
#line 752
int SIMDWidth; 
#line 753
int memPitch; 
#line 754
int regsPerBlock; 
#line 755
int clockRate; 
#line 756
int textureAlign; 
#line 757
} CUdevprop_v1; 
#line 758
typedef CUdevprop_v1 CUdevprop; 
#line 785
typedef 
#line 763
enum CUpointer_attribute_enum { 
#line 764
CU_POINTER_ATTRIBUTE_CONTEXT = 1, 
#line 765
CU_POINTER_ATTRIBUTE_MEMORY_TYPE, 
#line 766
CU_POINTER_ATTRIBUTE_DEVICE_POINTER, 
#line 767
CU_POINTER_ATTRIBUTE_HOST_POINTER, 
#line 768
CU_POINTER_ATTRIBUTE_P2P_TOKENS, 
#line 769
CU_POINTER_ATTRIBUTE_SYNC_MEMOPS, 
#line 770
CU_POINTER_ATTRIBUTE_BUFFER_ID, 
#line 771
CU_POINTER_ATTRIBUTE_IS_MANAGED, 
#line 772
CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL, 
#line 773
CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE, 
#line 774
CU_POINTER_ATTRIBUTE_RANGE_START_ADDR, 
#line 775
CU_POINTER_ATTRIBUTE_RANGE_SIZE, 
#line 776
CU_POINTER_ATTRIBUTE_MAPPED, 
#line 777
CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES, 
#line 778
CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE, 
#line 779
CU_POINTER_ATTRIBUTE_ACCESS_FLAGS, 
#line 780
CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE, 
#line 782
CU_POINTER_ATTRIBUTE_MAPPING_SIZE, 
#line 783
CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR, 
#line 784
CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID
#line 785
} CUpointer_attribute; 
#line 932
typedef 
#line 790
enum CUfunction_attribute_enum { 
#line 796
CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, 
#line 803
CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES, 
#line 809
CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES, 
#line 814
CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES, 
#line 819
CU_FUNC_ATTRIBUTE_NUM_REGS, 
#line 828
CU_FUNC_ATTRIBUTE_PTX_VERSION, 
#line 837
CU_FUNC_ATTRIBUTE_BINARY_VERSION, 
#line 843
CU_FUNC_ATTRIBUTE_CACHE_MODE_CA, 
#line 851
CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES, 
#line 860
CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT, 
#line 867
CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET, 
#line 878
CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH, 
#line 889
CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT, 
#line 900
CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH, 
#line 922
CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED, 
#line 929
CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE, 
#line 931
CU_FUNC_ATTRIBUTE_MAX
#line 932
} CUfunction_attribute; 
#line 942
typedef 
#line 937
enum CUfunc_cache_enum { 
#line 938
CU_FUNC_CACHE_PREFER_NONE, 
#line 939
CU_FUNC_CACHE_PREFER_SHARED, 
#line 940
CU_FUNC_CACHE_PREFER_L1, 
#line 941
CU_FUNC_CACHE_PREFER_EQUAL
#line 942
} CUfunc_cache; 
#line 951
typedef 
#line 947
enum CUsharedconfig_enum { 
#line 948
CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE, 
#line 949
CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE, 
#line 950
CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE
#line 951
} CUsharedconfig; 
#line 960
typedef 
#line 956
enum CUshared_carveout_enum { 
#line 957
CU_SHAREDMEM_CARVEOUT_DEFAULT = (-1), 
#line 958
CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100, 
#line 959
CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0
#line 960
} CUshared_carveout; 
#line 970
typedef 
#line 965
enum CUmemorytype_enum { 
#line 966
CU_MEMORYTYPE_HOST = 1, 
#line 967
CU_MEMORYTYPE_DEVICE, 
#line 968
CU_MEMORYTYPE_ARRAY, 
#line 969
CU_MEMORYTYPE_UNIFIED
#line 970
} CUmemorytype; 
#line 979
typedef 
#line 975
enum CUcomputemode_enum { 
#line 976
CU_COMPUTEMODE_DEFAULT, 
#line 977
CU_COMPUTEMODE_PROHIBITED = 2, 
#line 978
CU_COMPUTEMODE_EXCLUSIVE_PROCESS
#line 979
} CUcomputemode; 
#line 991
typedef 
#line 984
enum CUmem_advise_enum { 
#line 985
CU_MEM_ADVISE_SET_READ_MOSTLY = 1, 
#line 986
CU_MEM_ADVISE_UNSET_READ_MOSTLY, 
#line 987
CU_MEM_ADVISE_SET_PREFERRED_LOCATION, 
#line 988
CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION, 
#line 989
CU_MEM_ADVISE_SET_ACCESSED_BY, 
#line 990
CU_MEM_ADVISE_UNSET_ACCESSED_BY
#line 991
} CUmem_advise; 
#line 998
typedef 
#line 993
enum CUmem_range_attribute_enum { 
#line 994
CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1, 
#line 995
CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION, 
#line 996
CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY, 
#line 997
CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION
#line 998
} CUmem_range_attribute; 
#line 1284
typedef 
#line 1003
enum CUjit_option_enum { 
#line 1010
CU_JIT_MAX_REGISTERS, 
#line 1025
CU_JIT_THREADS_PER_BLOCK, 
#line 1033
CU_JIT_WALL_TIME, 
#line 1042
CU_JIT_INFO_LOG_BUFFER, 
#line 1051
CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES, 
#line 1060
CU_JIT_ERROR_LOG_BUFFER, 
#line 1069
CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES, 
#line 1077
CU_JIT_OPTIMIZATION_LEVEL, 
#line 1085
CU_JIT_TARGET_FROM_CUCONTEXT, 
#line 1093
CU_JIT_TARGET, 
#line 1102
CU_JIT_FALLBACK_STRATEGY, 
#line 1110
CU_JIT_GENERATE_DEBUG_INFO, 
#line 1117
CU_JIT_LOG_VERBOSE, 
#line 1124
CU_JIT_GENERATE_LINE_INFO, 
#line 1132
CU_JIT_CACHE_MODE, 
#line 1138
CU_JIT_NEW_SM3X_OPT, 
#line 1143
CU_JIT_FAST_COMPILE, 
#line 1157
CU_JIT_GLOBAL_SYMBOL_NAMES, 
#line 1166
CU_JIT_GLOBAL_SYMBOL_ADDRESSES, 
#line 1174
CU_JIT_GLOBAL_SYMBOL_COUNT, 
#line 1182
CU_JIT_LTO, 
#line 1191
CU_JIT_FTZ, 
#line 1201
CU_JIT_PREC_DIV, 
#line 1211
CU_JIT_PREC_SQRT, 
#line 1220
CU_JIT_FMA, 
#line 1237
CU_JIT_REFERENCED_KERNEL_NAMES, 
#line 1244
CU_JIT_REFERENCED_KERNEL_COUNT, 
#line 1261
CU_JIT_REFERENCED_VARIABLE_NAMES, 
#line 1268
CU_JIT_REFERENCED_VARIABLE_COUNT, 
#line 1280
CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES, 
#line 1282
CU_JIT_NUM_OPTIONS
#line 1284
} CUjit_option; 
#line 1311
typedef 
#line 1289
enum CUjit_target_enum { 
#line 1291
CU_TARGET_COMPUTE_20 = 20, 
#line 1292
CU_TARGET_COMPUTE_21, 
#line 1293
CU_TARGET_COMPUTE_30 = 30, 
#line 1294
CU_TARGET_COMPUTE_32 = 32, 
#line 1295
CU_TARGET_COMPUTE_35 = 35, 
#line 1296
CU_TARGET_COMPUTE_37 = 37, 
#line 1297
CU_TARGET_COMPUTE_50 = 50, 
#line 1298
CU_TARGET_COMPUTE_52 = 52, 
#line 1299
CU_TARGET_COMPUTE_53, 
#line 1300
CU_TARGET_COMPUTE_60 = 60, 
#line 1301
CU_TARGET_COMPUTE_61, 
#line 1302
CU_TARGET_COMPUTE_62, 
#line 1303
CU_TARGET_COMPUTE_70 = 70, 
#line 1304
CU_TARGET_COMPUTE_72 = 72, 
#line 1305
CU_TARGET_COMPUTE_75 = 75, 
#line 1306
CU_TARGET_COMPUTE_80 = 80, 
#line 1307
CU_TARGET_COMPUTE_86 = 86, 
#line 1308
CU_TARGET_COMPUTE_87, 
#line 1309
CU_TARGET_COMPUTE_89 = 89, 
#line 1310
CU_TARGET_COMPUTE_90
#line 1311
} CUjit_target; 
#line 1322
typedef 
#line 1316
enum CUjit_fallback_enum { 
#line 1318
CU_PREFER_PTX, 
#line 1320
CU_PREFER_BINARY
#line 1322
} CUjit_fallback; 
#line 1332
typedef 
#line 1327
enum CUjit_cacheMode_enum { 
#line 1329
CU_JIT_CACHE_OPTION_NONE, 
#line 1330
CU_JIT_CACHE_OPTION_CG, 
#line 1331
CU_JIT_CACHE_OPTION_CA
#line 1332
} CUjit_cacheMode; 
#line 1376
typedef 
#line 1337
enum CUjitInputType_enum { 
#line 1343
CU_JIT_INPUT_CUBIN, 
#line 1349
CU_JIT_INPUT_PTX, 
#line 1355
CU_JIT_INPUT_FATBINARY, 
#line 1361
CU_JIT_INPUT_OBJECT, 
#line 1367
CU_JIT_INPUT_LIBRARY, 
#line 1373
CU_JIT_INPUT_NVVM, 
#line 1375
CU_JIT_NUM_INPUT_TYPES
#line 1376
} CUjitInputType; 
#line 1378
typedef struct CUlinkState_st *CUlinkState; 
#line 1389
typedef 
#line 1383
enum CUgraphicsRegisterFlags_enum { 
#line 1384
CU_GRAPHICS_REGISTER_FLAGS_NONE, 
#line 1385
CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY, 
#line 1386
CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD, 
#line 1387
CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4, 
#line 1388
CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8
#line 1389
} CUgraphicsRegisterFlags; 
#line 1398
typedef 
#line 1394
enum CUgraphicsMapResourceFlags_enum { 
#line 1395
CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE, 
#line 1396
CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY, 
#line 1397
CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD
#line 1398
} CUgraphicsMapResourceFlags; 
#line 1410
typedef 
#line 1403
enum CUarray_cubemap_face_enum { 
#line 1404
CU_CUBEMAP_FACE_POSITIVE_X, 
#line 1405
CU_CUBEMAP_FACE_NEGATIVE_X, 
#line 1406
CU_CUBEMAP_FACE_POSITIVE_Y, 
#line 1407
CU_CUBEMAP_FACE_NEGATIVE_Y, 
#line 1408
CU_CUBEMAP_FACE_POSITIVE_Z, 
#line 1409
CU_CUBEMAP_FACE_NEGATIVE_Z
#line 1410
} CUarray_cubemap_face; 
#line 1424
typedef 
#line 1415
enum CUlimit_enum { 
#line 1416
CU_LIMIT_STACK_SIZE, 
#line 1417
CU_LIMIT_PRINTF_FIFO_SIZE, 
#line 1418
CU_LIMIT_MALLOC_HEAP_SIZE, 
#line 1419
CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH, 
#line 1420
CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT, 
#line 1421
CU_LIMIT_MAX_L2_FETCH_GRANULARITY, 
#line 1422
CU_LIMIT_PERSISTING_L2_CACHE_SIZE, 
#line 1423
CU_LIMIT_MAX
#line 1424
} CUlimit; 
#line 1434
typedef 
#line 1429
enum CUresourcetype_enum { 
#line 1430
CU_RESOURCE_TYPE_ARRAY, 
#line 1431
CU_RESOURCE_TYPE_MIPMAPPED_ARRAY, 
#line 1432
CU_RESOURCE_TYPE_LINEAR, 
#line 1433
CU_RESOURCE_TYPE_PITCH2D
#line 1434
} CUresourcetype; 
#line 1446 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
typedef void (__stdcall *CUhostFn)(void * userData); 
#line 1455
typedef 
#line 1451
enum CUaccessProperty_enum { 
#line 1452
CU_ACCESS_PROPERTY_NORMAL, 
#line 1453
CU_ACCESS_PROPERTY_STREAMING, 
#line 1454
CU_ACCESS_PROPERTY_PERSISTING
#line 1455
} CUaccessProperty; 
#line 1475
typedef 
#line 1469
struct CUaccessPolicyWindow_st { 
#line 1470
void *base_ptr; 
#line 1471
size_t num_bytes; 
#line 1472
float hitRatio; 
#line 1473
CUaccessProperty hitProp; 
#line 1474
CUaccessProperty missProp; 
#line 1475
} CUaccessPolicyWindow_v1; 
#line 1476
typedef CUaccessPolicyWindow_v1 CUaccessPolicyWindow; 
#line 1492
typedef 
#line 1481
struct CUDA_KERNEL_NODE_PARAMS_st { 
#line 1482
CUfunction func; 
#line 1483
unsigned gridDimX; 
#line 1484
unsigned gridDimY; 
#line 1485
unsigned gridDimZ; 
#line 1486
unsigned blockDimX; 
#line 1487
unsigned blockDimY; 
#line 1488
unsigned blockDimZ; 
#line 1489
unsigned sharedMemBytes; 
#line 1490
void **kernelParams; 
#line 1491
void **extra; 
#line 1492
} CUDA_KERNEL_NODE_PARAMS_v1; 
#line 1493
typedef CUDA_KERNEL_NODE_PARAMS_v1 CUDA_KERNEL_NODE_PARAMS; 
#line 1505
typedef 
#line 1498
struct CUDA_MEMSET_NODE_PARAMS_st { 
#line 1499
CUdeviceptr dst; 
#line 1500
size_t pitch; 
#line 1501
unsigned value; 
#line 1502
unsigned elementSize; 
#line 1503
size_t width; 
#line 1504
size_t height; 
#line 1505
} CUDA_MEMSET_NODE_PARAMS_v1; 
#line 1506
typedef CUDA_MEMSET_NODE_PARAMS_v1 CUDA_MEMSET_NODE_PARAMS; 
#line 1514
typedef 
#line 1511
struct CUDA_HOST_NODE_PARAMS_st { 
#line 1512
CUhostFn fn; 
#line 1513
void *userData; 
#line 1514
} CUDA_HOST_NODE_PARAMS_v1; 
#line 1515
typedef CUDA_HOST_NODE_PARAMS_v1 CUDA_HOST_NODE_PARAMS; 
#line 1535
typedef 
#line 1520
enum CUgraphNodeType_enum { 
#line 1521
CU_GRAPH_NODE_TYPE_KERNEL, 
#line 1522
CU_GRAPH_NODE_TYPE_MEMCPY, 
#line 1523
CU_GRAPH_NODE_TYPE_MEMSET, 
#line 1524
CU_GRAPH_NODE_TYPE_HOST, 
#line 1525
CU_GRAPH_NODE_TYPE_GRAPH, 
#line 1526
CU_GRAPH_NODE_TYPE_EMPTY, 
#line 1527
CU_GRAPH_NODE_TYPE_WAIT_EVENT, 
#line 1528
CU_GRAPH_NODE_TYPE_EVENT_RECORD, 
#line 1529
CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL, 
#line 1530
CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT, 
#line 1531
CU_GRAPH_NODE_TYPE_MEM_ALLOC, 
#line 1532
CU_GRAPH_NODE_TYPE_MEM_FREE, 
#line 1534
CU_GRAPH_NODE_TYPE_BATCH_MEM_OP
#line 1535
} CUgraphNodeType; 
#line 1542
typedef 
#line 1537
enum CUsynchronizationPolicy_enum { 
#line 1538
CU_SYNC_POLICY_AUTO = 1, 
#line 1539
CU_SYNC_POLICY_SPIN, 
#line 1540
CU_SYNC_POLICY_YIELD, 
#line 1541
CU_SYNC_POLICY_BLOCKING_SYNC
#line 1542
} CUsynchronizationPolicy; 
#line 1551
typedef 
#line 1547
enum CUclusterSchedulingPolicy_enum { 
#line 1548
CU_CLUSTER_SCHEDULING_POLICY_DEFAULT, 
#line 1549
CU_CLUSTER_SCHEDULING_POLICY_SPREAD, 
#line 1550
CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING
#line 1551
} CUclusterSchedulingPolicy; 
#line 1588
typedef 
#line 1553
enum CUlaunchAttributeID_enum { 
#line 1554
CU_LAUNCH_ATTRIBUTE_IGNORE, 
#line 1555
CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW, 
#line 1556
CU_LAUNCH_ATTRIBUTE_COOPERATIVE, 
#line 1557
CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY, 
#line 1558
CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION, 
#line 1559
CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE, 
#line 1560
CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION, 
#line 1568
CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT, 
#line 1587
CU_LAUNCH_ATTRIBUTE_PRIORITY
#line 1588
} CUlaunchAttributeID; 
#line 1608
typedef 
#line 1590
union CUlaunchAttributeValue_union { 
#line 1591
char pad[64]; 
#line 1592
CUaccessPolicyWindow accessPolicyWindow; 
#line 1593
int cooperative; 
#line 1594
CUsynchronizationPolicy syncPolicy; 
#line 1595
struct { 
#line 1596
unsigned x; 
#line 1597
unsigned y; 
#line 1598
unsigned z; 
#line 1599
} clusterDim; 
#line 1600
CUclusterSchedulingPolicy clusterSchedulingPolicyPreference; 
#line 1601
int programmaticStreamSerializationAllowed; 
#line 1602
struct { 
#line 1603
CUevent event; 
#line 1604
int flags; 
#line 1605
int triggerAtBlockStart; 
#line 1606
} programmaticEvent; 
#line 1607
int priority; 
#line 1608
} CUlaunchAttributeValue; 
#line 1614
typedef 
#line 1610
struct CUlaunchAttribute_st { 
#line 1611
CUlaunchAttributeID id; 
#line 1612
char pad[(8) - sizeof(CUlaunchAttributeID)]; 
#line 1613
CUlaunchAttributeValue value; 
#line 1614
} CUlaunchAttribute; 
#line 1627
typedef 
#line 1616
struct CUlaunchConfig_st { 
#line 1617
unsigned gridDimX; 
#line 1618
unsigned gridDimY; 
#line 1619
unsigned gridDimZ; 
#line 1620
unsigned blockDimX; 
#line 1621
unsigned blockDimY; 
#line 1622
unsigned blockDimZ; 
#line 1623
unsigned sharedMemBytes; 
#line 1624
CUstream hStream; 
#line 1625
CUlaunchAttribute *attrs; 
#line 1626
unsigned numAttrs; 
#line 1627
} CUlaunchConfig; 
#line 1632
typedef CUlaunchAttributeID CUkernelNodeAttrID; 
#line 1642
typedef CUlaunchAttributeValue CUkernelNodeAttrValue_v1; 
#line 1643
typedef CUkernelNodeAttrValue_v1 CUkernelNodeAttrValue; 
#line 1653
typedef 
#line 1648
enum CUstreamCaptureStatus_enum { 
#line 1649
CU_STREAM_CAPTURE_STATUS_NONE, 
#line 1650
CU_STREAM_CAPTURE_STATUS_ACTIVE, 
#line 1651
CU_STREAM_CAPTURE_STATUS_INVALIDATED
#line 1653
} CUstreamCaptureStatus; 
#line 1663
typedef 
#line 1659
enum CUstreamCaptureMode_enum { 
#line 1660
CU_STREAM_CAPTURE_MODE_GLOBAL, 
#line 1661
CU_STREAM_CAPTURE_MODE_THREAD_LOCAL, 
#line 1662
CU_STREAM_CAPTURE_MODE_RELAXED
#line 1663
} CUstreamCaptureMode; 
#line 1668
typedef CUlaunchAttributeID CUstreamAttrID; 
#line 1675
typedef CUlaunchAttributeValue CUstreamAttrValue_v1; 
#line 1676
typedef CUstreamAttrValue_v1 CUstreamAttrValue; 
#line 1685
typedef 
#line 1681
enum CUdriverProcAddress_flags_enum { 
#line 1682
CU_GET_PROC_ADDRESS_DEFAULT, 
#line 1683
CU_GET_PROC_ADDRESS_LEGACY_STREAM, 
#line 1684
CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM
#line 1685
} CUdriverProcAddress_flags; 
#line 1693
typedef 
#line 1690
enum CUexecAffinityType_enum { 
#line 1691
CU_EXEC_AFFINITY_TYPE_SM_COUNT, 
#line 1692
CU_EXEC_AFFINITY_TYPE_MAX
#line 1693
} CUexecAffinityType; 
#line 1700
typedef 
#line 1698
struct CUexecAffinitySmCount_st { 
#line 1699
unsigned val; 
#line 1700
} CUexecAffinitySmCount_v1; 
#line 1701
typedef CUexecAffinitySmCount_v1 CUexecAffinitySmCount; 
#line 1711
typedef 
#line 1706
struct CUexecAffinityParam_st { 
#line 1707
CUexecAffinityType type; 
#line 1708
union { 
#line 1709
CUexecAffinitySmCount smCount; 
#line 1710
} param; 
#line 1711
} CUexecAffinityParam_v1; 
#line 1712
typedef CUexecAffinityParam_v1 CUexecAffinityParam; 
#line 2308
typedef 
#line 1717
enum cudaError_enum { 
#line 1723
CUDA_SUCCESS, 
#line 1729
CUDA_ERROR_INVALID_VALUE, 
#line 1735
CUDA_ERROR_OUT_OF_MEMORY, 
#line 1741
CUDA_ERROR_NOT_INITIALIZED, 
#line 1746
CUDA_ERROR_DEINITIALIZED, 
#line 1753
CUDA_ERROR_PROFILER_DISABLED, 
#line 1761
CUDA_ERROR_PROFILER_NOT_INITIALIZED, 
#line 1768
CUDA_ERROR_PROFILER_ALREADY_STARTED, 
#line 1775
CUDA_ERROR_PROFILER_ALREADY_STOPPED, 
#line 1782
CUDA_ERROR_STUB_LIBRARY = 34, 
#line 1789
CUDA_ERROR_DEVICE_UNAVAILABLE = 46, 
#line 1795
CUDA_ERROR_NO_DEVICE = 100, 
#line 1802
CUDA_ERROR_INVALID_DEVICE, 
#line 1807
CUDA_ERROR_DEVICE_NOT_LICENSED, 
#line 1813
CUDA_ERROR_INVALID_IMAGE = 200, 
#line 1823
CUDA_ERROR_INVALID_CONTEXT, 
#line 1832
CUDA_ERROR_CONTEXT_ALREADY_CURRENT, 
#line 1837
CUDA_ERROR_MAP_FAILED = 205, 
#line 1842
CUDA_ERROR_UNMAP_FAILED, 
#line 1848
CUDA_ERROR_ARRAY_IS_MAPPED, 
#line 1853
CUDA_ERROR_ALREADY_MAPPED, 
#line 1861
CUDA_ERROR_NO_BINARY_FOR_GPU, 
#line 1866
CUDA_ERROR_ALREADY_ACQUIRED, 
#line 1871
CUDA_ERROR_NOT_MAPPED, 
#line 1877
CUDA_ERROR_NOT_MAPPED_AS_ARRAY, 
#line 1883
CUDA_ERROR_NOT_MAPPED_AS_POINTER, 
#line 1889
CUDA_ERROR_ECC_UNCORRECTABLE, 
#line 1895
CUDA_ERROR_UNSUPPORTED_LIMIT, 
#line 1902
CUDA_ERROR_CONTEXT_ALREADY_IN_USE, 
#line 1908
CUDA_ERROR_PEER_ACCESS_UNSUPPORTED, 
#line 1913
CUDA_ERROR_INVALID_PTX, 
#line 1918
CUDA_ERROR_INVALID_GRAPHICS_CONTEXT, 
#line 1924
CUDA_ERROR_NVLINK_UNCORRECTABLE, 
#line 1929
CUDA_ERROR_JIT_COMPILER_NOT_FOUND, 
#line 1935
CUDA_ERROR_UNSUPPORTED_PTX_VERSION, 
#line 1940
CUDA_ERROR_JIT_COMPILATION_DISABLED, 
#line 1946
CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY, 
#line 1952
CUDA_ERROR_INVALID_SOURCE = 300, 
#line 1957
CUDA_ERROR_FILE_NOT_FOUND, 
#line 1962
CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND, 
#line 1967
CUDA_ERROR_SHARED_OBJECT_INIT_FAILED, 
#line 1972
CUDA_ERROR_OPERATING_SYSTEM, 
#line 1978
CUDA_ERROR_INVALID_HANDLE = 400, 
#line 1984
CUDA_ERROR_ILLEGAL_STATE, 
#line 1991
CUDA_ERROR_NOT_FOUND = 500, 
#line 1999
CUDA_ERROR_NOT_READY = 600, 
#line 2008
CUDA_ERROR_ILLEGAL_ADDRESS = 700, 
#line 2019
CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES, 
#line 2029
CUDA_ERROR_LAUNCH_TIMEOUT, 
#line 2035
CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING, 
#line 2042
CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED, 
#line 2049
CUDA_ERROR_PEER_ACCESS_NOT_ENABLED, 
#line 2055
CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708, 
#line 2062
CUDA_ERROR_CONTEXT_IS_DESTROYED, 
#line 2070
CUDA_ERROR_ASSERT, 
#line 2077
CUDA_ERROR_TOO_MANY_PEERS, 
#line 2083
CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED, 
#line 2089
CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED, 
#line 2098
CUDA_ERROR_HARDWARE_STACK_ERROR, 
#line 2106
CUDA_ERROR_ILLEGAL_INSTRUCTION, 
#line 2115
CUDA_ERROR_MISALIGNED_ADDRESS, 
#line 2126
CUDA_ERROR_INVALID_ADDRESS_SPACE, 
#line 2134
CUDA_ERROR_INVALID_PC, 
#line 2145
CUDA_ERROR_LAUNCH_FAILED, 
#line 2154
CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE, 
#line 2159
CUDA_ERROR_NOT_PERMITTED = 800, 
#line 2165
CUDA_ERROR_NOT_SUPPORTED, 
#line 2174
CUDA_ERROR_SYSTEM_NOT_READY, 
#line 2181
CUDA_ERROR_SYSTEM_DRIVER_MISMATCH, 
#line 2190
CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE, 
#line 2195
CUDA_ERROR_MPS_CONNECTION_FAILED, 
#line 2200
CUDA_ERROR_MPS_RPC_FAILURE, 
#line 2206
CUDA_ERROR_MPS_SERVER_NOT_READY, 
#line 2211
CUDA_ERROR_MPS_MAX_CLIENTS_REACHED, 
#line 2216
CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED, 
#line 2221
CUDA_ERROR_MPS_CLIENT_TERMINATED, 
#line 2227
CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = 900, 
#line 2233
CUDA_ERROR_STREAM_CAPTURE_INVALIDATED, 
#line 2239
CUDA_ERROR_STREAM_CAPTURE_MERGE, 
#line 2244
CUDA_ERROR_STREAM_CAPTURE_UNMATCHED, 
#line 2250
CUDA_ERROR_STREAM_CAPTURE_UNJOINED, 
#line 2257
CUDA_ERROR_STREAM_CAPTURE_ISOLATION, 
#line 2263
CUDA_ERROR_STREAM_CAPTURE_IMPLICIT, 
#line 2269
CUDA_ERROR_CAPTURED_EVENT, 
#line 2276
CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD, 
#line 2281
CUDA_ERROR_TIMEOUT, 
#line 2287
CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE, 
#line 2297
CUDA_ERROR_EXTERNAL_DEVICE, 
#line 2302
CUDA_ERROR_INVALID_CLUSTER_SIZE, 
#line 2307
CUDA_ERROR_UNKNOWN = 999
#line 2308
} CUresult; 
#line 2319
typedef 
#line 2313
enum CUdevice_P2PAttribute_enum { 
#line 2314
CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 1, 
#line 2315
CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED, 
#line 2316
CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED, 
#line 2317
CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED, 
#line 2318
CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED = 4
#line 2319
} CUdevice_P2PAttribute; 
#line 2327
typedef void (__stdcall *CUstreamCallback)(CUstream hStream, CUresult status, void * userData); 
#line 2335
typedef size_t (__stdcall *CUoccupancyB2DSize)(int blockSize); 
#line 2421
typedef 
#line 2400
struct CUDA_MEMCPY2D_st { 
#line 2401
size_t srcXInBytes; 
#line 2402
size_t srcY; 
#line 2404
CUmemorytype srcMemoryType; 
#line 2405
const void *srcHost; 
#line 2406
CUdeviceptr srcDevice; 
#line 2407
CUarray srcArray; 
#line 2408
size_t srcPitch; 
#line 2410
size_t dstXInBytes; 
#line 2411
size_t dstY; 
#line 2413
CUmemorytype dstMemoryType; 
#line 2414
void *dstHost; 
#line 2415
CUdeviceptr dstDevice; 
#line 2416
CUarray dstArray; 
#line 2417
size_t dstPitch; 
#line 2419
size_t WidthInBytes; 
#line 2420
size_t Height; 
#line 2421
} CUDA_MEMCPY2D_v2; 
#line 2422
typedef CUDA_MEMCPY2D_v2 CUDA_MEMCPY2D; 
#line 2455
typedef 
#line 2427
struct CUDA_MEMCPY3D_st { 
#line 2428
size_t srcXInBytes; 
#line 2429
size_t srcY; 
#line 2430
size_t srcZ; 
#line 2431
size_t srcLOD; 
#line 2432
CUmemorytype srcMemoryType; 
#line 2433
const void *srcHost; 
#line 2434
CUdeviceptr srcDevice; 
#line 2435
CUarray srcArray; 
#line 2436
void *reserved0; 
#line 2437
size_t srcPitch; 
#line 2438
size_t srcHeight; 
#line 2440
size_t dstXInBytes; 
#line 2441
size_t dstY; 
#line 2442
size_t dstZ; 
#line 2443
size_t dstLOD; 
#line 2444
CUmemorytype dstMemoryType; 
#line 2445
void *dstHost; 
#line 2446
CUdeviceptr dstDevice; 
#line 2447
CUarray dstArray; 
#line 2448
void *reserved1; 
#line 2449
size_t dstPitch; 
#line 2450
size_t dstHeight; 
#line 2452
size_t WidthInBytes; 
#line 2453
size_t Height; 
#line 2454
size_t Depth; 
#line 2455
} CUDA_MEMCPY3D_v2; 
#line 2456
typedef CUDA_MEMCPY3D_v2 CUDA_MEMCPY3D; 
#line 2489
typedef 
#line 2461
struct CUDA_MEMCPY3D_PEER_st { 
#line 2462
size_t srcXInBytes; 
#line 2463
size_t srcY; 
#line 2464
size_t srcZ; 
#line 2465
size_t srcLOD; 
#line 2466
CUmemorytype srcMemoryType; 
#line 2467
const void *srcHost; 
#line 2468
CUdeviceptr srcDevice; 
#line 2469
CUarray srcArray; 
#line 2470
CUcontext srcContext; 
#line 2471
size_t srcPitch; 
#line 2472
size_t srcHeight; 
#line 2474
size_t dstXInBytes; 
#line 2475
size_t dstY; 
#line 2476
size_t dstZ; 
#line 2477
size_t dstLOD; 
#line 2478
CUmemorytype dstMemoryType; 
#line 2479
void *dstHost; 
#line 2480
CUdeviceptr dstDevice; 
#line 2481
CUarray dstArray; 
#line 2482
CUcontext dstContext; 
#line 2483
size_t dstPitch; 
#line 2484
size_t dstHeight; 
#line 2486
size_t WidthInBytes; 
#line 2487
size_t Height; 
#line 2488
size_t Depth; 
#line 2489
} CUDA_MEMCPY3D_PEER_v1; 
#line 2490
typedef CUDA_MEMCPY3D_PEER_v1 CUDA_MEMCPY3D_PEER; 
#line 2502
typedef 
#line 2495
struct CUDA_ARRAY_DESCRIPTOR_st { 
#line 2497
size_t Width; 
#line 2498
size_t Height; 
#line 2500
CUarray_format Format; 
#line 2501
unsigned NumChannels; 
#line 2502
} CUDA_ARRAY_DESCRIPTOR_v2; 
#line 2503
typedef CUDA_ARRAY_DESCRIPTOR_v2 CUDA_ARRAY_DESCRIPTOR; 
#line 2517
typedef 
#line 2508
struct CUDA_ARRAY3D_DESCRIPTOR_st { 
#line 2510
size_t Width; 
#line 2511
size_t Height; 
#line 2512
size_t Depth; 
#line 2514
CUarray_format Format; 
#line 2515
unsigned NumChannels; 
#line 2516
unsigned Flags; 
#line 2517
} CUDA_ARRAY3D_DESCRIPTOR_v2; 
#line 2518
typedef CUDA_ARRAY3D_DESCRIPTOR_v2 CUDA_ARRAY3D_DESCRIPTOR; 
#line 2548
typedef 
#line 2528
struct CUDA_ARRAY_SPARSE_PROPERTIES_st { 
#line 2529
struct { 
#line 2530
unsigned width; 
#line 2531
unsigned height; 
#line 2532
unsigned depth; 
#line 2533
} tileExtent; 
#line 2538
unsigned miptailFirstLevel; 
#line 2542
unsigned __int64 miptailSize; 
#line 2546
unsigned flags; 
#line 2547
unsigned reserved[4]; 
#line 2548
} CUDA_ARRAY_SPARSE_PROPERTIES_v1; 
#line 2549
typedef CUDA_ARRAY_SPARSE_PROPERTIES_v1 CUDA_ARRAY_SPARSE_PROPERTIES; 
#line 2558
typedef 
#line 2554
struct CUDA_ARRAY_MEMORY_REQUIREMENTS_st { 
#line 2555
size_t size; 
#line 2556
size_t alignment; 
#line 2557
unsigned reserved[4]; 
#line 2558
} CUDA_ARRAY_MEMORY_REQUIREMENTS_v1; 
#line 2559
typedef CUDA_ARRAY_MEMORY_REQUIREMENTS_v1 CUDA_ARRAY_MEMORY_REQUIREMENTS; 
#line 2595
typedef 
#line 2564
struct CUDA_RESOURCE_DESC_st { 
#line 2566
CUresourcetype resType; 
#line 2568
union { 
#line 2569
struct { 
#line 2570
CUarray hArray; 
#line 2571
} array; 
#line 2572
struct { 
#line 2573
CUmipmappedArray hMipmappedArray; 
#line 2574
} mipmap; 
#line 2575
struct { 
#line 2576
CUdeviceptr devPtr; 
#line 2577
CUarray_format format; 
#line 2578
unsigned numChannels; 
#line 2579
size_t sizeInBytes; 
#line 2580
} linear; 
#line 2581
struct { 
#line 2582
CUdeviceptr devPtr; 
#line 2583
CUarray_format format; 
#line 2584
unsigned numChannels; 
#line 2585
size_t width; 
#line 2586
size_t height; 
#line 2587
size_t pitchInBytes; 
#line 2588
} pitch2D; 
#line 2589
struct { 
#line 2590
int reserved[32]; 
#line 2591
} reserved; 
#line 2592
} res; 
#line 2594
unsigned flags; 
#line 2595
} CUDA_RESOURCE_DESC_v1; 
#line 2596
typedef CUDA_RESOURCE_DESC_v1 CUDA_RESOURCE_DESC; 
#line 2612
typedef 
#line 2601
struct CUDA_TEXTURE_DESC_st { 
#line 2602
CUaddress_mode addressMode[3]; 
#line 2603
CUfilter_mode filterMode; 
#line 2604
unsigned flags; 
#line 2605
unsigned maxAnisotropy; 
#line 2606
CUfilter_mode mipmapFilterMode; 
#line 2607
float mipmapLevelBias; 
#line 2608
float minMipmapLevelClamp; 
#line 2609
float maxMipmapLevelClamp; 
#line 2610
float borderColor[4]; 
#line 2611
int reserved[12]; 
#line 2612
} CUDA_TEXTURE_DESC_v1; 
#line 2613
typedef CUDA_TEXTURE_DESC_v1 CUDA_TEXTURE_DESC; 
#line 2655
typedef 
#line 2618
enum CUresourceViewFormat_enum { 
#line 2620
CU_RES_VIEW_FORMAT_NONE, 
#line 2621
CU_RES_VIEW_FORMAT_UINT_1X8, 
#line 2622
CU_RES_VIEW_FORMAT_UINT_2X8, 
#line 2623
CU_RES_VIEW_FORMAT_UINT_4X8, 
#line 2624
CU_RES_VIEW_FORMAT_SINT_1X8, 
#line 2625
CU_RES_VIEW_FORMAT_SINT_2X8, 
#line 2626
CU_RES_VIEW_FORMAT_SINT_4X8, 
#line 2627
CU_RES_VIEW_FORMAT_UINT_1X16, 
#line 2628
CU_RES_VIEW_FORMAT_UINT_2X16, 
#line 2629
CU_RES_VIEW_FORMAT_UINT_4X16, 
#line 2630
CU_RES_VIEW_FORMAT_SINT_1X16, 
#line 2631
CU_RES_VIEW_FORMAT_SINT_2X16, 
#line 2632
CU_RES_VIEW_FORMAT_SINT_4X16, 
#line 2633
CU_RES_VIEW_FORMAT_UINT_1X32, 
#line 2634
CU_RES_VIEW_FORMAT_UINT_2X32, 
#line 2635
CU_RES_VIEW_FORMAT_UINT_4X32, 
#line 2636
CU_RES_VIEW_FORMAT_SINT_1X32, 
#line 2637
CU_RES_VIEW_FORMAT_SINT_2X32, 
#line 2638
CU_RES_VIEW_FORMAT_SINT_4X32, 
#line 2639
CU_RES_VIEW_FORMAT_FLOAT_1X16, 
#line 2640
CU_RES_VIEW_FORMAT_FLOAT_2X16, 
#line 2641
CU_RES_VIEW_FORMAT_FLOAT_4X16, 
#line 2642
CU_RES_VIEW_FORMAT_FLOAT_1X32, 
#line 2643
CU_RES_VIEW_FORMAT_FLOAT_2X32, 
#line 2644
CU_RES_VIEW_FORMAT_FLOAT_4X32, 
#line 2645
CU_RES_VIEW_FORMAT_UNSIGNED_BC1, 
#line 2646
CU_RES_VIEW_FORMAT_UNSIGNED_BC2, 
#line 2647
CU_RES_VIEW_FORMAT_UNSIGNED_BC3, 
#line 2648
CU_RES_VIEW_FORMAT_UNSIGNED_BC4, 
#line 2649
CU_RES_VIEW_FORMAT_SIGNED_BC4, 
#line 2650
CU_RES_VIEW_FORMAT_UNSIGNED_BC5, 
#line 2651
CU_RES_VIEW_FORMAT_SIGNED_BC5, 
#line 2652
CU_RES_VIEW_FORMAT_UNSIGNED_BC6H, 
#line 2653
CU_RES_VIEW_FORMAT_SIGNED_BC6H, 
#line 2654
CU_RES_VIEW_FORMAT_UNSIGNED_BC7
#line 2655
} CUresourceViewFormat; 
#line 2671
typedef 
#line 2660
struct CUDA_RESOURCE_VIEW_DESC_st { 
#line 2662
CUresourceViewFormat format; 
#line 2663
size_t width; 
#line 2664
size_t height; 
#line 2665
size_t depth; 
#line 2666
unsigned firstMipmapLevel; 
#line 2667
unsigned lastMipmapLevel; 
#line 2668
unsigned firstLayer; 
#line 2669
unsigned lastLayer; 
#line 2670
unsigned reserved[16]; 
#line 2671
} CUDA_RESOURCE_VIEW_DESC_v1; 
#line 2672
typedef CUDA_RESOURCE_VIEW_DESC_v1 CUDA_RESOURCE_VIEW_DESC; 
#line 2680
typedef 
#line 2677
struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st { 
#line 2678
unsigned __int64 p2pToken; 
#line 2679
unsigned vaSpaceToken; 
#line 2680
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1; 
#line 2681
typedef CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 CUDA_POINTER_ATTRIBUTE_P2P_TOKENS; 
#line 2691
typedef 
#line 2687
enum CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum { 
#line 2688
CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE, 
#line 2689
CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ, 
#line 2690
CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = 3
#line 2691
} CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS; 
#line 2707
typedef 
#line 2696
struct CUDA_LAUNCH_PARAMS_st { 
#line 2697
CUfunction function; 
#line 2698
unsigned gridDimX; 
#line 2699
unsigned gridDimY; 
#line 2700
unsigned gridDimZ; 
#line 2701
unsigned blockDimX; 
#line 2702
unsigned blockDimY; 
#line 2703
unsigned blockDimZ; 
#line 2704
unsigned sharedMemBytes; 
#line 2705
CUstream hStream; 
#line 2706
void **kernelParams; 
#line 2707
} CUDA_LAUNCH_PARAMS_v1; 
#line 2708
typedef CUDA_LAUNCH_PARAMS_v1 CUDA_LAUNCH_PARAMS; 
#line 2746
typedef 
#line 2713
enum CUexternalMemoryHandleType_enum { 
#line 2717
CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1, 
#line 2721
CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32, 
#line 2725
CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT, 
#line 2729
CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP, 
#line 2733
CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE, 
#line 2737
CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE, 
#line 2741
CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT, 
#line 2745
CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF
#line 2746
} CUexternalMemoryHandleType; 
#line 2840
typedef 
#line 2787
struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st { 
#line 2791
CUexternalMemoryHandleType type; 
#line 2792
union { 
#line 2798
int fd; 
#line 2814
struct { 
#line 2818
void *handle; 
#line 2823
const void *name; 
#line 2824
} win32; 
#line 2829
const void *nvSciBufObject; 
#line 2830
} handle; 
#line 2834
unsigned __int64 size; 
#line 2838
unsigned flags; 
#line 2839
unsigned reserved[16]; 
#line 2840
} CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1; 
#line 2841
typedef CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 CUDA_EXTERNAL_MEMORY_HANDLE_DESC; 
#line 2860
typedef 
#line 2846
struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st { 
#line 2850
unsigned __int64 offset; 
#line 2854
unsigned __int64 size; 
#line 2858
unsigned flags; 
#line 2859
unsigned reserved[16]; 
#line 2860
} CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1; 
#line 2861
typedef CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 CUDA_EXTERNAL_MEMORY_BUFFER_DESC; 
#line 2881
typedef 
#line 2866
struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st { 
#line 2871
unsigned __int64 offset; 
#line 2875
CUDA_ARRAY3D_DESCRIPTOR arrayDesc; 
#line 2879
unsigned numLevels; 
#line 2880
unsigned reserved[16]; 
#line 2881
} CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1; 
#line 2882
typedef CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC; 
#line 2928
typedef 
#line 2887
enum CUexternalSemaphoreHandleType_enum { 
#line 2891
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1, 
#line 2895
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32, 
#line 2899
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT, 
#line 2903
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE, 
#line 2907
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE, 
#line 2911
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, 
#line 2915
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX, 
#line 2919
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT, 
#line 2923
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD, 
#line 2927
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32
#line 2928
} CUexternalSemaphoreHandleType; 
#line 2982
typedef 
#line 2933
struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st { 
#line 2937
CUexternalSemaphoreHandleType type; 
#line 2938
union { 
#line 2945
int fd; 
#line 2961
struct { 
#line 2965
void *handle; 
#line 2970
const void *name; 
#line 2971
} win32; 
#line 2975
const void *nvSciSyncObj; 
#line 2976
} handle; 
#line 2980
unsigned flags; 
#line 2981
unsigned reserved[16]; 
#line 2982
} CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1; 
#line 2983
typedef CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC; 
#line 3030
typedef 
#line 2988
struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st { 
#line 2989
struct { 
#line 2993
struct { 
#line 2997
unsigned __int64 value; 
#line 2998
} fence; 
#line 2999
union { 
#line 3004
void *fence; 
#line 3005
unsigned __int64 reserved; 
#line 3006
} nvSciSync; 
#line 3010
struct { 
#line 3014
unsigned __int64 key; 
#line 3015
} keyedMutex; 
#line 3016
unsigned reserved[12]; 
#line 3017
} params; 
#line 3028
unsigned flags; 
#line 3029
unsigned reserved[16]; 
#line 3030
} CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1; 
#line 3031
typedef CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS; 
#line 3081
typedef 
#line 3036
struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st { 
#line 3037
struct { 
#line 3041
struct { 
#line 3045
unsigned __int64 value; 
#line 3046
} fence; 
#line 3051
union { 
#line 3052
void *fence; 
#line 3053
unsigned __int64 reserved; 
#line 3054
} nvSciSync; 
#line 3058
struct { 
#line 3062
unsigned __int64 key; 
#line 3066
unsigned timeoutMs; 
#line 3067
} keyedMutex; 
#line 3068
unsigned reserved[10]; 
#line 3069
} params; 
#line 3079
unsigned flags; 
#line 3080
unsigned reserved[16]; 
#line 3081
} CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1; 
#line 3082
typedef CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS; 
#line 3091
typedef 
#line 3087
struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st { 
#line 3088
CUexternalSemaphore *extSemArray; 
#line 3089
const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS *paramsArray; 
#line 3090
unsigned numExtSems; 
#line 3091
} CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1; 
#line 3092
typedef CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 CUDA_EXT_SEM_SIGNAL_NODE_PARAMS; 
#line 3101
typedef 
#line 3097
struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st { 
#line 3098
CUexternalSemaphore *extSemArray; 
#line 3099
const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS *paramsArray; 
#line 3100
unsigned numExtSems; 
#line 3101
} CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1; 
#line 3102
typedef CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 CUDA_EXT_SEM_WAIT_NODE_PARAMS; 
#line 3104
typedef unsigned __int64 CUmemGenericAllocationHandle_v1; 
#line 3105
typedef CUmemGenericAllocationHandle_v1 CUmemGenericAllocationHandle; 
#line 3116
typedef 
#line 3110
enum CUmemAllocationHandleType_enum { 
#line 3111
CU_MEM_HANDLE_TYPE_NONE, 
#line 3112
CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR, 
#line 3113
CU_MEM_HANDLE_TYPE_WIN32, 
#line 3114
CU_MEM_HANDLE_TYPE_WIN32_KMT = 4, 
#line 3115
CU_MEM_HANDLE_TYPE_MAX = 2147483647
#line 3116
} CUmemAllocationHandleType; 
#line 3126
typedef 
#line 3121
enum CUmemAccess_flags_enum { 
#line 3122
CU_MEM_ACCESS_FLAGS_PROT_NONE, 
#line 3123
CU_MEM_ACCESS_FLAGS_PROT_READ, 
#line 3124
CU_MEM_ACCESS_FLAGS_PROT_READWRITE = 3, 
#line 3125
CU_MEM_ACCESS_FLAGS_PROT_MAX = 2147483647
#line 3126
} CUmemAccess_flags; 
#line 3135
typedef 
#line 3131
enum CUmemLocationType_enum { 
#line 3132
CU_MEM_LOCATION_TYPE_INVALID, 
#line 3133
CU_MEM_LOCATION_TYPE_DEVICE, 
#line 3134
CU_MEM_LOCATION_TYPE_MAX = 2147483647
#line 3135
} CUmemLocationType; 
#line 3148
typedef 
#line 3140
enum CUmemAllocationType_enum { 
#line 3141
CU_MEM_ALLOCATION_TYPE_INVALID, 
#line 3146
CU_MEM_ALLOCATION_TYPE_PINNED, 
#line 3147
CU_MEM_ALLOCATION_TYPE_MAX = 2147483647
#line 3148
} CUmemAllocationType; 
#line 3156
typedef 
#line 3153
enum CUmemAllocationGranularity_flags_enum { 
#line 3154
CU_MEM_ALLOC_GRANULARITY_MINIMUM, 
#line 3155
CU_MEM_ALLOC_GRANULARITY_RECOMMENDED
#line 3156
} CUmemAllocationGranularity_flags; 
#line 3165
typedef 
#line 3161
enum CUmemRangeHandleType_enum { 
#line 3163
CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD = 1, 
#line 3164
CU_MEM_RANGE_HANDLE_TYPE_MAX = 2147483647
#line 3165
} CUmemRangeHandleType; 
#line 3173
typedef 
#line 3170
enum CUarraySparseSubresourceType_enum { 
#line 3171
CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL, 
#line 3172
CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL
#line 3173
} CUarraySparseSubresourceType; 
#line 3181
typedef 
#line 3178
enum CUmemOperationType_enum { 
#line 3179
CU_MEM_OPERATION_TYPE_MAP = 1, 
#line 3180
CU_MEM_OPERATION_TYPE_UNMAP
#line 3181
} CUmemOperationType; 
#line 3188
typedef 
#line 3186
enum CUmemHandleType_enum { 
#line 3187
CU_MEM_HANDLE_TYPE_GENERIC
#line 3188
} CUmemHandleType; 
#line 3232
typedef 
#line 3193
struct CUarrayMapInfo_st { 
#line 3194
CUresourcetype resourceType; 
#line 3196
union { 
#line 3197
CUmipmappedArray mipmap; 
#line 3198
CUarray array; 
#line 3199
} resource; 
#line 3201
CUarraySparseSubresourceType subresourceType; 
#line 3203
union { 
#line 3204
struct { 
#line 3205
unsigned level; 
#line 3206
unsigned layer; 
#line 3207
unsigned offsetX; 
#line 3208
unsigned offsetY; 
#line 3209
unsigned offsetZ; 
#line 3210
unsigned extentWidth; 
#line 3211
unsigned extentHeight; 
#line 3212
unsigned extentDepth; 
#line 3213
} sparseLevel; 
#line 3214
struct { 
#line 3215
unsigned layer; 
#line 3216
unsigned __int64 offset; 
#line 3217
unsigned __int64 size; 
#line 3218
} miptail; 
#line 3219
} subresource; 
#line 3221
CUmemOperationType memOperationType; 
#line 3222
CUmemHandleType memHandleType; 
#line 3224
union { 
#line 3225
CUmemGenericAllocationHandle memHandle; 
#line 3226
} memHandle; 
#line 3228
unsigned __int64 offset; 
#line 3229
unsigned deviceBitMask; 
#line 3230
unsigned flags; 
#line 3231
unsigned reserved[2]; 
#line 3232
} CUarrayMapInfo_v1; 
#line 3233
typedef CUarrayMapInfo_v1 CUarrayMapInfo; 
#line 3241
typedef 
#line 3238
struct CUmemLocation_st { 
#line 3239
CUmemLocationType type; 
#line 3240
int id; 
#line 3241
} CUmemLocation_v1; 
#line 3242
typedef CUmemLocation_v1 CUmemLocation; 
#line 3250
typedef 
#line 3247
enum CUmemAllocationCompType_enum { 
#line 3248
CU_MEM_ALLOCATION_COMP_NONE, 
#line 3249
CU_MEM_ALLOCATION_COMP_GENERIC
#line 3250
} CUmemAllocationCompType; 
#line 3292
typedef 
#line 3260
struct CUmemAllocationProp_st { 
#line 3262
CUmemAllocationType type; 
#line 3264
CUmemAllocationHandleType requestedHandleTypes; 
#line 3266
CUmemLocation location; 
#line 3274
void *win32HandleMetaData; 
#line 3275
struct { 
#line 3286
unsigned char compressionType; 
#line 3287
unsigned char gpuDirectRDMACapable; 
#line 3289
unsigned short usage; 
#line 3290
unsigned char reserved[4]; 
#line 3291
} allocFlags; 
#line 3292
} CUmemAllocationProp_v1; 
#line 3293
typedef CUmemAllocationProp_v1 CUmemAllocationProp; 
#line 3301
typedef 
#line 3298
struct CUmemAccessDesc_st { 
#line 3299
CUmemLocation location; 
#line 3300
CUmemAccess_flags flags; 
#line 3301
} CUmemAccessDesc_v1; 
#line 3302
typedef CUmemAccessDesc_v1 CUmemAccessDesc; 
#line 3314
typedef 
#line 3304
enum CUgraphExecUpdateResult_enum { 
#line 3305
CU_GRAPH_EXEC_UPDATE_SUCCESS, 
#line 3306
CU_GRAPH_EXEC_UPDATE_ERROR, 
#line 3307
CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED, 
#line 3308
CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED, 
#line 3309
CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED, 
#line 3310
CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED, 
#line 3311
CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED, 
#line 3312
CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE, 
#line 3313
CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED
#line 3314
} CUgraphExecUpdateResult; 
#line 3380
typedef 
#line 3319
enum CUmemPool_attribute_enum { 
#line 3328
CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = 1, 
#line 3335
CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC, 
#line 3343
CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES, 
#line 3353
CU_MEMPOOL_ATTR_RELEASE_THRESHOLD, 
#line 3359
CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT, 
#line 3366
CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH, 
#line 3372
CU_MEMPOOL_ATTR_USED_MEM_CURRENT, 
#line 3379
CU_MEMPOOL_ATTR_USED_MEM_HIGH
#line 3380
} CUmemPool_attribute; 
#line 3397
typedef 
#line 3385
struct CUmemPoolProps_st { 
#line 3386
CUmemAllocationType allocType; 
#line 3387
CUmemAllocationHandleType handleTypes; 
#line 3388
CUmemLocation location; 
#line 3395
void *win32SecurityAttributes; 
#line 3396
unsigned char reserved[64]; 
#line 3397
} CUmemPoolProps_v1; 
#line 3398
typedef CUmemPoolProps_v1 CUmemPoolProps; 
#line 3405
typedef 
#line 3403
struct CUmemPoolPtrExportData_st { 
#line 3404
unsigned char reserved[64]; 
#line 3405
} CUmemPoolPtrExportData_v1; 
#line 3406
typedef CUmemPoolPtrExportData_v1 CUmemPoolPtrExportData; 
#line 3421
typedef 
#line 3411
struct CUDA_MEM_ALLOC_NODE_PARAMS_st { 
#line 3416
CUmemPoolProps poolProps; 
#line 3417
const CUmemAccessDesc *accessDescs; 
#line 3418
size_t accessDescCount; 
#line 3419
size_t bytesize; 
#line 3420
CUdeviceptr dptr; 
#line 3421
} CUDA_MEM_ALLOC_NODE_PARAMS; 
#line 3450
typedef 
#line 3423
enum CUgraphMem_attribute_enum { 
#line 3428
CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT, 
#line 3435
CU_GRAPH_MEM_ATTR_USED_MEM_HIGH, 
#line 3442
CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT, 
#line 3449
CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH
#line 3450
} CUgraphMem_attribute; 
#line 3623
typedef 
#line 3620
enum CUflushGPUDirectRDMAWritesOptions_enum { 
#line 3621
CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = (1 << 0), 
#line 3622
CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS
#line 3623
} CUflushGPUDirectRDMAWritesOptions; 
#line 3632
typedef 
#line 3628
enum CUGPUDirectRDMAWritesOrdering_enum { 
#line 3629
CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE, 
#line 3630
CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = 100, 
#line 3631
CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = 200
#line 3632
} CUGPUDirectRDMAWritesOrdering; 
#line 3640
typedef 
#line 3637
enum CUflushGPUDirectRDMAWritesScope_enum { 
#line 3638
CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = 100, 
#line 3639
CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = 200
#line 3640
} CUflushGPUDirectRDMAWritesScope; 
#line 3647
typedef 
#line 3645
enum CUflushGPUDirectRDMAWritesTarget_enum { 
#line 3646
CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX
#line 3647
} CUflushGPUDirectRDMAWritesTarget; 
#line 3668
typedef 
#line 3652
enum CUgraphDebugDot_flags_enum { 
#line 3653
CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = (1 << 0), 
#line 3654
CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES, 
#line 3655
CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = (1 << 2), 
#line 3656
CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = (1 << 3), 
#line 3657
CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = (1 << 4), 
#line 3658
CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = (1 << 5), 
#line 3659
CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = (1 << 6), 
#line 3660
CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = (1 << 7), 
#line 3661
CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = (1 << 8), 
#line 3662
CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = (1 << 9), 
#line 3663
CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = (1 << 10), 
#line 3664
CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = (1 << 11), 
#line 3665
CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = (1 << 12), 
#line 3667
CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS = (1 << 13)
#line 3668
} CUgraphDebugDot_flags; 
#line 3675
typedef 
#line 3673
enum CUuserObject_flags_enum { 
#line 3674
CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = 1
#line 3675
} CUuserObject_flags; 
#line 3682
typedef 
#line 3680
enum CUuserObjectRetain_flags_enum { 
#line 3681
CU_GRAPH_USER_OBJECT_MOVE = 1
#line 3682
} CUuserObjectRetain_flags; 
#line 3691
typedef 
#line 3687
enum CUgraphInstantiate_flags_enum { 
#line 3688
CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = 1, 
#line 3689
CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY = 8
#line 3691
} CUgraphInstantiate_flags; 
#line 3738 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
CUresult __stdcall cuGetErrorString(CUresult error, const char ** pStr); 
#line 3759
CUresult __stdcall cuGetErrorName(CUresult error, const char ** pStr); 
#line 3793
CUresult __stdcall cuInit(unsigned Flags); 
#line 3831
CUresult __stdcall cuDriverGetVersion(int * driverVersion); 
#line 3874
CUresult __stdcall cuDeviceGet(CUdevice * device, int ordinal); 
#line 3903
CUresult __stdcall cuDeviceGetCount(int * count); 
#line 3935
CUresult __stdcall cuDeviceGetName(char * name, int len, CUdevice dev); 
#line 3968
CUresult __stdcall cuDeviceGetUuid(CUuuid * uuid, CUdevice dev); 
#line 3997
CUresult __stdcall cuDeviceGetUuid_v2(CUuuid * uuid, CUdevice dev); 
#line 4026
CUresult __stdcall cuDeviceGetLuid(char * luid, unsigned * deviceNodeMask, CUdevice dev); 
#line 4055
CUresult __stdcall cuDeviceTotalMem_v2(size_t * bytes, CUdevice dev); 
#line 4086
CUresult __stdcall cuDeviceGetTexture1DLinearMaxWidth(size_t * maxWidthInElements, CUarray_format format, unsigned numChannels, CUdevice dev); 
#line 4309
CUresult __stdcall cuDeviceGetAttribute(int * pi, CUdevice_attribute attrib, CUdevice dev); 
#line 4358
CUresult __stdcall cuDeviceGetNvSciSyncAttributes(void * nvSciSyncAttrList, CUdevice dev, int flags); 
#line 4376
CUresult __stdcall cuDeviceSetMemPool(CUdevice dev, CUmemoryPool pool); 
#line 4392
CUresult __stdcall cuDeviceGetMemPool(CUmemoryPool * pool, CUdevice dev); 
#line 4410
CUresult __stdcall cuDeviceGetDefaultMemPool(CUmemoryPool * pool_out, CUdevice dev); 
#line 4441
CUresult __stdcall cuFlushGPUDirectRDMAWrites(CUflushGPUDirectRDMAWritesTarget target, CUflushGPUDirectRDMAWritesScope scope); 
#line 4519
__declspec(deprecated) CUresult __stdcall cuDeviceGetProperties(CUdevprop * prop, CUdevice dev); 
#line 4553
__declspec(deprecated) CUresult __stdcall cuDeviceComputeCapability(int * major, int * minor, CUdevice dev); 
#line 4620
CUresult __stdcall cuDevicePrimaryCtxRetain(CUcontext * pctx, CUdevice dev); 
#line 4661
CUresult __stdcall cuDevicePrimaryCtxRelease_v2(CUdevice dev); 
#line 4726
CUresult __stdcall cuDevicePrimaryCtxSetFlags_v2(CUdevice dev, unsigned flags); 
#line 4752
CUresult __stdcall cuDevicePrimaryCtxGetState(CUdevice dev, unsigned * flags, int * active); 
#line 4792
CUresult __stdcall cuDevicePrimaryCtxReset_v2(CUdevice dev); 
#line 4825
CUresult __stdcall cuDeviceGetExecAffinitySupport(int * pi, CUexecAffinityType type, CUdevice dev); 
#line 4934
CUresult __stdcall cuCtxCreate_v2(CUcontext * pctx, unsigned flags, CUdevice dev); 
#line 5041
CUresult __stdcall cuCtxCreate_v3(CUcontext * pctx, CUexecAffinityParam * paramsArray, int numParams, unsigned flags, CUdevice dev); 
#line 5086
CUresult __stdcall cuCtxDestroy_v2(CUcontext ctx); 
#line 5120
CUresult __stdcall cuCtxPushCurrent_v2(CUcontext ctx); 
#line 5154
CUresult __stdcall cuCtxPopCurrent_v2(CUcontext * pctx); 
#line 5184
CUresult __stdcall cuCtxSetCurrent(CUcontext ctx); 
#line 5207
CUresult __stdcall cuCtxGetCurrent(CUcontext * pctx); 
#line 5237
CUresult __stdcall cuCtxGetDevice(CUdevice * device); 
#line 5265
CUresult __stdcall cuCtxGetFlags(unsigned * flags); 
#line 5295
CUresult __stdcall cuCtxSynchronize(); 
#line 5394
CUresult __stdcall cuCtxSetLimit(CUlimit limit, size_t value); 
#line 5436
CUresult __stdcall cuCtxGetLimit(size_t * pvalue, CUlimit limit); 
#line 5480
CUresult __stdcall cuCtxGetCacheConfig(CUfunc_cache * pconfig); 
#line 5531
CUresult __stdcall cuCtxSetCacheConfig(CUfunc_cache config); 
#line 5573
CUresult __stdcall cuCtxGetSharedMemConfig(CUsharedconfig * pConfig); 
#line 5626
CUresult __stdcall cuCtxSetSharedMemConfig(CUsharedconfig config); 
#line 5664
CUresult __stdcall cuCtxGetApiVersion(CUcontext ctx, unsigned * version); 
#line 5704
CUresult __stdcall cuCtxGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
#line 5720
CUresult __stdcall cuCtxResetPersistingL2Cache(); 
#line 5744
CUresult __stdcall cuCtxGetExecAffinity(CUexecAffinityParam * pExecAffinity, CUexecAffinityType type); 
#line 5800
__declspec(deprecated) CUresult __stdcall cuCtxAttach(CUcontext * pctx, unsigned flags); 
#line 5836
__declspec(deprecated) CUresult __stdcall cuCtxDetach(CUcontext ctx); 
#line 5892
CUresult __stdcall cuModuleLoad(CUmodule * module, const char * fname); 
#line 5930
CUresult __stdcall cuModuleLoadData(CUmodule * module, const void * image); 
#line 5974
CUresult __stdcall cuModuleLoadDataEx(CUmodule * module, const void * image, unsigned numOptions, CUjit_option * options, void ** optionValues); 
#line 6017
CUresult __stdcall cuModuleLoadFatBinary(CUmodule * module, const void * fatCubin); 
#line 6043
CUresult __stdcall cuModuleUnload(CUmodule hmod); 
#line 6051
typedef 
#line 6048
enum CUmoduleLoadingMode_enum { 
#line 6049
CU_MODULE_EAGER_LOADING = 1, 
#line 6050
CU_MODULE_LAZY_LOADING
#line 6051
} CUmoduleLoadingMode; 
#line 6069
CUresult __stdcall cuModuleGetLoadingMode(CUmoduleLoadingMode * mode); 
#line 6099
CUresult __stdcall cuModuleGetFunction(CUfunction * hfunc, CUmodule hmod, const char * name); 
#line 6134
CUresult __stdcall cuModuleGetGlobal_v2(CUdeviceptr * dptr, size_t * bytes, CUmodule hmod, const char * name); 
#line 6169
CUresult __stdcall cuModuleGetTexRef(CUtexref * pTexRef, CUmodule hmod, const char * name); 
#line 6202
CUresult __stdcall cuModuleGetSurfRef(CUsurfref * pSurfRef, CUmodule hmod, const char * name); 
#line 6243
CUresult __stdcall cuLinkCreate_v2(unsigned numOptions, CUjit_option * options, void ** optionValues, CUlinkState * stateOut); 
#line 6281
CUresult __stdcall cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void * data, size_t size, const char * name, unsigned numOptions, CUjit_option * options, void ** optionValues); 
#line 6321
CUresult __stdcall cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char * path, unsigned numOptions, CUjit_option * options, void ** optionValues); 
#line 6348
CUresult __stdcall cuLinkComplete(CUlinkState state, void ** cubinOut, size_t * sizeOut); 
#line 6362
CUresult __stdcall cuLinkDestroy(CUlinkState state); 
#line 6420
CUresult __stdcall cuMemGetInfo_v2(size_t * free, size_t * total); 
#line 6454
CUresult __stdcall cuMemAlloc_v2(CUdeviceptr * dptr, size_t bytesize); 
#line 6516
CUresult __stdcall cuMemAllocPitch_v2(CUdeviceptr * dptr, size_t * pPitch, size_t WidthInBytes, size_t Height, unsigned ElementSizeBytes); 
#line 6552
CUresult __stdcall cuMemFree_v2(CUdeviceptr dptr); 
#line 6586
CUresult __stdcall cuMemGetAddressRange_v2(CUdeviceptr * pbase, size_t * psize, CUdeviceptr dptr); 
#line 6633
CUresult __stdcall cuMemAllocHost_v2(void ** pp, size_t bytesize); 
#line 6663
CUresult __stdcall cuMemFreeHost(void * p); 
#line 6742
CUresult __stdcall cuMemHostAlloc(void ** pp, size_t bytesize, unsigned Flags); 
#line 6795
CUresult __stdcall cuMemHostGetDevicePointer_v2(CUdeviceptr * pdptr, void * p, unsigned Flags); 
#line 6822
CUresult __stdcall cuMemHostGetFlags(unsigned * pFlags, void * p); 
#line 6932
CUresult __stdcall cuMemAllocManaged(CUdeviceptr * dptr, size_t bytesize, unsigned flags); 
#line 6961
CUresult __stdcall cuDeviceGetByPCIBusId(CUdevice * dev, const char * pciBusId); 
#line 6993
CUresult __stdcall cuDeviceGetPCIBusId(char * pciBusId, int len, CUdevice dev); 
#line 7038
CUresult __stdcall cuIpcGetEventHandle(CUipcEventHandle * pHandle, CUevent event); 
#line 7078
CUresult __stdcall cuIpcOpenEventHandle(CUevent * phEvent, CUipcEventHandle handle); 
#line 7119
CUresult __stdcall cuIpcGetMemHandle(CUipcMemHandle * pHandle, CUdeviceptr dptr); 
#line 7177
CUresult __stdcall cuIpcOpenMemHandle_v2(CUdeviceptr * pdptr, CUipcMemHandle handle, unsigned Flags); 
#line 7211
CUresult __stdcall cuIpcCloseMemHandle(CUdeviceptr dptr); 
#line 7298
CUresult __stdcall cuMemHostRegister_v2(void * p, size_t bytesize, unsigned Flags); 
#line 7324
CUresult __stdcall cuMemHostUnregister(void * p); 
#line 7364
CUresult __stdcall cuMemcpy(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount); 
#line 7394
CUresult __stdcall cuMemcpyPeer(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount); 
#line 7430
CUresult __stdcall cuMemcpyHtoD_v2(CUdeviceptr dstDevice, const void * srcHost, size_t ByteCount); 
#line 7466
CUresult __stdcall cuMemcpyDtoH_v2(void * dstHost, CUdeviceptr srcDevice, size_t ByteCount); 
#line 7502
CUresult __stdcall cuMemcpyDtoD_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount); 
#line 7538
CUresult __stdcall cuMemcpyDtoA_v2(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount); 
#line 7576
CUresult __stdcall cuMemcpyAtoD_v2(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
#line 7613
CUresult __stdcall cuMemcpyHtoA_v2(CUarray dstArray, size_t dstOffset, const void * srcHost, size_t ByteCount); 
#line 7650
CUresult __stdcall cuMemcpyAtoH_v2(void * dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
#line 7690
CUresult __stdcall cuMemcpyAtoA_v2(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
#line 7854
CUresult __stdcall cuMemcpy2D_v2(const CUDA_MEMCPY2D * pCopy); 
#line 8016
CUresult __stdcall cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D * pCopy); 
#line 8185
CUresult __stdcall cuMemcpy3D_v2(const CUDA_MEMCPY3D * pCopy); 
#line 8209
CUresult __stdcall cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER * pCopy); 
#line 8254
CUresult __stdcall cuMemcpyAsync(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream); 
#line 8287
CUresult __stdcall cuMemcpyPeerAsync(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream); 
#line 8328
CUresult __stdcall cuMemcpyHtoDAsync_v2(CUdeviceptr dstDevice, const void * srcHost, size_t ByteCount, CUstream hStream); 
#line 8369
CUresult __stdcall cuMemcpyDtoHAsync_v2(void * dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream); 
#line 8410
CUresult __stdcall cuMemcpyDtoDAsync_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream); 
#line 8452
CUresult __stdcall cuMemcpyHtoAAsync_v2(CUarray dstArray, size_t dstOffset, const void * srcHost, size_t ByteCount, CUstream hStream); 
#line 8494
CUresult __stdcall cuMemcpyAtoHAsync_v2(void * dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream); 
#line 8663
CUresult __stdcall cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D * pCopy, CUstream hStream); 
#line 8837
CUresult __stdcall cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D * pCopy, CUstream hStream); 
#line 8863
CUresult __stdcall cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER * pCopy, CUstream hStream); 
#line 8898
CUresult __stdcall cuMemsetD8_v2(CUdeviceptr dstDevice, unsigned char uc, size_t N); 
#line 8933
CUresult __stdcall cuMemsetD16_v2(CUdeviceptr dstDevice, unsigned short us, size_t N); 
#line 8968
CUresult __stdcall cuMemsetD32_v2(CUdeviceptr dstDevice, unsigned ui, size_t N); 
#line 9008
CUresult __stdcall cuMemsetD2D8_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height); 
#line 9049
CUresult __stdcall cuMemsetD2D16_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height); 
#line 9090
CUresult __stdcall cuMemsetD2D32_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned ui, size_t Width, size_t Height); 
#line 9127
CUresult __stdcall cuMemsetD8Async(CUdeviceptr dstDevice, unsigned char uc, size_t N, CUstream hStream); 
#line 9164
CUresult __stdcall cuMemsetD16Async(CUdeviceptr dstDevice, unsigned short us, size_t N, CUstream hStream); 
#line 9200
CUresult __stdcall cuMemsetD32Async(CUdeviceptr dstDevice, unsigned ui, size_t N, CUstream hStream); 
#line 9242
CUresult __stdcall cuMemsetD2D8Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, CUstream hStream); 
#line 9285
CUresult __stdcall cuMemsetD2D16Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, CUstream hStream); 
#line 9328
CUresult __stdcall cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned ui, size_t Width, size_t Height, CUstream hStream); 
#line 9432
CUresult __stdcall cuArrayCreate_v2(CUarray * pHandle, const CUDA_ARRAY_DESCRIPTOR * pAllocateArray); 
#line 9466
CUresult __stdcall cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR * pArrayDescriptor, CUarray hArray); 
#line 9490
CUresult __stdcall cuArrayGetSparseProperties(CUDA_ARRAY_SPARSE_PROPERTIES * sparseProperties, CUarray array); 
#line 9515
CUresult __stdcall cuMipmappedArrayGetSparseProperties(CUDA_ARRAY_SPARSE_PROPERTIES * sparseProperties, CUmipmappedArray mipmap); 
#line 9538
CUresult __stdcall cuArrayGetMemoryRequirements(CUDA_ARRAY_MEMORY_REQUIREMENTS * memoryRequirements, CUarray array, CUdevice device); 
#line 9562
CUresult __stdcall cuMipmappedArrayGetMemoryRequirements(CUDA_ARRAY_MEMORY_REQUIREMENTS * memoryRequirements, CUmipmappedArray mipmap, CUdevice device); 
#line 9595
CUresult __stdcall cuArrayGetPlane(CUarray * pPlaneArray, CUarray hArray, unsigned planeIdx); 
#line 9626
CUresult __stdcall cuArrayDestroy(CUarray hArray); 
#line 9806
CUresult __stdcall cuArray3DCreate_v2(CUarray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pAllocateArray); 
#line 9844
CUresult __stdcall cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR * pArrayDescriptor, CUarray hArray); 
#line 9986
CUresult __stdcall cuMipmappedArrayCreate(CUmipmappedArray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc, unsigned numMipmapLevels); 
#line 10016
CUresult __stdcall cuMipmappedArrayGetLevel(CUarray * pLevelArray, CUmipmappedArray hMipmappedArray, unsigned level); 
#line 10041
CUresult __stdcall cuMipmappedArrayDestroy(CUmipmappedArray hMipmappedArray); 
#line 10074
CUresult __stdcall cuMemGetHandleForAddressRange(void * handle, CUdeviceptr dptr, size_t size, CUmemRangeHandleType handleType, unsigned __int64 flags); 
#line 10115
CUresult __stdcall cuMemAddressReserve(CUdeviceptr * ptr, size_t size, size_t alignment, CUdeviceptr addr, unsigned __int64 flags); 
#line 10136
CUresult __stdcall cuMemAddressFree(CUdeviceptr ptr, size_t size); 
#line 10175
CUresult __stdcall cuMemCreate(CUmemGenericAllocationHandle * handle, size_t size, const CUmemAllocationProp * prop, unsigned __int64 flags); 
#line 10202
CUresult __stdcall cuMemRelease(CUmemGenericAllocationHandle handle); 
#line 10246
CUresult __stdcall cuMemMap(CUdeviceptr ptr, size_t size, size_t offset, CUmemGenericAllocationHandle handle, unsigned __int64 flags); 
#line 10381
CUresult __stdcall cuMemMapArrayAsync(CUarrayMapInfo * mapInfoList, unsigned count, CUstream hStream); 
#line 10410
CUresult __stdcall cuMemUnmap(CUdeviceptr ptr, size_t size); 
#line 10435
CUresult __stdcall cuMemSetAccess(CUdeviceptr ptr, size_t size, const CUmemAccessDesc * desc, size_t count); 
#line 10454
CUresult __stdcall cuMemGetAccess(unsigned __int64 * flags, const CUmemLocation * location, CUdeviceptr ptr); 
#line 10487
CUresult __stdcall cuMemExportToShareableHandle(void * shareableHandle, CUmemGenericAllocationHandle handle, CUmemAllocationHandleType handleType, unsigned __int64 flags); 
#line 10514
CUresult __stdcall cuMemImportFromShareableHandle(CUmemGenericAllocationHandle * handle, void * osHandle, CUmemAllocationHandleType shHandleType); 
#line 10536
CUresult __stdcall cuMemGetAllocationGranularity(size_t * granularity, const CUmemAllocationProp * prop, CUmemAllocationGranularity_flags option); 
#line 10553
CUresult __stdcall cuMemGetAllocationPropertiesFromHandle(CUmemAllocationProp * prop, CUmemGenericAllocationHandle handle); 
#line 10577
CUresult __stdcall cuMemRetainAllocationHandle(CUmemGenericAllocationHandle * handle, void * addr); 
#line 10634
CUresult __stdcall cuMemFreeAsync(CUdeviceptr dptr, CUstream hStream); 
#line 10667
CUresult __stdcall cuMemAllocAsync(CUdeviceptr * dptr, size_t bytesize, CUstream hStream); 
#line 10693
CUresult __stdcall cuMemPoolTrimTo(CUmemoryPool pool, size_t minBytesToKeep); 
#line 10736
CUresult __stdcall cuMemPoolSetAttribute(CUmemoryPool pool, CUmemPool_attribute attr, void * value); 
#line 10783
CUresult __stdcall cuMemPoolGetAttribute(CUmemoryPool pool, CUmemPool_attribute attr, void * value); 
#line 10800
CUresult __stdcall cuMemPoolSetAccess(CUmemoryPool pool, const CUmemAccessDesc * map, size_t count); 
#line 10814
CUresult __stdcall cuMemPoolGetAccess(CUmemAccess_flags * flags, CUmemoryPool memPool, CUmemLocation * location); 
#line 10836
CUresult __stdcall cuMemPoolCreate(CUmemoryPool * pool, const CUmemPoolProps * poolProps); 
#line 10859
CUresult __stdcall cuMemPoolDestroy(CUmemoryPool pool); 
#line 10897
CUresult __stdcall cuMemAllocFromPoolAsync(CUdeviceptr * dptr, size_t bytesize, CUmemoryPool pool, CUstream hStream); 
#line 10926
CUresult __stdcall cuMemPoolExportToShareableHandle(void * handle_out, CUmemoryPool pool, CUmemAllocationHandleType handleType, unsigned __int64 flags); 
#line 10950
CUresult __stdcall cuMemPoolImportFromShareableHandle(CUmemoryPool * pool_out, void * handle, CUmemAllocationHandleType handleType, unsigned __int64 flags); 
#line 10974
CUresult __stdcall cuMemPoolExportPointer(CUmemPoolPtrExportData * shareData_out, CUdeviceptr ptr); 
#line 11003
CUresult __stdcall cuMemPoolImportPointer(CUdeviceptr * ptr_out, CUmemoryPool pool, CUmemPoolPtrExportData * shareData); 
#line 11288
CUresult __stdcall cuPointerGetAttribute(void * data, CUpointer_attribute attribute, CUdeviceptr ptr); 
#line 11356
CUresult __stdcall cuMemPrefetchAsync(CUdeviceptr devPtr, size_t count, CUdevice dstDevice, CUstream hStream); 
#line 11470
CUresult __stdcall cuMemAdvise(CUdeviceptr devPtr, size_t count, CUmem_advise advice, CUdevice device); 
#line 11528
CUresult __stdcall cuMemRangeGetAttribute(void * data, size_t dataSize, CUmem_range_attribute attribute, CUdeviceptr devPtr, size_t count); 
#line 11568
CUresult __stdcall cuMemRangeGetAttributes(void ** data, size_t * dataSizes, CUmem_range_attribute * attributes, size_t numAttributes, CUdeviceptr devPtr, size_t count); 
#line 11610
CUresult __stdcall cuPointerSetAttribute(const void * value, CUpointer_attribute attribute, CUdeviceptr ptr); 
#line 11659
CUresult __stdcall cuPointerGetAttributes(unsigned numAttributes, CUpointer_attribute * attributes, void ** data, CUdeviceptr ptr); 
#line 11710
CUresult __stdcall cuStreamCreate(CUstream * phStream, unsigned Flags); 
#line 11759
CUresult __stdcall cuStreamCreateWithPriority(CUstream * phStream, unsigned flags, int priority); 
#line 11790
CUresult __stdcall cuStreamGetPriority(CUstream hStream, int * priority); 
#line 11818
CUresult __stdcall cuStreamGetFlags(CUstream hStream, unsigned * flags); 
#line 11862
CUresult __stdcall cuStreamGetCtx(CUstream hStream, CUcontext * pctx); 
#line 11899
CUresult __stdcall cuStreamWaitEvent(CUstream hStream, CUevent hEvent, unsigned Flags); 
#line 11974
CUresult __stdcall cuStreamAddCallback(CUstream hStream, CUstreamCallback callback, void * userData, unsigned flags); 
#line 12012
CUresult __stdcall cuStreamBeginCapture_v2(CUstream hStream, CUstreamCaptureMode mode); 
#line 12065
CUresult __stdcall cuThreadExchangeStreamCaptureMode(CUstreamCaptureMode * mode); 
#line 12095
CUresult __stdcall cuStreamEndCapture(CUstream hStream, CUgraph * phGraph); 
#line 12135
CUresult __stdcall cuStreamIsCapturing(CUstream hStream, CUstreamCaptureStatus * captureStatus); 
#line 12163
CUresult __stdcall cuStreamGetCaptureInfo(CUstream hStream, CUstreamCaptureStatus * captureStatus_out, cuuint64_t * id_out); 
#line 12217
CUresult __stdcall cuStreamGetCaptureInfo_v2(CUstream hStream, CUstreamCaptureStatus * captureStatus_out, cuuint64_t * id_out, CUgraph * graph_out, const CUgraphNode ** dependencies_out, size_t * numDependencies_out); 
#line 12250
CUresult __stdcall cuStreamUpdateCaptureDependencies(CUstream hStream, CUgraphNode * dependencies, size_t numDependencies, unsigned flags); 
#line 12338
CUresult __stdcall cuStreamAttachMemAsync(CUstream hStream, CUdeviceptr dptr, size_t length, unsigned flags); 
#line 12368
CUresult __stdcall cuStreamQuery(CUstream hStream); 
#line 12397
CUresult __stdcall cuStreamSynchronize(CUstream hStream); 
#line 12427
CUresult __stdcall cuStreamDestroy_v2(CUstream hStream); 
#line 12447
CUresult __stdcall cuStreamCopyAttributes(CUstream dst, CUstream src); 
#line 12468
CUresult __stdcall cuStreamGetAttribute(CUstream hStream, CUstreamAttrID attr, CUstreamAttrValue * value_out); 
#line 12491
CUresult __stdcall cuStreamSetAttribute(CUstream hStream, CUstreamAttrID attr, const CUstreamAttrValue * value); 
#line 12548
CUresult __stdcall cuEventCreate(CUevent * phEvent, unsigned Flags); 
#line 12590
CUresult __stdcall cuEventRecord(CUevent hEvent, CUstream hStream); 
#line 12639
CUresult __stdcall cuEventRecordWithFlags(CUevent hEvent, CUstream hStream, unsigned flags); 
#line 12671
CUresult __stdcall cuEventQuery(CUevent hEvent); 
#line 12702
CUresult __stdcall cuEventSynchronize(CUevent hEvent); 
#line 12731
CUresult __stdcall cuEventDestroy_v2(CUevent hEvent); 
#line 12776
CUresult __stdcall cuEventElapsedTime(float * pMilliseconds, CUevent hStart, CUevent hEnd); 
#line 12954
CUresult __stdcall cuImportExternalMemory(CUexternalMemory * extMem_out, const CUDA_EXTERNAL_MEMORY_HANDLE_DESC * memHandleDesc); 
#line 13008
CUresult __stdcall cuExternalMemoryGetMappedBuffer(CUdeviceptr * devPtr, CUexternalMemory extMem, const CUDA_EXTERNAL_MEMORY_BUFFER_DESC * bufferDesc); 
#line 13064
CUresult __stdcall cuExternalMemoryGetMappedMipmappedArray(CUmipmappedArray * mipmap, CUexternalMemory extMem, const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC * mipmapDesc); 
#line 13086
CUresult __stdcall cuDestroyExternalMemory(CUexternalMemory extMem); 
#line 13243
CUresult __stdcall cuImportExternalSemaphore(CUexternalSemaphore * extSem_out, const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC * semHandleDesc); 
#line 13310
CUresult __stdcall cuSignalExternalSemaphoresAsync(const CUexternalSemaphore * extSemArray, const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS * paramsArray, unsigned numExtSems, CUstream stream); 
#line 13386
CUresult __stdcall cuWaitExternalSemaphoresAsync(const CUexternalSemaphore * extSemArray, const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS * paramsArray, unsigned numExtSems, CUstream stream); 
#line 13407
CUresult __stdcall cuDestroyExternalSemaphore(CUexternalSemaphore extSem); 
#line 13532
CUresult __stdcall cuStreamWaitValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
#line 13577
CUresult __stdcall cuStreamWaitValue64(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned flags); 
#line 13612
CUresult __stdcall cuStreamWriteValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
#line 13646
CUresult __stdcall cuStreamWriteValue64(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned flags); 
#line 13691
CUresult __stdcall cuStreamBatchMemOp(CUstream stream, unsigned count, CUstreamBatchMemOpParams * paramArray, unsigned flags); 
#line 13737
CUresult __stdcall cuStreamWaitValue32_v2(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
#line 13782
CUresult __stdcall cuStreamWaitValue64_v2(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned flags); 
#line 13811
CUresult __stdcall cuStreamWriteValue32_v2(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
#line 13842
CUresult __stdcall cuStreamWriteValue64_v2(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned flags); 
#line 13885
CUresult __stdcall cuStreamBatchMemOp_v2(CUstream stream, unsigned count, CUstreamBatchMemOpParams * paramArray, unsigned flags); 
#line 13980
CUresult __stdcall cuFuncGetAttribute(int * pi, CUfunction_attribute attrib, CUfunction hfunc); 
#line 14043
CUresult __stdcall cuFuncSetAttribute(CUfunction hfunc, CUfunction_attribute attrib, int value); 
#line 14087
CUresult __stdcall cuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config); 
#line 14139
CUresult __stdcall cuFuncSetSharedMemConfig(CUfunction hfunc, CUsharedconfig config); 
#line 14165
CUresult __stdcall cuFuncGetModule(CUmodule * hmod, CUfunction hfunc); 
#line 14274
CUresult __stdcall cuLaunchKernel(CUfunction f, unsigned gridDimX, unsigned gridDimY, unsigned gridDimZ, unsigned blockDimX, unsigned blockDimY, unsigned blockDimZ, unsigned sharedMemBytes, CUstream hStream, void ** kernelParams, void ** extra); 
#line 14457
CUresult __stdcall cuLaunchKernelEx(const CUlaunchConfig * config, CUfunction f, void ** kernelParams, void ** extra); 
#line 14538
CUresult __stdcall cuLaunchCooperativeKernel(CUfunction f, unsigned gridDimX, unsigned gridDimY, unsigned gridDimZ, unsigned blockDimX, unsigned blockDimY, unsigned blockDimZ, unsigned sharedMemBytes, CUstream hStream, void ** kernelParams); 
#line 14684
__declspec(deprecated) CUresult __stdcall cuLaunchCooperativeKernelMultiDevice(CUDA_LAUNCH_PARAMS * launchParamsList, unsigned numDevices, unsigned flags); 
#line 14749
CUresult __stdcall cuLaunchHostFunc(CUstream hStream, CUhostFn fn, void * userData); 
#line 14799
__declspec(deprecated) CUresult __stdcall cuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z); 
#line 14833
__declspec(deprecated) CUresult __stdcall cuFuncSetSharedSize(CUfunction hfunc, unsigned bytes); 
#line 14865
__declspec(deprecated) CUresult __stdcall cuParamSetSize(CUfunction hfunc, unsigned numbytes); 
#line 14898
__declspec(deprecated) CUresult __stdcall cuParamSeti(CUfunction hfunc, int offset, unsigned value); 
#line 14931
__declspec(deprecated) CUresult __stdcall cuParamSetf(CUfunction hfunc, int offset, float value); 
#line 14966
__declspec(deprecated) CUresult __stdcall cuParamSetv(CUfunction hfunc, int offset, void * ptr, unsigned numbytes); 
#line 15018
__declspec(deprecated) CUresult __stdcall cuLaunch(CUfunction f); 
#line 15072
__declspec(deprecated) CUresult __stdcall cuLaunchGrid(CUfunction f, int grid_width, int grid_height); 
#line 15134
__declspec(deprecated) CUresult __stdcall cuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream); 
#line 15159
__declspec(deprecated) CUresult __stdcall cuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef); 
#line 15205
CUresult __stdcall cuGraphCreate(CUgraph * phGraph, unsigned flags); 
#line 15305
CUresult __stdcall cuGraphAddKernelNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, const CUDA_KERNEL_NODE_PARAMS * nodeParams); 
#line 15337
CUresult __stdcall cuGraphKernelNodeGetParams(CUgraphNode hNode, CUDA_KERNEL_NODE_PARAMS * nodeParams); 
#line 15360
CUresult __stdcall cuGraphKernelNodeSetParams(CUgraphNode hNode, const CUDA_KERNEL_NODE_PARAMS * nodeParams); 
#line 15408
CUresult __stdcall cuGraphAddMemcpyNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, const CUDA_MEMCPY3D * copyParams, CUcontext ctx); 
#line 15431
CUresult __stdcall cuGraphMemcpyNodeGetParams(CUgraphNode hNode, CUDA_MEMCPY3D * nodeParams); 
#line 15454
CUresult __stdcall cuGraphMemcpyNodeSetParams(CUgraphNode hNode, const CUDA_MEMCPY3D * nodeParams); 
#line 15496
CUresult __stdcall cuGraphAddMemsetNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, const CUDA_MEMSET_NODE_PARAMS * memsetParams, CUcontext ctx); 
#line 15519
CUresult __stdcall cuGraphMemsetNodeGetParams(CUgraphNode hNode, CUDA_MEMSET_NODE_PARAMS * nodeParams); 
#line 15542
CUresult __stdcall cuGraphMemsetNodeSetParams(CUgraphNode hNode, const CUDA_MEMSET_NODE_PARAMS * nodeParams); 
#line 15583
CUresult __stdcall cuGraphAddHostNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, const CUDA_HOST_NODE_PARAMS * nodeParams); 
#line 15606
CUresult __stdcall cuGraphHostNodeGetParams(CUgraphNode hNode, CUDA_HOST_NODE_PARAMS * nodeParams); 
#line 15629
CUresult __stdcall cuGraphHostNodeSetParams(CUgraphNode hNode, const CUDA_HOST_NODE_PARAMS * nodeParams); 
#line 15669
CUresult __stdcall cuGraphAddChildGraphNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, CUgraph childGraph); 
#line 15696
CUresult __stdcall cuGraphChildGraphNodeGetGraph(CUgraphNode hNode, CUgraph * phGraph); 
#line 15734
CUresult __stdcall cuGraphAddEmptyNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies); 
#line 15775
CUresult __stdcall cuGraphAddEventRecordNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, CUevent event); 
#line 15800
CUresult __stdcall cuGraphEventRecordNodeGetEvent(CUgraphNode hNode, CUevent * event_out); 
#line 15825
CUresult __stdcall cuGraphEventRecordNodeSetEvent(CUgraphNode hNode, CUevent event); 
#line 15867
CUresult __stdcall cuGraphAddEventWaitNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, CUevent event); 
#line 15892
CUresult __stdcall cuGraphEventWaitNodeGetEvent(CUgraphNode hNode, CUevent * event_out); 
#line 15917
CUresult __stdcall cuGraphEventWaitNodeSetEvent(CUgraphNode hNode, CUevent event); 
#line 15965
CUresult __stdcall cuGraphAddExternalSemaphoresSignalNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS * nodeParams); 
#line 15996
CUresult __stdcall cuGraphExternalSemaphoresSignalNodeGetParams(CUgraphNode hNode, CUDA_EXT_SEM_SIGNAL_NODE_PARAMS * params_out); 
#line 16021
CUresult __stdcall cuGraphExternalSemaphoresSignalNodeSetParams(CUgraphNode hNode, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS * nodeParams); 
#line 16069
CUresult __stdcall cuGraphAddExternalSemaphoresWaitNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, const CUDA_EXT_SEM_WAIT_NODE_PARAMS * nodeParams); 
#line 16100
CUresult __stdcall cuGraphExternalSemaphoresWaitNodeGetParams(CUgraphNode hNode, CUDA_EXT_SEM_WAIT_NODE_PARAMS * params_out); 
#line 16125
CUresult __stdcall cuGraphExternalSemaphoresWaitNodeSetParams(CUgraphNode hNode, const CUDA_EXT_SEM_WAIT_NODE_PARAMS * nodeParams); 
#line 16180
CUresult __stdcall cuGraphAddBatchMemOpNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, const CUDA_BATCH_MEM_OP_NODE_PARAMS * nodeParams); 
#line 16208
CUresult __stdcall cuGraphBatchMemOpNodeGetParams(CUgraphNode hNode, CUDA_BATCH_MEM_OP_NODE_PARAMS * nodeParams_out); 
#line 16234
CUresult __stdcall cuGraphBatchMemOpNodeSetParams(CUgraphNode hNode, const CUDA_BATCH_MEM_OP_NODE_PARAMS * nodeParams); 
#line 16280
CUresult __stdcall cuGraphExecBatchMemOpNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_BATCH_MEM_OP_NODE_PARAMS * nodeParams); 
#line 16354
CUresult __stdcall cuGraphAddMemAllocNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, CUDA_MEM_ALLOC_NODE_PARAMS * nodeParams); 
#line 16379
CUresult __stdcall cuGraphMemAllocNodeGetParams(CUgraphNode hNode, CUDA_MEM_ALLOC_NODE_PARAMS * params_out); 
#line 16436
CUresult __stdcall cuGraphAddMemFreeNode(CUgraphNode * phGraphNode, CUgraph hGraph, const CUgraphNode * dependencies, size_t numDependencies, CUdeviceptr dptr); 
#line 16458
CUresult __stdcall cuGraphMemFreeNodeGetParams(CUgraphNode hNode, CUdeviceptr * dptr_out); 
#line 16478
CUresult __stdcall cuDeviceGraphMemTrim(CUdevice device); 
#line 16506
CUresult __stdcall cuDeviceGetGraphMemAttribute(CUdevice device, CUgraphMem_attribute attr, void * value); 
#line 16531
CUresult __stdcall cuDeviceSetGraphMemAttribute(CUdevice device, CUgraphMem_attribute attr, void * value); 
#line 16556
CUresult __stdcall cuGraphClone(CUgraph * phGraphClone, CUgraph originalGraph); 
#line 16582
CUresult __stdcall cuGraphNodeFindInClone(CUgraphNode * phNode, CUgraphNode hOriginalNode, CUgraph hClonedGraph); 
#line 16613
CUresult __stdcall cuGraphNodeGetType(CUgraphNode hNode, CUgraphNodeType * type); 
#line 16644
CUresult __stdcall cuGraphGetNodes(CUgraph hGraph, CUgraphNode * nodes, size_t * numNodes); 
#line 16675
CUresult __stdcall cuGraphGetRootNodes(CUgraph hGraph, CUgraphNode * rootNodes, size_t * numRootNodes); 
#line 16709
CUresult __stdcall cuGraphGetEdges(CUgraph hGraph, CUgraphNode * from, CUgraphNode * to, size_t * numEdges); 
#line 16740
CUresult __stdcall cuGraphNodeGetDependencies(CUgraphNode hNode, CUgraphNode * dependencies, size_t * numDependencies); 
#line 16772
CUresult __stdcall cuGraphNodeGetDependentNodes(CUgraphNode hNode, CUgraphNode * dependentNodes, size_t * numDependentNodes); 
#line 16801
CUresult __stdcall cuGraphAddDependencies(CUgraph hGraph, const CUgraphNode * from, const CUgraphNode * to, size_t numDependencies); 
#line 16833
CUresult __stdcall cuGraphRemoveDependencies(CUgraph hGraph, const CUgraphNode * from, const CUgraphNode * to, size_t numDependencies); 
#line 16860
CUresult __stdcall cuGraphDestroyNode(CUgraphNode hNode); 
#line 16898
CUresult __stdcall cuGraphInstantiate_v2(CUgraphExec * phGraphExec, CUgraph hGraph, CUgraphNode * phErrorNode, char * logBuffer, size_t bufferSize); 
#line 16945
CUresult __stdcall cuGraphInstantiateWithFlags(CUgraphExec * phGraphExec, CUgraph hGraph, unsigned __int64 flags); 
#line 16989
CUresult __stdcall cuGraphExecKernelNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_KERNEL_NODE_PARAMS * nodeParams); 
#line 17035
CUresult __stdcall cuGraphExecMemcpyNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_MEMCPY3D * copyParams, CUcontext ctx); 
#line 17081
CUresult __stdcall cuGraphExecMemsetNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_MEMSET_NODE_PARAMS * memsetParams, CUcontext ctx); 
#line 17118
CUresult __stdcall cuGraphExecHostNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_HOST_NODE_PARAMS * nodeParams); 
#line 17161
CUresult __stdcall cuGraphExecChildGraphNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, CUgraph childGraph); 
#line 17201
CUresult __stdcall cuGraphExecEventRecordNodeSetEvent(CUgraphExec hGraphExec, CUgraphNode hNode, CUevent event); 
#line 17241
CUresult __stdcall cuGraphExecEventWaitNodeSetEvent(CUgraphExec hGraphExec, CUgraphNode hNode, CUevent event); 
#line 17284
CUresult __stdcall cuGraphExecExternalSemaphoresSignalNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS * nodeParams); 
#line 17327
CUresult __stdcall cuGraphExecExternalSemaphoresWaitNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_EXT_SEM_WAIT_NODE_PARAMS * nodeParams); 
#line 17363
CUresult __stdcall cuGraphNodeSetEnabled(CUgraphExec hGraphExec, CUgraphNode hNode, unsigned isEnabled); 
#line 17393
CUresult __stdcall cuGraphNodeGetEnabled(CUgraphExec hGraphExec, CUgraphNode hNode, unsigned * isEnabled); 
#line 17419
CUresult __stdcall cuGraphUpload(CUgraphExec hGraphExec, CUstream hStream); 
#line 17449
CUresult __stdcall cuGraphLaunch(CUgraphExec hGraphExec, CUstream hStream); 
#line 17474
CUresult __stdcall cuGraphExecDestroy(CUgraphExec hGraphExec); 
#line 17494
CUresult __stdcall cuGraphDestroy(CUgraph hGraph); 
#line 17573
CUresult __stdcall cuGraphExecUpdate(CUgraphExec hGraphExec, CUgraph hGraph, CUgraphNode * hErrorNode_out, CUgraphExecUpdateResult * updateResult_out); 
#line 17593
CUresult __stdcall cuGraphKernelNodeCopyAttributes(CUgraphNode dst, CUgraphNode src); 
#line 17614
CUresult __stdcall cuGraphKernelNodeGetAttribute(CUgraphNode hNode, CUkernelNodeAttrID attr, CUkernelNodeAttrValue * value_out); 
#line 17636
CUresult __stdcall cuGraphKernelNodeSetAttribute(CUgraphNode hNode, CUkernelNodeAttrID attr, const CUkernelNodeAttrValue * value); 
#line 17656
CUresult __stdcall cuGraphDebugDotPrint(CUgraph hGraph, const char * path, unsigned flags); 
#line 17692
CUresult __stdcall cuUserObjectCreate(CUuserObject * object_out, void * ptr, CUhostFn destroy, unsigned initialRefcount, unsigned flags); 
#line 17717
CUresult __stdcall cuUserObjectRetain(CUuserObject object, unsigned count); 
#line 17745
CUresult __stdcall cuUserObjectRelease(CUuserObject object, unsigned count); 
#line 17773
CUresult __stdcall cuGraphRetainUserObject(CUgraph graph, CUuserObject object, unsigned count, unsigned flags); 
#line 17798
CUresult __stdcall cuGraphReleaseUserObject(CUgraph graph, CUuserObject object, unsigned count); 
#line 17837
CUresult __stdcall cuOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize); 
#line 17879
CUresult __stdcall cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
#line 17931
CUresult __stdcall cuOccupancyMaxPotentialBlockSize(int * minGridSize, int * blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit); 
#line 17977
CUresult __stdcall cuOccupancyMaxPotentialBlockSizeWithFlags(int * minGridSize, int * blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned flags); 
#line 18000
CUresult __stdcall cuOccupancyAvailableDynamicSMemPerBlock(size_t * dynamicSmemSize, CUfunction func, int numBlocks, int blockSize); 
#line 18035
CUresult __stdcall cuOccupancyMaxPotentialClusterSize(int * clusterSize, CUfunction func, const CUlaunchConfig * config); 
#line 18072
CUresult __stdcall cuOccupancyMaxActiveClusters(int * numClusters, CUfunction func, const CUlaunchConfig * config); 
#line 18117
__declspec(deprecated) CUresult __stdcall cuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned Flags); 
#line 18148
__declspec(deprecated) CUresult __stdcall cuTexRefSetMipmappedArray(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, unsigned Flags); 
#line 18195
__declspec(deprecated) CUresult __stdcall cuTexRefSetAddress_v2(size_t * ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes); 
#line 18251
__declspec(deprecated) CUresult __stdcall cuTexRefSetAddress2D_v3(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR * desc, CUdeviceptr dptr, size_t Pitch); 
#line 18287
__declspec(deprecated) CUresult __stdcall cuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents); 
#line 18334
__declspec(deprecated) CUresult __stdcall cuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am); 
#line 18371
__declspec(deprecated) CUresult __stdcall cuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm); 
#line 18408
__declspec(deprecated) CUresult __stdcall cuTexRefSetMipmapFilterMode(CUtexref hTexRef, CUfilter_mode fm); 
#line 18438
__declspec(deprecated) CUresult __stdcall cuTexRefSetMipmapLevelBias(CUtexref hTexRef, float bias); 
#line 18470
__declspec(deprecated) CUresult __stdcall cuTexRefSetMipmapLevelClamp(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp); 
#line 18501
__declspec(deprecated) CUresult __stdcall cuTexRefSetMaxAnisotropy(CUtexref hTexRef, unsigned maxAniso); 
#line 18538
__declspec(deprecated) CUresult __stdcall cuTexRefSetBorderColor(CUtexref hTexRef, float * pBorderColor); 
#line 18584
__declspec(deprecated) CUresult __stdcall cuTexRefSetFlags(CUtexref hTexRef, unsigned Flags); 
#line 18611
__declspec(deprecated) CUresult __stdcall cuTexRefGetAddress_v2(CUdeviceptr * pdptr, CUtexref hTexRef); 
#line 18638
__declspec(deprecated) CUresult __stdcall cuTexRefGetArray(CUarray * phArray, CUtexref hTexRef); 
#line 18665
__declspec(deprecated) CUresult __stdcall cuTexRefGetMipmappedArray(CUmipmappedArray * phMipmappedArray, CUtexref hTexRef); 
#line 18693
__declspec(deprecated) CUresult __stdcall cuTexRefGetAddressMode(CUaddress_mode * pam, CUtexref hTexRef, int dim); 
#line 18719
__declspec(deprecated) CUresult __stdcall cuTexRefGetFilterMode(CUfilter_mode * pfm, CUtexref hTexRef); 
#line 18747
__declspec(deprecated) CUresult __stdcall cuTexRefGetFormat(CUarray_format * pFormat, int * pNumChannels, CUtexref hTexRef); 
#line 18773
__declspec(deprecated) CUresult __stdcall cuTexRefGetMipmapFilterMode(CUfilter_mode * pfm, CUtexref hTexRef); 
#line 18799
__declspec(deprecated) CUresult __stdcall cuTexRefGetMipmapLevelBias(float * pbias, CUtexref hTexRef); 
#line 18826
__declspec(deprecated) CUresult __stdcall cuTexRefGetMipmapLevelClamp(float * pminMipmapLevelClamp, float * pmaxMipmapLevelClamp, CUtexref hTexRef); 
#line 18852
__declspec(deprecated) CUresult __stdcall cuTexRefGetMaxAnisotropy(int * pmaxAniso, CUtexref hTexRef); 
#line 18881
__declspec(deprecated) CUresult __stdcall cuTexRefGetBorderColor(float * pBorderColor, CUtexref hTexRef); 
#line 18906
__declspec(deprecated) CUresult __stdcall cuTexRefGetFlags(unsigned * pFlags, CUtexref hTexRef); 
#line 18931
__declspec(deprecated) CUresult __stdcall cuTexRefCreate(CUtexref * pTexRef); 
#line 18951
__declspec(deprecated) CUresult __stdcall cuTexRefDestroy(CUtexref hTexRef); 
#line 18995
__declspec(deprecated) CUresult __stdcall cuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned Flags); 
#line 19018
__declspec(deprecated) CUresult __stdcall cuSurfRefGetArray(CUarray * phArray, CUsurfref hSurfRef); 
#line 19258
CUresult __stdcall cuTexObjectCreate(CUtexObject * pTexObject, const CUDA_RESOURCE_DESC * pResDesc, const CUDA_TEXTURE_DESC * pTexDesc, const CUDA_RESOURCE_VIEW_DESC * pResViewDesc); 
#line 19278
CUresult __stdcall cuTexObjectDestroy(CUtexObject texObject); 
#line 19299
CUresult __stdcall cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUtexObject texObject); 
#line 19320
CUresult __stdcall cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC * pTexDesc, CUtexObject texObject); 
#line 19342
CUresult __stdcall cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC * pResViewDesc, CUtexObject texObject); 
#line 19385
CUresult __stdcall cuSurfObjectCreate(CUsurfObject * pSurfObject, const CUDA_RESOURCE_DESC * pResDesc); 
#line 19405
CUresult __stdcall cuSurfObjectDestroy(CUsurfObject surfObject); 
#line 19426
CUresult __stdcall cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUsurfObject surfObject); 
#line 19468
CUresult __stdcall cuDeviceCanAccessPeer(int * canAccessPeer, CUdevice dev, CUdevice peerDev); 
#line 19521
CUresult __stdcall cuCtxEnablePeerAccess(CUcontext peerContext, unsigned Flags); 
#line 19548
CUresult __stdcall cuCtxDisablePeerAccess(CUcontext peerContext); 
#line 19588
CUresult __stdcall cuDeviceGetP2PAttribute(int * value, CUdevice_P2PAttribute attrib, CUdevice srcDevice, CUdevice dstDevice); 
#line 19632
CUresult __stdcall cuGraphicsUnregisterResource(CUgraphicsResource resource); 
#line 19672
CUresult __stdcall cuGraphicsSubResourceGetMappedArray(CUarray * pArray, CUgraphicsResource resource, unsigned arrayIndex, unsigned mipLevel); 
#line 19703
CUresult __stdcall cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray * pMipmappedArray, CUgraphicsResource resource); 
#line 19737
CUresult __stdcall cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr * pDevPtr, size_t * pSize, CUgraphicsResource resource); 
#line 19778
CUresult __stdcall cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource resource, unsigned flags); 
#line 19818
CUresult __stdcall cuGraphicsMapResources(unsigned count, CUgraphicsResource * resources, CUstream hStream); 
#line 19855
CUresult __stdcall cuGraphicsUnmapResources(unsigned count, CUgraphicsResource * resources, CUstream hStream); 
#line 19921
CUresult __stdcall cuGetProcAddress(const char * symbol, void ** pfn, int cudaVersion, cuuint64_t flags); 
#line 19925
CUresult __stdcall cuGetExportTable(const void ** ppExportTable, const CUuuid * pExportTableId); 
#line 20284 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
}
#line 14 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#pragma external_header(push)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\climits"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdio"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 16
__pragma( pack ( push, 8 )) extern "C" {
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
__declspec(noinline) __inline unsigned __int64 *__cdecl __local_stdio_printf_options() 
#line 90
{ 
#line 91
static unsigned __int64 _OptionsStorage; 
#line 92
return &_OptionsStorage; 
#line 93
} 
#line 99
__declspec(noinline) __inline unsigned __int64 *__cdecl __local_stdio_scanf_options() 
#line 100
{ 
#line 101
static unsigned __int64 _OptionsStorage; 
#line 102
return &_OptionsStorage; 
#line 103
} 
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
}__pragma( pack ( pop )) 
#line 131
#pragma warning(pop)
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 31
typedef 
#line 28
struct _iobuf { 
#line 30
void *_Placeholder; 
#line 31
} FILE; 
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
FILE *__cdecl __acrt_iob_func(unsigned _Ix); 
#line 51
wint_t __cdecl fgetwc(FILE * _Stream); 
#line 56
wint_t __cdecl _fgetwchar(); 
#line 59
wint_t __cdecl fputwc(__wchar_t _Character, FILE * _Stream); 
#line 64
wint_t __cdecl _fputwchar(__wchar_t _Character); 
#line 69
wint_t __cdecl getwc(FILE * _Stream); 
#line 74
wint_t __cdecl getwchar(); 
#line 79
__wchar_t *__cdecl fgetws(__wchar_t * _Buffer, int _BufferCount, FILE * _Stream); 
#line 86
int __cdecl fputws(const __wchar_t * _Buffer, FILE * _Stream); 
#line 93
__wchar_t *__cdecl _getws_s(__wchar_t * _Buffer, size_t _BufferCount); 
#line 98
extern "C++" {template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _getws_s ( _Buffer, _Size ); }}
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
wint_t __cdecl putwc(__wchar_t _Character, FILE * _Stream); 
#line 111
wint_t __cdecl putwchar(__wchar_t _Character); 
#line 116
int __cdecl _putws(const __wchar_t * _Buffer); 
#line 121
wint_t __cdecl ungetwc(wint_t _Character, FILE * _Stream); 
#line 127
FILE *__cdecl _wfdopen(int _FileHandle, const __wchar_t * _Mode); 
#line 133
FILE *__cdecl _wfopen(const __wchar_t * _FileName, const __wchar_t * _Mode); 
#line 139
errno_t __cdecl _wfopen_s(FILE ** _Stream, const __wchar_t * _FileName, const __wchar_t * _Mode); 
#line 147
FILE *__cdecl _wfreopen(const __wchar_t * _FileName, const __wchar_t * _Mode, FILE * _OldStream); 
#line 154
errno_t __cdecl _wfreopen_s(FILE ** _Stream, const __wchar_t * _FileName, const __wchar_t * _Mode, FILE * _OldStream); 
#line 162
FILE *__cdecl _wfsopen(const __wchar_t * _FileName, const __wchar_t * _Mode, int _ShFlag); 
#line 168
void __cdecl _wperror(const __wchar_t * _ErrorMessage); 
#line 175
FILE *__cdecl _wpopen(const __wchar_t * _Command, const __wchar_t * _Mode); 
#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
int __cdecl _wremove(const __wchar_t * _FileName); 
#line 190
__declspec(allocator) __wchar_t *__cdecl _wtempnam(const __wchar_t * _Directory, const __wchar_t * _FilePrefix); 
#line 199
errno_t __cdecl _wtmpnam_s(__wchar_t * _Buffer, size_t _BufferCount); 
#line 204
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wtmpnam_s ( _Buffer, _Size ); }}
#line 210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__wchar_t *__cdecl _wtmpnam(__wchar_t * _Buffer); 
#line 224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
wint_t __cdecl _fgetwc_nolock(FILE * _Stream); 
#line 229
wint_t __cdecl _fputwc_nolock(__wchar_t _Character, FILE * _Stream); 
#line 235
wint_t __cdecl _getwc_nolock(FILE * _Stream); 
#line 240
wint_t __cdecl _putwc_nolock(__wchar_t _Character, FILE * _Stream); 
#line 246
wint_t __cdecl _ungetwc_nolock(wint_t _Character, FILE * _Stream); 
#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
int __cdecl __stdio_common_vfwprintf(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 281
int __cdecl __stdio_common_vfwprintf_s(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 290
int __cdecl __stdio_common_vfwprintf_p(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 299
__inline int __cdecl _vfwprintf_l(FILE *const 
#line 300
_Stream, const __wchar_t *const 
#line 301
_Format, const _locale_t 
#line 302
_Locale, va_list 
#line 303
_ArgList) 
#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 309
return __stdio_common_vfwprintf(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 310
} 
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwprintf(FILE *const 
#line 315
_Stream, const __wchar_t *const 
#line 316
_Format, va_list 
#line 317
_ArgList) 
#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 323
return _vfwprintf_l(_Stream, _Format, 0, _ArgList); 
#line 324
} 
#line 328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_s_l(FILE *const 
#line 329
_Stream, const __wchar_t *const 
#line 330
_Format, const _locale_t 
#line 331
_Locale, va_list 
#line 332
_ArgList) 
#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 338
return __stdio_common_vfwprintf_s(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 339
} 
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwprintf_s(FILE *const 
#line 346
_Stream, const __wchar_t *const 
#line 347
_Format, va_list 
#line 348
_ArgList) 
#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 354
return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 355
} 
#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_p_l(FILE *const 
#line 362
_Stream, const __wchar_t *const 
#line 363
_Format, const _locale_t 
#line 364
_Locale, va_list 
#line 365
_ArgList) 
#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 371
return __stdio_common_vfwprintf_p(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 372
} 
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_p(FILE *const 
#line 377
_Stream, const __wchar_t *const 
#line 378
_Format, va_list 
#line 379
_ArgList) 
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 385
return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 386
} 
#line 390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_l(const __wchar_t *const 
#line 391
_Format, const _locale_t 
#line 392
_Locale, va_list 
#line 393
_ArgList) 
#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 399
return _vfwprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 400
} 
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwprintf(const __wchar_t *const 
#line 405
_Format, va_list 
#line 406
_ArgList) 
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 412
return _vfwprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 413
} 
#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_s_l(const __wchar_t *const 
#line 418
_Format, const _locale_t 
#line 419
_Locale, va_list 
#line 420
_ArgList) 
#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 426
return _vfwprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 427
} 
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwprintf_s(const __wchar_t *const 
#line 434
_Format, va_list 
#line 435
_ArgList) 
#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 441
return _vfwprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 442
} 
#line 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_p_l(const __wchar_t *const 
#line 449
_Format, const _locale_t 
#line 450
_Locale, va_list 
#line 451
_ArgList) 
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 457
return _vfwprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 458
} 
#line 462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_p(const __wchar_t *const 
#line 463
_Format, va_list 
#line 464
_ArgList) 
#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 470
return _vfwprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 471
} 
#line 475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_l(FILE *const 
#line 476
_Stream, const __wchar_t *const 
#line 477
_Format, const _locale_t 
#line 478
_Locale, ...) 
#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 484
int _Result; 
#line 485
va_list _ArgList; 
#line 486
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 487
_Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList); 
#line 488
(void)(_ArgList = ((va_list)0)); 
#line 489
return _Result; 
#line 490
} 
#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwprintf(FILE *const 
#line 495
_Stream, const __wchar_t *const 
#line 496
_Format, ...) 
#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 502
int _Result; 
#line 503
va_list _ArgList; 
#line 504
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 505
_Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList); 
#line 506
(void)(_ArgList = ((va_list)0)); 
#line 507
return _Result; 
#line 508
} 
#line 512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_s_l(FILE *const 
#line 513
_Stream, const __wchar_t *const 
#line 514
_Format, const _locale_t 
#line 515
_Locale, ...) 
#line 520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 521
int _Result; 
#line 522
va_list _ArgList; 
#line 523
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 524
_Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 525
(void)(_ArgList = ((va_list)0)); 
#line 526
return _Result; 
#line 527
} 
#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwprintf_s(FILE *const 
#line 534
_Stream, const __wchar_t *const 
#line 535
_Format, ...) 
#line 540 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 541
int _Result; 
#line 542
va_list _ArgList; 
#line 543
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 544
_Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 545
(void)(_ArgList = ((va_list)0)); 
#line 546
return _Result; 
#line 547
} 
#line 553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_p_l(FILE *const 
#line 554
_Stream, const __wchar_t *const 
#line 555
_Format, const _locale_t 
#line 556
_Locale, ...) 
#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 562
int _Result; 
#line 563
va_list _ArgList; 
#line 564
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 565
_Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList); 
#line 566
(void)(_ArgList = ((va_list)0)); 
#line 567
return _Result; 
#line 568
} 
#line 572 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_p(FILE *const 
#line 573
_Stream, const __wchar_t *const 
#line 574
_Format, ...) 
#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 580
int _Result; 
#line 581
va_list _ArgList; 
#line 582
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 583
_Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 584
(void)(_ArgList = ((va_list)0)); 
#line 585
return _Result; 
#line 586
} 
#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_l(const __wchar_t *const 
#line 591
_Format, const _locale_t 
#line 592
_Locale, ...) 
#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 598
int _Result; 
#line 599
va_list _ArgList; 
#line 600
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 601
_Result = _vfwprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 602
(void)(_ArgList = ((va_list)0)); 
#line 603
return _Result; 
#line 604
} 
#line 608 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wprintf(const __wchar_t *const 
#line 609
_Format, ...) 
#line 614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 615
int _Result; 
#line 616
va_list _ArgList; 
#line 617
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 618
_Result = _vfwprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 619
(void)(_ArgList = ((va_list)0)); 
#line 620
return _Result; 
#line 621
} 
#line 625 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_s_l(const __wchar_t *const 
#line 626
_Format, const _locale_t 
#line 627
_Locale, ...) 
#line 632 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 633
int _Result; 
#line 634
va_list _ArgList; 
#line 635
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 636
_Result = _vfwprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 637
(void)(_ArgList = ((va_list)0)); 
#line 638
return _Result; 
#line 639
} 
#line 645 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wprintf_s(const __wchar_t *const 
#line 646
_Format, ...) 
#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 652
int _Result; 
#line 653
va_list _ArgList; 
#line 654
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 655
_Result = _vfwprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 656
(void)(_ArgList = ((va_list)0)); 
#line 657
return _Result; 
#line 658
} 
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_p_l(const __wchar_t *const 
#line 665
_Format, const _locale_t 
#line 666
_Locale, ...) 
#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 672
int _Result; 
#line 673
va_list _ArgList; 
#line 674
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 675
_Result = _vfwprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 676
(void)(_ArgList = ((va_list)0)); 
#line 677
return _Result; 
#line 678
} 
#line 682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_p(const __wchar_t *const 
#line 683
_Format, ...) 
#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 689
int _Result; 
#line 690
va_list _ArgList; 
#line 691
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 692
_Result = _vfwprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 693
(void)(_ArgList = ((va_list)0)); 
#line 694
return _Result; 
#line 695
} 
#line 705 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
int __cdecl __stdio_common_vfwscanf(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 714
__inline int __cdecl _vfwscanf_l(FILE *const 
#line 715
_Stream, const __wchar_t *const 
#line 716
_Format, const _locale_t 
#line 717
_Locale, va_list 
#line 718
_ArgList) 
#line 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 724
return __stdio_common_vfwscanf(*__local_stdio_scanf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 727
} 
#line 731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwscanf(FILE *const 
#line 732
_Stream, const __wchar_t *const 
#line 733
_Format, va_list 
#line 734
_ArgList) 
#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 740
return _vfwscanf_l(_Stream, _Format, 0, _ArgList); 
#line 741
} 
#line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwscanf_s_l(FILE *const 
#line 746
_Stream, const __wchar_t *const 
#line 747
_Format, const _locale_t 
#line 748
_Locale, va_list 
#line 749
_ArgList) 
#line 754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 755
return __stdio_common_vfwscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Stream, _Format, _Locale, _ArgList); 
#line 758
} 
#line 764 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwscanf_s(FILE *const 
#line 765
_Stream, const __wchar_t *const 
#line 766
_Format, va_list 
#line 767
_ArgList) 
#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 773
return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 774
} 
#line 779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwscanf_l(const __wchar_t *const 
#line 780
_Format, const _locale_t 
#line 781
_Locale, va_list 
#line 782
_ArgList) 
#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 788
return _vfwscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 789
} 
#line 793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwscanf(const __wchar_t *const 
#line 794
_Format, va_list 
#line 795
_ArgList) 
#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 801
return _vfwscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 802
} 
#line 806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwscanf_s_l(const __wchar_t *const 
#line 807
_Format, const _locale_t 
#line 808
_Locale, va_list 
#line 809
_ArgList) 
#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 815
return _vfwscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 816
} 
#line 822 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwscanf_s(const __wchar_t *const 
#line 823
_Format, va_list 
#line 824
_ArgList) 
#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 830
return _vfwscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 831
} 
#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwscanf_l(FILE *const 
#line 838
_Stream, const __wchar_t *const 
#line 839
_Format, const _locale_t 
#line 840
_Locale, ...) 
#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 846
int _Result; 
#line 847
va_list _ArgList; 
#line 848
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 849
_Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList); 
#line 850
(void)(_ArgList = ((va_list)0)); 
#line 851
return _Result; 
#line 852
} 
#line 856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwscanf(FILE *const 
#line 857
_Stream, const __wchar_t *const 
#line 858
_Format, ...) 
#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 864
int _Result; 
#line 865
va_list _ArgList; 
#line 866
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 867
_Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList); 
#line 868
(void)(_ArgList = ((va_list)0)); 
#line 869
return _Result; 
#line 870
} 
#line 874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwscanf_s_l(FILE *const 
#line 875
_Stream, const __wchar_t *const 
#line 876
_Format, const _locale_t 
#line 877
_Locale, ...) 
#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 883
int _Result; 
#line 884
va_list _ArgList; 
#line 885
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 886
_Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 887
(void)(_ArgList = ((va_list)0)); 
#line 888
return _Result; 
#line 889
} 
#line 895 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwscanf_s(FILE *const 
#line 896
_Stream, const __wchar_t *const 
#line 897
_Format, ...) 
#line 902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 903
int _Result; 
#line 904
va_list _ArgList; 
#line 905
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 906
_Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 907
(void)(_ArgList = ((va_list)0)); 
#line 908
return _Result; 
#line 909
} 
#line 915 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wscanf_l(const __wchar_t *const 
#line 916
_Format, const _locale_t 
#line 917
_Locale, ...) 
#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 923
int _Result; 
#line 924
va_list _ArgList; 
#line 925
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 926
_Result = _vfwscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 927
(void)(_ArgList = ((va_list)0)); 
#line 928
return _Result; 
#line 929
} 
#line 933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wscanf(const __wchar_t *const 
#line 934
_Format, ...) 
#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 940
int _Result; 
#line 941
va_list _ArgList; 
#line 942
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 943
_Result = _vfwscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 944
(void)(_ArgList = ((va_list)0)); 
#line 945
return _Result; 
#line 946
} 
#line 950 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wscanf_s_l(const __wchar_t *const 
#line 951
_Format, const _locale_t 
#line 952
_Locale, ...) 
#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 958
int _Result; 
#line 959
va_list _ArgList; 
#line 960
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 961
_Result = _vfwscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 962
(void)(_ArgList = ((va_list)0)); 
#line 963
return _Result; 
#line 964
} 
#line 970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wscanf_s(const __wchar_t *const 
#line 971
_Format, ...) 
#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 977
int _Result; 
#line 978
va_list _ArgList; 
#line 979
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 980
_Result = _vfwscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 981
(void)(_ArgList = ((va_list)0)); 
#line 982
return _Result; 
#line 983
} 
#line 1006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
int __cdecl __stdio_common_vswprintf(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1017
int __cdecl __stdio_common_vswprintf_s(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1028
int __cdecl __stdio_common_vsnwprintf_s(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1040
int __cdecl __stdio_common_vswprintf_p(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1051
__inline int __cdecl _vsnwprintf_l(__wchar_t *const 
#line 1052
_Buffer, const size_t 
#line 1053
_BufferCount, const __wchar_t *const 
#line 1054
_Format, const _locale_t 
#line 1055
_Locale, va_list 
#line 1056
_ArgList) 
#line 1061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1062
const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1066
return (_Result < 0) ? -1 : _Result; 
#line 1067
} 
#line 1072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwprintf_s_l(__wchar_t *const 
#line 1073
_Buffer, const size_t 
#line 1074
_BufferCount, const size_t 
#line 1075
_MaxCount, const __wchar_t *const 
#line 1076
_Format, const _locale_t 
#line 1077
_Locale, va_list 
#line 1078
_ArgList) 
#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1084
const int _Result = __stdio_common_vsnwprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1088
return (_Result < 0) ? -1 : _Result; 
#line 1089
} 
#line 1094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwprintf_s(__wchar_t *const 
#line 1095
_Buffer, const size_t 
#line 1096
_BufferCount, const size_t 
#line 1097
_MaxCount, const __wchar_t *const 
#line 1098
_Format, va_list 
#line 1099
_ArgList) 
#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1105
return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1106
} 
#line 1109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, ...); __inline int __cdecl _vsnwprintf(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, va_list _Args); 
#line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwprintf(__wchar_t *
#line 1121
_Buffer, size_t 
#line 1122
_BufferCount, const __wchar_t *
#line 1123
_Format, va_list 
#line 1124
_ArgList) 
#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1130
return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1131
} 
#line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Buffer ) [ _Size ], size_t _BufferCount, wchar_t const * _Format, va_list _ArgList ) throw ( ) { return _vsnwprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_c_l(__wchar_t *const 
#line 1146
_Buffer, const size_t 
#line 1147
_BufferCount, const __wchar_t *const 
#line 1148
_Format, const _locale_t 
#line 1149
_Locale, va_list 
#line 1150
_ArgList) 
#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1156
const int _Result = __stdio_common_vswprintf(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1160
return (_Result < 0) ? -1 : _Result; 
#line 1161
} 
#line 1166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_c(__wchar_t *const 
#line 1167
_Buffer, const size_t 
#line 1168
_BufferCount, const __wchar_t *const 
#line 1169
_Format, va_list 
#line 1170
_ArgList) 
#line 1175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1176
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1177
} 
#line 1182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_l(__wchar_t *const 
#line 1183
_Buffer, const size_t 
#line 1184
_BufferCount, const __wchar_t *const 
#line 1185
_Format, const _locale_t 
#line 1186
_Locale, va_list 
#line 1187
_ArgList) 
#line 1192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1193
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1194
} 
#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __vswprintf_l(__wchar_t *const 
#line 1200
_Buffer, const __wchar_t *const 
#line 1201
_Format, const _locale_t 
#line 1202
_Locale, va_list 
#line 1203
_ArgList) 
#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1209
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1210
} 
#line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf(__wchar_t *const 
#line 1216
_Buffer, const __wchar_t *const 
#line 1217
_Format, va_list 
#line 1218
_ArgList) 
#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1224
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, 0, _ArgList); 
#line 1225
} 
#line 1230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswprintf(__wchar_t *const 
#line 1231
_Buffer, const size_t 
#line 1232
_BufferCount, const __wchar_t *const 
#line 1233
_Format, va_list 
#line 1234
_ArgList) 
#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1240
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1241
} 
#line 1246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_s_l(__wchar_t *const 
#line 1247
_Buffer, const size_t 
#line 1248
_BufferCount, const __wchar_t *const 
#line 1249
_Format, const _locale_t 
#line 1250
_Locale, va_list 
#line 1251
_ArgList) 
#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1257
const int _Result = __stdio_common_vswprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1261
return (_Result < 0) ? -1 : _Result; 
#line 1262
} 
#line 1268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswprintf_s(__wchar_t *const 
#line 1269
_Buffer, const size_t 
#line 1270
_BufferCount, const __wchar_t *const 
#line 1271
_Format, va_list 
#line 1272
_ArgList) 
#line 1277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1278
return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1279
} 
#line 1284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, va_list _ArgList ) throw ( ) { return vswprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1294 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_p_l(__wchar_t *const 
#line 1295
_Buffer, const size_t 
#line 1296
_BufferCount, const __wchar_t *const 
#line 1297
_Format, const _locale_t 
#line 1298
_Locale, va_list 
#line 1299
_ArgList) 
#line 1304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1305
const int _Result = __stdio_common_vswprintf_p(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1309
return (_Result < 0) ? -1 : _Result; 
#line 1310
} 
#line 1315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_p(__wchar_t *const 
#line 1316
_Buffer, const size_t 
#line 1317
_BufferCount, const __wchar_t *const 
#line 1318
_Format, va_list 
#line 1319
_ArgList) 
#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1325
return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1326
} 
#line 1331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_l(const __wchar_t *const 
#line 1332
_Format, const _locale_t 
#line 1333
_Locale, va_list 
#line 1334
_ArgList) 
#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1340
const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1344
return (_Result < 0) ? -1 : _Result; 
#line 1345
} 
#line 1350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf(const __wchar_t *const 
#line 1351
_Format, va_list 
#line 1352
_ArgList) 
#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1358
return _vscwprintf_l(_Format, 0, _ArgList); 
#line 1359
} 
#line 1364 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_p_l(const __wchar_t *const 
#line 1365
_Format, const _locale_t 
#line 1366
_Locale, va_list 
#line 1367
_ArgList) 
#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1373
const int _Result = __stdio_common_vswprintf_p((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1377
return (_Result < 0) ? -1 : _Result; 
#line 1378
} 
#line 1383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_p(const __wchar_t *const 
#line 1384
_Format, va_list 
#line 1385
_ArgList) 
#line 1390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1391
return _vscwprintf_p_l(_Format, 0, _ArgList); 
#line 1392
} 
#line 1397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __swprintf_l(__wchar_t *const 
#line 1398
_Buffer, const __wchar_t *const 
#line 1399
_Format, const _locale_t 
#line 1400
_Locale, ...) 
#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1406
int _Result; 
#line 1407
va_list _ArgList; 
#line 1408
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1409
_Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 1410
(void)(_ArgList = ((va_list)0)); 
#line 1411
return _Result; 
#line 1412
} 
#line 1417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_l(__wchar_t *const 
#line 1418
_Buffer, const size_t 
#line 1419
_BufferCount, const __wchar_t *const 
#line 1420
_Format, const _locale_t 
#line 1421
_Locale, ...) 
#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1427
int _Result; 
#line 1428
va_list _ArgList; 
#line 1429
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1430
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1431
(void)(_ArgList = ((va_list)0)); 
#line 1432
return _Result; 
#line 1433
} 
#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf(__wchar_t *const 
#line 1439
_Buffer, const __wchar_t *const 
#line 1440
_Format, ...) 
#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1446
int _Result; 
#line 1447
va_list _ArgList; 
#line 1448
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1449
_Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList); 
#line 1450
(void)(_ArgList = ((va_list)0)); 
#line 1451
return _Result; 
#line 1452
} 
#line 1457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swprintf(__wchar_t *const 
#line 1458
_Buffer, const size_t 
#line 1459
_BufferCount, const __wchar_t *const 
#line 1460
_Format, ...) 
#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1466
int _Result; 
#line 1467
va_list _ArgList; 
#line 1468
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1469
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1470
(void)(_ArgList = ((va_list)0)); 
#line 1471
return _Result; 
#line 1472
} 
#line 1475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __swprintf_l(__wchar_t * _Buffer, const __wchar_t * _Format, _locale_t _Locale, ...); __inline int __cdecl __vswprintf_l(__wchar_t * _Buffer, const __wchar_t * _Format, _locale_t _Locale, va_list _Args); 
#line 1484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf(__wchar_t * _Buffer, const __wchar_t * _Format, ...); __inline int __cdecl _vswprintf(__wchar_t * _Buffer, const __wchar_t * _Format, va_list _Args); 
#line 1493 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_s_l(__wchar_t *const 
#line 1494
_Buffer, const size_t 
#line 1495
_BufferCount, const __wchar_t *const 
#line 1496
_Format, const _locale_t 
#line 1497
_Locale, ...) 
#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1503
int _Result; 
#line 1504
va_list _ArgList; 
#line 1505
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1506
_Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1507
(void)(_ArgList = ((va_list)0)); 
#line 1508
return _Result; 
#line 1509
} 
#line 1515 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swprintf_s(__wchar_t *const 
#line 1516
_Buffer, const size_t 
#line 1517
_BufferCount, const __wchar_t *const 
#line 1518
_Format, ...) 
#line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1524
int _Result; 
#line 1525
va_list _ArgList; 
#line 1526
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1527
_Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1528
(void)(_ArgList = ((va_list)0)); 
#line 1529
return _Result; 
#line 1530
} 
#line 1535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return vswprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_p_l(__wchar_t *const 
#line 1545
_Buffer, const size_t 
#line 1546
_BufferCount, const __wchar_t *const 
#line 1547
_Format, const _locale_t 
#line 1548
_Locale, ...) 
#line 1553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1554
int _Result; 
#line 1555
va_list _ArgList; 
#line 1556
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1557
_Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1558
(void)(_ArgList = ((va_list)0)); 
#line 1559
return _Result; 
#line 1560
} 
#line 1565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_p(__wchar_t *const 
#line 1566
_Buffer, const size_t 
#line 1567
_BufferCount, const __wchar_t *const 
#line 1568
_Format, ...) 
#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1574
int _Result; 
#line 1575
va_list _ArgList; 
#line 1576
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1577
_Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1578
(void)(_ArgList = ((va_list)0)); 
#line 1579
return _Result; 
#line 1580
} 
#line 1585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_c_l(__wchar_t *const 
#line 1586
_Buffer, const size_t 
#line 1587
_BufferCount, const __wchar_t *const 
#line 1588
_Format, const _locale_t 
#line 1589
_Locale, ...) 
#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1595
int _Result; 
#line 1596
va_list _ArgList; 
#line 1597
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1598
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1599
(void)(_ArgList = ((va_list)0)); 
#line 1600
return _Result; 
#line 1601
} 
#line 1606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_c(__wchar_t *const 
#line 1607
_Buffer, const size_t 
#line 1608
_BufferCount, const __wchar_t *const 
#line 1609
_Format, ...) 
#line 1614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1615
int _Result; 
#line 1616
va_list _ArgList; 
#line 1617
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1618
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1619
(void)(_ArgList = ((va_list)0)); 
#line 1620
return _Result; 
#line 1621
} 
#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_l(__wchar_t *const 
#line 1627
_Buffer, const size_t 
#line 1628
_BufferCount, const __wchar_t *const 
#line 1629
_Format, const _locale_t 
#line 1630
_Locale, ...) 
#line 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1636
int _Result; 
#line 1637
va_list _ArgList; 
#line 1638
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1640
_Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1642
(void)(_ArgList = ((va_list)0)); 
#line 1643
return _Result; 
#line 1644
} 
#line 1649 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf(__wchar_t *
#line 1650
_Buffer, size_t 
#line 1651
_BufferCount, const __wchar_t *
#line 1652
_Format, ...) 
#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1658
int _Result; 
#line 1659
va_list _ArgList; 
#line 1660
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1662
_Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1664
(void)(_ArgList = ((va_list)0)); 
#line 1665
return _Result; 
#line 1666
} 
#line 1671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_s_l(__wchar_t *const 
#line 1672
_Buffer, const size_t 
#line 1673
_BufferCount, const size_t 
#line 1674
_MaxCount, const __wchar_t *const 
#line 1675
_Format, const _locale_t 
#line 1676
_Locale, ...) 
#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1682
int _Result; 
#line 1683
va_list _ArgList; 
#line 1684
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1685
_Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1686
(void)(_ArgList = ((va_list)0)); 
#line 1687
return _Result; 
#line 1688
} 
#line 1693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_s(__wchar_t *const 
#line 1694
_Buffer, const size_t 
#line 1695
_BufferCount, const size_t 
#line 1696
_MaxCount, const __wchar_t *const 
#line 1697
_Format, ...) 
#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1703
int _Result; 
#line 1704
va_list _ArgList; 
#line 1705
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1706
_Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1707
(void)(_ArgList = ((va_list)0)); 
#line 1708
return _Result; 
#line 1709
} 
#line 1712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Buffer ) [ _Size ], size_t _BufferCount, wchar_t const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return _vsnwprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1721 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_l(const __wchar_t *const 
#line 1722
_Format, const _locale_t 
#line 1723
_Locale, ...) 
#line 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1729
int _Result; 
#line 1730
va_list _ArgList; 
#line 1731
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1732
_Result = _vscwprintf_l(_Format, _Locale, _ArgList); 
#line 1733
(void)(_ArgList = ((va_list)0)); 
#line 1734
return _Result; 
#line 1735
} 
#line 1740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf(const __wchar_t *const 
#line 1741
_Format, ...) 
#line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1747
int _Result; 
#line 1748
va_list _ArgList; 
#line 1749
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1750
_Result = _vscwprintf_l(_Format, 0, _ArgList); 
#line 1751
(void)(_ArgList = ((va_list)0)); 
#line 1752
return _Result; 
#line 1753
} 
#line 1758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_p_l(const __wchar_t *const 
#line 1759
_Format, const _locale_t 
#line 1760
_Locale, ...) 
#line 1765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1766
int _Result; 
#line 1767
va_list _ArgList; 
#line 1768
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1769
_Result = _vscwprintf_p_l(_Format, _Locale, _ArgList); 
#line 1770
(void)(_ArgList = ((va_list)0)); 
#line 1771
return _Result; 
#line 1772
} 
#line 1777 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_p(const __wchar_t *const 
#line 1778
_Format, ...) 
#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1784
int _Result; 
#line 1785
va_list _ArgList; 
#line 1786
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1787
_Result = _vscwprintf_p_l(_Format, 0, _ArgList); 
#line 1788
(void)(_ArgList = ((va_list)0)); 
#line 1789
return _Result; 
#line 1790
} 
#line 1797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#pragma warning(disable: 4141 6054)
#line 1803
extern "C++" 
#line 1802
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int 
#line 1803
swprintf(__wchar_t *const 
#line 1804
_Buffer, const __wchar_t *const 
#line 1805
_Format, ...) throw() 
#line 1807
{ 
#line 1808
int _Result; 
#line 1809
va_list _ArgList; 
#line 1810
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1811
_Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList); 
#line 1812
(void)(_ArgList = ((va_list)0)); 
#line 1813
return _Result; 
#line 1814
} 
#line 1817
extern "C++" 
#line 1816
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int __cdecl 
#line 1817
vswprintf(__wchar_t *const 
#line 1818
_Buffer, const __wchar_t *const 
#line 1819
_Format, va_list 
#line 1820
_ArgList) throw() 
#line 1822
{ 
#line 1823
return vswprintf(_Buffer, 2147483647, _Format, _ArgList); 
#line 1824
} 
#line 1827
extern "C++" 
#line 1826
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int 
#line 1827
_swprintf_l(__wchar_t *const 
#line 1828
_Buffer, const __wchar_t *const 
#line 1829
_Format, const _locale_t 
#line 1830
_Locale, ...) throw() 
#line 1832
{ 
#line 1833
int _Result; 
#line 1834
va_list _ArgList; 
#line 1835
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1836
_Result = _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1837
(void)(_ArgList = ((va_list)0)); 
#line 1838
return _Result; 
#line 1839
} 
#line 1842
extern "C++" 
#line 1841
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int __cdecl 
#line 1842
_vswprintf_l(__wchar_t *const 
#line 1843
_Buffer, const __wchar_t *const 
#line 1844
_Format, const _locale_t 
#line 1845
_Locale, va_list 
#line 1846
_ArgList) throw() 
#line 1848
{ 
#line 1849
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1850
} 
#line 1854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(pop)
#line 1871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
int __cdecl __stdio_common_vswscanf(unsigned __int64 _Options, const __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1882
__inline int __cdecl _vswscanf_l(const __wchar_t *const 
#line 1883
_Buffer, const __wchar_t *const 
#line 1884
_Format, const _locale_t 
#line 1885
_Locale, va_list 
#line 1886
_ArgList) 
#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1892
return __stdio_common_vswscanf(*__local_stdio_scanf_options(), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1895
} 
#line 1900 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswscanf(const __wchar_t *
#line 1901
_Buffer, const __wchar_t *
#line 1902
_Format, va_list 
#line 1903
_ArgList) 
#line 1908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1909
return _vswscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 1910
} 
#line 1915 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswscanf_s_l(const __wchar_t *const 
#line 1916
_Buffer, const __wchar_t *const 
#line 1917
_Format, const _locale_t 
#line 1918
_Locale, va_list 
#line 1919
_ArgList) 
#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1925
return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1928
} 
#line 1935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswscanf_s(const __wchar_t *const 
#line 1936
_Buffer, const __wchar_t *const 
#line 1937
_Format, va_list 
#line 1938
_ArgList) 
#line 1943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1944
return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 1945
} 
#line 1950 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vswscanf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, va_list _ArgList ) throw ( ) { return vswscanf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1960 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwscanf_l(const __wchar_t *const 
#line 1961
_Buffer, const size_t 
#line 1962
_BufferCount, const __wchar_t *const 
#line 1963
_Format, const _locale_t 
#line 1964
_Locale, va_list 
#line 1965
_ArgList) 
#line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1971
return __stdio_common_vswscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1974
} 
#line 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwscanf_s_l(const __wchar_t *const 
#line 1980
_Buffer, const size_t 
#line 1981
_BufferCount, const __wchar_t *const 
#line 1982
_Format, const _locale_t 
#line 1983
_Locale, va_list 
#line 1984
_ArgList) 
#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1990
return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1993
} 
#line 1998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swscanf_l(const __wchar_t *const 
#line 1999
_Buffer, const __wchar_t *const 
#line 2000
_Format, _locale_t 
#line 2001
_Locale, ...) 
#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2007
int _Result; 
#line 2008
va_list _ArgList; 
#line 2009
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2010
_Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2011
(void)(_ArgList = ((va_list)0)); 
#line 2012
return _Result; 
#line 2013
} 
#line 2018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swscanf(const __wchar_t *const 
#line 2019
_Buffer, const __wchar_t *const 
#line 2020
_Format, ...) 
#line 2025 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2026
int _Result; 
#line 2027
va_list _ArgList; 
#line 2028
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2029
_Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2030
(void)(_ArgList = ((va_list)0)); 
#line 2031
return _Result; 
#line 2032
} 
#line 2037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swscanf_s_l(const __wchar_t *const 
#line 2038
_Buffer, const __wchar_t *const 
#line 2039
_Format, const _locale_t 
#line 2040
_Locale, ...) 
#line 2045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2046
int _Result; 
#line 2047
va_list _ArgList; 
#line 2048
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2049
_Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2050
(void)(_ArgList = ((va_list)0)); 
#line 2051
return _Result; 
#line 2052
} 
#line 2059 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swscanf_s(const __wchar_t *const 
#line 2060
_Buffer, const __wchar_t *const 
#line 2061
_Format, ...) 
#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2067
int _Result; 
#line 2068
va_list _ArgList; 
#line 2069
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2070
_Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 2071
(void)(_ArgList = ((va_list)0)); 
#line 2072
return _Result; 
#line 2073
} 
#line 2080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_l(const __wchar_t *const 
#line 2081
_Buffer, const size_t 
#line 2082
_BufferCount, const __wchar_t *const 
#line 2083
_Format, const _locale_t 
#line 2084
_Locale, ...) 
#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2090
int _Result; 
#line 2091
va_list _ArgList; 
#line 2092
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2094
_Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2096
(void)(_ArgList = ((va_list)0)); 
#line 2097
return _Result; 
#line 2098
} 
#line 2103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf(const __wchar_t *const 
#line 2104
_Buffer, const size_t 
#line 2105
_BufferCount, const __wchar_t *const 
#line 2106
_Format, ...) 
#line 2111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2112
int _Result; 
#line 2113
va_list _ArgList; 
#line 2114
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2116
_Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2118
(void)(_ArgList = ((va_list)0)); 
#line 2119
return _Result; 
#line 2120
} 
#line 2125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_s_l(const __wchar_t *const 
#line 2126
_Buffer, const size_t 
#line 2127
_BufferCount, const __wchar_t *const 
#line 2128
_Format, const _locale_t 
#line 2129
_Locale, ...) 
#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2135
int _Result; 
#line 2136
va_list _ArgList; 
#line 2137
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2138
_Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2139
(void)(_ArgList = ((va_list)0)); 
#line 2140
return _Result; 
#line 2141
} 
#line 2146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_s(const __wchar_t *const 
#line 2147
_Buffer, const size_t 
#line 2148
_BufferCount, const __wchar_t *const 
#line 2149
_Format, ...) 
#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2155
int _Result; 
#line 2156
va_list _ArgList; 
#line 2157
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2158
_Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2159
(void)(_ArgList = ((va_list)0)); 
#line 2160
return _Result; 
#line 2161
} 
#line 2169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
}__pragma( pack ( pop )) 
#line 2171
#pragma warning(pop)
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
typedef __int64 fpos_t; 
#line 80
errno_t __cdecl _get_stream_buffer_pointers(FILE * _Stream, char *** _Base, char *** _Pointer, int ** _Count); 
#line 96
errno_t __cdecl clearerr_s(FILE * _Stream); 
#line 102
errno_t __cdecl fopen_s(FILE ** _Stream, const char * _FileName, const char * _Mode); 
#line 110
size_t __cdecl fread_s(void * _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 119
errno_t __cdecl freopen_s(FILE ** _Stream, const char * _FileName, const char * _Mode, FILE * _OldStream); 
#line 127
char *__cdecl gets_s(char * _Buffer, rsize_t _Size); 
#line 133
errno_t __cdecl tmpfile_s(FILE ** _Stream); 
#line 139
errno_t __cdecl tmpnam_s(char * _Buffer, rsize_t _Size); 
#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
void __cdecl clearerr(FILE * _Stream); 
#line 152
int __cdecl fclose(FILE * _Stream); 
#line 157
int __cdecl _fcloseall(); 
#line 160
FILE *__cdecl _fdopen(int _FileHandle, const char * _Mode); 
#line 166
int __cdecl feof(FILE * _Stream); 
#line 171
int __cdecl ferror(FILE * _Stream); 
#line 176
int __cdecl fflush(FILE * _Stream); 
#line 182
int __cdecl fgetc(FILE * _Stream); 
#line 187
int __cdecl _fgetchar(); 
#line 191
int __cdecl fgetpos(FILE * _Stream, fpos_t * _Position); 
#line 198
char *__cdecl fgets(char * _Buffer, int _MaxCount, FILE * _Stream); 
#line 205
int __cdecl _fileno(FILE * _Stream); 
#line 210
int __cdecl _flushall(); 
#line 213
FILE *__cdecl fopen(const char * _FileName, const char * _Mode); 
#line 221
int __cdecl fputc(int _Character, FILE * _Stream); 
#line 227
int __cdecl _fputchar(int _Character); 
#line 233
int __cdecl fputs(const char * _Buffer, FILE * _Stream); 
#line 239
size_t __cdecl fread(void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 248
FILE *__cdecl freopen(const char * _FileName, const char * _Mode, FILE * _Stream); 
#line 255
FILE *__cdecl _fsopen(const char * _FileName, const char * _Mode, int _ShFlag); 
#line 263
int __cdecl fsetpos(FILE * _Stream, const fpos_t * _Position); 
#line 270
int __cdecl fseek(FILE * _Stream, long _Offset, int _Origin); 
#line 278
int __cdecl _fseeki64(FILE * _Stream, __int64 _Offset, int _Origin); 
#line 286
long __cdecl ftell(FILE * _Stream); 
#line 292
__int64 __cdecl _ftelli64(FILE * _Stream); 
#line 297
size_t __cdecl fwrite(const void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 306
int __cdecl getc(FILE * _Stream); 
#line 311
int __cdecl getchar(); 
#line 314
int __cdecl _getmaxstdio(); 
#line 316
extern "C++" {template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return gets_s ( _Buffer, _Size ); }}
#line 321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl _getw(FILE * _Stream); 
#line 325
void __cdecl perror(const char * _ErrorMessage); 
#line 333
int __cdecl _pclose(FILE * _Stream); 
#line 338
FILE *__cdecl _popen(const char * _Command, const char * _Mode); 
#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl putc(int _Character, FILE * _Stream); 
#line 353
int __cdecl putchar(int _Character); 
#line 358
int __cdecl puts(const char * _Buffer); 
#line 364
int __cdecl _putw(int _Word, FILE * _Stream); 
#line 369
int __cdecl remove(const char * _FileName); 
#line 374
int __cdecl rename(const char * _OldFileName, const char * _NewFileName); 
#line 379
int __cdecl _unlink(const char * _FileName); 
#line 386
int __cdecl unlink(const char * _FileName); 
#line 392 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
void __cdecl rewind(FILE * _Stream); 
#line 397
int __cdecl _rmtmp(); 
#line 400
void __cdecl setbuf(FILE * _Stream, char * _Buffer); 
#line 406
int __cdecl _setmaxstdio(int _Maximum); 
#line 412
int __cdecl setvbuf(FILE * _Stream, char * _Buffer, int _Mode, size_t _Size); 
#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__declspec(allocator) char *__cdecl _tempnam(const char * _DirectoryName, const char * _FilePrefix); 
#line 435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
FILE *__cdecl tmpfile(); 
#line 437
extern "C++" {template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return tmpnam_s ( _Buffer, _Size ); }}
#line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
char *__cdecl tmpnam(char * _Buffer); 
#line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl ungetc(int _Character, FILE * _Stream); 
#line 463
void __cdecl _lock_file(FILE * _Stream); 
#line 467
void __cdecl _unlock_file(FILE * _Stream); 
#line 473
int __cdecl _fclose_nolock(FILE * _Stream); 
#line 479
int __cdecl _fflush_nolock(FILE * _Stream); 
#line 485
int __cdecl _fgetc_nolock(FILE * _Stream); 
#line 491
int __cdecl _fputc_nolock(int _Character, FILE * _Stream); 
#line 497
size_t __cdecl _fread_nolock(void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 506
size_t __cdecl _fread_nolock_s(void * _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 515
int __cdecl _fseek_nolock(FILE * _Stream, long _Offset, int _Origin); 
#line 522
int __cdecl _fseeki64_nolock(FILE * _Stream, __int64 _Offset, int _Origin); 
#line 529
long __cdecl _ftell_nolock(FILE * _Stream); 
#line 534
__int64 __cdecl _ftelli64_nolock(FILE * _Stream); 
#line 539
size_t __cdecl _fwrite_nolock(const void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 547
int __cdecl _getc_nolock(FILE * _Stream); 
#line 552
int __cdecl _putc_nolock(int _Character, FILE * _Stream); 
#line 558
int __cdecl _ungetc_nolock(int _Character, FILE * _Stream); 
#line 589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int *__cdecl __p__commode(); 
#line 609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl __stdio_common_vfprintf(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 617
int __cdecl __stdio_common_vfprintf_s(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 626
int __cdecl __stdio_common_vfprintf_p(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 635
__inline int __cdecl _vfprintf_l(FILE *const 
#line 636
_Stream, const char *const 
#line 637
_Format, const _locale_t 
#line 638
_Locale, va_list 
#line 639
_ArgList) 
#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 645
return __stdio_common_vfprintf(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 646
} 
#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vfprintf(FILE *const 
#line 651
_Stream, const char *const 
#line 652
_Format, va_list 
#line 653
_ArgList) 
#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 659
return _vfprintf_l(_Stream, _Format, 0, _ArgList); 
#line 660
} 
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_s_l(FILE *const 
#line 665
_Stream, const char *const 
#line 666
_Format, const _locale_t 
#line 667
_Locale, va_list 
#line 668
_ArgList) 
#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 674
return __stdio_common_vfprintf_s(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 675
} 
#line 681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vfprintf_s(FILE *const 
#line 682
_Stream, const char *const 
#line 683
_Format, va_list 
#line 684
_ArgList) 
#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 690
return _vfprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 691
} 
#line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_p_l(FILE *const 
#line 698
_Stream, const char *const 
#line 699
_Format, const _locale_t 
#line 700
_Locale, va_list 
#line 701
_ArgList) 
#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 707
return __stdio_common_vfprintf_p(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 708
} 
#line 712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_p(FILE *const 
#line 713
_Stream, const char *const 
#line 714
_Format, va_list 
#line 715
_ArgList) 
#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 721
return _vfprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 722
} 
#line 726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_l(const char *const 
#line 727
_Format, const _locale_t 
#line 728
_Locale, va_list 
#line 729
_ArgList) 
#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 735
return _vfprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 736
} 
#line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vprintf(const char *const 
#line 741
_Format, va_list 
#line 742
_ArgList) 
#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 748
return _vfprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 749
} 
#line 753 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_s_l(const char *const 
#line 754
_Format, const _locale_t 
#line 755
_Locale, va_list 
#line 756
_ArgList) 
#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 762
return _vfprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 763
} 
#line 769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vprintf_s(const char *const 
#line 770
_Format, va_list 
#line 771
_ArgList) 
#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 777
return _vfprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 778
} 
#line 784 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_p_l(const char *const 
#line 785
_Format, const _locale_t 
#line 786
_Locale, va_list 
#line 787
_ArgList) 
#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 793
return _vfprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 794
} 
#line 798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_p(const char *const 
#line 799
_Format, va_list 
#line 800
_ArgList) 
#line 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 806
return _vfprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 807
} 
#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_l(FILE *const 
#line 812
_Stream, const char *const 
#line 813
_Format, const _locale_t 
#line 814
_Locale, ...) 
#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 820
int _Result; 
#line 821
va_list _ArgList; 
#line 822
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 823
_Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList); 
#line 824
(void)(_ArgList = ((va_list)0)); 
#line 825
return _Result; 
#line 826
} 
#line 830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl fprintf(FILE *const 
#line 831
_Stream, const char *const 
#line 832
_Format, ...) 
#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 838
int _Result; 
#line 839
va_list _ArgList; 
#line 840
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 841
_Result = _vfprintf_l(_Stream, _Format, 0, _ArgList); 
#line 842
(void)(_ArgList = ((va_list)0)); 
#line 843
return _Result; 
#line 844
} 
#line 847 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl _set_printf_count_output(int _Value); 
#line 851
int __cdecl _get_printf_count_output(); 
#line 854
__inline int __cdecl _fprintf_s_l(FILE *const 
#line 855
_Stream, const char *const 
#line 856
_Format, const _locale_t 
#line 857
_Locale, ...) 
#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 863
int _Result; 
#line 864
va_list _ArgList; 
#line 865
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 866
_Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 867
(void)(_ArgList = ((va_list)0)); 
#line 868
return _Result; 
#line 869
} 
#line 875 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl fprintf_s(FILE *const 
#line 876
_Stream, const char *const 
#line 877
_Format, ...) 
#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 883
int _Result; 
#line 884
va_list _ArgList; 
#line 885
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 886
_Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 887
(void)(_ArgList = ((va_list)0)); 
#line 888
return _Result; 
#line 889
} 
#line 895 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_p_l(FILE *const 
#line 896
_Stream, const char *const 
#line 897
_Format, const _locale_t 
#line 898
_Locale, ...) 
#line 903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 904
int _Result; 
#line 905
va_list _ArgList; 
#line 906
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 907
_Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList); 
#line 908
(void)(_ArgList = ((va_list)0)); 
#line 909
return _Result; 
#line 910
} 
#line 914 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_p(FILE *const 
#line 915
_Stream, const char *const 
#line 916
_Format, ...) 
#line 921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 922
int _Result; 
#line 923
va_list _ArgList; 
#line 924
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 925
_Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 926
(void)(_ArgList = ((va_list)0)); 
#line 927
return _Result; 
#line 928
} 
#line 932 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_l(const char *const 
#line 933
_Format, const _locale_t 
#line 934
_Locale, ...) 
#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 940
int _Result; 
#line 941
va_list _ArgList; 
#line 942
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 943
_Result = _vfprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 944
(void)(_ArgList = ((va_list)0)); 
#line 945
return _Result; 
#line 946
} 
#line 950 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl printf(const char *const 
#line 951
_Format, ...) 
#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 957
int _Result; 
#line 958
va_list _ArgList; 
#line 959
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 960
_Result = _vfprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 961
(void)(_ArgList = ((va_list)0)); 
#line 962
return _Result; 
#line 963
} 
#line 967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_s_l(const char *const 
#line 968
_Format, const _locale_t 
#line 969
_Locale, ...) 
#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 975
int _Result; 
#line 976
va_list _ArgList; 
#line 977
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 978
_Result = _vfprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 979
(void)(_ArgList = ((va_list)0)); 
#line 980
return _Result; 
#line 981
} 
#line 987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl printf_s(const char *const 
#line 988
_Format, ...) 
#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 994
int _Result; 
#line 995
va_list _ArgList; 
#line 996
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 997
_Result = _vfprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 998
(void)(_ArgList = ((va_list)0)); 
#line 999
return _Result; 
#line 1000
} 
#line 1006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_p_l(const char *const 
#line 1007
_Format, const _locale_t 
#line 1008
_Locale, ...) 
#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1014
int _Result; 
#line 1015
va_list _ArgList; 
#line 1016
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1017
_Result = _vfprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 1018
(void)(_ArgList = ((va_list)0)); 
#line 1019
return _Result; 
#line 1020
} 
#line 1024 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_p(const char *const 
#line 1025
_Format, ...) 
#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1031
int _Result; 
#line 1032
va_list _ArgList; 
#line 1033
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1034
_Result = _vfprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 1035
(void)(_ArgList = ((va_list)0)); 
#line 1036
return _Result; 
#line 1037
} 
#line 1046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl __stdio_common_vfscanf(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _Arglist); 
#line 1055
__inline int __cdecl _vfscanf_l(FILE *const 
#line 1056
_Stream, const char *const 
#line 1057
_Format, const _locale_t 
#line 1058
_Locale, va_list 
#line 1059
_ArgList) 
#line 1064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1065
return __stdio_common_vfscanf(*__local_stdio_scanf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 1068
} 
#line 1072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vfscanf(FILE *const 
#line 1073
_Stream, const char *const 
#line 1074
_Format, va_list 
#line 1075
_ArgList) 
#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1081
return _vfscanf_l(_Stream, _Format, 0, _ArgList); 
#line 1082
} 
#line 1086 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vfscanf_s_l(FILE *const 
#line 1087
_Stream, const char *const 
#line 1088
_Format, const _locale_t 
#line 1089
_Locale, va_list 
#line 1090
_ArgList) 
#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1096
return __stdio_common_vfscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Stream, _Format, _Locale, _ArgList); 
#line 1099
} 
#line 1106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vfscanf_s(FILE *const 
#line 1107
_Stream, const char *const 
#line 1108
_Format, va_list 
#line 1109
_ArgList) 
#line 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1115
return _vfscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 1116
} 
#line 1122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vscanf_l(const char *const 
#line 1123
_Format, const _locale_t 
#line 1124
_Locale, va_list 
#line 1125
_ArgList) 
#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1131
return _vfscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1132
} 
#line 1136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vscanf(const char *const 
#line 1137
_Format, va_list 
#line 1138
_ArgList) 
#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1144
return _vfscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1145
} 
#line 1149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vscanf_s_l(const char *const 
#line 1150
_Format, const _locale_t 
#line 1151
_Locale, va_list 
#line 1152
_ArgList) 
#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1158
return _vfscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1159
} 
#line 1165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vscanf_s(const char *const 
#line 1166
_Format, va_list 
#line 1167
_ArgList) 
#line 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1173
return _vfscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1174
} 
#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _fscanf_l(FILE *const 
#line 1181
_Stream, const char *const 
#line 1182
_Format, const _locale_t 
#line 1183
_Locale, ...) 
#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1189
int _Result; 
#line 1190
va_list _ArgList; 
#line 1191
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1192
_Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList); 
#line 1193
(void)(_ArgList = ((va_list)0)); 
#line 1194
return _Result; 
#line 1195
} 
#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl fscanf(FILE *const 
#line 1200
_Stream, const char *const 
#line 1201
_Format, ...) 
#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1207
int _Result; 
#line 1208
va_list _ArgList; 
#line 1209
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1210
_Result = _vfscanf_l(_Stream, _Format, 0, _ArgList); 
#line 1211
(void)(_ArgList = ((va_list)0)); 
#line 1212
return _Result; 
#line 1213
} 
#line 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _fscanf_s_l(FILE *const 
#line 1218
_Stream, const char *const 
#line 1219
_Format, const _locale_t 
#line 1220
_Locale, ...) 
#line 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1226
int _Result; 
#line 1227
va_list _ArgList; 
#line 1228
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1229
_Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 1230
(void)(_ArgList = ((va_list)0)); 
#line 1231
return _Result; 
#line 1232
} 
#line 1238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl fscanf_s(FILE *const 
#line 1239
_Stream, const char *const 
#line 1240
_Format, ...) 
#line 1245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1246
int _Result; 
#line 1247
va_list _ArgList; 
#line 1248
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1249
_Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 1250
(void)(_ArgList = ((va_list)0)); 
#line 1251
return _Result; 
#line 1252
} 
#line 1258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _scanf_l(const char *const 
#line 1259
_Format, const _locale_t 
#line 1260
_Locale, ...) 
#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1266
int _Result; 
#line 1267
va_list _ArgList; 
#line 1268
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1269
_Result = _vfscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1270
(void)(_ArgList = ((va_list)0)); 
#line 1271
return _Result; 
#line 1272
} 
#line 1276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl scanf(const char *const 
#line 1277
_Format, ...) 
#line 1282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1283
int _Result; 
#line 1284
va_list _ArgList; 
#line 1285
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1286
_Result = _vfscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1287
(void)(_ArgList = ((va_list)0)); 
#line 1288
return _Result; 
#line 1289
} 
#line 1293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _scanf_s_l(const char *const 
#line 1294
_Format, const _locale_t 
#line 1295
_Locale, ...) 
#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1301
int _Result; 
#line 1302
va_list _ArgList; 
#line 1303
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1304
_Result = _vfscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1305
(void)(_ArgList = ((va_list)0)); 
#line 1306
return _Result; 
#line 1307
} 
#line 1313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl scanf_s(const char *const 
#line 1314
_Format, ...) 
#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1320
int _Result; 
#line 1321
va_list _ArgList; 
#line 1322
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1323
_Result = _vfscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1324
(void)(_ArgList = ((va_list)0)); 
#line 1325
return _Result; 
#line 1326
} 
#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl __stdio_common_vsprintf(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1349
int __cdecl __stdio_common_vsprintf_s(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1359
int __cdecl __stdio_common_vsnprintf_s(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1370
int __cdecl __stdio_common_vsprintf_p(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1381
__inline int __cdecl _vsnprintf_l(char *const 
#line 1382
_Buffer, const size_t 
#line 1383
_BufferCount, const char *const 
#line 1384
_Format, const _locale_t 
#line 1385
_Locale, va_list 
#line 1386
_ArgList) 
#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1392
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1396
return (_Result < 0) ? -1 : _Result; 
#line 1397
} 
#line 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf(char *const 
#line 1403
_Buffer, const size_t 
#line 1404
_BufferCount, const char *const 
#line 1405
_Format, va_list 
#line 1406
_ArgList) 
#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1412
return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1413
} 
#line 1429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vsnprintf(char *const 
#line 1430
_Buffer, const size_t 
#line 1431
_BufferCount, const char *const 
#line 1432
_Format, va_list 
#line 1433
_ArgList) 
#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1439
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1443
return (_Result < 0) ? -1 : _Result; 
#line 1444
} 
#line 1449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_l(char *const 
#line 1450
_Buffer, const char *const 
#line 1451
_Format, const _locale_t 
#line 1452
_Locale, va_list 
#line 1453
_ArgList) 
#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1459
return _vsnprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1460
} 
#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vsprintf(char *const 
#line 1466
_Buffer, const char *const 
#line 1467
_Format, va_list 
#line 1468
_ArgList) 
#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1474
return _vsnprintf_l(_Buffer, (size_t)(-1), _Format, 0, _ArgList); 
#line 1475
} 
#line 1480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_s_l(char *const 
#line 1481
_Buffer, const size_t 
#line 1482
_BufferCount, const char *const 
#line 1483
_Format, const _locale_t 
#line 1484
_Locale, va_list 
#line 1485
_ArgList) 
#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1491
const int _Result = __stdio_common_vsprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1495
return (_Result < 0) ? -1 : _Result; 
#line 1496
} 
#line 1503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vsprintf_s(char *const 
#line 1504
_Buffer, const size_t 
#line 1505
_BufferCount, const char *const 
#line 1506
_Format, va_list 
#line 1507
_ArgList) 
#line 1512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1513
return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1514
} 
#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Buffer ) [ _Size ], char const * _Format, va_list _ArgList ) throw ( ) { return vsprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_p_l(char *const 
#line 1530
_Buffer, const size_t 
#line 1531
_BufferCount, const char *const 
#line 1532
_Format, const _locale_t 
#line 1533
_Locale, va_list 
#line 1534
_ArgList) 
#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1540
const int _Result = __stdio_common_vsprintf_p(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1544
return (_Result < 0) ? -1 : _Result; 
#line 1545
} 
#line 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_p(char *const 
#line 1551
_Buffer, const size_t 
#line 1552
_BufferCount, const char *const 
#line 1553
_Format, va_list 
#line 1554
_ArgList) 
#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1560
return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1561
} 
#line 1566 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_s_l(char *const 
#line 1567
_Buffer, const size_t 
#line 1568
_BufferCount, const size_t 
#line 1569
_MaxCount, const char *const 
#line 1570
_Format, const _locale_t 
#line 1571
_Locale, va_list 
#line 1572
_ArgList) 
#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1578
const int _Result = __stdio_common_vsnprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1582
return (_Result < 0) ? -1 : _Result; 
#line 1583
} 
#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_s(char *const 
#line 1589
_Buffer, const size_t 
#line 1590
_BufferCount, const size_t 
#line 1591
_MaxCount, const char *const 
#line 1592
_Format, va_list 
#line 1593
_ArgList) 
#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1599
return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1600
} 
#line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, va_list _ArgList ) throw ( ) { return _vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1616 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vsnprintf_s(char *const 
#line 1617
_Buffer, const size_t 
#line 1618
_BufferCount, const size_t 
#line 1619
_MaxCount, const char *const 
#line 1620
_Format, va_list 
#line 1621
_ArgList) 
#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1627
return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1628
} 
#line 1631 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsnprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, va_list _ArgList ) throw ( ) { return vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_l(const char *const 
#line 1644
_Format, const _locale_t 
#line 1645
_Locale, va_list 
#line 1646
_ArgList) 
#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1652
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1656
return (_Result < 0) ? -1 : _Result; 
#line 1657
} 
#line 1661 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf(const char *const 
#line 1662
_Format, va_list 
#line 1663
_ArgList) 
#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1669
return _vscprintf_l(_Format, 0, _ArgList); 
#line 1670
} 
#line 1674 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_p_l(const char *const 
#line 1675
_Format, const _locale_t 
#line 1676
_Locale, va_list 
#line 1677
_ArgList) 
#line 1682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1683
const int _Result = __stdio_common_vsprintf_p((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1687
return (_Result < 0) ? -1 : _Result; 
#line 1688
} 
#line 1692 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_p(const char *const 
#line 1693
_Format, va_list 
#line 1694
_ArgList) 
#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1700
return _vscprintf_p_l(_Format, 0, _ArgList); 
#line 1701
} 
#line 1705 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_c_l(char *const 
#line 1706
_Buffer, const size_t 
#line 1707
_BufferCount, const char *const 
#line 1708
_Format, const _locale_t 
#line 1709
_Locale, va_list 
#line 1710
_ArgList) 
#line 1715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1716
const int _Result = __stdio_common_vsprintf(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1720
return (_Result < 0) ? -1 : _Result; 
#line 1721
} 
#line 1726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_c(char *const 
#line 1727
_Buffer, const size_t 
#line 1728
_BufferCount, const char *const 
#line 1729
_Format, va_list 
#line 1730
_ArgList) 
#line 1735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1736
return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1737
} 
#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_l(char *const 
#line 1743
_Buffer, const char *const 
#line 1744
_Format, const _locale_t 
#line 1745
_Locale, ...) 
#line 1750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1751
int _Result; 
#line 1752
va_list _ArgList; 
#line 1753
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1755
_Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 1757
(void)(_ArgList = ((va_list)0)); 
#line 1758
return _Result; 
#line 1759
} 
#line 1764 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf(char *const 
#line 1765
_Buffer, const char *const 
#line 1766
_Format, ...) 
#line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1772
int _Result; 
#line 1773
va_list _ArgList; 
#line 1774
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1776
_Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList); 
#line 1778
(void)(_ArgList = ((va_list)0)); 
#line 1779
return _Result; 
#line 1780
} 
#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf(char * _Buffer, const char * _Format, ...); __inline int __cdecl vsprintf(char * _Buffer, const char * _Format, va_list _Args); 
#line 1792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_s_l(char *const 
#line 1793
_Buffer, const size_t 
#line 1794
_BufferCount, const char *const 
#line 1795
_Format, const _locale_t 
#line 1796
_Locale, ...) 
#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1802
int _Result; 
#line 1803
va_list _ArgList; 
#line 1804
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1805
_Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1806
(void)(_ArgList = ((va_list)0)); 
#line 1807
return _Result; 
#line 1808
} 
#line 1815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf_s(char *const 
#line 1816
_Buffer, const size_t 
#line 1817
_BufferCount, const char *const 
#line 1818
_Format, ...) 
#line 1823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1824
int _Result; 
#line 1825
va_list _ArgList; 
#line 1826
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1827
_Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1828
(void)(_ArgList = ((va_list)0)); 
#line 1829
return _Result; 
#line 1830
} 
#line 1835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Buffer ) [ _Size ], char const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return vsprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_p_l(char *const 
#line 1845
_Buffer, const size_t 
#line 1846
_BufferCount, const char *const 
#line 1847
_Format, const _locale_t 
#line 1848
_Locale, ...) 
#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1854
int _Result; 
#line 1855
va_list _ArgList; 
#line 1856
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1857
_Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1858
(void)(_ArgList = ((va_list)0)); 
#line 1859
return _Result; 
#line 1860
} 
#line 1865 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_p(char *const 
#line 1866
_Buffer, const size_t 
#line 1867
_BufferCount, const char *const 
#line 1868
_Format, ...) 
#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1874
int _Result; 
#line 1875
va_list _ArgList; 
#line 1876
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1877
_Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1878
(void)(_ArgList = ((va_list)0)); 
#line 1879
return _Result; 
#line 1880
} 
#line 1885 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_l(char *const 
#line 1886
_Buffer, const size_t 
#line 1887
_BufferCount, const char *const 
#line 1888
_Format, const _locale_t 
#line 1889
_Locale, ...) 
#line 1894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1895
int _Result; 
#line 1896
va_list _ArgList; 
#line 1897
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1899
_Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1901
(void)(_ArgList = ((va_list)0)); 
#line 1902
return _Result; 
#line 1903
} 
#line 1919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl snprintf(char *const 
#line 1920
_Buffer, const size_t 
#line 1921
_BufferCount, const char *const 
#line 1922
_Format, ...) 
#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1928
int _Result; 
#line 1929
va_list _ArgList; 
#line 1930
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1931
_Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList); 
#line 1932
(void)(_ArgList = ((va_list)0)); 
#line 1933
return _Result; 
#line 1934
} 
#line 1939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf(char *const 
#line 1940
_Buffer, const size_t 
#line 1941
_BufferCount, const char *const 
#line 1942
_Format, ...) 
#line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1948
int _Result; 
#line 1949
va_list _ArgList; 
#line 1950
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1951
_Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList); 
#line 1952
(void)(_ArgList = ((va_list)0)); 
#line 1953
return _Result; 
#line 1954
} 
#line 1957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf(char * _Buffer, size_t _BufferCount, const char * _Format, ...); __inline int __cdecl _vsnprintf(char * _Buffer, size_t _BufferCount, const char * _Format, va_list _Args); 
#line 1968 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_c_l(char *const 
#line 1969
_Buffer, const size_t 
#line 1970
_BufferCount, const char *const 
#line 1971
_Format, const _locale_t 
#line 1972
_Locale, ...) 
#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1978
int _Result; 
#line 1979
va_list _ArgList; 
#line 1980
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1981
_Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1982
(void)(_ArgList = ((va_list)0)); 
#line 1983
return _Result; 
#line 1984
} 
#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_c(char *const 
#line 1990
_Buffer, const size_t 
#line 1991
_BufferCount, const char *const 
#line 1992
_Format, ...) 
#line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 1998
int _Result; 
#line 1999
va_list _ArgList; 
#line 2000
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2001
_Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2002
(void)(_ArgList = ((va_list)0)); 
#line 2003
return _Result; 
#line 2004
} 
#line 2009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_s_l(char *const 
#line 2010
_Buffer, const size_t 
#line 2011
_BufferCount, const size_t 
#line 2012
_MaxCount, const char *const 
#line 2013
_Format, const _locale_t 
#line 2014
_Locale, ...) 
#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2020
int _Result; 
#line 2021
va_list _ArgList; 
#line 2022
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2023
_Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 2024
(void)(_ArgList = ((va_list)0)); 
#line 2025
return _Result; 
#line 2026
} 
#line 2031 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_s(char *const 
#line 2032
_Buffer, const size_t 
#line 2033
_BufferCount, const size_t 
#line 2034
_MaxCount, const char *const 
#line 2035
_Format, ...) 
#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2041
int _Result; 
#line 2042
va_list _ArgList; 
#line 2043
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2044
_Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 2045
(void)(_ArgList = ((va_list)0)); 
#line 2046
return _Result; 
#line 2047
} 
#line 2050 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return _vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 2059 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_l(const char *const 
#line 2060
_Format, const _locale_t 
#line 2061
_Locale, ...) 
#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2067
int _Result; 
#line 2068
va_list _ArgList; 
#line 2069
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2070
_Result = _vscprintf_l(_Format, _Locale, _ArgList); 
#line 2071
(void)(_ArgList = ((va_list)0)); 
#line 2072
return _Result; 
#line 2073
} 
#line 2077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf(const char *const 
#line 2078
_Format, ...) 
#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2084
int _Result; 
#line 2085
va_list _ArgList; 
#line 2086
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2087
_Result = _vscprintf_l(_Format, 0, _ArgList); 
#line 2088
(void)(_ArgList = ((va_list)0)); 
#line 2089
return _Result; 
#line 2090
} 
#line 2094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_p_l(const char *const 
#line 2095
_Format, const _locale_t 
#line 2096
_Locale, ...) 
#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2102
int _Result; 
#line 2103
va_list _ArgList; 
#line 2104
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2105
_Result = _vscprintf_p_l(_Format, _Locale, _ArgList); 
#line 2106
(void)(_ArgList = ((va_list)0)); 
#line 2107
return _Result; 
#line 2108
} 
#line 2112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_p(const char *const 
#line 2113
_Format, ...) 
#line 2118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2119
int _Result; 
#line 2120
va_list _ArgList; 
#line 2121
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2122
_Result = _vscprintf_p(_Format, _ArgList); 
#line 2123
(void)(_ArgList = ((va_list)0)); 
#line 2124
return _Result; 
#line 2125
} 
#line 2133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl __stdio_common_vsscanf(unsigned __int64 _Options, const char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 2143
__inline int __cdecl _vsscanf_l(const char *const 
#line 2144
_Buffer, const char *const 
#line 2145
_Format, const _locale_t 
#line 2146
_Locale, va_list 
#line 2147
_ArgList) 
#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2153
return __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 2156
} 
#line 2160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl vsscanf(const char *const 
#line 2161
_Buffer, const char *const 
#line 2162
_Format, va_list 
#line 2163
_ArgList) 
#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2169
return _vsscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2170
} 
#line 2174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _vsscanf_s_l(const char *const 
#line 2175
_Buffer, const char *const 
#line 2176
_Format, const _locale_t 
#line 2177
_Locale, va_list 
#line 2178
_ArgList) 
#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2184
return __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 2187
} 
#line 2192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 6530)
#line 2196
__inline int __cdecl vsscanf_s(const char *const 
#line 2197
_Buffer, const char *const 
#line 2198
_Format, va_list 
#line 2199
_ArgList) 
#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2205
return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 2206
} 
#line 2209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsscanf_s ( char const ( & _Buffer ) [ _Size ], char const * _Format, va_list _ArgList ) throw ( ) { return vsscanf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 2216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 2221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _sscanf_l(const char *const 
#line 2222
_Buffer, const char *const 
#line 2223
_Format, const _locale_t 
#line 2224
_Locale, ...) 
#line 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2230
int _Result; 
#line 2231
va_list _ArgList; 
#line 2232
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2233
_Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2234
(void)(_ArgList = ((va_list)0)); 
#line 2235
return _Result; 
#line 2236
} 
#line 2240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl sscanf(const char *const 
#line 2241
_Buffer, const char *const 
#line 2242
_Format, ...) 
#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2248
int _Result; 
#line 2249
va_list _ArgList; 
#line 2250
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2251
_Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2252
(void)(_ArgList = ((va_list)0)); 
#line 2253
return _Result; 
#line 2254
} 
#line 2258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _sscanf_s_l(const char *const 
#line 2259
_Buffer, const char *const 
#line 2260
_Format, const _locale_t 
#line 2261
_Locale, ...) 
#line 2266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2267
int _Result; 
#line 2268
va_list _ArgList; 
#line 2269
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2270
_Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2271
(void)(_ArgList = ((va_list)0)); 
#line 2272
return _Result; 
#line 2273
} 
#line 2279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl sscanf_s(const char *const 
#line 2280
_Buffer, const char *const 
#line 2281
_Format, ...) 
#line 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2287
int _Result; 
#line 2288
va_list _ArgList; 
#line 2289
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2291
_Result = vsscanf_s(_Buffer, _Format, _ArgList); 
#line 2293
(void)(_ArgList = ((va_list)0)); 
#line 2294
return _Result; 
#line 2295
} 
#line 2300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 6530)
#line 2304
__inline int __cdecl _snscanf_l(const char *const 
#line 2305
_Buffer, const size_t 
#line 2306
_BufferCount, const char *const 
#line 2307
_Format, const _locale_t 
#line 2308
_Locale, ...) 
#line 2313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2314
int _Result; 
#line 2315
va_list _ArgList; 
#line 2316
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2318
_Result = __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2322
(void)(_ArgList = ((va_list)0)); 
#line 2323
return _Result; 
#line 2324
} 
#line 2328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf(const char *const 
#line 2329
_Buffer, const size_t 
#line 2330
_BufferCount, const char *const 
#line 2331
_Format, ...) 
#line 2336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2337
int _Result; 
#line 2338
va_list _ArgList; 
#line 2339
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2341
_Result = __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2345
(void)(_ArgList = ((va_list)0)); 
#line 2346
return _Result; 
#line 2347
} 
#line 2352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf_s_l(const char *const 
#line 2353
_Buffer, const size_t 
#line 2354
_BufferCount, const char *const 
#line 2355
_Format, const _locale_t 
#line 2356
_Locale, ...) 
#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2362
int _Result; 
#line 2363
va_list _ArgList; 
#line 2364
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2366
_Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2370
(void)(_ArgList = ((va_list)0)); 
#line 2371
return _Result; 
#line 2372
} 
#line 2376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf_s(const char *const 
#line 2377
_Buffer, const size_t 
#line 2378
_BufferCount, const char *const 
#line 2379
_Format, ...) 
#line 2384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
{ 
#line 2385
int _Result; 
#line 2386
va_list _ArgList; 
#line 2387
(void)(__vcrt_assert_va_start_is_not_reference< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2389
_Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2393
(void)(_ArgList = ((va_list)0)); 
#line 2394
return _Result; 
#line 2395
} 
#line 2398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 2421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
char *__cdecl tempnam(const char * _Directory, const char * _FilePrefix); 
#line 2430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
int __cdecl fcloseall(); 
#line 2431
FILE *__cdecl fdopen(int _FileHandle, const char * _Format); 
#line 2432
int __cdecl fgetchar(); 
#line 2433
int __cdecl fileno(FILE * _Stream); 
#line 2434
int __cdecl flushall(); 
#line 2435
int __cdecl fputchar(int _Ch); 
#line 2436
int __cdecl getw(FILE * _Stream); 
#line 2437
int __cdecl putw(int _Ch, FILE * _Stream); 
#line 2438
int __cdecl rmtmp(); 
#line 2445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
}__pragma( pack ( pop )) 
#line 2447
#pragma warning(pop)
#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdio"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 33
namespace std { 
#pragma warning(push)
#pragma warning(disable : 4995)
#line 37
using ::FILE;
#line 38
using ::_Mbstatet;
#line 41
using ::fpos_t;
#line 43
using ::clearerr;
#line 44
using ::fclose;
#line 45
using ::feof;
#line 46
using ::ferror;
#line 47
using ::fflush;
#line 48
using ::fgetc;
#line 49
using ::fgetpos;
#line 50
using ::fgets;
#line 51
using ::fopen;
#line 52
using ::fprintf;
#line 53
using ::fputc;
#line 54
using ::fputs;
#line 55
using ::fread;
#line 56
using ::freopen;
#line 57
using ::fscanf;
#line 58
using ::fseek;
#line 59
using ::fsetpos;
#line 60
using ::ftell;
#line 61
using ::fwrite;
#line 62
using ::getc;
#line 63
using ::getchar;
#line 64
using ::perror;
#line 65
using ::putc;
#line 66
using ::putchar;
#line 67
using ::printf;
#line 68
using ::puts;
#line 69
using ::remove;
#line 70
using ::rename;
#line 71
using ::rewind;
#line 72
using ::scanf;
#line 73
using ::setbuf;
#line 74
using ::setvbuf;
#line 75
using ::sprintf;
#line 76
using ::sscanf;
#line 77
using ::tmpfile;
#line 78
using ::tmpnam;
#line 79
using ::ungetc;
#line 80
using ::vfprintf;
#line 81
using ::vprintf;
#line 82
using ::vsprintf;
#line 84
using ::snprintf;
#line 85
using ::vsnprintf;
#line 86
using ::vfscanf;
#line 87
using ::vscanf;
#line 88
using ::vsscanf;
#line 90
#pragma warning(pop)
}
#line 95
#pragma warning(pop)
#pragma pack ( pop )
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdio"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstring"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#pragma warning(push)
#pragma warning(disable : 4995)
#line 26
using ::memchr;
#line 27
using ::memcmp;
#line 28
using ::memcpy;
#line 29
using ::memmove;
#line 30
using ::memset;
#line 31
using ::strcat;
#line 32
using ::strchr;
#line 33
using ::strcmp;
#line 34
using ::strcoll;
#line 35
using ::strcpy;
#line 36
using ::strcspn;
#line 37
using ::strerror;
#line 38
using ::strlen;
#line 39
using ::strncat;
#line 40
using ::strncmp;
#line 41
using ::strncpy;
#line 42
using ::strpbrk;
#line 43
using ::strrchr;
#line 44
using ::strspn;
#line 45
using ::strstr;
#line 46
using ::strtok;
#line 47
using ::strxfrm;
#line 49
#pragma warning(pop)
}
#line 54
#pragma warning(pop)
#pragma pack ( pop )
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstring"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cwchar"
#pragma external_header(push)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 28
errno_t __cdecl _cgetws_s(__wchar_t * _Buffer, size_t _BufferCount, size_t * _SizeRead); 
#line 34
extern "C++" {template < size_t _Size > inline errno_t __cdecl _cgetws_s ( wchar_t ( & _Buffer ) [ _Size ], size_t * _SizeRead ) throw ( ) { return _cgetws_s ( _Buffer, _Size, _SizeRead ); }}
#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
int __cdecl _cputws(const __wchar_t * _Buffer); 
#line 46
wint_t __cdecl _getwch(); 
#line 47
wint_t __cdecl _getwche(); 
#line 48
wint_t __cdecl _putwch(__wchar_t _Character); 
#line 49
wint_t __cdecl _ungetwch(wint_t _Character); 
#line 51
wint_t __cdecl _getwch_nolock(); 
#line 52
wint_t __cdecl _getwche_nolock(); 
#line 53
wint_t __cdecl _putwch_nolock(__wchar_t _Character); 
#line 54
wint_t __cdecl _ungetwch_nolock(wint_t _Character); 
#line 64
int __cdecl __conio_common_vcwprintf(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 72
int __cdecl __conio_common_vcwprintf_s(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 80
int __cdecl __conio_common_vcwprintf_p(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 88
__inline int __cdecl _vcwprintf_l(const __wchar_t *const 
#line 89
_Format, const _locale_t 
#line 90
_Locale, va_list 
#line 91
_ArgList) 
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 97
return __conio_common_vcwprintf(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 98
} 
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf(const __wchar_t *const 
#line 103
_Format, va_list 
#line 104
_ArgList) 
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 110
return _vcwprintf_l(_Format, 0, _ArgList); 
#line 111
} 
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_s_l(const __wchar_t *const 
#line 116
_Format, const _locale_t 
#line 117
_Locale, va_list 
#line 118
_ArgList) 
#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 124
return __conio_common_vcwprintf_s(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 125
} 
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_s(const __wchar_t *const 
#line 130
_Format, va_list 
#line 131
_ArgList) 
#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 137
return _vcwprintf_s_l(_Format, 0, _ArgList); 
#line 138
} 
#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_p_l(const __wchar_t *const 
#line 143
_Format, const _locale_t 
#line 144
_Locale, va_list 
#line 145
_ArgList) 
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 151
return __conio_common_vcwprintf_p(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 152
} 
#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_p(const __wchar_t *const 
#line 157
_Format, va_list 
#line 158
_ArgList) 
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 164
return _vcwprintf_p_l(_Format, 0, _ArgList); 
#line 165
} 
#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_l(const __wchar_t *const 
#line 170
_Format, const _locale_t 
#line 171
_Locale, ...) 
#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 177
int _Result; 
#line 178
va_list _ArgList; 
#line 179
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 180
_Result = _vcwprintf_l(_Format, _Locale, _ArgList); 
#line 181
(void)(_ArgList = ((va_list)0)); 
#line 182
return _Result; 
#line 183
} 
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf(const __wchar_t *const 
#line 188
_Format, ...) 
#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 194
int _Result; 
#line 195
va_list _ArgList; 
#line 196
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 197
_Result = _vcwprintf_l(_Format, 0, _ArgList); 
#line 198
(void)(_ArgList = ((va_list)0)); 
#line 199
return _Result; 
#line 200
} 
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_s_l(const __wchar_t *const 
#line 205
_Format, const _locale_t 
#line 206
_Locale, ...) 
#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 212
int _Result; 
#line 213
va_list _ArgList; 
#line 214
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 215
_Result = _vcwprintf_s_l(_Format, _Locale, _ArgList); 
#line 216
(void)(_ArgList = ((va_list)0)); 
#line 217
return _Result; 
#line 218
} 
#line 222 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_s(const __wchar_t *const 
#line 223
_Format, ...) 
#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 229
int _Result; 
#line 230
va_list _ArgList; 
#line 231
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 232
_Result = _vcwprintf_s_l(_Format, 0, _ArgList); 
#line 233
(void)(_ArgList = ((va_list)0)); 
#line 234
return _Result; 
#line 235
} 
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_p_l(const __wchar_t *const 
#line 240
_Format, const _locale_t 
#line 241
_Locale, ...) 
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 247
int _Result; 
#line 248
va_list _ArgList; 
#line 249
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 250
_Result = _vcwprintf_p_l(_Format, _Locale, _ArgList); 
#line 251
(void)(_ArgList = ((va_list)0)); 
#line 252
return _Result; 
#line 253
} 
#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_p(const __wchar_t *const 
#line 258
_Format, ...) 
#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 264
int _Result; 
#line 265
va_list _ArgList; 
#line 266
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 267
_Result = _vcwprintf_p_l(_Format, 0, _ArgList); 
#line 268
(void)(_ArgList = ((va_list)0)); 
#line 269
return _Result; 
#line 270
} 
#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
int __cdecl __conio_common_vcwscanf(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 289
__inline int __cdecl _vcwscanf_l(const __wchar_t *const 
#line 290
_Format, const _locale_t 
#line 291
_Locale, va_list 
#line 292
_ArgList) 
#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 298
return __conio_common_vcwscanf(*__local_stdio_scanf_options(), _Format, _Locale, _ArgList); 
#line 301
} 
#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf(const __wchar_t *const 
#line 306
_Format, va_list 
#line 307
_ArgList) 
#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 313
return _vcwscanf_l(_Format, 0, _ArgList); 
#line 314
} 
#line 318 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf_s_l(const __wchar_t *const 
#line 319
_Format, const _locale_t 
#line 320
_Locale, va_list 
#line 321
_ArgList) 
#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 327
return __conio_common_vcwscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Format, _Locale, _ArgList); 
#line 330
} 
#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf_s(const __wchar_t *const 
#line 335
_Format, va_list 
#line 336
_ArgList) 
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 342
return _vcwscanf_s_l(_Format, 0, _ArgList); 
#line 343
} 
#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_l(const __wchar_t *const 
#line 348
_Format, const _locale_t 
#line 349
_Locale, ...) 
#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 355
int _Result; 
#line 356
va_list _ArgList; 
#line 357
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 359
_Result = _vcwscanf_l(_Format, _Locale, _ArgList); 
#line 361
(void)(_ArgList = ((va_list)0)); 
#line 362
return _Result; 
#line 363
} 
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf(const __wchar_t *const 
#line 368
_Format, ...) 
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 374
int _Result; 
#line 375
va_list _ArgList; 
#line 376
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 378
_Result = _vcwscanf_l(_Format, 0, _ArgList); 
#line 380
(void)(_ArgList = ((va_list)0)); 
#line 381
return _Result; 
#line 382
} 
#line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_s_l(const __wchar_t *const 
#line 387
_Format, const _locale_t 
#line 388
_Locale, ...) 
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 394
int _Result; 
#line 395
va_list _ArgList; 
#line 396
(void)(__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 397
_Result = _vcwscanf_s_l(_Format, _Locale, _ArgList); 
#line 398
(void)(_ArgList = ((va_list)0)); 
#line 399
return _Result; 
#line 400
} 
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_s(const __wchar_t *const 
#line 405
_Format, ...) 
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
{ 
#line 411
int _Result; 
#line 412
va_list _ArgList; 
#line 413
(void)(__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 414
_Result = _vcwscanf_s_l(_Format, 0, _ArgList); 
#line 415
(void)(_ArgList = ((va_list)0)); 
#line 416
return _Result; 
#line 417
} 
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
}__pragma( pack ( pop )) 
#line 424
#pragma warning(pop)
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"
const unsigned short *__cdecl __pctype_func(); 
#line 36
const wctype_t *__cdecl __pwctype_func(); 
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"
int __cdecl iswalnum(wint_t _C); 
#line 68
int __cdecl iswalpha(wint_t _C); 
#line 69
int __cdecl iswascii(wint_t _C); 
#line 70
int __cdecl iswblank(wint_t _C); 
#line 71
int __cdecl iswcntrl(wint_t _C); 
#line 74
int __cdecl iswdigit(wint_t _C); 
#line 76
int __cdecl iswgraph(wint_t _C); 
#line 77
int __cdecl iswlower(wint_t _C); 
#line 78
int __cdecl iswprint(wint_t _C); 
#line 79
int __cdecl iswpunct(wint_t _C); 
#line 80
int __cdecl iswspace(wint_t _C); 
#line 81
int __cdecl iswupper(wint_t _C); 
#line 82
int __cdecl iswxdigit(wint_t _C); 
#line 83
int __cdecl __iswcsymf(wint_t _C); 
#line 84
int __cdecl __iswcsym(wint_t _C); 
#line 86
int __cdecl _iswalnum_l(wint_t _C, _locale_t _Locale); 
#line 87
int __cdecl _iswalpha_l(wint_t _C, _locale_t _Locale); 
#line 88
int __cdecl _iswblank_l(wint_t _C, _locale_t _Locale); 
#line 89
int __cdecl _iswcntrl_l(wint_t _C, _locale_t _Locale); 
#line 90
int __cdecl _iswdigit_l(wint_t _C, _locale_t _Locale); 
#line 91
int __cdecl _iswgraph_l(wint_t _C, _locale_t _Locale); 
#line 92
int __cdecl _iswlower_l(wint_t _C, _locale_t _Locale); 
#line 93
int __cdecl _iswprint_l(wint_t _C, _locale_t _Locale); 
#line 94
int __cdecl _iswpunct_l(wint_t _C, _locale_t _Locale); 
#line 95
int __cdecl _iswspace_l(wint_t _C, _locale_t _Locale); 
#line 96
int __cdecl _iswupper_l(wint_t _C, _locale_t _Locale); 
#line 97
int __cdecl _iswxdigit_l(wint_t _C, _locale_t _Locale); 
#line 98
int __cdecl _iswcsymf_l(wint_t _C, _locale_t _Locale); 
#line 99
int __cdecl _iswcsym_l(wint_t _C, _locale_t _Locale); 
#line 102
wint_t __cdecl towupper(wint_t _C); 
#line 103
wint_t __cdecl towlower(wint_t _C); 
#line 104
int __cdecl iswctype(wint_t _C, wctype_t _Type); 
#line 106
wint_t __cdecl _towupper_l(wint_t _C, _locale_t _Locale); 
#line 107
wint_t __cdecl _towlower_l(wint_t _C, _locale_t _Locale); 
#line 108
int __cdecl _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale); 
#line 112
int __cdecl isleadbyte(int _C); 
#line 113
int __cdecl _isleadbyte_l(int _C, _locale_t _Locale); 
#line 115
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instea" "d. See online help for details.")) int __cdecl is_wctype(wint_t _C, wctype_t _Type); 
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"
}__pragma( pack ( pop )) 
#line 205
#pragma warning(pop)
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wdirect.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 26
__declspec(allocator) __wchar_t *__cdecl _wgetcwd(__wchar_t * _DstBuf, int _SizeInWords); 
#line 33
__declspec(allocator) __wchar_t *__cdecl _wgetdcwd(int _Drive, __wchar_t * _DstBuf, int _SizeInWords); 
#line 45
int __cdecl _wchdir(const __wchar_t * _Path); 
#line 50
int __cdecl _wmkdir(const __wchar_t * _Path); 
#line 55
int __cdecl _wrmdir(const __wchar_t * _Path); 
#line 61
}__pragma( pack ( pop )) 
#line 63
#pragma warning(pop)
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_share.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_share.h"
#pragma warning(pop)
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"
typedef unsigned long _fsize_t; 
#line 35
struct _wfinddata32_t { 
#line 37
unsigned attrib; 
#line 38
__time32_t time_create; 
#line 39
__time32_t time_access; 
#line 40
__time32_t time_write; 
#line 41
_fsize_t size; 
#line 42
__wchar_t name[260]; 
#line 43
}; 
#line 45
struct _wfinddata32i64_t { 
#line 47
unsigned attrib; 
#line 48
__time32_t time_create; 
#line 49
__time32_t time_access; 
#line 50
__time32_t time_write; 
#line 51
__int64 size; 
#line 52
__wchar_t name[260]; 
#line 53
}; 
#line 55
struct _wfinddata64i32_t { 
#line 57
unsigned attrib; 
#line 58
__time64_t time_create; 
#line 59
__time64_t time_access; 
#line 60
__time64_t time_write; 
#line 61
_fsize_t size; 
#line 62
__wchar_t name[260]; 
#line 63
}; 
#line 65
struct _wfinddata64_t { 
#line 67
unsigned attrib; 
#line 68
__time64_t time_create; 
#line 69
__time64_t time_access; 
#line 70
__time64_t time_write; 
#line 71
__int64 size; 
#line 72
__wchar_t name[260]; 
#line 73
}; 
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"
int __cdecl _waccess(const __wchar_t * _FileName, int _AccessMode); 
#line 101
errno_t __cdecl _waccess_s(const __wchar_t * _FileName, int _AccessMode); 
#line 107
int __cdecl _wchmod(const __wchar_t * _FileName, int _Mode); 
#line 113
int __cdecl _wcreat(const __wchar_t * _FileName, int _PermissionMode); 
#line 120
intptr_t __cdecl _wfindfirst32(const __wchar_t * _FileName, _wfinddata32_t * _FindData); 
#line 127
int __cdecl _wfindnext32(intptr_t _FindHandle, _wfinddata32_t * _FindData); 
#line 132
int __cdecl _wunlink(const __wchar_t * _FileName); 
#line 137
int __cdecl _wrename(const __wchar_t * _OldFileName, const __wchar_t * _NewFileName); 
#line 142
errno_t __cdecl _wmktemp_s(__wchar_t * _TemplateName, size_t _SizeInWords); 
#line 147
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wmktemp_s ( wchar_t ( & _TemplateName ) [ _Size ] ) throw ( ) { return _wmktemp_s ( _TemplateName, _Size ); }}
#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"
__wchar_t *__cdecl _wmktemp(__wchar_t * _TemplateName); 
#line 160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"
intptr_t __cdecl _wfindfirst32i64(const __wchar_t * _FileName, _wfinddata32i64_t * _FindData); 
#line 167
intptr_t __cdecl _wfindfirst64i32(const __wchar_t * _FileName, _wfinddata64i32_t * _FindData); 
#line 174
intptr_t __cdecl _wfindfirst64(const __wchar_t * _FileName, _wfinddata64_t * _FindData); 
#line 181
int __cdecl _wfindnext32i64(intptr_t _FindHandle, _wfinddata32i64_t * _FindData); 
#line 188
int __cdecl _wfindnext64i32(intptr_t _FindHandle, _wfinddata64i32_t * _FindData); 
#line 195
int __cdecl _wfindnext64(intptr_t _FindHandle, _wfinddata64_t * _FindData); 
#line 201
errno_t __cdecl _wsopen_s(int * _FileHandle, const __wchar_t * _FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag); 
#line 209
errno_t __cdecl _wsopen_dispatch(const __wchar_t * _FileName, int _OFlag, int _ShFlag, int _PMode, int * _PFileHandle, int _BSecure); 
#line 224
extern "C++" inline int __cdecl _wopen(const __wchar_t *
#line 225
_FileName, int 
#line 226
_OFlag, int 
#line 227
_PMode = 0) 
#line 229
{ 
#line 230
int _FileHandle; 
#line 232
const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, 64, _PMode, &_FileHandle, 0); 
#line 233
return (_Result) ? -1 : _FileHandle; 
#line 234
} 
#line 237
extern "C++" inline int __cdecl _wsopen(const __wchar_t *
#line 238
_FileName, int 
#line 239
_OFlag, int 
#line 240
_ShFlag, int 
#line 241
_PMode = 0) 
#line 243
{ 
#line 244
int _FileHandle; 
#line 246
const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0); 
#line 247
return (_Result) ? -1 : _FileHandle; 
#line 248
} 
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"
}__pragma( pack ( pop )) 
#line 270
#pragma warning(pop)
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wprocess.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 24
intptr_t __cdecl _wexecl(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 29
intptr_t __cdecl _wexecle(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 34
intptr_t __cdecl _wexeclp(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 39
intptr_t __cdecl _wexeclpe(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 44
intptr_t __cdecl _wexecv(const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 49
intptr_t __cdecl _wexecve(const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 55
intptr_t __cdecl _wexecvp(const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 60
intptr_t __cdecl _wexecvpe(const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 66
intptr_t __cdecl _wspawnl(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 72
intptr_t __cdecl _wspawnle(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 78
intptr_t __cdecl _wspawnlp(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 84
intptr_t __cdecl _wspawnlpe(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 90
intptr_t __cdecl _wspawnv(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 96
intptr_t __cdecl _wspawnve(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 103
intptr_t __cdecl _wspawnvp(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 109
intptr_t __cdecl _wspawnvpe(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 116
int __cdecl _wsystem(const __wchar_t * _Command); 
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wprocess.h"
}__pragma( pack ( pop )) 
#line 127
#pragma warning(pop)
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
typedef unsigned short _ino_t; 
#line 22
typedef _ino_t ino_t; 
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"
typedef unsigned _dev_t; 
#line 34
typedef _dev_t dev_t; 
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"
typedef long _off_t; 
#line 46
typedef _off_t off_t; 
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"
#pragma warning(pop)
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 17
__pragma( pack ( push, 8 )) extern "C" {
#line 24
struct _stat32 { 
#line 26
_dev_t st_dev; 
#line 27
_ino_t st_ino; 
#line 28
unsigned short st_mode; 
#line 29
short st_nlink; 
#line 30
short st_uid; 
#line 31
short st_gid; 
#line 32
_dev_t st_rdev; 
#line 33
_off_t st_size; 
#line 34
__time32_t st_atime; 
#line 35
__time32_t st_mtime; 
#line 36
__time32_t st_ctime; 
#line 37
}; 
#line 39
struct _stat32i64 { 
#line 41
_dev_t st_dev; 
#line 42
_ino_t st_ino; 
#line 43
unsigned short st_mode; 
#line 44
short st_nlink; 
#line 45
short st_uid; 
#line 46
short st_gid; 
#line 47
_dev_t st_rdev; 
#line 48
__int64 st_size; 
#line 49
__time32_t st_atime; 
#line 50
__time32_t st_mtime; 
#line 51
__time32_t st_ctime; 
#line 52
}; 
#line 54
struct _stat64i32 { 
#line 56
_dev_t st_dev; 
#line 57
_ino_t st_ino; 
#line 58
unsigned short st_mode; 
#line 59
short st_nlink; 
#line 60
short st_uid; 
#line 61
short st_gid; 
#line 62
_dev_t st_rdev; 
#line 63
_off_t st_size; 
#line 64
__time64_t st_atime; 
#line 65
__time64_t st_mtime; 
#line 66
__time64_t st_ctime; 
#line 67
}; 
#line 69
struct _stat64 { 
#line 71
_dev_t st_dev; 
#line 72
_ino_t st_ino; 
#line 73
unsigned short st_mode; 
#line 74
short st_nlink; 
#line 75
short st_uid; 
#line 76
short st_gid; 
#line 77
_dev_t st_rdev; 
#line 78
__int64 st_size; 
#line 79
__time64_t st_atime; 
#line 80
__time64_t st_mtime; 
#line 81
__time64_t st_ctime; 
#line 82
}; 
#line 87
struct stat { 
#line 89
_dev_t st_dev; 
#line 90
_ino_t st_ino; 
#line 91
unsigned short st_mode; 
#line 92
short st_nlink; 
#line 93
short st_uid; 
#line 94
short st_gid; 
#line 95
_dev_t st_rdev; 
#line 96
_off_t st_size; 
#line 97
time_t st_atime; 
#line 98
time_t st_mtime; 
#line 99
time_t st_ctime; 
#line 100
}; 
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"
int __cdecl _fstat32(int _FileHandle, struct _stat32 * _Stat); 
#line 159
int __cdecl _fstat32i64(int _FileHandle, struct _stat32i64 * _Stat); 
#line 164
int __cdecl _fstat64i32(int _FileHandle, struct _stat64i32 * _Stat); 
#line 169
int __cdecl _fstat64(int _FileHandle, struct _stat64 * _Stat); 
#line 174
int __cdecl _stat32(const char * _FileName, struct _stat32 * _Stat); 
#line 179
int __cdecl _stat32i64(const char * _FileName, struct _stat32i64 * _Stat); 
#line 184
int __cdecl _stat64i32(const char * _FileName, struct _stat64i32 * _Stat); 
#line 189
int __cdecl _stat64(const char * _FileName, struct _stat64 * _Stat); 
#line 194
int __cdecl _wstat32(const __wchar_t * _FileName, struct _stat32 * _Stat); 
#line 199
int __cdecl _wstat32i64(const __wchar_t * _FileName, struct _stat32i64 * _Stat); 
#line 204
int __cdecl _wstat64i32(const __wchar_t * _FileName, struct _stat64i32 * _Stat); 
#line 209
int __cdecl _wstat64(const __wchar_t * _FileName, struct _stat64 * _Stat); 
#line 233
static __inline int __cdecl fstat(const int _FileHandle, struct stat *const _Stat) 
#line 234
{ 
#line 235
static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
#line 236
return _fstat64i32(_FileHandle, (struct _stat64i32 *)_Stat); 
#line 237
} 
#line 238
static __inline int __cdecl stat(const char *const _FileName, struct stat *const _Stat) 
#line 239
{ 
#line 240
static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
#line 241
return _stat64i32(_FileName, (struct _stat64i32 *)_Stat); 
#line 242
} 
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"
}__pragma( pack ( pop )) 
#line 249
#pragma warning(pop)
#pragma external_header(pop)
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 33
__pragma( pack ( push, 8 )) extern "C" {
#line 42
typedef __wchar_t _Wint_t; 
#line 49
__wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); 
#line 55
_locale_t __cdecl _wcreate_locale(int _Category, const __wchar_t * _Locale); 
#line 62
wint_t __cdecl btowc(int _Ch); 
#line 66
size_t __cdecl mbrlen(const char * _Ch, size_t _SizeInBytes, mbstate_t * _State); 
#line 72
size_t __cdecl mbrtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SizeInBytes, mbstate_t * _State); 
#line 80
errno_t __cdecl mbsrtowcs_s(size_t * _Retval, __wchar_t * _Dst, size_t _Size, const char ** _PSrc, size_t _N, mbstate_t * _State); 
#line 89
extern "C++" {template < size_t _Size > inline errno_t __cdecl mbsrtowcs_s ( size_t * _Retval, wchar_t ( & _Dest ) [ _Size ], char const * * _PSource, size_t _Count, mbstate_t * _State ) throw ( ) { return mbsrtowcs_s ( _Retval, _Dest, _Size, _PSource, _Count, _State ); }}
#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
size_t __cdecl mbsrtowcs(__wchar_t * _Dest, const char ** _PSrc, size_t _Count, mbstate_t * _State); 
#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
errno_t __cdecl wcrtomb_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, __wchar_t _Ch, mbstate_t * _State); 
#line 116
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcrtomb_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t _Source, mbstate_t * _State ) throw ( ) { return wcrtomb_s ( _Retval, _Dest, _Size, _Source, _State ); }}
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
size_t __cdecl wcrtomb(char * _Dest, __wchar_t _Source, mbstate_t * _State); 
#line 133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
errno_t __cdecl wcsrtombs_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, const __wchar_t ** _Src, size_t _Size, mbstate_t * _State); 
#line 142
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsrtombs_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t const * * _PSrc, size_t _Count, mbstate_t * _State ) throw ( ) { return wcsrtombs_s ( _Retval, _Dest, _Size, _PSrc, _Count, _State ); }}
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
size_t __cdecl wcsrtombs(char * _Dest, const __wchar_t ** _PSource, size_t _Count, mbstate_t * _State); 
#line 160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
int __cdecl wctob(wint_t _WCh); 
#line 167
errno_t __cdecl wmemcpy_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); 
#line 175
errno_t __cdecl wmemmove_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); 
#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
__inline int __cdecl fwide(FILE *
#line 185
_F, int 
#line 186
_M) 
#line 188
{ 
#line 189
(void)_F; 
#line 190
return _M; 
#line 191
} 
#line 193
__inline int __cdecl mbsinit(const mbstate_t *
#line 194
_P) 
#line 196
{ 
#line 197
return (_P == (0)) || ((_P->_Wchar) == (0)); 
#line 198
} 
#line 200
__inline const __wchar_t *__cdecl wmemchr(const __wchar_t *
#line 201
_S, __wchar_t 
#line 202
_C, size_t 
#line 203
_N) 
#line 205
{ 
#line 206
for (; (0) < _N; (++_S), (--_N)) { 
#line 207
if ((*_S) == _C) { 
#line 208
return (const __wchar_t *)_S; }  }  
#line 210
return 0; 
#line 211
} 
#line 213
__inline int __cdecl wmemcmp(const __wchar_t *
#line 214
_S1, const __wchar_t *
#line 215
_S2, size_t 
#line 216
_N) 
#line 218
{ 
#line 219
for (; (0) < _N; ((++_S1), (++_S2)), (--_N)) { 
#line 220
if ((*_S1) != (*_S2)) { 
#line 221
return ((*_S1) < (*_S2)) ? -1 : 1; }  }  
#line 223
return 0; 
#line 224
} 
#line 229
__inline __wchar_t *__cdecl wmemcpy(__wchar_t *
#line 230
_S1, const __wchar_t *
#line 231
_S2, size_t 
#line 232
_N) 
#line 234
{ 
#pragma warning(suppress: 6386)
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
#line 237
} 
#line 240
__inline __wchar_t *__cdecl wmemmove(__wchar_t *
#line 241
_S1, const __wchar_t *
#line 242
_S2, size_t 
#line 243
_N) 
#line 245
{ 
#pragma warning(suppress: 6386)
return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
#line 248
} 
#line 252
__inline __wchar_t *__cdecl wmemset(__wchar_t *
#line 253
_S, __wchar_t 
#line 254
_C, size_t 
#line 255
_N) 
#line 257
{ 
#line 258
__wchar_t *_Su = _S; 
#line 259
for (; (0) < _N; (++_Su), (--_N)) 
#line 260
{ 
#line 261
(*_Su) = _C; 
#line 262
}  
#line 263
return _S; 
#line 264
} 
#line 268
extern "C++" inline __wchar_t *__cdecl wmemchr(__wchar_t *
#line 269
_S, __wchar_t 
#line 270
_C, size_t 
#line 271
_N) 
#line 273
{ 
#line 274
const __wchar_t *const _SC = _S; 
#line 275
return const_cast< __wchar_t *>(wmemchr(_SC, _C, _N)); 
#line 276
} 
#line 283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
}__pragma( pack ( pop )) 
#line 285
#pragma warning(pop)
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cwchar"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 22
extern "C" { using _Mbstatet = mbstate_t; }
#line 24
namespace std { 
#pragma warning(push)
#pragma warning(disable : 4995)
#line 30
using ::mbstate_t;
#line 32
using ::tm;
#line 33
using ::wint_t;
#line 35
using ::btowc;
#line 36
using ::fgetwc;
#line 37
using ::fgetws;
#line 38
using ::fputwc;
#line 39
using ::fputws;
#line 40
using ::fwide;
#line 41
using ::fwprintf;
#line 42
using ::fwscanf;
#line 43
using ::getwc;
#line 44
using ::getwchar;
#line 45
using ::mbrlen;
#line 46
using ::mbrtowc;
#line 47
using ::mbsrtowcs;
#line 48
using ::mbsinit;
#line 49
using ::putwc;
#line 50
using ::putwchar;
#line 51
using ::swprintf;
#line 52
using ::swscanf;
#line 53
using ::ungetwc;
#line 54
using ::vfwprintf;
#line 55
using ::vswprintf;
#line 56
using ::vwprintf;
#line 57
using ::wcrtomb;
#line 58
using ::wprintf;
#line 59
using ::wscanf;
#line 60
using ::wcsrtombs;
#line 61
using ::wcstol;
#line 62
using ::wcscat;
#line 63
using ::wcschr;
#line 64
using ::wcscmp;
#line 65
using ::wcscoll;
#line 66
using ::wcscpy;
#line 67
using ::wcscspn;
#line 68
using ::wcslen;
#line 69
using ::wcsncat;
#line 70
using ::wcsncmp;
#line 71
using ::wcsncpy;
#line 72
using ::wcspbrk;
#line 73
using ::wcsrchr;
#line 74
using ::wcsspn;
#line 75
using ::wcstod;
#line 76
using ::wcstoul;
#line 77
using ::wcsstr;
#line 78
using ::wcstok;
#line 79
using ::wcsxfrm;
#line 80
using ::wctob;
#line 81
using ::wmemchr;
#line 82
using ::wmemcmp;
#line 83
using ::wmemcpy;
#line 84
using ::wmemmove;
#line 85
using ::wmemset;
#line 86
using ::wcsftime;
#line 88
using ::vfwscanf;
#line 89
using ::vswscanf;
#line 90
using ::vwscanf;
#line 91
using ::wcstof;
#line 92
using ::wcstold;
#line 93
using ::wcstoll;
#line 94
using ::wcstoull;
#line 96
#pragma warning(pop)
}
#line 101
#pragma warning(pop)
#pragma pack ( pop )
#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cwchar"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstddef"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 22
namespace std { 
#line 23
using ::ptrdiff_t;
#line 25
using max_align_t = double; 
#line 92
}
#line 94
using std::max_align_t;
#line 98
#pragma warning(pop)
#pragma pack ( pop )
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstddef"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\initializer_list"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 20
namespace std { 
#line 21
template < class _Elem >
class initializer_list {
public :
    using value_type = _Elem;
    using reference = const _Elem &;
    using const_reference = const _Elem &;
    using size_type = size_t;

    using iterator = const _Elem *;
    using const_iterator = const _Elem *;

    constexpr initializer_list ( ) noexcept : _First ( nullptr ), _Last ( nullptr ) { }

    constexpr initializer_list ( const _Elem * _First_arg, const _Elem * _Last_arg ) noexcept
        : _First ( _First_arg ), _Last ( _Last_arg ) { }

    [ [ nodiscard ] ] constexpr const _Elem * begin ( ) const noexcept {
        return _First;
    }

    [ [ nodiscard ] ] constexpr const _Elem * end ( ) const noexcept {
        return _Last;
    }

    [ [ nodiscard ] ] constexpr size_t size ( ) const noexcept {
        return static_cast < size_t > ( _Last - _First );
    }

private :
    const _Elem * _First;
    const _Elem * _Last;
};
#line 54
template < class _Elem >
[ [ nodiscard ] ] constexpr const _Elem * begin ( initializer_list < _Elem > _Ilist ) noexcept {
    return _Ilist . begin ( );
}
#line 59
template < class _Elem >
[ [ nodiscard ] ] constexpr const _Elem * end ( initializer_list < _Elem > _Ilist ) noexcept {
    return _Ilist . end ( );
}
#line 63
}
#line 66
#pragma warning(pop)
#pragma pack ( pop )
#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\initializer_list"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 23
namespace std { 
#line 24
template< class > constexpr bool 
#line 26
_Always_false = false; 
#line 30
template< class _Arg, class _Result> 
#line 31
struct unary_function { 
#line 32
using argument_type = _Arg; 
#line 33
using result_type = _Result; 
#line 34
}; 
#line 36
template< class _Arg1, class _Arg2, class _Result> 
#line 37
struct binary_function { 
#line 38
using first_argument_type = _Arg1; 
#line 39
using second_argument_type = _Arg2; 
#line 40
using result_type = _Result; 
#line 41
}; 
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
template < class _Ty = void >
struct plus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [ [ nodiscard ] ] constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left + _Right;
    }
};
#line 55
template < class _Ty = void >
struct minus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [ [ nodiscard ] ] constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left - _Right;
    }
};
#line 66
template < class _Ty = void >
struct multiplies {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [ [ nodiscard ] ] constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left * _Right;
    }
};
#line 77
template < class _Ty = void >
struct equal_to {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left == _Right;
    }
};
#line 88
template < class _Ty = void >
struct not_equal_to {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left != _Right;
    }
};
#line 99
template < class _Ty = void >
struct greater {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left > _Right;
    }
};
#line 110
template < class _Ty = void >
struct less {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left < _Right;
    }
};
#line 121
template < class _Ty = void >
struct greater_equal {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left >= _Right;
    }
};
#line 132
template < class _Ty = void >
struct less_equal {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [ [ nodiscard ] ] constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const {
        return _Left <= _Right;
    }
};
#line 144
template<> struct plus< void>  { 
#line 145
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) + static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) + static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) + static_cast < _Ty2 && > ( _Right );
    }
#line 152
using is_transparent = int; 
#line 153
}; 
#line 156
template<> struct minus< void>  { 
#line 157
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) - static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) - static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) - static_cast < _Ty2 && > ( _Right );
    }
#line 164
using is_transparent = int; 
#line 165
}; 
#line 168
template<> struct multiplies< void>  { 
#line 169
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) * static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) * static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) * static_cast < _Ty2 && > ( _Right );
    }
#line 176
using is_transparent = int; 
#line 177
}; 
#line 180
template<> struct equal_to<>  { 
#line 181
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) == static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) == static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) == static_cast < _Ty2 && > ( _Right );
    }
#line 188
using is_transparent = int; 
#line 189
}; 
#line 192
template<> struct not_equal_to< void>  { 
#line 193
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) != static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) != static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) != static_cast < _Ty2 && > ( _Right );
    }
#line 200
using is_transparent = int; 
#line 201
}; 
#line 204
template<> struct greater< void>  { 
#line 205
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) > static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) > static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) > static_cast < _Ty2 && > ( _Right );
    }
#line 212
using is_transparent = int; 
#line 213
}; 
#line 216
template<> struct less<>  { 
#line 217
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) < static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) < static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) < static_cast < _Ty2 && > ( _Right );
    }
#line 224
using is_transparent = int; 
#line 225
}; 
#line 228
template<> struct greater_equal< void>  { 
#line 229
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) >= static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) >= static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) >= static_cast < _Ty2 && > ( _Right );
    }
#line 236
using is_transparent = int; 
#line 237
}; 
#line 240
template<> struct less_equal< void>  { 
#line 241
template < class _Ty1, class _Ty2 >
    [ [ nodiscard ] ] constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
        noexcept ( noexcept ( static_cast < _Ty1 && > ( _Left ) <= static_cast < _Ty2 && > ( _Right ) ) )
        -> decltype ( static_cast < _Ty1 && > ( _Left ) <= static_cast < _Ty2 && > ( _Right ) ) {
        return static_cast < _Ty1 && > ( _Left ) <= static_cast < _Ty2 && > ( _Right );
    }
#line 248
using is_transparent = int; 
#line 249
}; 
#line 251
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty * addressof ( _Ty & _Val ) noexcept {
    return __builtin_addressof ( _Val );
}
#line 256
template < class _Ty >
const _Ty * addressof ( const _Ty && ) = delete;
#line 259
template < class _Ptrty >
[ [ nodiscard ] ] constexpr auto _Unfancy ( _Ptrty _Ptr ) noexcept {
    return :: std :: addressof ( * _Ptr );
}
#line 264
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty * _Unfancy ( _Ty * _Ptr ) noexcept {
    return _Ptr;
}
#line 268
}
#line 399 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#pragma warning(pop)
#pragma pack ( pop )
#line 403 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 24
namespace std { 
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
using streamoff = __int64; 
#line 48
using streamsize = __int64; 
#line 50
template < class _Statetype >
class fpos {
public :
     fpos ( streamoff _Off = 0 ) : _Myoff ( _Off ), _Fpos ( 0 ), _Mystate ( ) { }

    fpos ( _Statetype _State, fpos_t _Fileposition ) : _Myoff ( _Fileposition ), _Fpos ( 0 ), _Mystate ( _State ) { }

    [ [ nodiscard ] ] _Statetype state ( ) const {
        return _Mystate;
    }

    void state ( _Statetype _State ) {
        _Mystate = _State;
    }

    operator streamoff ( ) const {


        return _Myoff + _Fpos;
    }


    [ [ deprecated ( "warning STL4019: The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with workarounds for o" "ld versions of Visual C++. It will be removed in a future release, and in this release always returns 0. Please use standards-co" "nforming mechanisms to manipulate fpos, such as conversions to and from streamoff, or an integral type, instead. If you are rece" "iving this message while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use standards-conforming mec" "hanisms, as it does for other compilers. You can define _SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have r" "eceived this warning, or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely." ) ] ] fpos_t seekpos ( ) const noexcept {
        return { };
    }


    [ [ nodiscard ] ] streamoff operator - ( const fpos & _Right ) const {
        return static_cast < streamoff > ( * this ) - static_cast < streamoff > ( _Right );
    }

    fpos & operator += ( streamoff _Off ) {
        _Myoff += _Off;
        return * this;
    }

    fpos & operator -= ( streamoff _Off ) {
        _Myoff -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] fpos operator + ( streamoff _Off ) const {
        fpos _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] fpos operator - ( streamoff _Off ) const {
        fpos _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] bool operator == ( const fpos & _Right ) const {
        return static_cast < streamoff > ( * this ) == static_cast < streamoff > ( _Right );
    }

    template < class _Int, enable_if_t < is_integral_v < _Int >, int > = 0 >
    friend bool operator == ( const fpos & _Left, const _Int _Right ) {
        return static_cast < streamoff > ( _Left ) == _Right;
    }

    template < class _Int, enable_if_t < is_integral_v < _Int >, int > = 0 >
    friend bool operator == ( const _Int _Left, const fpos & _Right ) {
        return _Left == static_cast < streamoff > ( _Right );
    }

    [ [ nodiscard ] ] bool operator != ( const fpos & _Right ) const {
        return static_cast < streamoff > ( * this ) != static_cast < streamoff > ( _Right );
    }

    template < class _Int, enable_if_t < is_integral_v < _Int >, int > = 0 >
    friend bool operator != ( const fpos & _Left, const _Int _Right ) {
        return static_cast < streamoff > ( _Left ) != _Right;
    }

    template < class _Int, enable_if_t < is_integral_v < _Int >, int > = 0 >
    friend bool operator != ( const _Int _Left, const fpos & _Right ) {
        return _Left != static_cast < streamoff > ( _Right );
    }

private :
    streamoff _Myoff;
    fpos_t _Fpos;
    _Statetype _Mystate;
};
#line 137 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
using streampos = fpos< _Mbstatet> ; 
#line 138
using wstreampos = streampos; 
#line 140
class locale; 
#line 141
template < class _Facet >
const _Facet & __cdecl use_facet ( const locale & );
#line 144
template< class _Elem> struct char_traits; 
#line 147
template<> struct char_traits< char> ; 
#line 153
template<> struct char_traits< char16_t> ; 
#line 155
template<> struct char_traits< char32_t> ; 
#line 157
template<> struct char_traits< __wchar_t> ; 
#line 160
template<> struct char_traits< unsigned short> ; 
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
template < class _Ty >
class allocator;
#line 165
class ios_base; 
#line 166
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_ios;
#line 168
template < class _Elem, class _Traits = char_traits < _Elem > >
class istreambuf_iterator;
#line 170
template < class _Elem, class _Traits = char_traits < _Elem > >
class ostreambuf_iterator;
#line 172
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_streambuf;
#line 175
#pragma vtordisp(push, 2)
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_istream;
#line 178
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_ostream;
#pragma vtordisp(pop)
#line 182
template < class _Elem, class _Traits = char_traits < _Elem > >
class basic_iostream;
#line 184
template< class _Elem, class _Traits = char_traits< _Elem> , class _Alloc = allocator< _Elem> > class basic_stringbuf; 
#line 186
template< class _Elem, class _Traits = char_traits< _Elem> , class _Alloc = allocator< _Elem> > class basic_istringstream; 
#line 188
template< class _Elem, class _Traits = char_traits< _Elem> , class _Alloc = allocator< _Elem> > class basic_ostringstream; 
#line 190
template< class _Elem, class _Traits = char_traits< _Elem> , class _Alloc = allocator< _Elem> > class basic_stringstream; 
#line 192
template< class _Elem, class _Traits = char_traits< _Elem> > class basic_filebuf; 
#line 194
template< class _Elem, class _Traits = char_traits< _Elem> > class basic_ifstream; 
#line 196
template< class _Elem, class _Traits = char_traits< _Elem> > class basic_ofstream; 
#line 198
template< class _Elem, class _Traits = char_traits< _Elem> > class basic_fstream; 
#line 218 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
using ios = basic_ios< char, char_traits< char> > ; 
#line 219
using streambuf = basic_streambuf< char, char_traits< char> > ; 
#line 220
using istream = basic_istream< char, char_traits< char> > ; 
#line 221
using ostream = basic_ostream< char, char_traits< char> > ; 
#line 222
using iostream = basic_iostream< char, char_traits< char> > ; 
#line 223
using stringbuf = basic_stringbuf< char, char_traits< char> , allocator< char> > ; 
#line 224
using istringstream = basic_istringstream< char, char_traits< char> , allocator< char> > ; 
#line 225
using ostringstream = basic_ostringstream< char, char_traits< char> , allocator< char> > ; 
#line 226
using stringstream = basic_stringstream< char, char_traits< char> , allocator< char> > ; 
#line 227
using filebuf = basic_filebuf< char, char_traits< char> > ; 
#line 228
using ifstream = basic_ifstream< char, char_traits< char> > ; 
#line 229
using ofstream = basic_ofstream< char, char_traits< char> > ; 
#line 230
using fstream = basic_fstream< char, char_traits< char> > ; 
#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
using wios = basic_ios< __wchar_t, char_traits< __wchar_t> > ; 
#line 237
using wstreambuf = basic_streambuf< __wchar_t, char_traits< __wchar_t> > ; 
#line 238
using wistream = basic_istream< __wchar_t, char_traits< __wchar_t> > ; 
#line 239
using wostream = basic_ostream< __wchar_t, char_traits< __wchar_t> > ; 
#line 240
using wiostream = basic_iostream< __wchar_t, char_traits< __wchar_t> > ; 
#line 241
using wstringbuf = basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 242
using wistringstream = basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 243
using wostringstream = basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 244
using wstringstream = basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 245
using wfilebuf = basic_filebuf< __wchar_t, char_traits< __wchar_t> > ; 
#line 246
using wifstream = basic_ifstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 247
using wofstream = basic_ofstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 248
using wfstream = basic_fstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
}
#line 263
#pragma warning(pop)
#pragma pack ( pop )
#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdint.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 18
typedef signed char int8_t; 
#line 19
typedef short int16_t; 
#line 20
typedef int int32_t; 
#line 21
typedef __int64 int64_t; 
#line 22
typedef unsigned char uint8_t; 
#line 23
typedef unsigned short uint16_t; 
#line 24
typedef unsigned uint32_t; 
#line 25
typedef unsigned __int64 uint64_t; 
#line 27
typedef signed char int_least8_t; 
#line 28
typedef short int_least16_t; 
#line 29
typedef int int_least32_t; 
#line 30
typedef __int64 int_least64_t; 
#line 31
typedef unsigned char uint_least8_t; 
#line 32
typedef unsigned short uint_least16_t; 
#line 33
typedef unsigned uint_least32_t; 
#line 34
typedef unsigned __int64 uint_least64_t; 
#line 36
typedef signed char int_fast8_t; 
#line 37
typedef int int_fast16_t; 
#line 38
typedef int int_fast32_t; 
#line 39
typedef __int64 int_fast64_t; 
#line 40
typedef unsigned char uint_fast8_t; 
#line 41
typedef unsigned uint_fast16_t; 
#line 42
typedef unsigned uint_fast32_t; 
#line 43
typedef unsigned __int64 uint_fast64_t; 
#line 45
typedef __int64 intmax_t; 
#line 46
typedef unsigned __int64 uintmax_t; 
#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdint.h"
#pragma warning(pop)
#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdint.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#line 22
using ::int8_t;
#line 23
using ::int16_t;
#line 24
using ::int32_t;
#line 25
using ::int64_t;
#line 26
using ::uint8_t;
#line 27
using ::uint16_t;
#line 28
using ::uint32_t;
#line 29
using ::uint64_t;
#line 31
using ::int_least8_t;
#line 32
using ::int_least16_t;
#line 33
using ::int_least32_t;
#line 34
using ::int_least64_t;
#line 35
using ::uint_least8_t;
#line 36
using ::uint_least16_t;
#line 37
using ::uint_least32_t;
#line 38
using ::uint_least64_t;
#line 40
using ::int_fast8_t;
#line 41
using ::int_fast16_t;
#line 42
using ::int_fast32_t;
#line 43
using ::int_fast64_t;
#line 44
using ::uint_fast8_t;
#line 45
using ::uint_fast16_t;
#line 46
using ::uint_fast32_t;
#line 47
using ::uint_fast64_t;
#line 49
using ::intmax_t;
#line 50
using ::intptr_t;
#line 51
using ::uintmax_t;
#line 52
using ::uintptr_t;
#line 55
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 56
using ::int8_t;
#line 57
using ::int16_t;
#line 58
using ::int32_t;
#line 59
using ::int64_t;
#line 60
using ::uint8_t;
#line 61
using ::uint16_t;
#line 62
using ::uint32_t;
#line 63
using ::uint64_t;
#line 65
using ::int_least8_t;
#line 66
using ::int_least16_t;
#line 67
using ::int_least32_t;
#line 68
using ::int_least64_t;
#line 69
using ::uint_least8_t;
#line 70
using ::uint_least16_t;
#line 71
using ::uint_least32_t;
#line 72
using ::uint_least64_t;
#line 74
using ::int_fast8_t;
#line 75
using ::int_fast16_t;
#line 76
using ::int_fast32_t;
#line 77
using ::int_fast64_t;
#line 78
using ::uint_fast8_t;
#line 79
using ::uint_fast16_t;
#line 80
using ::uint_fast32_t;
#line 81
using ::uint_fast64_t;
#line 83
using ::intmax_t;
#line 84
using ::intptr_t;
#line 85
using ::uintmax_t;
#line 86
using ::uintptr_t;
#line 87
}
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"
}
#line 93
#pragma warning(pop)
#pragma pack ( pop )
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#line 22
template < class _Ty, _Ty ... _Vals >
struct integer_sequence {
    static_assert ( is_integral_v < _Ty >, "integer_sequence<T, I...> requires T to be an integral type." );

    using value_type = _Ty;

    [ [ nodiscard ] ] static constexpr size_t size ( ) noexcept {
        return sizeof ... ( _Vals );
    }
};
#line 33
template< class _Ty, _Ty _Size> using make_integer_sequence = __make_integer_seq< integer_sequence, _Ty, _Size> ; 
#line 36
template< size_t ..._Vals> using index_sequence = integer_sequence< unsigned __int64, _Vals...> ; 
#line 39
template< size_t _Size> using make_index_sequence = make_integer_sequence< unsigned __int64, _Size> ; 
#line 42
template< class ..._Types> using index_sequence_for = make_index_sequence< sizeof...(_Types)> ; 
#line 45
template< bool _First_value, class _First, class ..._Rest> 
#line 46
struct _Conjunction { 
#line 47
using type = _First; 
#line 48
}; 
#line 50
template< class _True, class _Next, class ..._Rest> 
#line 51
struct _Conjunction< true, _True, _Next, _Rest...>  { 
#line 52
using type = typename std::_Conjunction< _Next::value, _Next, _Rest...> ::type; 
#line 53
}; 
#line 55
template< class ..._Traits> 
#line 56
struct conjunction : public true_type { }; 
#line 58
template< class _First, class ..._Rest> 
#line 59
struct conjunction< _First, _Rest...>  : public _Conjunction< _First::value, _First, _Rest...> ::type { 
#line 61
}; 
#line 63
template< class ..._Traits> constexpr bool 
#line 64
conjunction_v = (conjunction< _Traits...> ::value); 
#line 66
template< class _Trait> 
#line 67
struct negation : public bool_constant< !(static_cast< bool>(_Trait::value))>  { }; 
#line 69
template< class _Trait> constexpr bool 
#line 70
negation_v = (negation< _Trait> ::value); 
#line 72
template< class _Ty> constexpr bool 
#line 73
is_void_v = is_same_v< remove_cv_t< _Ty> , void> ; 
#line 75
template< class _Ty> 
#line 76
struct is_void : public bool_constant< is_void_v< _Ty> >  { }; 
#line 78
template< class ..._Types> using void_t = void; 
#line 82
template< class _Ty> 
#line 83
struct add_const { 
#line 84
using type = const _Ty; 
#line 85
}; 
#line 87
template< class _Ty> using add_const_t = typename add_const< _Ty> ::type; 
#line 90
template< class _Ty> 
#line 91
struct add_volatile { 
#line 92
using type = volatile _Ty; 
#line 93
}; 
#line 95
template< class _Ty> using add_volatile_t = typename add_volatile< _Ty> ::type; 
#line 98
template< class _Ty> 
#line 99
struct add_cv { 
#line 100
using type = const volatile _Ty; 
#line 101
}; 
#line 103
template< class _Ty> using add_cv_t = typename add_cv< _Ty> ::type; 
#line 106
template< class _Ty, class  = void> 
#line 107
struct _Add_reference { 
#line 108
using _Lvalue = _Ty; 
#line 109
using _Rvalue = _Ty; 
#line 110
}; 
#line 112
template< class _Ty> 
#line 113
struct _Add_reference< _Ty, void_t< _Ty &> >  { 
#line 114
using _Lvalue = _Ty &; 
#line 115
using _Rvalue = _Ty &&; 
#line 116
}; 
#line 118
template< class _Ty> 
#line 119
struct add_lvalue_reference { 
#line 120
using type = typename _Add_reference< _Ty> ::_Lvalue; 
#line 121
}; 
#line 123
template< class _Ty> using add_lvalue_reference_t = typename _Add_reference< _Ty> ::_Lvalue; 
#line 126
template< class _Ty> 
#line 127
struct add_rvalue_reference { 
#line 128
using type = typename _Add_reference< _Ty> ::_Rvalue; 
#line 129
}; 
#line 131
template< class _Ty> using add_rvalue_reference_t = typename _Add_reference< _Ty> ::_Rvalue; 
#line 134
template< class _Ty> add_rvalue_reference_t< _Ty>  declval() noexcept; 
#line 137
template< class _Ty> 
#line 138
struct remove_extent { 
#line 139
using type = _Ty; 
#line 140
}; 
#line 142
template< class _Ty, size_t _Ix> 
#line 143
struct remove_extent< _Ty [_Ix]>  { 
#line 144
using type = _Ty; 
#line 145
}; 
#line 147
template< class _Ty> 
#line 148
struct remove_extent< _Ty []>  { 
#line 149
using type = _Ty; 
#line 150
}; 
#line 152
template< class _Ty> using remove_extent_t = typename remove_extent< _Ty> ::type; 
#line 155
template< class _Ty> 
#line 156
struct remove_all_extents { 
#line 157
using type = _Ty; 
#line 158
}; 
#line 160
template< class _Ty, size_t _Ix> 
#line 161
struct remove_all_extents< _Ty [_Ix]>  { 
#line 162
using type = typename std::remove_all_extents< _Ty> ::type; 
#line 163
}; 
#line 165
template< class _Ty> 
#line 166
struct remove_all_extents< _Ty []>  { 
#line 167
using type = typename std::remove_all_extents< _Ty> ::type; 
#line 168
}; 
#line 170
template< class _Ty> using remove_all_extents_t = typename remove_all_extents< _Ty> ::type; 
#line 173
template< class _Ty> 
#line 174
struct remove_pointer { 
#line 175
using type = _Ty; 
#line 176
}; 
#line 178
template< class _Ty> 
#line 179
struct remove_pointer< _Ty *>  { 
#line 180
using type = _Ty; 
#line 181
}; 
#line 183
template< class _Ty> 
#line 184
struct remove_pointer< _Ty *const>  { 
#line 185
using type = _Ty; 
#line 186
}; 
#line 188
template< class _Ty> 
#line 189
struct remove_pointer< _Ty *volatile>  { 
#line 190
using type = _Ty; 
#line 191
}; 
#line 193
template< class _Ty> 
#line 194
struct remove_pointer< _Ty *const volatile>  { 
#line 195
using type = _Ty; 
#line 196
}; 
#line 198
template< class _Ty> using remove_pointer_t = typename remove_pointer< _Ty> ::type; 
#line 201
template< class _Ty, class  = void> 
#line 202
struct _Add_pointer { 
#line 203
using type = _Ty; 
#line 204
}; 
#line 206
template< class _Ty> 
#line 207
struct _Add_pointer< _Ty, void_t< remove_reference_t< _Ty>  *> >  { 
#line 208
using type = remove_reference_t< _Ty>  *; 
#line 209
}; 
#line 211
template< class _Ty> 
#line 212
struct add_pointer { 
#line 213
using type = typename _Add_pointer< _Ty> ::type; 
#line 214
}; 
#line 216
template< class _Ty> using add_pointer_t = typename _Add_pointer< _Ty> ::type; 
#line 219
template< class > constexpr bool 
#line 220
is_array_v = false; 
#line 222
template< class _Ty, size_t _Nx> constexpr bool 
#line 223
is_array_v< _Ty [_Nx]>  = true; 
#line 225
template< class _Ty> constexpr bool 
#line 226
is_array_v< _Ty []>  = true; 
#line 228
template< class _Ty> 
#line 229
struct is_array : public bool_constant< is_array_v< _Ty> >  { }; 
#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class > constexpr bool 
#line 252
is_lvalue_reference_v = false; 
#line 254
template< class _Ty> constexpr bool 
#line 255
is_lvalue_reference_v< _Ty &>  = true; 
#line 257
template< class _Ty> 
#line 258
struct is_lvalue_reference : public bool_constant< is_lvalue_reference_v< _Ty> >  { }; 
#line 260
template< class > constexpr bool 
#line 261
is_rvalue_reference_v = false; 
#line 263
template< class _Ty> constexpr bool 
#line 264
is_rvalue_reference_v< _Ty &&>  = true; 
#line 266
template< class _Ty> 
#line 267
struct is_rvalue_reference : public bool_constant< is_rvalue_reference_v< _Ty> >  { }; 
#line 269
template< class > constexpr bool 
#line 270
is_reference_v = false; 
#line 272
template< class _Ty> constexpr bool 
#line 273
is_reference_v< _Ty &>  = true; 
#line 275
template< class _Ty> constexpr bool 
#line 276
is_reference_v< _Ty &&>  = true; 
#line 278
template< class _Ty> 
#line 279
struct is_reference : public bool_constant< is_reference_v< _Ty> >  { }; 
#line 281
template< class > constexpr bool 
#line 282
is_pointer_v = false; 
#line 284
template< class _Ty> constexpr bool 
#line 285
is_pointer_v< _Ty *>  = true; 
#line 287
template< class _Ty> constexpr bool 
#line 288
is_pointer_v< _Ty *const>  = true; 
#line 290
template< class _Ty> constexpr bool 
#line 291
is_pointer_v< _Ty *volatile>  = true; 
#line 293
template< class _Ty> constexpr bool 
#line 294
is_pointer_v< _Ty *const volatile>  = true; 
#line 296
template< class _Ty> 
#line 297
struct is_pointer : public bool_constant< is_pointer_v< _Ty> >  { }; 
#line 299
template< class _Ty> constexpr bool 
#line 300
is_null_pointer_v = is_same_v< remove_cv_t< _Ty> , std::nullptr_t> ; 
#line 303
template< class _Ty> 
#line 304
struct is_null_pointer : public bool_constant< is_null_pointer_v< _Ty> >  { }; 
#line 306
template< class _Ty> 
#line 307
struct is_union : public bool_constant< __is_union(_Ty)>  { }; 
#line 309
template< class _Ty> constexpr bool 
#line 310
is_union_v = __is_union(_Ty); 
#line 312
template< class _Ty> 
#line 313
struct is_class : public bool_constant< __is_class(_Ty)>  { }; 
#line 315
template< class _Ty> constexpr bool 
#line 316
is_class_v = __is_class(_Ty); 
#line 318
template< class _Ty> constexpr bool 
#line 319
is_fundamental_v = (is_arithmetic_v< _Ty>  || is_void_v< _Ty> ) || is_null_pointer_v< _Ty> ; 
#line 321
template< class _Ty> 
#line 322
struct is_fundamental : public bool_constant< is_fundamental_v< _Ty> >  { }; 
#line 324
template< class _From, class _To> 
#line 325
struct is_convertible : public bool_constant< __is_convertible_to(_From, _To)>  { 
#line 327
}; 
#line 329
template< class _From, class _To> constexpr bool 
#line 330
is_convertible_v = __is_convertible_to(_From, _To); 
#line 333
template< class _Ty> 
#line 334
struct is_convertible< _Ty &, volatile _Ty &>  : public true_type { }; 
#line 336
template< class _Ty> 
#line 337
struct is_convertible< volatile _Ty &, volatile _Ty &>  : public true_type { }; 
#line 339
template< class _Ty> 
#line 340
struct is_convertible< _Ty &, const volatile _Ty &>  : public true_type { }; 
#line 342
template< class _Ty> 
#line 343
struct is_convertible< volatile _Ty &, const volatile _Ty &>  : public true_type { }; 
#line 345
template< class _Ty> constexpr bool 
#line 346
is_convertible_v< _Ty &, volatile _Ty &>  = true; 
#line 348
template< class _Ty> constexpr bool 
#line 349
is_convertible_v< volatile _Ty &, volatile _Ty &>  = true; 
#line 351
template< class _Ty> constexpr bool 
#line 352
is_convertible_v< _Ty &, const volatile _Ty &>  = true; 
#line 354
template< class _Ty> constexpr bool 
#line 355
is_convertible_v< volatile _Ty &, const volatile _Ty &>  = true; 
#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 359
struct is_enum : public bool_constant< __is_enum(_Ty)>  { }; 
#line 361
template< class _Ty> constexpr bool 
#line 362
is_enum_v = __is_enum(_Ty); 
#line 364
template< class _Ty> 
#line 365
struct is_compound : public bool_constant< !is_fundamental_v< _Ty> >  { }; 
#line 367
template< class _Ty> constexpr bool 
#line 368
is_compound_v = (!is_fundamental_v< _Ty> ); 
#line 370
template< class ..._Types> 
#line 371
struct _Arg_types { }; 
#line 373
template< class _Ty1> 
#line 374
struct _Arg_types< _Ty1>  { 
#line 375
typedef _Ty1 argument_type; 
#line 376
}; 
#line 378
template< class _Ty1, class _Ty2> 
#line 379
struct _Arg_types< _Ty1, _Ty2>  { 
#line 380
typedef _Ty1 first_argument_type; 
#line 381
typedef _Ty2 second_argument_type; 
#line 382
}; 
#line 384
template< class _Ty> 
#line 385
struct _Is_memfunptr { 
#line 386
using _Bool_type = false_type; 
#line 387
}; 
#line 399
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...)>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...)>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) &>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) &>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const &>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const &>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile &>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile &>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile &>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile &>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) &&>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) &&>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const &&>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const &&>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile &&>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile &&>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile &&>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile &&>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; 
#line 412
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...)>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) &>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const &>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile &>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile &>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) &&>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const &&>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile &&>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile &&>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; 
#line 419
template< class _Ty> constexpr bool 
#line 420
is_member_function_pointer_v = (_Is_memfunptr< remove_cv_t< _Ty> > ::_Bool_type::value); 
#line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 424
struct is_member_function_pointer : public bool_constant< is_member_function_pointer_v< _Ty> >  { }; 
#line 426
template< class > constexpr bool 
#line 427
is_const_v = false; 
#line 429
template< class _Ty> constexpr bool 
#line 430
is_const_v< const _Ty>  = true; 
#line 432
template< class _Ty> 
#line 433
struct is_const : public bool_constant< is_const_v< _Ty> >  { }; 
#line 435
template< class > constexpr bool 
#line 436
is_volatile_v = false; 
#line 438
template< class _Ty> constexpr bool 
#line 439
is_volatile_v< volatile _Ty>  = true; 
#line 441
template< class _Ty> 
#line 442
struct is_volatile : public bool_constant< is_volatile_v< _Ty> >  { }; 
#line 444
template< class _Ty> constexpr bool 
#line 445
is_function_v = ((!is_const_v< const _Ty> ) && (!is_reference_v< _Ty> )); 
#line 448
template< class _Ty> 
#line 449
struct is_function : public bool_constant< is_function_v< _Ty> >  { }; 
#line 451
template< class _Ty> constexpr bool 
#line 452
is_object_v = is_const_v< const _Ty>  && (!is_void_v< _Ty> ); 
#line 455
template< class _Ty> 
#line 456
struct is_object : public bool_constant< is_object_v< _Ty> >  { }; 
#line 458
template< class > 
#line 459
struct _Is_member_object_pointer { 
#line 460
static constexpr bool value = false; 
#line 461
}; 
#line 463
template< class _Ty1, class _Ty2> 
#line 464
struct _Is_member_object_pointer< _Ty1 _Ty2::*>  { 
#line 465
static constexpr bool value = (!is_function_v< _Ty1> ); 
#line 466
using _Class_type = _Ty2; 
#line 467
}; 
#line 473
template< class _Ty> constexpr bool 
#line 474
is_member_object_pointer_v = (_Is_member_object_pointer< remove_cv_t< _Ty> > ::value); 
#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 478
struct is_member_object_pointer : public bool_constant< is_member_object_pointer_v< _Ty> >  { }; 
#line 484
template< class _Ty> constexpr bool 
#line 485
is_member_pointer_v = is_member_object_pointer_v< _Ty>  || is_member_function_pointer_v< _Ty> ; 
#line 488 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 489
struct is_member_pointer : public bool_constant< is_member_pointer_v< _Ty> >  { }; 
#line 491
template< class _Ty> constexpr bool 
#line 492
is_scalar_v = (((is_arithmetic_v< _Ty>  || is_enum_v< _Ty> ) || is_pointer_v< _Ty> ) || is_member_pointer_v< _Ty> ) || is_null_pointer_v< _Ty> ; 
#line 495
template< class _Ty> 
#line 496
struct is_scalar : public bool_constant< is_scalar_v< _Ty> >  { }; 
#line 498
template< class _Ty> 
#line 499
struct is_pod : public bool_constant< __is_pod(_Ty)>  { }; 
#line 501
template< class _Ty> constexpr bool 
#line 502
is_pod_v = __is_pod(_Ty); 
#line 504
template< class _Ty> 
#line 505
struct is_empty : public bool_constant< __is_empty(_Ty)>  { }; 
#line 507
template< class _Ty> constexpr bool 
#line 508
is_empty_v = __is_empty(_Ty); 
#line 510
template< class _Ty> 
#line 511
struct is_polymorphic : public bool_constant< __is_polymorphic(_Ty)>  { }; 
#line 513
template< class _Ty> constexpr bool 
#line 514
is_polymorphic_v = __is_polymorphic(_Ty); 
#line 516
template< class _Ty> 
#line 517
struct is_abstract : public bool_constant< __is_abstract(_Ty)>  { }; 
#line 519
template< class _Ty> constexpr bool 
#line 520
is_abstract_v = __is_abstract(_Ty); 
#line 522
template< class _Ty> 
#line 523
struct is_final : public bool_constant< __is_final(_Ty)>  { }; 
#line 525
template< class _Ty> constexpr bool 
#line 526
is_final_v = __is_final(_Ty); 
#line 528
template< class _Ty> 
#line 529
struct is_standard_layout : public bool_constant< __is_standard_layout(_Ty)>  { }; 
#line 531
template< class _Ty> constexpr bool 
#line 532
is_standard_layout_v = __is_standard_layout(_Ty); 
#line 535
template< class _Ty> 
#line 536
struct is_literal_type : public bool_constant< __is_literal_type(_Ty)>  { 
#line 538
}; 
#line 540
template< class _Ty> constexpr bool 
#line 541
is_literal_type_v = __is_literal_type(_Ty); 
#line 545 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 546
struct is_trivial : public bool_constant< __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)>  { 
#line 548
}; 
#line 550
template< class _Ty> constexpr bool 
#line 551
is_trivial_v = (__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)); 
#line 560 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 561
struct is_trivially_copyable : public bool_constant< __is_trivially_copyable(_Ty)>  { 
#line 563
}; 
#line 565
template< class _Ty> constexpr bool 
#line 566
is_trivially_copyable_v = __is_trivially_copyable(_Ty); 
#line 568
template< class _Ty> 
#line 569
struct has_virtual_destructor : public bool_constant< __has_virtual_destructor(_Ty)>  { 
#line 571
}; 
#line 573
template< class _Ty> constexpr bool 
#line 574
has_virtual_destructor_v = __has_virtual_destructor(_Ty); 
#line 592 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty, class ..._Args> 
#line 593
struct is_constructible : public bool_constant< __is_constructible(_Ty, _Args...)>  { 
#line 595
}; 
#line 597
template< class _Ty, class ..._Args> constexpr bool 
#line 598
is_constructible_v = __is_constructible(_Ty, _Args...); 
#line 600
template< class _Ty> 
#line 601
struct is_copy_constructible : public bool_constant< __is_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 603
}; 
#line 605
template< class _Ty> constexpr bool 
#line 606
is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 608
template< class _Ty> 
#line 609
struct is_default_constructible : public bool_constant< __is_constructible(_Ty)>  { 
#line 611
}; 
#line 613
template< class _Ty> constexpr bool 
#line 614
is_default_constructible_v = __is_constructible(_Ty); 
#line 616
template< class _Ty, class  = void> 
#line 617
struct _Is_implicitly_default_constructible : public false_type { 
#line 619
}; 
#line 621
template< class _Ty> void _Implicitly_default_construct(const _Ty &); 
#line 624
template< class _Ty> 
#line 625
struct _Is_implicitly_default_constructible< _Ty, void_t< decltype(_Implicitly_default_construct< _Ty> ({}))> >  : public true_type { 
#line 626
}; 
#line 628
template< class _Ty> 
#line 629
struct is_move_constructible : public bool_constant< __is_constructible(_Ty, _Ty)>  { 
#line 631
}; 
#line 633
template< class _Ty> constexpr bool 
#line 634
is_move_constructible_v = __is_constructible(_Ty, _Ty); 
#line 636
template< class _To, class _From> 
#line 637
struct is_assignable : public bool_constant< __is_assignable(_To, _From)>  { }; 
#line 639
template< class _To, class _From> constexpr bool 
#line 640
is_assignable_v = __is_assignable(_To, _From); 
#line 642
template< class _Ty> 
#line 643
struct is_copy_assignable : public bool_constant< __is_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 646
}; 
#line 648
template< class _Ty> constexpr bool 
#line 649
is_copy_assignable_v = __is_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 662 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> using _Is_copy_assignable_no_precondition_check = is_copy_assignable< _Ty> ; 
#line 665
template< class _Ty> constexpr bool 
#line 666
_Is_copy_assignable_unchecked_v = is_copy_assignable_v< _Ty> ; 
#line 669 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 670
struct is_move_assignable : public bool_constant< __is_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 672
}; 
#line 674
template< class _Ty> constexpr bool 
#line 675
is_move_assignable_v = __is_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 686 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> using _Is_move_assignable_no_precondition_check = is_move_assignable< _Ty> ; 
#line 689
template< class _Ty> constexpr bool 
#line 690
_Is_move_assignable_unchecked_v = is_move_assignable_v< _Ty> ; 
#line 693 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 694
struct is_destructible : public bool_constant< __is_destructible(_Ty)>  { 
#line 696
}; 
#line 698
template< class _Ty> constexpr bool 
#line 699
is_destructible_v = __is_destructible(_Ty); 
#line 701
template< class _Ty, class ..._Args> 
#line 702
struct is_trivially_constructible : public bool_constant< __is_trivially_constructible(_Ty, _Args...)>  { 
#line 704
}; 
#line 706
template< class _Ty, class ..._Args> constexpr bool 
#line 707
is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...); 
#line 709
template< class _Ty> 
#line 710
struct is_trivially_copy_constructible : public bool_constant< __is_trivially_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 713
}; 
#line 715
template< class _Ty> constexpr bool 
#line 716
is_trivially_copy_constructible_v = __is_trivially_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 719
template< class _Ty> 
#line 720
struct is_trivially_default_constructible : public bool_constant< __is_trivially_constructible(_Ty)>  { 
#line 722
}; 
#line 724
template< class _Ty> constexpr bool 
#line 725
is_trivially_default_constructible_v = __is_trivially_constructible(_Ty); 
#line 727
template< class _Ty> 
#line 728
struct is_trivially_move_constructible : public bool_constant< __is_trivially_constructible(_Ty, _Ty)>  { 
#line 730
}; 
#line 732
template< class _Ty> constexpr bool 
#line 733
is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty); 
#line 735
template< class _To, class _From> 
#line 736
struct is_trivially_assignable : public bool_constant< __is_trivially_assignable(_To, _From)>  { 
#line 738
}; 
#line 740
template< class _To, class _From> constexpr bool 
#line 741
is_trivially_assignable_v = __is_trivially_assignable(_To, _From); 
#line 743
template< class _Ty> 
#line 744
struct is_trivially_copy_assignable : public bool_constant< __is_trivially_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 747
}; 
#line 749
template< class _Ty> constexpr bool 
#line 750
is_trivially_copy_assignable_v = __is_trivially_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 753
template< class _Ty> 
#line 754
struct is_trivially_move_assignable : public bool_constant< __is_trivially_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 756
}; 
#line 758
template< class _Ty> constexpr bool 
#line 759
is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 761
template< class _Ty> 
#line 762
struct is_trivially_destructible : public bool_constant< __is_trivially_destructible(_Ty)>  { 
#line 764
}; 
#line 766
template< class _Ty> constexpr bool 
#line 767
is_trivially_destructible_v = __is_trivially_destructible(_Ty); 
#line 769
template< class _Ty, class ..._Args> 
#line 770
struct is_nothrow_constructible : public bool_constant< __is_nothrow_constructible(_Ty, _Args...)>  { 
#line 772
}; 
#line 774
template< class _Ty, class ..._Args> constexpr bool 
#line 775
is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...); 
#line 777
template< class _Ty> 
#line 778
struct is_nothrow_copy_constructible : public bool_constant< __is_nothrow_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 782
}; 
#line 784
template< class _Ty> constexpr bool 
#line 785
is_nothrow_copy_constructible_v = __is_nothrow_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 788
template< class _Ty> 
#line 789
struct is_nothrow_default_constructible : public bool_constant< __is_nothrow_constructible(_Ty)>  { 
#line 791
}; 
#line 793
template< class _Ty> constexpr bool 
#line 794
is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty); 
#line 796
template< class _Ty> 
#line 797
struct is_nothrow_move_constructible : public bool_constant< __is_nothrow_constructible(_Ty, _Ty)>  { 
#line 799
}; 
#line 801
template< class _Ty> constexpr bool 
#line 802
is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty); 
#line 804
template< class _To, class _From> 
#line 805
struct is_nothrow_assignable : public bool_constant< __is_nothrow_assignable(_To, _From)>  { 
#line 807
}; 
#line 809
template< class _To, class _From> constexpr bool 
#line 810
is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From); 
#line 812
template< class _Ty> 
#line 813
struct is_nothrow_copy_assignable : public bool_constant< __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 816
}; 
#line 818
template< class _Ty> constexpr bool 
#line 819
is_nothrow_copy_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 822
template< class _Ty> 
#line 823
struct is_nothrow_move_assignable : public bool_constant< __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 825
}; 
#line 827
template< class _Ty> constexpr bool 
#line 828
is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 830
template< class _Ty> 
#line 831
struct is_nothrow_destructible : public bool_constant< __is_nothrow_destructible(_Ty)>  { 
#line 834
}; 
#line 836
template< class _Ty> constexpr bool 
#line 837
is_nothrow_destructible_v = __is_nothrow_destructible(_Ty); 
#line 839
template< class _Ty, bool  = is_integral_v< _Ty> > 
#line 840
struct _Sign_base { 
#line 841
using _Uty = remove_cv_t< _Ty> ; 
#line 843
static constexpr bool _Signed = ((static_cast< _Uty>(-1)) < (static_cast< _Uty>(0))); 
#line 844
static constexpr bool _Unsigned = (!_Signed); 
#line 845
}; 
#line 847
template< class _Ty> 
#line 848
struct _Sign_base< _Ty, false>  { 
#line 850
static constexpr bool _Signed = is_floating_point_v< _Ty> ; 
#line 851
static constexpr bool _Unsigned = false; 
#line 852
}; 
#line 854
template< class _Ty> 
#line 855
struct is_signed : public bool_constant< _Sign_base< _Ty> ::_Signed>  { }; 
#line 857
template< class _Ty> constexpr bool 
#line 858
is_signed_v = (_Sign_base< _Ty> ::_Signed); 
#line 860
template< class _Ty> 
#line 861
struct is_unsigned : public bool_constant< _Sign_base< _Ty> ::_Unsigned>  { }; 
#line 863
template< class _Ty> constexpr bool 
#line 864
is_unsigned_v = (_Sign_base< _Ty> ::_Unsigned); 
#line 866
template< class _Ty> constexpr bool 
#line 867
_Is_nonbool_integral = is_integral_v< _Ty>  && (!is_same_v< remove_cv_t< _Ty> , bool> ); 
#line 869
template< bool > 
#line 870
struct _Select { 
#line 871
template< class _Ty1, class > using _Apply = _Ty1; 
#line 873
}; 
#line 876
template<> struct _Select< false>  { 
#line 877
template< class , class _Ty2> using _Apply = _Ty2; 
#line 879
}; 
#line 881
template< size_t > struct _Make_signed2; 
#line 885
template<> struct _Make_signed2< 1Ui64>  { 
#line 886
template< class > using _Apply = signed char; 
#line 888
}; 
#line 891
template<> struct _Make_signed2< 2Ui64>  { 
#line 892
template< class > using _Apply = short; 
#line 894
}; 
#line 897
template<> struct _Make_signed2< 4Ui64>  { 
#line 898
template< class _Ty> using _Apply = typename _Select< is_same_v< _Ty, long>  || is_same_v< _Ty, unsigned long> > ::template _Apply< long, int> ; 
#line 901
}; 
#line 904
template<> struct _Make_signed2< 8Ui64>  { 
#line 905
template< class > using _Apply = __int64; 
#line 907
}; 
#line 909
template< class _Ty> using _Make_signed1 = typename _Make_signed2< sizeof(_Ty)> ::template _Apply< _Ty> ; 
#line 913
template< class _Ty> 
#line 914
struct make_signed { 
#line 915
static_assert((_Is_nonbool_integral< _Ty>  || is_enum_v< _Ty> ), "make_signed<T> requires that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool type.");
#line 919
using type = typename remove_cv< _Ty> ::template _Apply< _Make_signed1> ; 
#line 920
}; 
#line 922
template< class _Ty> using make_signed_t = typename make_signed< _Ty> ::type; 
#line 925
template< size_t > struct _Make_unsigned2; 
#line 929
template<> struct _Make_unsigned2< 1Ui64>  { 
#line 930
template< class > using _Apply = unsigned char; 
#line 932
}; 
#line 935
template<> struct _Make_unsigned2< 2Ui64>  { 
#line 936
template< class > using _Apply = unsigned short; 
#line 938
}; 
#line 941
template<> struct _Make_unsigned2< 4Ui64>  { 
#line 942
template< class _Ty> using _Apply = typename _Select< is_same_v< _Ty, long>  || is_same_v< _Ty, unsigned long> > ::template _Apply< unsigned long, unsigned> ; 
#line 946
}; 
#line 949
template<> struct _Make_unsigned2< 8Ui64>  { 
#line 950
template< class > using _Apply = unsigned __int64; 
#line 952
}; 
#line 954
template< class _Ty> using _Make_unsigned1 = typename _Make_unsigned2< sizeof(_Ty)> ::template _Apply< _Ty> ; 
#line 958
template< class _Ty> 
#line 959
struct make_unsigned { 
#line 960
static_assert((_Is_nonbool_integral< _Ty>  || is_enum_v< _Ty> ), "make_unsigned<T> requires that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool type.");
#line 964
using type = typename remove_cv< _Ty> ::template _Apply< _Make_unsigned1> ; 
#line 965
}; 
#line 967
template< class _Ty> using make_unsigned_t = typename make_unsigned< _Ty> ::type; 
#line 970
template < class _Rep >
constexpr make_unsigned_t < _Rep > _Unsigned_value ( _Rep _Val ) {
    return static_cast < make_unsigned_t < _Rep >> ( _Val );
}
#line 975
template< class _Ty> 
#line 976
struct alignment_of : public integral_constant< unsigned __int64, __alignof(_Ty)>  { }; 
#line 978
template< class _Ty> constexpr size_t 
#line 979
alignment_of_v = __alignof(_Ty); 
#line 981
template< class _Ty, size_t _Len> 
#line 982
union _Align_type { 
#line 983
_Ty _Val; 
#line 984
char _Pad[_Len]; 
#line 985
}; 
#line 987
template< size_t _Len, size_t _Align, class _Ty, bool _Ok> struct _Aligned; 
#line 990
template< size_t _Len, size_t _Align, class _Ty> 
#line 991
struct _Aligned< _Len, _Align, _Ty, true>  { 
#line 992
using type = _Align_type< _Ty, _Len> ; 
#line 993
}; 
#line 995
template< size_t _Len, size_t _Align> 
#line 996
struct _Aligned< _Len, _Align, double, false>  { 
#line 1003
static_assert((_Always_false< std::_Aligned< _Len, _Align, double, false> > ), "You\'ve instantiated std::aligned_storage<Len, Align> with an extended alignment (in other words, Align > alignof(max_align_t))." " Before VS 2017 15.8, the member \"type\" would non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 wa" "s fixed to handle this correctly, but the fix inherently changes layout and breaks binary compatibility (*only* for uses of alig" "ned_storage with extended alignments). Please define either (1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you underst" "and this message and that you actually want a type with an extended alignment, or (2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silen" "ce this message and get the old non-conforming behavior.");
#line 1015 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
using type = _Align_type< max_align_t, _Len> ; 
#line 1017 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
}; 
#line 1019
template< size_t _Len, size_t _Align> 
#line 1020
struct _Aligned< _Len, _Align, int, false>  { 
#line 1021
using _Next = double; 
#line 1022
static constexpr bool _Fits = (_Align <= __alignof(_Next)); 
#line 1023
using type = typename std::_Aligned< _Len, _Align, double, _Fits> ::type; 
#line 1024
}; 
#line 1026
template< size_t _Len, size_t _Align> 
#line 1027
struct _Aligned< _Len, _Align, short, false>  { 
#line 1028
using _Next = int; 
#line 1029
static constexpr bool _Fits = (_Align <= __alignof(_Next)); 
#line 1030
using type = typename std::_Aligned< _Len, _Align, int, _Fits> ::type; 
#line 1031
}; 
#line 1033
template< size_t _Len, size_t _Align> 
#line 1034
struct _Aligned< _Len, _Align, char, false>  { 
#line 1035
using _Next = short; 
#line 1036
static constexpr bool _Fits = (_Align <= __alignof(_Next)); 
#line 1037
using type = typename std::_Aligned< _Len, _Align, short, _Fits> ::type; 
#line 1038
}; 
#line 1040
template< size_t _Len, size_t _Align = 8Ui64> 
#line 1041
struct aligned_storage { 
#line 1042
using _Next = char; 
#line 1043
static constexpr bool _Fits = (_Align <= __alignof(_Next)); 
#line 1044
using type = typename _Aligned< _Len, _Align, char, _Fits> ::type; 
#line 1045
}; 
#line 1047
template< size_t _Len, size_t _Align = 8Ui64> using aligned_storage_t = typename aligned_storage< _Len, _Align> ::type; 
#line 1050
template< size_t ..._Vals> struct _Maximum; 
#line 1054
template<> struct _Maximum< >  : public integral_constant< unsigned __int64, 0Ui64>  { }; 
#line 1056
template< size_t _Val> 
#line 1057
struct _Maximum< _Val>  : public integral_constant< unsigned __int64, _Val>  { }; 
#line 1059
template< size_t _First, size_t _Second, size_t ..._Rest> 
#line 1060
struct _Maximum< _First, _Second, _Rest...>  : public std::_Maximum< (((_First) < _Second) ? _Second : _First), _Rest...> ::type { 
#line 1062
}; 
#line 1064
template< size_t _Len, class ..._Types> 
#line 1065
struct aligned_union { 
#line 1066
static constexpr size_t _Max_len = (_Maximum< _Len, sizeof(_Types)...> ::value); 
#line 1067
static constexpr size_t alignment_value = (_Maximum< __alignof(_Types)...> ::value); 
#line 1069
using type = aligned_storage_t< _Max_len, alignment_value> ; 
#line 1070
}; 
#line 1072
template< size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union< _Len, _Types...> ::type; 
#line 1075
template< class _Ty, bool  = is_enum_v< _Ty> > 
#line 1076
struct _Underlying_type { 
#line 1077
using type = __underlying_type(_Ty); 
#line 1078
}; 
#line 1080
template< class _Ty> 
#line 1081
struct _Underlying_type< _Ty, false>  { }; 
#line 1083
template< class _Ty> 
#line 1084
struct underlying_type : public _Underlying_type< _Ty>  { }; 
#line 1086
template< class _Ty> using underlying_type_t = typename _Underlying_type< _Ty> ::type; 
#line 1089
template< class _Ty> constexpr size_t 
#line 1090
rank_v = (0); 
#line 1092
template< class _Ty, size_t _Nx> constexpr size_t 
#line 1093
rank_v< _Ty [_Nx]>  = rank_v< _Ty>  + 1; 
#line 1095
template< class _Ty> constexpr size_t 
#line 1096
rank_v< _Ty []>  = rank_v< _Ty>  + 1; 
#line 1098
template< class _Ty> 
#line 1099
struct rank : public integral_constant< unsigned __int64, rank_v< _Ty> >  { }; 
#line 1101
template< class _Ty, unsigned _Ix = 0U> constexpr size_t 
#line 1102
extent_v = (0); 
#line 1104
template< class _Ty, size_t _Nx> constexpr size_t 
#line 1105
extent_v< _Ty [_Nx], 0>  = _Nx; 
#line 1107
template< class _Ty, unsigned _Ix, size_t _Nx> constexpr size_t 
#line 1108
extent_v< _Ty [_Nx], _Ix>  = extent_v< _Ty, _Ix - (1)> ; 
#line 1110
template< class _Ty, unsigned _Ix> constexpr size_t 
#line 1111
extent_v< _Ty [], _Ix>  = extent_v< _Ty, _Ix - (1)> ; 
#line 1113
template< class _Ty, unsigned _Ix = 0U> 
#line 1114
struct extent : public integral_constant< unsigned __int64, extent_v< _Ty, _Ix> >  { }; 
#line 1116
template< class _Base, class _Derived> 
#line 1117
struct is_base_of : public bool_constant< __is_base_of(_Base, _Derived)>  { 
#line 1119
}; 
#line 1121
template< class _Base, class _Derived> constexpr bool 
#line 1122
is_base_of_v = __is_base_of(_Base, _Derived); 
#line 1124
template< class _Ty> 
#line 1125
struct decay { 
#line 1126
using _Ty1 = remove_reference_t< _Ty> ; 
#line 1127
using _Ty2 = typename _Select< is_function_v< _Ty1> > ::template _Apply< add_pointer< _Ty1> , remove_cv< _Ty1> > ; 
#line 1128
using type = typename _Select< is_array_v< _Ty1> > ::template _Apply< add_pointer< remove_extent_t< _Ty1> > , _Ty2> ::type; 
#line 1129
}; 
#line 1131
template< class _Ty> using decay_t = typename decay< _Ty> ::type; 
#line 1134
template< class _Ty1, class _Ty2> using _Conditional_type = decltype(false ? std::declval< _Ty1> () : std::declval< _Ty2> ()); 
#line 1151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty1, class _Ty2, class  = void> 
#line 1152
struct _Decayed_cond_oper { }; 
#line 1155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty1, class _Ty2> 
#line 1156
struct _Decayed_cond_oper< _Ty1, _Ty2, void_t< _Conditional_type< _Ty1, _Ty2> > >  { 
#line 1157
using type = decay_t< _Conditional_type< _Ty1, _Ty2> > ; 
#line 1158
}; 
#line 1160
template< class ..._Ty> struct common_type; 
#line 1163
template< class ..._Ty> using common_type_t = typename common_type< _Ty...> ::type; 
#line 1167
template<> struct common_type< >  { }; 
#line 1169
template< class _Ty1> 
#line 1170
struct common_type< _Ty1>  : public std::common_type< _Ty1, _Ty1>  { }; 
#line 1172
template< class _Ty1, class _Ty2, class _Decayed1 = decay_t< _Ty1> , class _Decayed2 = decay_t< _Ty2> > 
#line 1173
struct _Common_type2 : public common_type< _Decayed1, _Decayed2>  { }; 
#line 1175
template< class _Ty1, class _Ty2> 
#line 1176
struct _Common_type2< _Ty1, _Ty2, _Ty1, _Ty2>  : public _Decayed_cond_oper< _Ty1, _Ty2>  { }; 
#line 1178
template< class _Ty1, class _Ty2> 
#line 1179
struct common_type< _Ty1, _Ty2>  : public _Common_type2< _Ty1, _Ty2>  { }; 
#line 1181
template< class _Void, class _Ty1, class _Ty2, class ..._Rest> 
#line 1182
struct _Common_type3 { }; 
#line 1184
template< class _Ty1, class _Ty2, class ..._Rest> 
#line 1185
struct _Common_type3< void_t< common_type_t< _Ty1, _Ty2> > , _Ty1, _Ty2, _Rest...>  : public common_type< common_type_t< _Ty1, _Ty2> , _Rest...>  { 
#line 1186
}; 
#line 1188
template< class _Ty1, class _Ty2, class ..._Rest> 
#line 1189
struct common_type< _Ty1, _Ty2, _Rest...>  : public _Common_type3< void, _Ty1, _Ty2, _Rest...>  { }; 
#line 1359 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 1360
struct _Identity { 
#line 1361
using type = _Ty; 
#line 1362
}; 
#line 1363
template< class _Ty> using _Identity_t = typename _Identity< _Ty> ::type; 
#line 1375 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Type, template< class ...>  class _Template> constexpr bool 
#line 1376
_Is_specialization_v = false; 
#line 1377
template< template< class ...>  class _Template, class ..._Types> constexpr bool 
#line 1378
_Is_specialization_v< _Template< _Types...> , _Template>  = true; 
#line 1380
template< class _Type, template< class ...>  class _Template> 
#line 1381
struct _Is_specialization : public bool_constant< _Is_specialization_v< _Type, _Template> >  { }; 
#line 1383
template< class _Ty> 
#line 1384
[[nodiscard]] constexpr _Ty &&forward(remove_reference_t< _Ty>  &
#line 1385
_Arg) noexcept { 
#line 1386
return static_cast< _Ty &&>(_Arg); 
#line 1387
} 
#line 1389
template< class _Ty> 
#line 1390
[[nodiscard]] constexpr _Ty &&forward(remove_reference_t< _Ty>  &&_Arg) noexcept { 
#line 1391
static_assert((!is_lvalue_reference_v< _Ty> ), "bad forward call");
#line 1392
return static_cast< _Ty &&>(_Arg); 
#line 1393
} 
#line 1395
template< class _Ty> 
#line 1396
[[nodiscard]] constexpr remove_reference_t< _Ty>  &&move(_Ty &&_Arg) noexcept { 
#line 1397
return static_cast< remove_reference_t< _Ty>  &&>(_Arg); 
#line 1398
} 
#line 1400
template < class _Ty >
[ [ nodiscard ] ] constexpr conditional_t < ! is_nothrow_move_constructible_v < _Ty > && is_copy_constructible_v < _Ty >, const _Ty &,
    _Ty && >
    move_if_noexcept ( _Ty & _Arg ) noexcept {
    return :: std :: move ( _Arg );
}
#line 1407
template < class _Ty >
class reference_wrapper;
#line 1414
#pragma warning(push)
#pragma warning(disable : 28278)
enum class _Invoker_strategy { 
#line 1417
_Functor, 
#line 1418
_Pmf_object, 
#line 1419
_Pmf_refwrap, 
#line 1420
_Pmf_pointer, 
#line 1421
_Pmd_object, 
#line 1422
_Pmd_refwrap, 
#line 1423
_Pmd_pointer
#line 1424
}; 
#line 1426
struct _Invoker_functor { 
#line 1427
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor; 
#line 1429
template < class _Callable, class ... _Types >
    static constexpr auto _Call ( _Callable && _Obj, _Types && ... _Args ) noexcept (
        noexcept ( static_cast < _Callable && > ( _Obj ) ( static_cast < _Types && > ( _Args ) ... ) ) )
        -> decltype ( static_cast < _Callable && > ( _Obj ) ( static_cast < _Types && > ( _Args ) ... ) ) {
        return static_cast < _Callable && > ( _Obj ) ( static_cast < _Types && > ( _Args ) ... );
    }
#line 1435
}; 
#line 1437
struct _Invoker_pmf_object { 
#line 1438
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object; 
#line 1440
template < class _Decayed, class _Ty1, class ... _Types2 >
    static constexpr auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 ) noexcept (
        noexcept ( ( static_cast < _Ty1 && > ( _Arg1 ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) )
        -> decltype ( ( static_cast < _Ty1 && > ( _Arg1 ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) {
        return ( static_cast < _Ty1 && > ( _Arg1 ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    }
#line 1446
}; 
#line 1448
struct _Invoker_pmf_refwrap { 
#line 1449
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap; 
#line 1451
template < class _Decayed, class _Refwrap, class ... _Types2 >
    static constexpr auto _Call ( _Decayed _Pmf, _Refwrap _Rw, _Types2 && ... _Args2 ) noexcept (
        noexcept ( ( _Rw . get ( ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) )
        -> decltype ( ( _Rw . get ( ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) {
        return ( _Rw . get ( ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    }
#line 1457
}; 
#line 1459
struct _Invoker_pmf_pointer { 
#line 1460
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer; 
#line 1462
template < class _Decayed, class _Ty1, class ... _Types2 >
    static constexpr auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 ) noexcept (
        noexcept ( ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) )
        -> decltype ( ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... ) ) {
        return ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmf ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    }
#line 1468
}; 
#line 1470
struct _Invoker_pmd_object { 
#line 1471
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object; 
#line 1473
template < class _Decayed, class _Ty1 >
    static constexpr auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 ) noexcept -> decltype ( static_cast < _Ty1 && > ( _Arg1 ) .* _Pmd ) {
        return static_cast < _Ty1 && > ( _Arg1 ) .* _Pmd;
    }
#line 1477
}; 
#line 1479
struct _Invoker_pmd_refwrap { 
#line 1480
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap; 
#line 1482
template < class _Decayed, class _Refwrap >
    static constexpr auto _Call ( _Decayed _Pmd, _Refwrap _Rw ) noexcept -> decltype ( _Rw . get ( ) .* _Pmd ) {
        return _Rw . get ( ) .* _Pmd;
    }
#line 1486
}; 
#line 1488
struct _Invoker_pmd_pointer { 
#line 1489
static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer; 
#line 1491
template < class _Decayed, class _Ty1 >
    static constexpr auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 ) noexcept ( noexcept ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmd ) )
        -> decltype ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmd ) {
        return ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Pmd;
    }
#line 1496
}; 
#line 1498
template< class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t< _Callable> , bool 
#line 1499
_Is_pmf = is_member_function_pointer_v< _Removed_cvref> , bool 
#line 1500
_Is_pmd = is_member_object_pointer_v< _Removed_cvref> > struct _Invoker1; 
#line 1503
template< class _Callable, class _Ty1, class _Removed_cvref> 
#line 1504
struct _Invoker1< _Callable, _Ty1, _Removed_cvref, true, false>  : public conditional_t< is_base_of_v< typename _Is_memfunptr< _Removed_cvref> ::_Class_type, remove_reference_t< _Ty1> > , _Invoker_pmf_object, conditional_t< _Is_specialization_v< _Remove_cvref_t< _Ty1> , reference_wrapper> , _Invoker_pmf_refwrap, _Invoker_pmf_pointer> >  { 
#line 1508
}; 
#line 1510
template< class _Callable, class _Ty1, class _Removed_cvref> 
#line 1511
struct _Invoker1< _Callable, _Ty1, _Removed_cvref, false, true>  : public conditional_t< is_base_of_v< typename _Is_member_object_pointer< _Removed_cvref> ::_Class_type, remove_reference_t< _Ty1> > , _Invoker_pmd_object, conditional_t< _Is_specialization_v< _Remove_cvref_t< _Ty1> , reference_wrapper> , _Invoker_pmd_refwrap, _Invoker_pmd_pointer> >  { 
#line 1516
}; 
#line 1518
template< class _Callable, class _Ty1, class _Removed_cvref> 
#line 1519
struct _Invoker1< _Callable, _Ty1, _Removed_cvref, false, false>  : public _Invoker_functor { }; 
#line 1521
template < class _Callable >
inline auto invoke ( _Callable && _Obj ) noexcept ( noexcept ( static_cast < _Callable && > ( _Obj ) ( ) ) )
    -> decltype ( static_cast < _Callable && > ( _Obj ) ( ) ) {
    return static_cast < _Callable && > ( _Obj ) ( );
}
#line 1527
template < class _Callable, class _Ty1, class ... _Types2 >
inline auto invoke ( _Callable && _Obj, _Ty1 && _Arg1, _Types2 && ... _Args2 ) noexcept (
    noexcept ( _Invoker1 < _Callable, _Ty1 > :: _Call (
        static_cast < _Callable && > ( _Obj ), static_cast < _Ty1 && > ( _Arg1 ), static_cast < _Types2 && > ( _Args2 ) ... ) ) )
    -> decltype ( _Invoker1 < _Callable, _Ty1 > :: _Call (
        static_cast < _Callable && > ( _Obj ), static_cast < _Ty1 && > ( _Arg1 ), static_cast < _Types2 && > ( _Args2 ) ... ) ) {
    if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Functor ) {
        return static_cast < _Callable && > ( _Obj ) ( static_cast < _Ty1 && > ( _Arg1 ), static_cast < _Types2 && > ( _Args2 ) ... );
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmf_object ) {
        return ( static_cast < _Ty1 && > ( _Arg1 ) .* _Obj ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmf_refwrap ) {
        return ( _Arg1 . get ( ) .* _Obj ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmf_pointer ) {
        return ( ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Obj ) ( static_cast < _Types2 && > ( _Args2 ) ... );
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmd_object ) {
        return static_cast < _Ty1 && > ( _Arg1 ) .* _Obj;
    } else if constexpr ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmd_refwrap ) {
        return _Arg1 . get ( ) .* _Obj;
    } else {
        static_assert ( _Invoker1 < _Callable, _Ty1 > :: _Strategy == _Invoker_strategy :: _Pmd_pointer, "bug in invoke" );
        return ( * static_cast < _Ty1 && > ( _Arg1 ) ) .* _Obj;
    }
}
#pragma warning(pop)
#line 1552
#pragma warning(push)
#pragma warning(disable : 4242)
#pragma warning(disable : 4244)
#pragma warning(disable : 4365)
#pragma warning(disable : 5215)
#line 1563
template< class _To> void _Implicitly_convert_to(_To) noexcept; 
#line 1566
template< class _From, class _To, bool  = is_convertible_v< _From, _To> , bool  = is_void_v< _To> > constexpr bool 
#line 1567
_Is_nothrow_convertible_v = noexcept(_Implicitly_convert_to< _To> (std::declval< _From> ())); 
#line 1573
#pragma warning(pop)
#line 1575
template< class _From, class _To, bool _IsVoid> constexpr bool 
#line 1576
_Is_nothrow_convertible_v< _From, _To, false, _IsVoid>  = false; 
#line 1578
template< class _From, class _To> constexpr bool 
#line 1579
_Is_nothrow_convertible_v< _From, _To, true, true>  = true; 
#line 1581
template< class _From, class _To> 
#line 1582
struct _Is_nothrow_convertible : public bool_constant< _Is_nothrow_convertible_v< _From, _To, is_convertible_v< _From, _To> , is_void_v< _To> > >  { 
#line 1584
}; 
#line 1594 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> _Ty _Returns_exactly() noexcept; 
#line 1597
template< class _From, class _To, class  = void> 
#line 1598
struct _Invoke_convertible : public false_type { }; 
#line 1600
template< class _From, class _To> 
#line 1601
struct _Invoke_convertible< _From, _To, void_t< decltype(_Implicitly_convert_to< _To> (_Returns_exactly< _From> ()))> >  : public true_type { 
#line 1602
}; 
#line 1604
template< class _From, class _To> 
#line 1605
struct _Invoke_nothrow_convertible : public bool_constant< noexcept(_Implicitly_convert_to< _To> (_Returns_exactly< _From> ()))>  { }; 
#line 1607
template< class _Result, bool _Nothrow> 
#line 1608
struct _Invoke_traits_common { 
#line 1609
using type = _Result; 
#line 1610
using _Is_invocable = true_type; 
#line 1611
using _Is_nothrow_invocable = bool_constant< _Nothrow> ; 
#line 1612
template< class _Rx> using _Is_invocable_r = bool_constant< disjunction_v< is_void< _Rx> , _Invoke_convertible< type, _Rx> > > ; 
#line 1614
template< class _Rx> using _Is_nothrow_invocable_r = bool_constant< conjunction_v< _Is_nothrow_invocable, disjunction< is_void< _Rx> , conjunction< _Invoke_convertible< type, _Rx> , _Invoke_nothrow_convertible< type, _Rx> > > > > ; 
#line 1618
}; 
#line 1620
template< class _Void, class _Callable> 
#line 1621
struct _Invoke_traits_zero { 
#line 1623
using _Is_invocable = false_type; 
#line 1624
using _Is_nothrow_invocable = false_type; 
#line 1625
template< class _Rx> using _Is_invocable_r = false_type; 
#line 1627
template< class _Rx> using _Is_nothrow_invocable_r = false_type; 
#line 1629
}; 
#line 1631
template< class _Callable> using _Decltype_invoke_zero = decltype(std::declval< _Callable> ()()); 
#line 1634
template< class _Callable> 
#line 1635
struct _Invoke_traits_zero< void_t< _Decltype_invoke_zero< _Callable> > , _Callable>  : public _Invoke_traits_common< _Decltype_invoke_zero< _Callable> , noexcept(std::declval< _Callable> ()())>  { 
#line 1636
}; 
#line 1638
template< class _Void, class ..._Types> 
#line 1639
struct _Invoke_traits_nonzero { 
#line 1641
using _Is_invocable = false_type; 
#line 1642
using _Is_nothrow_invocable = false_type; 
#line 1643
template< class _Rx> using _Is_invocable_r = false_type; 
#line 1645
template< class _Rx> using _Is_nothrow_invocable_r = false_type; 
#line 1647
}; 
#line 1649
template< class _Callable, class _Ty1, class ..._Types2> using _Decltype_invoke_nonzero = decltype(_Invoker1< _Callable, _Ty1> ::_Call(std::declval< _Callable> (), std::declval< _Ty1> (), std::declval< _Types2> ()...)); 
#line 1653
template< class _Callable, class _Ty1, class ..._Types2> 
#line 1654
struct _Invoke_traits_nonzero< void_t< _Decltype_invoke_nonzero< _Callable, _Ty1, _Types2...> > , _Callable, _Ty1, _Types2...>  : public _Invoke_traits_common< _Decltype_invoke_nonzero< _Callable, _Ty1, _Types2...> , noexcept(_Invoker1< _Callable, _Ty1> ::_Call(std::declval< _Callable> (), std::declval< _Ty1> (), std::declval< _Types2> ()...))>  { 
#line 1657
}; 
#line 1659
template< class _Callable, class ..._Args> using _Select_invoke_traits = conditional_t< sizeof...(_Args) == (0), _Invoke_traits_zero< void, _Callable> , _Invoke_traits_nonzero< void, _Callable, _Args...> > ; 
#line 1664
template< class _Fty> 
#line 1665
struct result_of { 
#line 1666
static_assert((_Always_false< _Fty> ), "result_of<CallableType> is invalid; use result_of<CallableType(zero or more argument types)> instead.");
#line 1668
}; 
#line 1676
template< class _Callable, class ..._Args> struct result_of< _Callable __cdecl (_Args ...)>  : public _Select_invoke_traits< _Callable, _Args...>  { }; template< class _Callable, class ..._Args> struct result_of< _Callable __vectorcall (_Args ...)>  : public _Select_invoke_traits< _Callable, _Args...>  { }; 
#line 1679
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1680
template< class _Ty> using result_of_t = typename result_of< _Ty> ::type; 
#line 1682
__pragma( warning(pop)) 
#line 1685 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Callable, class ..._Args> using _Invoke_result_t = typename conditional< sizeof...(_Args) == (0), _Invoke_traits_zero< void, _Callable> , _Invoke_traits_nonzero< void, _Callable, _Args...> > ::type::type; 
#line 1688
template< class _Rx, class _Callable, class ..._Args> using _Is_invocable_r_ = typename conditional< sizeof...(_Args) == (0), _Invoke_traits_zero< void, _Callable> , _Invoke_traits_nonzero< void, _Callable, _Args...> > ::type::template _Is_invocable_r< _Rx> ; 
#line 1691
template< class _Rx, class _Callable, class ..._Args> 
#line 1692
struct _Is_invocable_r : public _Is_invocable_r_< _Rx, _Callable, _Args...>  { 
#line 1694
}; 
#line 1767 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> 
#line 1768
struct _Function_args { }; 
#line 1776
template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...)>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...)>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) volatile>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) volatile>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const volatile>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const volatile>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) &>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) &>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const &>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const &>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) volatile &>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) volatile &>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const volatile &>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const volatile &>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) &&>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) &&>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const &&>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const &&>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) volatile &&>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) volatile &&>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __cdecl (_Types ...) const volatile &&>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret __vectorcall (_Types ...) const volatile &&>  : public _Arg_types< _Types...>  { typedef _Ret result_type; }; 
#line 1785
template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...)>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) volatile>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const volatile>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) &>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const &>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) volatile &>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const volatile &>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) &&>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const &&>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) volatile &&>  { typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Function_args< _Ret (_Types ..., ...) const volatile &&>  { typedef _Ret result_type; }; 
#line 1788
template< class _Ty, class  = void> 
#line 1789
struct _Weak_result_type { }; 
#line 1791
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1792
template< class _Ty> 
#line 1793
struct _Weak_result_type< _Ty, void_t< typename _Ty::result_type> >  { 
#line 1794
typedef typename _Ty::result_type result_type; 
#line 1795
}; 
#line 1796
__pragma( warning(pop)) 
#line 1798
template< class _Ty, class  = void> 
#line 1799
struct _Weak_argument_type : public _Weak_result_type< _Ty>  { }; 
#line 1801
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1802
template< class _Ty> 
#line 1803
struct _Weak_argument_type< _Ty, void_t< typename _Ty::argument_type> >  : public _Weak_result_type< _Ty>  { 
#line 1805
typedef typename _Ty::argument_type argument_type; 
#line 1806
}; 
#line 1807
__pragma( warning(pop)) 
#line 1809
template< class _Ty, class  = void> 
#line 1810
struct _Weak_binary_args : public _Weak_argument_type< _Ty>  { }; 
#line 1812
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1813
template< class _Ty> 
#line 1814
struct _Weak_binary_args< _Ty, void_t< typename _Ty::first_argument_type, typename _Ty::second_argument_type> >  : public _Weak_argument_type< _Ty>  { 
#line 1817
typedef typename _Ty::first_argument_type first_argument_type; 
#line 1818
typedef typename _Ty::second_argument_type second_argument_type; 
#line 1819
}; 
#line 1820
__pragma( warning(pop)) 
#line 1822
template< class _Ty> using _Weak_types = conditional_t< is_function_v< remove_pointer_t< _Ty> > , _Function_args< remove_pointer_t< _Ty> > , conditional_t< is_member_function_pointer_v< _Ty> , _Is_memfunptr< remove_cv_t< _Ty> > , _Weak_binary_args< _Ty> > > ; 
#line 1826
template< class _Ty> void _Refwrap_ctor_fun(_Identity_t< _Ty &> ) noexcept; 
#line 1828
template < class _Ty >
void _Refwrap_ctor_fun ( _Identity_t < _Ty && > ) = delete;
#line 1831
template< class _Ty, class _Uty, class  = void> 
#line 1832
struct _Refwrap_has_ctor_from : public false_type { }; 
#line 1834
template< class _Ty, class _Uty> 
#line 1835
struct _Refwrap_has_ctor_from< _Ty, _Uty, void_t< decltype(_Refwrap_ctor_fun< _Ty> (std::declval< _Uty> ()))> >  : public true_type { }; 
#line 1837
template < class _Ty >
class reference_wrapper

    : public _Weak_types < _Ty >

{
public :
    static_assert ( is_object_v < _Ty > || is_function_v < _Ty >,
        "reference_wrapper<T> requires T to be an object type or a function type." );

    using type = _Ty;

    template < class _Uty, enable_if_t < conjunction_v < negation < is_same < _Remove_cvref_t < _Uty >, reference_wrapper >>,
                                          _Refwrap_has_ctor_from < _Ty, _Uty >>,
                              int > = 0 >
    inline reference_wrapper ( _Uty && _Val ) noexcept ( noexcept ( _Refwrap_ctor_fun < _Ty > ( :: std :: declval < _Uty > ( ) ) ) ) {
        _Ty & _Ref = static_cast < _Uty && > ( _Val );
        _Ptr = :: std :: addressof ( _Ref );
    }

    inline operator _Ty & ( ) const noexcept {
        return * _Ptr;
    }

    [ [ nodiscard ] ] inline _Ty & get ( ) const noexcept {
        return * _Ptr;
    }

private :
    _Ty * _Ptr { };

public :
    template < class ... _Types >
    inline auto operator ( ) ( _Types && ... _Args ) const
        noexcept ( noexcept ( :: std :: invoke ( * _Ptr, static_cast < _Types && > ( _Args ) ... ) ) )
        -> decltype ( :: std :: invoke ( * _Ptr, static_cast < _Types && > ( _Args ) ... ) ) {
        return :: std :: invoke ( * _Ptr, static_cast < _Types && > ( _Args ) ... );
    }
};
#line 1882 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template < class _Ty >
[ [ nodiscard ] ] inline reference_wrapper < _Ty > ref ( _Ty & _Val ) noexcept {
    return reference_wrapper < _Ty > ( _Val );
}
#line 1887
template < class _Ty >
void ref ( const _Ty && ) = delete;
#line 1890
template < class _Ty >
[ [ nodiscard ] ] inline reference_wrapper < _Ty > ref ( reference_wrapper < _Ty > _Val ) noexcept {
    return :: std :: ref ( _Val . get ( ) );
}
#line 1895
template < class _Ty >
[ [ nodiscard ] ] inline reference_wrapper < const _Ty > cref ( const _Ty & _Val ) noexcept {
    return reference_wrapper < const _Ty > ( _Val );
}
#line 1900
template < class _Ty >
void cref ( const _Ty && ) = delete;
#line 1903
template < class _Ty >
[ [ nodiscard ] ] inline reference_wrapper < const _Ty > cref ( reference_wrapper < _Ty > _Val ) noexcept {
    return :: std :: cref ( _Val . get ( ) );
}
#line 1928 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template< class _Ty> struct _Is_swappable; 
#line 1931
template< class _Ty> struct _Is_nothrow_swappable; 
#line 1937 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template < class _Ty, int _Enabled = 0 >

inline void swap ( _Ty &, _Ty & ) noexcept ( is_nothrow_move_constructible_v < _Ty > && is_nothrow_move_assignable_v < _Ty > );
#line 1941 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template < class _Ty, size_t _Size, enable_if_t < _Is_swappable < _Ty > :: value, int > = 0 >
inline void swap ( _Ty ( & ) [ _Size ], _Ty ( & ) [ _Size ] ) noexcept ( _Is_nothrow_swappable < _Ty > :: value );
#line 1944
template< class _Ty1, class _Ty2, class  = void> 
#line 1945
struct _Swappable_with_helper : public false_type { }; 
#line 1947
template< class _Ty1, class _Ty2> 
#line 1948
struct _Swappable_with_helper< _Ty1, _Ty2, void_t< decltype(swap(std::declval< _Ty1> (), std::declval< _Ty2> ()))> >  : public true_type { 
#line 1949
}; 
#line 1951
template< class _Ty1, class _Ty2> 
#line 1952
struct _Is_swappable_with : public bool_constant< conjunction_v< _Swappable_with_helper< _Ty1, _Ty2> , _Swappable_with_helper< _Ty2, _Ty1> > >  { 
#line 1955
}; 
#line 1957
template< class _Ty> 
#line 1958
struct _Is_swappable : public _Is_swappable_with< add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< _Ty> > ::type { 
#line 1960
}; 
#line 1962
template< class _Ty1, class _Ty2> 
#line 1963
struct _Swap_cannot_throw : public bool_constant< noexcept(swap(std::declval< _Ty1> (), std::declval< _Ty2> ())) && noexcept(swap(std::declval< _Ty2> (), std::declval< _Ty1> ()))>  { 
#line 1967
}; 
#line 1969
template< class _Ty1, class _Ty2> 
#line 1970
struct _Is_nothrow_swappable_with : public bool_constant< conjunction_v< _Is_swappable_with< _Ty1, _Ty2> , _Swap_cannot_throw< _Ty1, _Ty2> > >  { 
#line 1974
}; 
#line 1976
template< class _Ty> 
#line 1977
struct _Is_nothrow_swappable : public _Is_nothrow_swappable_with< add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< _Ty> > ::type { 
#line 1980
}; 
#line 2017 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
namespace _Has_ADL_swap_detail { 
#line 2018
void swap(); 
#line 2020
template< class , class  = void> 
#line 2021
struct _Has_ADL_swap : public false_type { }; 
#line 2022
template< class _Ty> 
#line 2023
struct _Has_ADL_swap< _Ty, void_t< decltype(swap(std::declval< _Ty &> (), std::declval< _Ty &> ()))> >  : public true_type { }; 
#line 2024
}
#line 2025
using _Has_ADL_swap_detail::_Has_ADL_swap;
#line 2027
template< class _Ty> constexpr bool 
#line 2028
_Is_trivially_swappable_v = conjunction_v< is_trivially_destructible< _Ty> , is_trivially_move_constructible< _Ty> , is_trivially_move_assignable< _Ty> , negation< _Has_ADL_swap_detail::_Has_ADL_swap< _Ty> > > ; 
#line 2036
template< class _Ty> 
#line 2037
struct _Is_trivially_swappable : public bool_constant< _Is_trivially_swappable_v< _Ty> >  { 
#line 2039
}; 
#line 2087
constexpr size_t _FNV_offset_basis = 14695981039346656037Ui64; 
#line 2088
constexpr size_t _FNV_prime = 1099511628211Ui64; 
#line 2094 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char *const _First, const size_t 
#line 2095
_Count) noexcept { 
#line 2096
for (size_t _Idx = (0); _Idx < _Count; ++_Idx) { 
#line 2097
_Val ^= (static_cast< size_t>(_First[_Idx])); 
#line 2098
_Val *= _FNV_prime; 
#line 2099
}  
#line 2101
return _Val; 
#line 2102
} 
#line 2104
template < class _Ty >
[ [ nodiscard ] ] size_t _Fnv1a_append_range ( const size_t _Val, const _Ty * const _First,
    const _Ty * const _Last ) noexcept {
    static_assert ( is_trivial_v < _Ty >, "Only trivial types can be directly hashed." );
    const auto _Firstb = reinterpret_cast < const unsigned char * > ( _First );
    const auto _Lastb = reinterpret_cast < const unsigned char * > ( _Last );
    return _Fnv1a_append_bytes ( _Val, _Firstb, static_cast < size_t > ( _Lastb - _Firstb ) );
}
#line 2113
template < class _Kty >
[ [ nodiscard ] ] size_t _Fnv1a_append_value (
    const size_t _Val, const _Kty & _Keyval ) noexcept {
    static_assert ( is_trivial_v < _Kty >, "Only trivial types can be directly hashed." );
    return _Fnv1a_append_bytes ( _Val, & reinterpret_cast < const unsigned char & > ( _Keyval ), sizeof ( _Kty ) );
}
#line 2120
template < class _Kty >
[ [ nodiscard ] ] size_t _Hash_representation ( const _Kty & _Keyval ) noexcept {
    return _Fnv1a_append_value ( _FNV_offset_basis, _Keyval );
}
#line 2125
template < class _Kty >
[ [ nodiscard ] ] size_t _Hash_array_representation (
    const _Kty * const _First, const size_t _Count ) noexcept {
    static_assert ( is_trivial_v < _Kty >, "Only trivial types can be directly hashed." );
    return _Fnv1a_append_bytes (
        _FNV_offset_basis, reinterpret_cast < const unsigned char * > ( _First ), _Count * sizeof ( _Kty ) );
}
#line 2133
template < class _Kty >
struct hash;
#line 2136
template < class _Kty, bool _Enabled >
struct _Conditionally_enabled_hash {
     typedef _Kty argument_type;
     typedef size_t result_type;

    [ [ nodiscard ] ] size_t operator ( ) ( const _Kty & _Keyval ) const
        noexcept ( noexcept ( hash < _Kty > :: _Do_hash ( _Keyval ) ) ) {
        return hash < _Kty > :: _Do_hash ( _Keyval );
    }
};
#line 2147
template< class _Kty> 
#line 2148
struct _Conditionally_enabled_hash< _Kty, false>  { 
#line 2149
_Conditionally_enabled_hash() = delete;
#line 2150
_Conditionally_enabled_hash(const std::_Conditionally_enabled_hash< _Kty, false>  &) = delete;
#line 2151
_Conditionally_enabled_hash(std::_Conditionally_enabled_hash< _Kty, false>  &&) = delete;
#line 2152
std::_Conditionally_enabled_hash< _Kty, false>  &operator=(const std::_Conditionally_enabled_hash< _Kty, false>  &) = delete;
#line 2153
std::_Conditionally_enabled_hash< _Kty, false>  &operator=(std::_Conditionally_enabled_hash< _Kty, false>  &&) = delete;
#line 2154
}; 
#line 2156
template < class _Kty >
struct hash
    : _Conditionally_enabled_hash < _Kty,
          ! is_const_v < _Kty > && ! is_volatile_v < _Kty > && ( is_enum_v < _Kty > || is_integral_v < _Kty > || is_pointer_v < _Kty > ) > {

    static size_t _Do_hash ( const _Kty & _Keyval ) noexcept {
        return _Hash_representation ( _Keyval );
    }
};
#line 2167
#pragma pack(8)
template<> 
#line 2167
struct hash< float>  { 
#line 2168
typedef float argument_type; 
#line 2169
typedef size_t result_type; 
#line 2170
[[nodiscard]] size_t operator()(const float _Keyval) const noexcept { 
#line 2171
return _Hash_representation((_Keyval == (0.0F)) ? (0.0F) : _Keyval); 
#line 2172
} 
#line 2173
}; 
#pragma pack()
#line 2176
#pragma pack(8)
template<> 
#line 2176
struct hash< double>  { 
#line 2177
typedef double argument_type; 
#line 2178
typedef size_t result_type; 
#line 2179
[[nodiscard]] size_t operator()(const double _Keyval) const noexcept { 
#line 2180
return _Hash_representation((_Keyval == (0.0)) ? (0.0) : _Keyval); 
#line 2181
} 
#line 2182
}; 
#pragma pack()
#line 2185
#pragma pack(8)
template<> 
#line 2185
struct hash< long double>  { 
#line 2186
typedef long double argument_type; 
#line 2187
typedef size_t result_type; 
#line 2188
[[nodiscard]] size_t operator()(const long double _Keyval) const noexcept { 
#line 2189
return _Hash_representation((_Keyval == (0.0L)) ? (0.0L) : _Keyval); 
#line 2190
} 
#line 2191
}; 
#pragma pack()
#line 2194
#pragma pack(8)
template<> 
#line 2194
struct hash< std::nullptr_t>  { 
#line 2195
typedef nullptr_t argument_type; 
#line 2196
typedef size_t result_type; 
#line 2197
[[nodiscard]] size_t operator()(nullptr_t) const noexcept { 
#line 2198
void *_Null{((void *)0i64)}; 
#line 2199
return _Hash_representation(_Null); 
#line 2200
} 
#line 2201
}; 
#pragma pack()
template< class _Kty, class  = void> 
#pragma pack(8)
#line 2204
struct _Is_nothrow_hashable : public false_type { }; 
#pragma pack()
template< class _Kty> 
#pragma pack(8)
#line 2207
struct _Is_nothrow_hashable< _Kty, void_t< decltype(hash< _Kty> {}(std::declval< const _Kty &> ()))> >  : public bool_constant< noexcept(hash< _Kty> {}(std::declval< const _Kty &> ()))>  { 
#line 2208
}; 
#pragma pack()
#line 2212
template< class _FloatingType> struct _Floating_type_traits; 
#line 2216
#pragma pack(8)
template<> 
#line 2216
struct _Floating_type_traits< float>  { 
#line 2217
static constexpr int32_t _Mantissa_bits = 24; 
#line 2218
static constexpr int32_t _Exponent_bits = 8; 
#line 2219
static constexpr int32_t _Maximum_binary_exponent = 127; 
#line 2220
static constexpr int32_t _Minimum_binary_exponent = (-126); 
#line 2221
static constexpr int32_t _Exponent_bias = 127; 
#line 2222
static constexpr int32_t _Sign_shift = 31; 
#line 2223
static constexpr int32_t _Exponent_shift = 23; 
#line 2225
using _Uint_type = uint32_t; 
#line 2227
static constexpr uint32_t _Exponent_mask = 255U; 
#line 2228
static constexpr uint32_t _Normal_mantissa_mask = 16777215U; 
#line 2229
static constexpr uint32_t _Denormal_mantissa_mask = 8388607U; 
#line 2230
static constexpr uint32_t _Special_nan_mantissa_mask = 4194304U; 
#line 2231
static constexpr uint32_t _Shifted_sign_mask = 2147483648U; 
#line 2232
static constexpr uint32_t _Shifted_exponent_mask = 2139095040U; 
#line 2233
}; 
#pragma pack()
#line 2236
#pragma pack(8)
template<> 
#line 2236
struct _Floating_type_traits< double>  { 
#line 2237
static constexpr int32_t _Mantissa_bits = 53; 
#line 2238
static constexpr int32_t _Exponent_bits = 11; 
#line 2239
static constexpr int32_t _Maximum_binary_exponent = 1023; 
#line 2240
static constexpr int32_t _Minimum_binary_exponent = (-1022); 
#line 2241
static constexpr int32_t _Exponent_bias = 1023; 
#line 2242
static constexpr int32_t _Sign_shift = 63; 
#line 2243
static constexpr int32_t _Exponent_shift = 52; 
#line 2245
using _Uint_type = uint64_t; 
#line 2247
static constexpr uint64_t _Exponent_mask = (2047U); 
#line 2248
static constexpr uint64_t _Normal_mantissa_mask = 9007199254740991Ui64; 
#line 2249
static constexpr uint64_t _Denormal_mantissa_mask = 4503599627370495Ui64; 
#line 2250
static constexpr uint64_t _Special_nan_mantissa_mask = 2251799813685248Ui64; 
#line 2251
static constexpr uint64_t _Shifted_sign_mask = 9223372036854775808Ui64; 
#line 2252
static constexpr uint64_t _Shifted_exponent_mask = 9218868437227405312Ui64; 
#line 2253
}; 
#pragma pack()
#line 2256
#pragma pack(8)
template<> 
#line 2256
struct _Floating_type_traits< long double>  : public std::_Floating_type_traits< double>  { }; 
#pragma pack()
#line 2261
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 2262
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 2263
using std::add_const;
#line 2264
using std::add_cv;
#line 2265
using std::add_pointer;
#line 2266
using std::add_volatile;
#line 2267
using std::aligned_storage;
#line 2268
using std::alignment_of;
#line 2269
using std::conditional;
#line 2270
using std::decay;
#line 2271
using std::enable_if;
#line 2272
using std::extent;
#line 2273
using std::false_type;
#line 2274
using std::has_virtual_destructor;
#line 2275
using std::integral_constant;
#line 2276
using std::is_abstract;
#line 2277
using std::is_arithmetic;
#line 2278
using std::is_array;
#line 2279
using std::is_base_of;
#line 2280
using std::is_class;
#line 2281
using std::is_compound;
#line 2282
using std::is_const;
#line 2283
using std::is_convertible;
#line 2284
using std::is_empty;
#line 2285
using std::is_enum;
#line 2286
using std::is_floating_point;
#line 2287
using std::is_function;
#line 2288
using std::is_fundamental;
#line 2289
using std::is_integral;
#line 2290
using std::is_member_function_pointer;
#line 2291
using std::is_member_object_pointer;
#line 2292
using std::is_member_pointer;
#line 2293
using std::is_object;
#line 2294
using std::is_pod;
#line 2295
using std::is_pointer;
#line 2296
using std::is_polymorphic;
#line 2297
using std::is_reference;
#line 2298
using std::is_same;
#line 2299
using std::is_scalar;
#line 2300
using std::is_signed;
#line 2301
using std::is_union;
#line 2302
using std::is_unsigned;
#line 2303
using std::is_void;
#line 2304
using std::is_volatile;
#line 2305
using std::make_signed;
#line 2306
using std::make_unsigned;
#line 2307
using std::rank;
#line 2308
using std::remove_all_extents;
#line 2309
using std::remove_const;
#line 2310
using std::remove_cv;
#line 2311
using std::remove_extent;
#line 2312
using std::remove_pointer;
#line 2313
using std::remove_reference;
#line 2314
using std::remove_volatile;
#line 2315
using std::true_type;
#line 2316
using std::cref;
#line 2317
using std::ref;
#line 2318
using std::reference_wrapper;
#line 2320
using std::result_of;
#line 2322 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
using std::hash;
#line 2323
}
#line 2324
__pragma( warning(pop)) 
#line 2327 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
}
#line 2331
#pragma warning(pop)
#pragma pack ( pop )
#line 2336 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
#pragma external_header(pop)
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 29
namespace std { 
#line 30
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr const _Ty & ( max ) ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred ) noexcept (
    noexcept ( _Pred ( _Left, _Right ) ) ) {

    return _Pred ( _Left, _Right ) ? _Right : _Left;
}
#line 37
#pragma warning(push)
#pragma warning(disable : 28285)
template < class _Ty >
[ [ nodiscard ] ] constexpr const _Ty & ( max ) (
    const _Ty & _Left, const _Ty & _Right ) noexcept ( noexcept ( _Left < _Right ) ) {

    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)
#line 47
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Ty ( max ) ( initializer_list < _Ty >, _Pr );
#line 50
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty ( max ) ( initializer_list < _Ty > );
#line 53
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr const _Ty & ( min ) ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred ) noexcept (
    noexcept ( _Pred ( _Right, _Left ) ) ) {

    return _Pred ( _Right, _Left ) ? _Right : _Left;
}
#line 60
#pragma warning(push)
#pragma warning(disable : 28285)
template < class _Ty >
[ [ nodiscard ] ] constexpr const _Ty & ( min ) (
    const _Ty & _Left, const _Ty & _Right ) noexcept ( noexcept ( _Right < _Left ) ) {

    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)
#line 70
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Ty ( min ) ( initializer_list < _Ty >, _Pr );
#line 73
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty ( min ) ( initializer_list < _Ty > );
#line 76
template < class _FwdIt1, class _FwdIt2 >
inline void iter_swap ( _FwdIt1 _Left, _FwdIt2 _Right ) {
    swap ( * _Left, * _Right );
}
#line 81
template < class _Ty, size_t _Size, enable_if_t < _Is_swappable < _Ty > :: value, int > _Enabled >
inline void swap ( _Ty ( & _Left ) [ _Size ], _Ty ( & _Right ) [ _Size ] ) noexcept ( _Is_nothrow_swappable < _Ty > :: value ) {
    if ( & _Left != & _Right ) {
        _Ty * _First1 = _Left;
        _Ty * _Last1 = _First1 + _Size;
        _Ty * _First2 = _Right;
        for (; _First1 != _Last1; ++ _First1, ++ _First2 ) {
            :: std :: iter_swap ( _First1, _First2 );
        }
    }
}
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
template < class _Ty, int _Enabled >

inline void swap ( _Ty & _Left, _Ty & _Right ) noexcept (
    is_nothrow_move_constructible_v < _Ty > && is_nothrow_move_assignable_v < _Ty > ) {
    _Ty _Tmp = :: std :: move ( _Left );
    _Left = :: std :: move ( _Right );
    _Right = :: std :: move ( _Tmp );
}
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
template < class _Ty >
inline void _Swap_adl ( _Ty & _Left, _Ty & _Right ) noexcept ( _Is_nothrow_swappable < _Ty > :: value ) {
    swap ( _Left, _Right );
}
#line 110
struct piecewise_construct_t { 
#line 111
explicit piecewise_construct_t() = default;
#line 112
}; 
#line 114
constexpr piecewise_construct_t piecewise_construct{}; 
#line 116
template< class ...> class tuple; 
#line 119
template < size_t _Index, class ... _Types >
[ [ nodiscard ] ] constexpr auto && _Tuple_get ( tuple < _Types ... > && _Tuple ) noexcept;
#line 122
template < class _Ty1, class _Ty2 >
struct pair {
    using first_type = _Ty1;
    using second_type = _Ty2;










    template < class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t < conjunction_v < is_default_constructible < _Uty1 >, is_default_constructible < _Uty2 >,
                        _Is_implicitly_default_constructible < _Uty1 >, _Is_implicitly_default_constructible < _Uty2 >>,
            int > = 0 >
    constexpr pair ( ) noexcept (
        is_nothrow_default_constructible_v < _Uty1 > && is_nothrow_default_constructible_v < _Uty2 > )
        : first ( ), second ( ) { }

    template < class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t < conjunction_v < is_default_constructible < _Uty1 >, is_default_constructible < _Uty2 >,
                        negation < conjunction < _Is_implicitly_default_constructible < _Uty1 >,
                            _Is_implicitly_default_constructible < _Uty2 >> >>,
            int > = 0 >
    constexpr explicit pair ( ) noexcept (
        is_nothrow_default_constructible_v < _Uty1 > && is_nothrow_default_constructible_v < _Uty2 > )
        : first ( ), second ( ) { }










    template < class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t < conjunction_v < is_copy_constructible < _Uty1 >, is_copy_constructible < _Uty2 >,
                        is_convertible < const _Uty1 &, _Uty1 >, is_convertible < const _Uty2 &, _Uty2 >>,
            int > = 0 >
    constexpr pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 ) noexcept (
        is_nothrow_copy_constructible_v < _Uty1 > && is_nothrow_copy_constructible_v < _Uty2 > )
        : first ( _Val1 ), second ( _Val2 ) { }

    template < class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t <
            conjunction_v < is_copy_constructible < _Uty1 >, is_copy_constructible < _Uty2 >,
                negation < conjunction < is_convertible < const _Uty1 &, _Uty1 >, is_convertible < const _Uty2 &, _Uty2 >> >>,
            int > = 0 >
    constexpr explicit pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 ) noexcept (
        is_nothrow_copy_constructible_v < _Uty1 > && is_nothrow_copy_constructible_v < _Uty2 > )
        : first ( _Val1 ), second ( _Val2 ) { }










    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < is_constructible < _Ty1, _Other1 >, is_constructible < _Ty2, _Other2 >,
                        is_convertible < _Other1, _Ty1 >, is_convertible < _Other2, _Ty2 >>,
            int > = 0 >
    constexpr pair ( _Other1 && _Val1, _Other2 && _Val2 ) noexcept (
        is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )
        : first ( :: std :: forward < _Other1 > ( _Val1 ) ), second ( :: std :: forward < _Other2 > ( _Val2 ) ) { }

    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < is_constructible < _Ty1, _Other1 >, is_constructible < _Ty2, _Other2 >,
                        negation < conjunction < is_convertible < _Other1, _Ty1 >, is_convertible < _Other2, _Ty2 >> >>,
            int > = 0 >
    constexpr explicit pair ( _Other1 && _Val1, _Other2 && _Val2 ) noexcept (
        is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )
        : first ( :: std :: forward < _Other1 > ( _Val1 ) ), second ( :: std :: forward < _Other2 > ( _Val2 ) ) { }


    pair ( const pair & ) = default;
    pair ( pair && ) = default;










    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < is_constructible < _Ty1, const _Other1 & >, is_constructible < _Ty2, const _Other2 & >,
                        is_convertible < const _Other1 &, _Ty1 >, is_convertible < const _Other2 &, _Ty2 >>,
            int > = 0 >
    constexpr pair ( const pair < _Other1, _Other2 > & _Right ) noexcept ( is_nothrow_constructible_v < _Ty1, const _Other1 & > &&
            is_nothrow_constructible_v < _Ty2, const _Other2 & > )
        : first ( _Right . first ), second ( _Right . second ) { }

    template < class _Other1, class _Other2,
        enable_if_t <
            conjunction_v < is_constructible < _Ty1, const _Other1 & >, is_constructible < _Ty2, const _Other2 & >,
                negation < conjunction < is_convertible < const _Other1 &, _Ty1 >, is_convertible < const _Other2 &, _Ty2 >> >>,
            int > = 0 >
    constexpr explicit pair ( const pair < _Other1, _Other2 > & _Right ) noexcept (
        is_nothrow_constructible_v < _Ty1, const _Other1 & > &&
            is_nothrow_constructible_v < _Ty2, const _Other2 & > )
        : first ( _Right . first ), second ( _Right . second ) { }










    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < is_constructible < _Ty1, _Other1 >, is_constructible < _Ty2, _Other2 >,
                        is_convertible < _Other1, _Ty1 >, is_convertible < _Other2, _Ty2 >>,
            int > = 0 >
    constexpr pair ( pair < _Other1, _Other2 > && _Right ) noexcept (
        is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )
        : first ( :: std :: forward < _Other1 > ( _Right . first ) ), second ( :: std :: forward < _Other2 > ( _Right . second ) ) { }

    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < is_constructible < _Ty1, _Other1 >, is_constructible < _Ty2, _Other2 >,
                        negation < conjunction < is_convertible < _Other1, _Ty1 >, is_convertible < _Other2, _Ty2 >> >>,
            int > = 0 >
    constexpr explicit pair ( pair < _Other1, _Other2 > && _Right ) noexcept (
        is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )
        : first ( :: std :: forward < _Other1 > ( _Right . first ) ), second ( :: std :: forward < _Other2 > ( _Right . second ) ) { }


    template < class _Tuple1, class _Tuple2, size_t ... _Indexes1, size_t ... _Indexes2 >
    constexpr pair ( _Tuple1 & _Val1, _Tuple2 & _Val2, index_sequence < _Indexes1 ... >, index_sequence < _Indexes2 ... > )
        : first ( _Tuple_get < _Indexes1 > ( :: std :: move ( _Val1 ) ) ... ), second ( _Tuple_get < _Indexes2 > ( :: std :: move ( _Val2 ) ) ... ) { }

    template < class ... _Types1, class ... _Types2 >
    inline pair ( piecewise_construct_t, tuple < _Types1 ... > _Val1, tuple < _Types2 ... > _Val2 )
        : pair ( _Val1, _Val2, index_sequence_for < _Types1 ... > { }, index_sequence_for < _Types2 ... > { } ) { }

    pair & operator = ( const volatile pair & ) = delete;

    template < class _Myself = pair,
        enable_if_t < conjunction_v < _Is_copy_assignable_no_precondition_check < typename _Myself :: first_type >,
                        _Is_copy_assignable_no_precondition_check < typename _Myself :: second_type >>,
            int > = 0 >
    inline pair & operator = ( _Identity_t < const _Myself & > _Right ) noexcept (
        conjunction_v < is_nothrow_copy_assignable < _Ty1 >, is_nothrow_copy_assignable < _Ty2 >> ) {
        first = _Right . first;
        second = _Right . second;
        return * this;
    }

    template < class _Myself = pair,
        enable_if_t < conjunction_v < _Is_move_assignable_no_precondition_check < typename _Myself :: first_type >,
                        _Is_move_assignable_no_precondition_check < typename _Myself :: second_type >>,
            int > = 0 >
    inline pair & operator = ( _Identity_t < _Myself && > _Right ) noexcept (
        conjunction_v < is_nothrow_move_assignable < _Ty1 >, is_nothrow_move_assignable < _Ty2 >> ) {
        first = :: std :: forward < _Ty1 > ( _Right . first );
        second = :: std :: forward < _Ty2 > ( _Right . second );
        return * this;
    }

    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < negation < is_same < pair, pair < _Other1, _Other2 >> >, is_assignable < _Ty1 &, const _Other1 & >,
                        is_assignable < _Ty2 &, const _Other2 & >>,
            int > = 0 >
    inline pair & operator = ( const pair < _Other1, _Other2 > & _Right ) noexcept (
        is_nothrow_assignable_v < _Ty1 &, const _Other1 & > &&
            is_nothrow_assignable_v < _Ty2 &, const _Other2 & > ) {
        first = _Right . first;
        second = _Right . second;
        return * this;
    }

    template < class _Other1, class _Other2,
        enable_if_t < conjunction_v < negation < is_same < pair, pair < _Other1, _Other2 >> >, is_assignable < _Ty1 &, _Other1 >,
                        is_assignable < _Ty2 &, _Other2 >>,
            int > = 0 >
    inline pair & operator = ( pair < _Other1, _Other2 > && _Right ) noexcept (
        is_nothrow_assignable_v < _Ty1 &, _Other1 > && is_nothrow_assignable_v < _Ty2 &, _Other2 > ) {
        first = :: std :: forward < _Other1 > ( _Right . first );
        second = :: std :: forward < _Other2 > ( _Right . second );
        return * this;
    }

    inline void swap ( pair & _Right ) noexcept (
        _Is_nothrow_swappable < _Ty1 > :: value && _Is_nothrow_swappable < _Ty2 > :: value ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Swap_adl ( first, _Right . first );
            _Swap_adl ( second, _Right . second );
        }
    }

    _Ty1 first;
    _Ty2 second;
};
#line 333 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
template < class _Ty1, class _Ty2, enable_if_t < _Is_swappable < _Ty1 > :: value && _Is_swappable < _Ty2 > :: value, int > = 0 >
inline void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > & _Right ) noexcept ( noexcept ( _Left . swap ( _Right ) ) ) {
    _Left . swap ( _Right );
}
#line 338
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool operator == ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right ) {
    return _Left . first == _Right . first && _Left . second == _Right . second;
}
#line 354
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool operator != ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right ) {
    return ! ( _Left == _Right );
}
#line 360 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool operator < ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right ) {
    return _Left . first < _Right . first || ( ! ( _Right . first < _Left . first ) && _Left . second < _Right . second );
}
#line 365
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool operator > ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right ) {
    return _Right < _Left;
}
#line 370
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool operator <= ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right ) {
    return ! ( _Right < _Left );
}
#line 375
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr bool operator >= ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right ) {
    return ! ( _Left < _Right );
}
#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
template< class _Ty> 
#line 382
struct _Unrefwrap_helper { 
#line 383
using type = _Ty; 
#line 384
}; 
#line 386
template< class _Ty> 
#line 387
struct _Unrefwrap_helper< reference_wrapper< _Ty> >  { 
#line 388
using type = _Ty &; 
#line 389
}; 
#line 392
template< class _Ty> using _Unrefwrap_t = typename _Unrefwrap_helper< decay_t< _Ty> > ::type; 
#line 395
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr pair < _Unrefwrap_t < _Ty1 >, _Unrefwrap_t < _Ty2 > > make_pair ( _Ty1 && _Val1, _Ty2 && _Val2 ) noexcept (
    is_nothrow_constructible_v < _Unrefwrap_t < _Ty1 >, _Ty1 > &&
        is_nothrow_constructible_v < _Unrefwrap_t < _Ty2 >, _Ty2 > ) {

    using _Mypair = pair < _Unrefwrap_t < _Ty1 >, _Unrefwrap_t < _Ty2 >>;
    return _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ), :: std :: forward < _Ty2 > ( _Val2 ) );
}
#line 404
namespace rel_ops { 
#line 405
template < class _Ty >
     [ [ nodiscard ] ] bool operator != ( const _Ty & _Left, const _Ty & _Right ) {
        return ! ( _Left == _Right );
    }
#line 410
template < class _Ty >
     [ [ nodiscard ] ] bool operator > ( const _Ty & _Left, const _Ty & _Right ) {
        return _Right < _Left;
    }
#line 415
template < class _Ty >
     [ [ nodiscard ] ] bool operator <= ( const _Ty & _Left, const _Ty & _Right ) {
        return ! ( _Right < _Left );
    }
#line 420
template < class _Ty >
     [ [ nodiscard ] ] bool operator >= ( const _Ty & _Left, const _Ty & _Right ) {
        return ! ( _Left < _Right );
    }
#line 424
}
#line 426
template< class _Tuple> struct tuple_size; 
#line 429
template< class _Tuple, class  = void> 
#line 430
struct _Tuple_size_sfinae { }; 
#line 432
template< class _Tuple> 
#line 433
struct _Tuple_size_sfinae< _Tuple, void_t< decltype(tuple_size< _Tuple> ::value)> >  : public integral_constant< unsigned __int64, tuple_size< _Tuple> ::value>  { 
#line 434
}; 
#line 436
template< class _Tuple> 
#line 437
struct tuple_size< const _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { }; 
#line 439
template< class _Tuple> 
#line 440
struct tuple_size< volatile _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { }; 
#line 442
template< class _Tuple> 
#line 443
struct tuple_size< const volatile _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { }; 
#line 445
template< class _Ty> constexpr size_t 
#line 446
tuple_size_v = (tuple_size< _Ty> ::value); 
#line 448
template< size_t _Index, class _Tuple> struct tuple_element; 
#line 451
template< size_t _Index, class _Tuple> 
#line 452
struct tuple_element< _Index, const _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 453
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 454
using type = std::add_const_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 455
}; 
#line 457
template< size_t _Index, class _Tuple> 
#line 458
struct tuple_element< _Index, volatile _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 460
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 461
using type = std::add_volatile_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 462
}; 
#line 464
template< size_t _Index, class _Tuple> 
#line 465
struct tuple_element< _Index, const volatile _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 467
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 468
using type = std::add_cv_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 469
}; 
#line 471
template< size_t _Index, class _Tuple> using tuple_element_t = typename tuple_element< _Index, _Tuple> ::type; 
#line 474
template< class _Ty, size_t _Size> class array; 
#line 477
template< class _Ty, size_t _Size> 
#line 478
struct tuple_size< array< _Ty, _Size> >  : public integral_constant< unsigned __int64, _Size>  { }; 
#line 480
template< size_t _Idx, class _Ty, size_t _Size> 
#line 481
struct tuple_element< _Idx, array< _Ty, _Size> >  { 
#line 482
static_assert((_Idx < _Size), "array index out of bounds");
#line 484
using type = _Ty; 
#line 485
}; 
#line 487
template< class ..._Types> 
#line 488
struct tuple_size< tuple< _Types...> >  : public integral_constant< unsigned __int64, sizeof...(_Types)>  { }; 
#line 490
template< size_t _Index> 
#line 491
struct tuple_element< _Index, tuple< > >  { 
#line 492
static_assert((_Always_false< integral_constant< size_t, _Index> > ), "tuple index out of bounds");
#line 493
}; 
#line 495
template< class _This, class ..._Rest> 
#line 496
struct tuple_element< 0, tuple< _This, _Rest...> >  { 
#line 497
using type = _This; 
#line 499
using _Ttype = tuple< _This, _Rest...> ; 
#line 500
}; 
#line 502
template< size_t _Index, class _This, class ..._Rest> 
#line 503
struct tuple_element< _Index, tuple< _This, _Rest...> >  : public std::tuple_element< _Index - (1), tuple< _Rest...> >  { 
#line 504
}; 
#line 506
template< class _Ty1, class _Ty2> 
#line 507
struct tuple_size< pair< _Ty1, _Ty2> >  : public integral_constant< unsigned __int64, 2Ui64>  { }; 
#line 509
template< size_t _Idx, class _Ty1, class _Ty2> 
#line 510
struct tuple_element< _Idx, pair< _Ty1, _Ty2> >  { 
#line 511
static_assert((_Idx < (2)), "pair index out of bounds");
#line 513
using type = conditional_t< _Idx == (0), _Ty1, _Ty2> ; 
#line 514
}; 
#line 516
template < class _Ret, class _Pair >
constexpr _Ret _Pair_get ( _Pair & _Pr, integral_constant < size_t, 0 > ) noexcept {
    return _Pr . first;
}
#line 521
template < class _Ret, class _Pair >
constexpr _Ret _Pair_get ( _Pair & _Pr, integral_constant < size_t, 1 > ) noexcept {
    return _Pr . second;
}
#line 526
template < size_t _Idx, class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > & get (
    pair < _Ty1, _Ty2 > & _Pr ) noexcept {
    using _Rtype = tuple_element_t < _Idx, pair < _Ty1, _Ty2 >> &;
    return _Pair_get < _Rtype > ( _Pr, integral_constant < size_t, _Idx > { } );
}
#line 533
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr _Ty1 & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept {
    return :: std :: get < 0 > ( _Pr );
}
#line 538
template < class _Ty2, class _Ty1 >
[ [ nodiscard ] ] constexpr _Ty2 & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept {
    return :: std :: get < 1 > ( _Pr );
}
#line 543
template < size_t _Idx, class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr const tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > & get (
    const pair < _Ty1, _Ty2 > & _Pr ) noexcept {
    using _Ctype = const tuple_element_t < _Idx, pair < _Ty1, _Ty2 >> &;
    return _Pair_get < _Ctype > ( _Pr, integral_constant < size_t, _Idx > { } );
}
#line 550
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr const _Ty1 & get (
    const pair < _Ty1, _Ty2 > & _Pr ) noexcept {
    return :: std :: get < 0 > ( _Pr );
}
#line 556
template < class _Ty2, class _Ty1 >
[ [ nodiscard ] ] constexpr const _Ty2 & get (
    const pair < _Ty1, _Ty2 > & _Pr ) noexcept {
    return :: std :: get < 1 > ( _Pr );
}
#line 562
template < size_t _Idx, class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > && get (
    pair < _Ty1, _Ty2 > && _Pr ) noexcept {
    using _RRtype = tuple_element_t < _Idx, pair < _Ty1, _Ty2 >> &&;
    return :: std :: forward < _RRtype > ( :: std :: get < _Idx > ( _Pr ) );
}
#line 569
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr _Ty1 && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept {
    return :: std :: get < 0 > ( :: std :: move ( _Pr ) );
}
#line 574
template < class _Ty2, class _Ty1 >
[ [ nodiscard ] ] constexpr _Ty2 && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept {
    return :: std :: get < 1 > ( :: std :: move ( _Pr ) );
}
#line 579
template < size_t _Idx, class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr const tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > && get (
    const pair < _Ty1, _Ty2 > && _Pr ) noexcept {
    using _RRtype = const tuple_element_t < _Idx, pair < _Ty1, _Ty2 >> &&;
    return :: std :: forward < _RRtype > ( :: std :: get < _Idx > ( _Pr ) );
}
#line 586
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] constexpr const _Ty1 && get (
    const pair < _Ty1, _Ty2 > && _Pr ) noexcept {
    return :: std :: get < 0 > ( :: std :: move ( _Pr ) );
}
#line 592
template < class _Ty2, class _Ty1 >
[ [ nodiscard ] ] constexpr const _Ty2 && get (
    const pair < _Ty1, _Ty2 > && _Pr ) noexcept {
    return :: std :: get < 1 > ( :: std :: move ( _Pr ) );
}
#line 598
template < class _Ty, class _Other = _Ty >
inline _Ty exchange ( _Ty & _Val, _Other && _New_val ) noexcept (
    conjunction_v < is_nothrow_move_constructible < _Ty >, is_nothrow_assignable < _Ty &, _Other >> ) {

    _Ty _Old_val = static_cast < _Ty && > ( _Val );
    _Val = static_cast < _Other && > ( _New_val );
    return _Old_val;
}
#line 607
template < class _Ty >
[ [ nodiscard ] ] constexpr add_const_t < _Ty > & as_const ( _Ty & _Val ) noexcept {
    return _Val;
}
#line 612
template < class _Ty >
void as_const ( const _Ty && ) = delete;
#line 744 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 745
using std::get;
#line 746
using std::tuple_element;
#line 747
using std::tuple_size;
#line 748
}
#line 751 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
}
#line 755
#pragma warning(pop)
#pragma pack ( pop )
#line 759 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
extern "C" {
#line 51
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void * _First, void * _Last) noexcept; 
#line 52
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void * _First, void * _Last) noexcept; 
#line 53
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void * _First, void * _Last) noexcept; 
#line 54
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void * _First, void * _Last) noexcept; 
#line 55
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(void * _First1, void * _Last1, void * _First2) noexcept; 
#line 57
}
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
namespace std { 
#line 62
template < class _To, class _From,
    enable_if_t < conjunction_v < bool_constant < sizeof ( _To ) == sizeof ( _From ) >, is_trivially_copyable < _To >,
                    is_trivially_copyable < _From > >,
        int > = 0 >
[ [ nodiscard ] ] inline _To _Bit_cast ( const _From & _Val ) noexcept {

    _To _To_obj;
    :: memcpy ( :: std :: addressof ( _To_obj ), :: std :: addressof ( _Val ), sizeof ( _To ) );
    return _To_obj;



}
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template< class _Ty> struct _Get_first_parameter; 
#line 79
template< template< class , class ...>  class _Ty, class _First, class ..._Rest> 
#line 80
struct _Get_first_parameter< _Ty< _First, _Rest...> >  { 
#line 81
using type = _First; 
#line 82
}; 
#line 84
template< class _Newfirst, class _Ty> struct _Replace_first_parameter; 
#line 87
template< class _Newfirst, template< class , class ...>  class _Ty, class _First, class ..._Rest> 
#line 88
struct _Replace_first_parameter< _Newfirst, _Ty< _First, _Rest...> >  { 
#line 89
using type = _Ty< _Newfirst, _Rest...> ; 
#line 90
}; 
#line 92
template< class _Ty, class  = void> 
#line 93
struct _Get_element_type { 
#line 94
using type = typename _Get_first_parameter< _Ty> ::type; 
#line 95
}; 
#line 97
template< class _Ty> 
#line 98
struct _Get_element_type< _Ty, void_t< typename _Ty::element_type> >  { 
#line 99
using type = typename _Ty::element_type; 
#line 100
}; 
#line 102
template< class _Ty, class  = void> 
#line 103
struct _Get_ptr_difference_type { 
#line 104
using type = ptrdiff_t; 
#line 105
}; 
#line 107
template< class _Ty> 
#line 108
struct _Get_ptr_difference_type< _Ty, void_t< typename _Ty::difference_type> >  { 
#line 109
using type = typename _Ty::difference_type; 
#line 110
}; 
#line 112
template< class _Ty, class _Other, class  = void> 
#line 113
struct _Get_rebind_alias { 
#line 114
using type = typename _Replace_first_parameter< _Other, _Ty> ::type; 
#line 115
}; 
#line 117
template< class _Ty, class _Other> 
#line 118
struct _Get_rebind_alias< _Ty, _Other, void_t< typename _Ty::template rebind< _Other> > >  { 
#line 119
using type = typename _Ty::template rebind< _Other> ; 
#line 120
}; 
#line 122
template < class _Iter >
[ [ nodiscard ] ] constexpr void * _Voidify_iter ( _Iter _It ) noexcept {
    if constexpr ( is_pointer_v < _Iter > ) {
        return const_cast < void * > ( static_cast < const volatile void * > ( _It ) );
    } else {
        return const_cast < void * > ( static_cast < const volatile void * > ( :: std :: addressof ( * _It ) ) );
    }
}
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _Ty, class ... _Types >
inline void _Construct_in_place ( _Ty & _Obj, _Types && ... _Args ) noexcept (
    is_nothrow_constructible_v < _Ty, _Types ... > ) {





    {
        :: new ( _Voidify_iter ( :: std :: addressof ( _Obj ) ) ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );
    }
}
#line 153
template < class _Ty >
void _Default_construct_in_place ( _Ty & _Obj ) noexcept ( is_nothrow_default_constructible_v < _Ty > ) {
    :: new ( _Voidify_iter ( :: std :: addressof ( _Obj ) ) ) _Ty;
}
#line 158
template < class _Ty >
struct pointer_traits {
    using pointer = _Ty;
    using element_type = typename _Get_element_type < _Ty > :: type;
    using difference_type = typename _Get_ptr_difference_type < _Ty > :: type;

    template < class _Other >
    using rebind = typename _Get_rebind_alias < _Ty, _Other > :: type;

    using _Reftype = conditional_t < is_void_v < element_type >, char, element_type > &;

    [ [ nodiscard ] ] static pointer pointer_to ( _Reftype _Val ) noexcept ( noexcept ( _Ty :: pointer_to ( _Val ) ) ) {
        return _Ty :: pointer_to ( _Val );
    }
};
#line 174
template < class _Ty >
struct pointer_traits < _Ty * > {
    using pointer = _Ty *;
    using element_type = _Ty;
    using difference_type = ptrdiff_t;

    template < class _Other >
    using rebind = _Other *;

    using _Reftype = conditional_t < is_void_v < _Ty >, char, _Ty > &;

    [ [ nodiscard ] ] static inline pointer pointer_to ( _Reftype _Val ) noexcept {
        return :: std :: addressof ( _Val );
    }
};
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template< class _Fx> 
#line 234
struct _Ref_fn { 
#line 235
template < class ... _Args >
    constexpr decltype ( auto ) operator ( ) ( _Args && ... _Vals ) {
        if constexpr ( is_member_pointer_v < _Fx > ) {
            return :: std :: invoke ( _Fn, :: std :: forward < _Args > ( _Vals ) ... );
        } else {
            return _Fn ( :: std :: forward < _Args > ( _Vals ) ... );
        }
    }
#line 244
_Fx &_Fn; 
#line 245
}; 
#line 247
template< class _Fn> constexpr bool 
#line 248
_Pass_functor_by_value_v = conjunction_v< bool_constant< sizeof(_Fn) <= sizeof(void *)> , is_trivially_copy_constructible< _Fn> , is_trivially_destructible< _Fn> > ; 
#line 251
template < class _Fn, enable_if_t < _Pass_functor_by_value_v < _Fn >, int > = 0 >
constexpr _Fn _Pass_fn ( _Fn _Val ) {
    return _Val;
}
#line 256
template < class _Fn, enable_if_t < ! _Pass_functor_by_value_v < _Fn >, int > = 0 >
constexpr _Ref_fn < _Fn > _Pass_fn ( _Fn & _Val ) {
    return { _Val };
}
#line 261
struct _Unused_parameter { 
#line 262
constexpr _Unused_parameter() noexcept = default;
#line 263
template < class _Ty >
    constexpr _Unused_parameter ( _Ty && ) noexcept { }
#line 265
}; 
#line 267
using _Any_tag = _Unused_parameter; 
#line 269
template< class _Ty> using _Algorithm_int_t = conditional_t< is_integral_v< _Ty> , _Ty, __int64> ; 
#line 273
struct input_iterator_tag { }; 
#line 275
struct output_iterator_tag { }; 
#line 277
struct forward_iterator_tag : public input_iterator_tag { }; 
#line 279
struct bidirectional_iterator_tag : public forward_iterator_tag { }; 
#line 281
struct random_access_iterator_tag : public bidirectional_iterator_tag { }; 
#line 1161
template< class , class  = void> 
#line 1162
struct _Iterator_traits_base { }; 
#line 1164
template< class _Iter> 
#line 1165
struct _Iterator_traits_base< _Iter, void_t< typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type, typename _Iter::pointer, typename _Iter::reference> >  { 
#line 1169
using iterator_category = typename _Iter::iterator_category; 
#line 1170
using value_type = typename _Iter::value_type; 
#line 1171
using difference_type = typename _Iter::difference_type; 
#line 1172
using pointer = typename _Iter::pointer; 
#line 1173
using reference = typename _Iter::reference; 
#line 1174
}; 
#line 1176
template< class _Ty, bool  = is_object_v< _Ty> > 
#line 1177
struct _Iterator_traits_pointer_base { 
#line 1178
using iterator_category = random_access_iterator_tag; 
#line 1179
using value_type = remove_cv_t< _Ty> ; 
#line 1180
using difference_type = ptrdiff_t; 
#line 1181
using pointer = _Ty *; 
#line 1182
using reference = _Ty &; 
#line 1183
}; 
#line 1185
template< class _Ty> 
#line 1186
struct _Iterator_traits_pointer_base< _Ty, false>  { }; 
#line 1188
template< class _Iter> 
#line 1189
struct iterator_traits : public _Iterator_traits_base< _Iter>  { }; 
#line 1191
template< class _Ty> 
#line 1192
struct iterator_traits< _Ty *>  : public _Iterator_traits_pointer_base< _Ty>  { }; 
#line 1194
template< class _Iter> using _Iter_ref_t = typename iterator_traits< _Iter> ::reference; 
#line 1197
template< class _Iter> using _Iter_value_t = typename iterator_traits< _Iter> ::value_type; 
#line 1200
template< class _Iter> using _Iter_diff_t = typename iterator_traits< _Iter> ::difference_type; 
#line 1204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template< class ..._Iters> using _Common_diff_t = common_type_t< _Iter_diff_t< _Iters> ...> ; 
#line 1207
template< class _Iter> using _Iter_cat_t = typename iterator_traits< _Iter> ::iterator_category; 
#line 1210
template< class _Ty, class  = void> constexpr bool 
#line 1211
_Is_iterator_v = false; 
#line 1213
template< class _Ty> constexpr bool 
#line 1214
_Is_iterator_v< _Ty, void_t< _Iter_cat_t< _Ty> > >  = true; 
#line 1216
template< class _Ty> 
#line 1217
struct _Is_iterator : public bool_constant< _Is_iterator_v< _Ty, void> >  { }; 
#line 1219
template< class _Iter> constexpr bool 
#line 1220
_Is_input_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , input_iterator_tag> ; 
#line 1222
template< class _Iter> constexpr bool 
#line 1223
_Is_fwd_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , forward_iterator_tag> ; 
#line 1225
template< class _Iter> constexpr bool 
#line 1226
_Is_bidi_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , bidirectional_iterator_tag> ; 
#line 1228
template< class _Iter> constexpr bool 
#line 1229
_Is_random_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , random_access_iterator_tag> ; 
#line 1231
template< class , class  = void> 
#line 1232
struct _Is_checked_helper { }; 
#line 1242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template< class _Iter, class  = void> constexpr bool 
#line 1243
_Allow_inheriting_unwrap_v = true; 
#line 1245
template< class _Iter> constexpr bool 
#line 1246
_Allow_inheriting_unwrap_v< _Iter, void_t< typename _Iter::_Prevent_inheriting_unwrap> >  = is_same_v< _Iter, typename _Iter::_Prevent_inheriting_unwrap> ; 
#line 1249
template< class _Iter, class _Sentinel = _Iter, class  = void> constexpr bool 
#line 1250
_Range_verifiable_v = false; 
#line 1252
template< class _Iter, class _Sentinel> constexpr bool 
#line 1253
_Range_verifiable_v< _Iter, _Sentinel, void_t< decltype(_Verify_range(std::declval< const _Iter &> (), std::declval< const _Sentinel &> ()))> >  = _Allow_inheriting_unwrap_v< _Iter, void> ; 
#line 1257
template < class _Iter, class _Sentinel >
constexpr void _Adl_verify_range ( const _Iter & _First, const _Sentinel & _Last ) {

    if constexpr ( _Range_verifiable_v < _Iter, _Sentinel > ) {
        _Verify_range ( _First, _Last );
    }
}
#line 1265
template< class _Iter, class  = void> constexpr bool 
#line 1266
_Unwrappable_v = false; 
#line 1268
template< class _Iter> constexpr bool 
#line 1269
_Unwrappable_v< _Iter, void_t< decltype(std::declval< _Remove_cvref_t< _Iter>  &> ()._Seek_to(std::declval< _Iter> ()._Unwrapped()))> >  = _Allow_inheriting_unwrap_v< _Remove_cvref_t< _Iter> , void> ; 
#line 1273
template < class _Iter >
[ [ nodiscard ] ] constexpr decltype ( auto ) _Get_unwrapped ( _Iter && _It ) {

    if constexpr ( is_pointer_v < decay_t < _Iter >> ) {
        return _It + 0;
    } else if constexpr ( _Unwrappable_v < _Iter > ) {
        return static_cast < _Iter && > ( _It ) . _Unwrapped ( );
    } else {
        return static_cast < _Iter && > ( _It );
    }
}
#line 1285
template< class _Iter> using _Unwrapped_t = _Remove_cvref_t< decltype(_Get_unwrapped(std::declval< _Iter> ()))> ; 
#line 1288
template< class _Iter, class  = bool> constexpr bool 
#line 1289
_Do_unwrap_when_unverified_v = false; 
#line 1291
template< class _Iter> constexpr bool 
#line 1293
_Do_unwrap_when_unverified_v< _Iter, decltype(static_cast< bool>(_Iter::_Unwrap_when_unverified))>  = (static_cast< bool>(_Iter::_Unwrap_when_unverified)); 
#line 1296
template< class _Iter> constexpr bool 
#line 1297
_Unwrappable_for_unverified_v = _Unwrappable_v< _Iter, void>  && _Do_unwrap_when_unverified_v< _Remove_cvref_t< _Iter> , bool> ; 
#line 1300
template < class _Iter >
[ [ nodiscard ] ] constexpr decltype ( auto ) _Get_unwrapped_unverified ( _Iter && _It ) {

    if constexpr ( is_pointer_v < decay_t < _Iter >> ) {
        return _It + 0;
    } else if constexpr ( _Unwrappable_for_unverified_v < _Iter > ) {
        return static_cast < _Iter && > ( _It ) . _Unwrapped ( );
    } else {
        return static_cast < _Iter && > ( _It );
    }
}
#line 1312
template< class _Iter> using _Unwrapped_unverified_t = _Remove_cvref_t< decltype(_Get_unwrapped_unverified(std::declval< _Iter> ()))> ; 
#line 1315
struct _Distance_unknown { 
#line 1316
constexpr _Distance_unknown operator-() const noexcept { 
#line 1317
return {}; 
#line 1318
} 
#line 1319
}; 
#line 1321
template< class _Diff> constexpr auto 
#line 1322
_Max_possible_v = (_Diff{(static_cast< make_unsigned_t< _Diff> >(-1)) >> 1}); 
#line 1324
template< class _Diff> constexpr auto 
#line 1325
_Min_possible_v = (_Diff{(-_Max_possible_v< _Diff> ) - 1}); 
#line 1327
template< class _Iter, class  = void> constexpr bool 
#line 1328
_Offset_verifiable_v = false; 
#line 1330
template< class _Iter> constexpr bool 
#line 1332
_Offset_verifiable_v< _Iter, void_t< decltype(std::declval< const _Iter &> ()._Verify_offset(_Iter_diff_t< _Iter> {}))> >  = true; 
#line 1335
template< class _Iter> constexpr bool 
#line 1336
_Unwrappable_for_offset_v = _Unwrappable_v< _Iter, void>  && _Offset_verifiable_v< _Remove_cvref_t< _Iter> , void> ; 
#line 1339
template < class _Iter, class _Diff >
[ [ nodiscard ] ] constexpr decltype ( auto ) _Get_unwrapped_n ( _Iter && _It, const _Diff _Off ) {
    if constexpr ( is_pointer_v < decay_t < _Iter >> ) {
        return _It + 0;
    } else if constexpr ( _Unwrappable_for_offset_v < _Iter > && is_integral_v < _Diff > ) {

        using _IDiff = _Iter_diff_t < _Remove_cvref_t < _Iter >>;
        using _CDiff = common_type_t < _Diff, _IDiff >;
        const auto _COff = static_cast < _CDiff > ( _Off );

        ;

        ( void ) _COff;

        _It . _Verify_offset ( static_cast < _IDiff > ( _Off ) );
        return static_cast < _Iter && > ( _It ) . _Unwrapped ( );
    } else if constexpr ( _Unwrappable_for_unverified_v < _Iter > ) {

        return static_cast < _Iter && > ( _It ) . _Unwrapped ( );
    } else {

        return static_cast < _Iter && > ( _It );
    }
}
#line 1365 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template< class _Iter, class _UIter, class  = void> constexpr bool 
#line 1366
_Wrapped_seekable_v = false; 
#line 1368
template< class _Iter, class _UIter> constexpr bool 
#line 1370
_Wrapped_seekable_v< _Iter, _UIter, void_t< decltype(std::declval< _Iter &> ()._Seek_to(std::declval< _UIter> ()))> >  = true; 
#line 1373
template < class _Iter, class _UIter >
constexpr void _Seek_wrapped ( _Iter & _It, _UIter && _UIt ) {
    if constexpr ( _Wrapped_seekable_v < _Iter, _UIter > ) {
        _It . _Seek_to ( :: std :: forward < _UIter > ( _UIt ) );
    } else {
        _It = :: std :: forward < _UIter > ( _UIt );
    }
}
#line 1418 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _Checked, class _Iter >
[ [ nodiscard ] ] constexpr auto _Idl_distance ( const _Iter & _First, const _Iter & _Last ) {

    if constexpr ( _Is_random_iter_v < _Iter > ) {
        return static_cast < _Iter_diff_t < _Checked >> ( _Last - _First );
    } else {
        return _Distance_unknown { };
    }
}
#line 1428
template< class _Elem, bool _Is_enum = is_enum_v< _Elem> > 
#line 1429
struct _Unwrap_enum { 
#line 1430
using type = underlying_type_t< _Elem> ; 
#line 1431
}; 
#line 1433
template< class _Elem> 
#line 1434
struct _Unwrap_enum< _Elem, false>  { 
#line 1435
using type = _Elem; 
#line 1436
}; 
#line 1438
template< class _Elem> using _Unwrap_enum_t = typename _Unwrap_enum< _Elem> ::type; 
#line 1494 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt, class _Diff >
inline void advance ( _InIt & _Where, _Diff _Off ) {
    if constexpr ( _Is_random_iter_v < _InIt > ) {
        _Where += _Off;
    } else {
        if constexpr ( is_signed_v < _Diff > && ! _Is_bidi_iter_v < _InIt > ) {
            ;
        }

        decltype ( auto ) _UWhere = _Get_unwrapped_n ( :: std :: move ( _Where ), _Off );
        constexpr bool _Need_rewrap = ! is_reference_v < decltype ( _Get_unwrapped_n ( :: std :: move ( _Where ), _Off ) ) >;

        if constexpr ( is_signed_v < _Diff > && _Is_bidi_iter_v < _InIt > ) {
            for (; _Off < 0; ++ _Off ) {
                -- _UWhere;
            }
        }

        for (; 0 < _Off; -- _Off ) {
            ++ _UWhere;
        }

        if constexpr ( _Need_rewrap ) {
            _Seek_wrapped ( _Where, :: std :: move ( _UWhere ) );
        }
    }
}
#line 1522
template < class _InIt >
[ [ nodiscard ] ] inline _Iter_diff_t < _InIt > distance ( _InIt _First, _InIt _Last ) {
    if constexpr ( _Is_random_iter_v < _InIt > ) {
        return _Last - _First;
    } else {
        _Adl_verify_range ( _First, _Last );
        auto _UFirst = _Get_unwrapped ( _First );
        const auto _ULast = _Get_unwrapped ( _Last );
        _Iter_diff_t < _InIt > _Off = 0;
        for (; _UFirst != _ULast; ++ _UFirst ) {
            ++ _Off;
        }

        return _Off;
    }
}
#line 1539
template < class _InIt >
constexpr _InIt _Next_iter ( _InIt _First ) {
    return ++ _First;
}
#line 1544
template < class _InIt >
[ [ nodiscard ] ] inline _InIt next ( _InIt _First, _Iter_diff_t < _InIt > _Off = 1 ) {
    static_assert ( _Is_input_iter_v < _InIt >, "next requires input iterator" );

    :: std :: advance ( _First, _Off );
    return _First;
}
#line 1552
template < class _BidIt >
constexpr _BidIt _Prev_iter ( _BidIt _First ) {
    return -- _First;
}
#line 1557
template < class _BidIt >
[ [ nodiscard ] ] inline _BidIt prev ( _BidIt _First, _Iter_diff_t < _BidIt > _Off = 1 ) {
    static_assert ( _Is_bidi_iter_v < _BidIt >, "prev requires bidirectional iterator" );

    :: std :: advance ( _First, - _Off );
    return _First;
}
#line 1565
template < class _BidIt >
class reverse_iterator {
public :
    using iterator_type = _BidIt;







    using iterator_category = _Iter_cat_t < _BidIt >;

    using value_type = _Iter_value_t < _BidIt >;
    using difference_type = _Iter_diff_t < _BidIt >;
    using pointer = typename iterator_traits < _BidIt > :: pointer;
    using reference = _Iter_ref_t < _BidIt >;

    template < class >
    friend class reverse_iterator;

    inline reverse_iterator ( ) = default;

    inline explicit reverse_iterator ( _BidIt _Right ) noexcept (
        is_nothrow_move_constructible_v < _BidIt > )
        : current ( :: std :: move ( _Right ) ) { }


    template < class _Other >



    inline reverse_iterator ( const reverse_iterator < _Other > & _Right ) noexcept (
        is_nothrow_constructible_v < _BidIt, const _Other & > )
        : current ( _Right . current ) { }

    template < class _Other >




    inline reverse_iterator & operator = ( const reverse_iterator < _Other > & _Right ) {
        current = _Right . current;
        return * this;
    }


    [ [ nodiscard ] ] inline _BidIt base ( ) const {
        return current;
    }

    [ [ nodiscard ] ] inline reference operator * ( ) const {
        _BidIt _Tmp = current;
        return * -- _Tmp;
    }















    [ [ nodiscard ] ] inline pointer operator -> ( ) const {
        _BidIt _Tmp = current;
        -- _Tmp;
        if constexpr ( is_pointer_v < _BidIt > ) {
            return _Tmp;
        } else {
            return _Tmp . operator -> ( );
        }
    }


    inline reverse_iterator & operator ++ ( ) {
        -- current;
        return * this;
    }

    inline reverse_iterator operator ++ ( int ) {
        reverse_iterator _Tmp = * this;
        -- current;
        return _Tmp;
    }

    inline reverse_iterator & operator -- ( ) {
        ++ current;
        return * this;
    }

    inline reverse_iterator operator -- ( int ) {
        reverse_iterator _Tmp = * this;
        ++ current;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline reverse_iterator operator + ( const difference_type _Off ) const {
        return reverse_iterator ( current - _Off );
    }

    inline reverse_iterator & operator += ( const difference_type _Off ) {
        current -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline reverse_iterator operator - ( const difference_type _Off ) const {
        return reverse_iterator ( current + _Off );
    }

    inline reverse_iterator & operator -= ( const difference_type _Off ) {
        current += _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const {
        return current [ static_cast < difference_type > ( - _Off - 1 ) ];
    }





















    using _Prevent_inheriting_unwrap = reverse_iterator;

    template < class _BidIt2, enable_if_t < _Range_verifiable_v < _BidIt, _BidIt2 >, int > = 0 >
    friend constexpr void _Verify_range ( const reverse_iterator & _First, const reverse_iterator < _BidIt2 > & _Last ) {
        _Verify_range ( _Last . _Get_current ( ), _First . current );
    }

    template < class _BidIt2 = _BidIt, enable_if_t < _Offset_verifiable_v < _BidIt2 >, int > = 0 >
    constexpr void _Verify_offset ( const difference_type _Off ) const {
        do { if ( _Off != _Min_possible_v < difference_type > ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        current . _Verify_offset ( - _Off );
    }

    template < class _BidIt2 = _BidIt, enable_if_t < _Unwrappable_v < const _BidIt2 & >, int > = 0 >
    [ [ nodiscard ] ] constexpr reverse_iterator < _Unwrapped_t < const _BidIt2 & >> _Unwrapped ( ) const {
        return static_cast < reverse_iterator < _Unwrapped_t < const _BidIt2 & >> > ( current . _Unwrapped ( ) );
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v < _BidIt >;

    template < class _Src, enable_if_t < _Wrapped_seekable_v < _BidIt, const _Src & >, int > = 0 >
    constexpr void _Seek_to ( const reverse_iterator < _Src > & _It ) {
        current . _Seek_to ( _It . current );
    }

    [ [ nodiscard ] ] constexpr const _BidIt & _Get_current ( ) const noexcept {
        return current;
    }

protected :
    _BidIt current { };
};
#line 1743 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator == ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )







{ return _Left . _Get_current ( ) == _Right . _Get_current ( ); }
#line 1754
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator != ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )







{ return _Left . _Get_current ( ) != _Right . _Get_current ( ); }
#line 1765
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator < ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )







{ return _Left . _Get_current ( ) > _Right . _Get_current ( ); }
#line 1776
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator > ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )







{ return _Left . _Get_current ( ) < _Right . _Get_current ( ); }
#line 1787
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator <= ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )







{ return _Left . _Get_current ( ) >= _Right . _Get_current ( ); }
#line 1798
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline bool operator >= ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )







{ return _Left . _Get_current ( ) <= _Right . _Get_current ( ); }
#line 1817
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline auto operator - ( const reverse_iterator < _BidIt1 > & _Left, const reverse_iterator < _BidIt2 > & _Right )
    -> decltype ( _Right . _Get_current ( ) - _Left . _Get_current ( ) ) {
    return _Right . _Get_current ( ) - _Left . _Get_current ( );
}
#line 1823
template < class _BidIt >
[ [ nodiscard ] ] inline reverse_iterator < _BidIt > operator + (
    typename reverse_iterator < _BidIt > :: difference_type _Off, const reverse_iterator < _BidIt > & _Right ) {
    return _Right + _Off;
}
#line 1829
template < class _BidIt >
[ [ nodiscard ] ] inline reverse_iterator < _BidIt > make_reverse_iterator ( _BidIt _Iter ) noexcept (
    is_nothrow_move_constructible_v < _BidIt > ) {
    return reverse_iterator < _BidIt > ( :: std :: move ( _Iter ) );
}
#line 1843
template < class _Container >
[ [ nodiscard ] ] inline auto begin ( _Container & _Cont ) -> decltype ( _Cont . begin ( ) ) {
    return _Cont . begin ( );
}
#line 1848
template < class _Container >
[ [ nodiscard ] ] inline auto begin ( const _Container & _Cont ) -> decltype ( _Cont . begin ( ) ) {
    return _Cont . begin ( );
}
#line 1853
template < class _Container >
[ [ nodiscard ] ] inline auto end ( _Container & _Cont ) -> decltype ( _Cont . end ( ) ) {
    return _Cont . end ( );
}
#line 1858
template < class _Container >
[ [ nodiscard ] ] inline auto end ( const _Container & _Cont ) -> decltype ( _Cont . end ( ) ) {
    return _Cont . end ( );
}
#line 1863
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr _Ty * begin ( _Ty ( & _Array ) [ _Size ] ) noexcept {
    return _Array;
}
#line 1868
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr _Ty * end ( _Ty ( & _Array ) [ _Size ] ) noexcept {
    return _Array + _Size;
}
#line 1873
template < class _Container >
[ [ nodiscard ] ] constexpr auto cbegin ( const _Container & _Cont ) noexcept ( noexcept ( :: std :: begin ( _Cont ) ) )
    -> decltype ( :: std :: begin ( _Cont ) ) {
    return :: std :: begin ( _Cont );
}
#line 1879
template < class _Container >
[ [ nodiscard ] ] constexpr auto cend ( const _Container & _Cont ) noexcept ( noexcept ( :: std :: end ( _Cont ) ) )
    -> decltype ( :: std :: end ( _Cont ) ) {
    return :: std :: end ( _Cont );
}
#line 1885
template < class _Container >
[ [ nodiscard ] ] inline auto rbegin ( _Container & _Cont ) -> decltype ( _Cont . rbegin ( ) ) {
    return _Cont . rbegin ( );
}
#line 1890
template < class _Container >
[ [ nodiscard ] ] inline auto rbegin ( const _Container & _Cont ) -> decltype ( _Cont . rbegin ( ) ) {
    return _Cont . rbegin ( );
}
#line 1895
template < class _Container >
[ [ nodiscard ] ] inline auto rend ( _Container & _Cont ) -> decltype ( _Cont . rend ( ) ) {
    return _Cont . rend ( );
}
#line 1900
template < class _Container >
[ [ nodiscard ] ] inline auto rend ( const _Container & _Cont ) -> decltype ( _Cont . rend ( ) ) {
    return _Cont . rend ( );
}
#line 1905
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] inline reverse_iterator < _Ty * > rbegin ( _Ty ( & _Array ) [ _Size ] ) {
    return reverse_iterator < _Ty * > ( _Array + _Size );
}
#line 1910
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] inline reverse_iterator < _Ty * > rend ( _Ty ( & _Array ) [ _Size ] ) {
    return reverse_iterator < _Ty * > ( _Array );
}
#line 1915
template < class _Elem >
[ [ nodiscard ] ] inline reverse_iterator < const _Elem * > rbegin ( initializer_list < _Elem > _Ilist ) {
    return reverse_iterator < const _Elem * > ( _Ilist . end ( ) );
}
#line 1920
template < class _Elem >
[ [ nodiscard ] ] inline reverse_iterator < const _Elem * > rend ( initializer_list < _Elem > _Ilist ) {
    return reverse_iterator < const _Elem * > ( _Ilist . begin ( ) );
}
#line 1925
template < class _Container >
[ [ nodiscard ] ] inline auto crbegin ( const _Container & _Cont ) -> decltype ( :: std :: rbegin ( _Cont ) ) {
    return :: std :: rbegin ( _Cont );
}
#line 1930
template < class _Container >
[ [ nodiscard ] ] inline auto crend ( const _Container & _Cont ) -> decltype ( :: std :: rend ( _Cont ) ) {
    return :: std :: rend ( _Cont );
}
#line 1935
template < class _Container >
[ [ nodiscard ] ] constexpr auto size ( const _Container & _Cont ) -> decltype ( _Cont . size ( ) ) {
    return _Cont . size ( );
}
#line 1940
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr size_t size ( const _Ty ( & ) [ _Size ] ) noexcept {
    return _Size;
}
#line 1959 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _Container >
[ [ nodiscard ] ] constexpr auto empty ( const _Container & _Cont ) -> decltype ( _Cont . empty ( ) ) {
    return _Cont . empty ( );
}
#line 1964
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr bool empty ( const _Ty ( & ) [ _Size ] ) noexcept {
    return false;
}
#line 1969
template < class _Elem >
[ [ nodiscard ] ] constexpr bool empty ( initializer_list < _Elem > _Ilist ) noexcept {
    return _Ilist . size ( ) == 0;
}
#line 1974
template < class _Container >
[ [ nodiscard ] ] constexpr auto data ( _Container & _Cont ) -> decltype ( _Cont . data ( ) ) {
    return _Cont . data ( );
}
#line 1979
template < class _Container >
[ [ nodiscard ] ] constexpr auto data ( const _Container & _Cont ) -> decltype ( _Cont . data ( ) ) {
    return _Cont . data ( );
}
#line 1984
template < class _Ty, size_t _Size >
[ [ nodiscard ] ] constexpr _Ty * data ( _Ty ( & _Array ) [ _Size ] ) noexcept {
    return _Array;
}
#line 1989
template < class _Elem >
[ [ nodiscard ] ] constexpr const _Elem * data ( initializer_list < _Elem > _Ilist ) noexcept {
    return _Ilist . begin ( );
}
#line 3611
struct _Container_proxy; 
#line 3612
struct _Iterator_base12; 
#line 3614
struct _Default_sentinel { }; 
#line 3632
template< class _Iter> 
#line 3633
struct _Move_iterator_category { 
#line 3634
using iterator_category = _Iter_cat_t< _Iter> ; 
#line 3635
}; 
#line 3638 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _Iter >
class move_iterator : public _Move_iterator_category < _Iter > {
public :
    using iterator_type = _Iter;
    using value_type = _Iter_value_t < _Iter >;
    using difference_type = _Iter_diff_t < _Iter >;
    using pointer = _Iter;





    using reference =
        conditional_t < is_reference_v < _Iter_ref_t < _Iter >>, remove_reference_t < _Iter_ref_t < _Iter >> &&, _Iter_ref_t < _Iter >>;


    inline move_iterator ( ) = default;

    inline explicit move_iterator ( _Iter _Right ) noexcept ( is_nothrow_move_constructible_v < _Iter > )
        : _Current ( :: std :: move ( _Right ) ) { }


    template < class _Other >



    inline move_iterator ( const move_iterator < _Other > & _Right ) noexcept (
        is_nothrow_constructible_v < _Iter, const _Other & > )
        : _Current ( _Right . base ( ) ) { }

    template < class _Other >




    inline move_iterator & operator = ( const move_iterator < _Other > & _Right ) noexcept (
        is_nothrow_assignable_v < _Iter &, const _Other & > ) {
        _Current = _Right . base ( );
        return * this;
    }










    [ [ nodiscard ] ] inline iterator_type base ( ) const {
        return _Current;
    }


    [ [ nodiscard ] ] inline reference operator * ( ) const {



        return static_cast < reference > ( * _Current );

    }

     [ [ nodiscard ] ] inline pointer operator -> ( ) const {
        return _Current;
    }

    inline move_iterator & operator ++ ( ) {
        ++ _Current;
        return * this;
    }

    inline auto operator ++ ( int ) {



            move_iterator _Tmp = * this;
            ++ _Current;
            return _Tmp;





    }

    inline move_iterator & operator -- ( ) {
        -- _Current;
        return * this;
    }

    inline move_iterator operator -- ( int ) {
        move_iterator _Tmp = * this;
        -- _Current;
        return _Tmp;
    }

    template < class _Iter2 = _Iter >
    [ [ nodiscard ] ] auto operator == ( _Default_sentinel _Sentinel ) const noexcept
        -> decltype ( :: std :: declval < const _Iter2 & > ( ) == _Sentinel ) {
        return _Current == _Sentinel;
    }

    template < class _Iter2 = _Iter >
    [ [ nodiscard ] ] auto operator != ( _Default_sentinel _Sentinel ) const noexcept
        -> decltype ( :: std :: declval < const _Iter2 & > ( ) != _Sentinel ) {
        return _Current != _Sentinel;
    }

    [ [ nodiscard ] ] inline move_iterator operator + ( const difference_type _Off ) const {
        return move_iterator ( _Current + _Off );
    }

    inline move_iterator & operator += ( const difference_type _Off ) {
        _Current += _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline move_iterator operator - ( const difference_type _Off ) const {
        return move_iterator ( _Current - _Off );
    }

    inline move_iterator & operator -= ( const difference_type _Off ) {
        _Current -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const {



        return :: std :: move ( _Current [ _Off ] );

    }









































    template < class _Iter2, enable_if_t < _Range_verifiable_v < _Iter, _Iter2 >, int > = 0 >
    friend constexpr void _Verify_range ( const move_iterator & _First, const move_iterator < _Iter2 > & _Last ) {
        _Verify_range ( _First . _Current, _Last . base ( ) );
    }







    using _Prevent_inheriting_unwrap = move_iterator;

    template < class _Iter2 = iterator_type, enable_if_t < _Offset_verifiable_v < _Iter2 >, int > = 0 >
    constexpr void _Verify_offset ( const difference_type _Off ) const {
        _Current . _Verify_offset ( _Off );
    }

    template < class _Iter2 = iterator_type, enable_if_t < _Unwrappable_v < const _Iter2 & >, int > = 0 >
    [ [ nodiscard ] ] constexpr move_iterator < _Unwrapped_t < const _Iter2 & >> _Unwrapped ( ) const & {
        return static_cast < move_iterator < _Unwrapped_t < const _Iter2 & >> > ( _Current . _Unwrapped ( ) );
    }
    template < class _Iter2 = iterator_type, enable_if_t < _Unwrappable_v < _Iter2 >, int > = 0 >
    [ [ nodiscard ] ] constexpr move_iterator < _Unwrapped_t < _Iter2 >> _Unwrapped ( ) && {
        return static_cast < move_iterator < _Unwrapped_t < _Iter2 >> > ( :: std :: move ( _Current ) . _Unwrapped ( ) );
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v < iterator_type >;

    template < class _Src, enable_if_t < _Wrapped_seekable_v < iterator_type, const _Src & >, int > = 0 >
    constexpr void _Seek_to ( const move_iterator < _Src > & _It ) {
        _Current . _Seek_to ( _It . base ( ) );
    }
    template < class _Src, enable_if_t < _Wrapped_seekable_v < iterator_type, _Src >, int > = 0 >
    constexpr void _Seek_to ( move_iterator < _Src > && _It ) {
        _Current . _Seek_to ( :: std :: move ( _It ) . base ( ) );
    }

private :
    iterator_type _Current { };
};
#line 3855 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator == ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )







{ return _Left . base ( ) == _Right . base ( ); }
#line 3867
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator != ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator < ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )







{ return _Left . base ( ) < _Right . base ( ); }
#line 3884
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator > ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )





{ return _Right < _Left; }
#line 3893
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator <= ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )





{ return ! ( _Right < _Left ); }
#line 3902
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline bool operator >= ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )





{ return ! ( _Left < _Right ); }
#line 3919
template < class _Iter1, class _Iter2 >
[ [ nodiscard ] ] inline auto operator - ( const move_iterator < _Iter1 > & _Left, const move_iterator < _Iter2 > & _Right )
    -> decltype ( _Left . base ( ) - _Right . base ( ) ) {
    return _Left . base ( ) - _Right . base ( );
}
#line 3925
template < class _Iter >
[ [ nodiscard ] ] inline move_iterator < _Iter > operator + (
    typename move_iterator < _Iter > :: difference_type _Off, const move_iterator < _Iter > & _Right )







{ return move_iterator < _Iter > { _Right . base ( ) + _Off }; }
#line 3937
template < class _Iter >
[ [ nodiscard ] ] inline move_iterator < _Iter > make_move_iterator ( _Iter _It ) {
    return move_iterator < _Iter > ( :: std :: move ( _It ) );
}
#line 3976
template< class _Iter> constexpr bool 
#line 3977
_Iterator_is_contiguous = is_pointer_v< _Iter> ; 
#line 3979
template < class _Iter >
[ [ nodiscard ] ] constexpr auto _To_address ( const _Iter & _Val ) noexcept {
    ;
    return _Val;
}
#line 3988 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template< class _Iter1, class _Iter2> constexpr bool 
#line 3989
_Iterators_are_contiguous = _Iterator_is_contiguous< _Iter1>  && _Iterator_is_contiguous< _Iter2> ; 
#line 3992
template< class _Source, class _Dest> 
#line 3993
struct _Ptr_cat_helper { 
#line 3994
using _USource = _Unwrap_enum_t< _Source> ; 
#line 3995
using _UDest = _Unwrap_enum_t< _Dest> ; 
#line 3996
static constexpr bool _Really_trivial = conjunction_v< bool_constant< (sizeof(_USource) == sizeof(_UDest)) && (is_same_v< bool, _USource>  == is_same_v< bool, _UDest> )> , is_integral< _USource> , is_integral< _UDest> > ; 
#line 3999
static constexpr bool _Trivially_copyable = _Really_trivial; 
#line 4000
}; 
#line 4002
template< class _Elem> 
#line 4003
struct _Ptr_cat_helper< _Elem, _Elem>  { 
#line 4004
static constexpr bool _Really_trivial = is_trivial_v< _Elem> ; 
#line 4005
static constexpr bool _Trivially_copyable = is_trivially_copyable_v< _Elem> ; 
#line 4006
}; 
#line 4008
template< class _Anything> 
#line 4009
struct _Ptr_cat_helper< _Anything *, const _Anything *>  { 
#line 4011
static constexpr bool _Really_trivial = true; 
#line 4012
static constexpr bool _Trivially_copyable = true; 
#line 4013
}; 
#line 4015
template< class _Anything> 
#line 4016
struct _Ptr_cat_helper< _Anything *, volatile _Anything *>  { 
#line 4018
static constexpr bool _Really_trivial = true; 
#line 4019
static constexpr bool _Trivially_copyable = true; 
#line 4020
}; 
#line 4022
template< class _Anything> 
#line 4023
struct _Ptr_cat_helper< _Anything *, const volatile _Anything *>  { 
#line 4025
static constexpr bool _Really_trivial = true; 
#line 4026
static constexpr bool _Trivially_copyable = true; 
#line 4027
}; 
#line 4029
struct _False_copy_cat { 
#line 4030
static constexpr bool _Really_trivial = false; 
#line 4031
static constexpr bool _Trivially_copyable = false; 
#line 4032
}; 
#line 4035
template< class _Source, class _Dest, bool _Non_contiguous = !_Iterators_are_contiguous< _Source, _Dest> > 
#line 4036
struct _Ptr_move_cat : public _False_copy_cat { }; 
#line 4038
template< class _Source, class _Dest> 
#line 4039
struct _Ptr_move_cat< _Source, _Dest, false>  : public conditional_t< is_trivially_assignable_v< _Iter_ref_t< _Dest> , remove_reference_t< _Iter_ref_t< _Source> > > , _Ptr_cat_helper< _Iter_value_t< _Source> , _Iter_value_t< _Dest> > , _False_copy_cat>  { 
#line 4041
}; 
#line 4043
template< class _Source, class _Dest> 
#line 4044
struct _Ptr_move_cat< move_iterator< _Source> , _Dest, true>  : public std::_Ptr_move_cat< _Source, _Dest>  { }; 
#line 4046
template< class _Source, class _Dest, bool _Non_contiguous = !_Iterators_are_contiguous< _Source, _Dest> > 
#line 4047
struct _Ptr_copy_cat : public _False_copy_cat { }; 
#line 4049
template< class _Source, class _Dest> 
#line 4050
struct _Ptr_copy_cat< _Source, _Dest, false>  : public conditional_t< is_trivially_assignable_v< _Iter_ref_t< _Dest> , _Iter_ref_t< _Source> > , _Ptr_cat_helper< _Iter_value_t< _Source> , _Iter_value_t< _Dest> > , _False_copy_cat>  { 
#line 4052
}; 
#line 4054
template< class _Source, class _Dest> 
#line 4055
struct _Ptr_copy_cat< move_iterator< _Source> , _Dest, true>  : public _Ptr_move_cat< _Source, _Dest>  { }; 
#line 4057
template < class _CtgIt, class _OutCtgIt >
_OutCtgIt _Copy_memmove ( _CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest ) {
    auto _FirstPtr = _To_address ( _First );
    auto _LastPtr = _To_address ( _Last );
    auto _DestPtr = _To_address ( _Dest );
    const char * const _First_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _FirstPtr ) );
    const char * const _Last_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _LastPtr ) );
    char * const _Dest_ch = const_cast < char * > ( reinterpret_cast < const volatile char * > ( _DestPtr ) );
    const auto _Count = static_cast < size_t > ( _Last_ch - _First_ch );
    :: memmove ( _Dest_ch, _First_ch, _Count );
    if constexpr ( is_pointer_v < _OutCtgIt > ) {
        return reinterpret_cast < _OutCtgIt > ( _Dest_ch + _Count );
    } else {
        return _Dest + ( _LastPtr - _FirstPtr );
    }
}
#line 4074
template < class _InIt, class _OutIt >
_OutIt _Copy_memmove ( move_iterator < _InIt > _First, move_iterator < _InIt > _Last, _OutIt _Dest ) {
    return _Copy_memmove ( _First . base ( ), _Last . base ( ), _Dest );
}
#line 4079
template< class _It, bool _RequiresMutable = false> constexpr bool 
#line 4080
_Is_vb_iterator = false; 
#line 4082
template < class _InIt, class _OutIt >
inline _OutIt _Copy_unchecked ( _InIt _First, _InIt _Last, _OutIt _Dest ) {


    if constexpr ( _Ptr_copy_cat < _InIt, _OutIt > :: _Trivially_copyable ) {



        {
            return _Copy_memmove ( _First, _Last, _Dest );
        }
    }

    for (; _First != _Last; ++ _Dest, ( void ) ++ _First ) {
        * _Dest = * _First;
    }

    return _Dest;
}
#line 4102
template < class _InIt, class _OutIt >
inline _OutIt copy ( _InIt _First, _InIt _Last, _OutIt _Dest ) {
    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    const auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    _Seek_wrapped ( _Dest, _Copy_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 4198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt, class _Diff, class _OutIt >
inline _OutIt copy_n ( _InIt _First, _Diff _Count_raw, _OutIt _Dest ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( 0 < _Count ) {
        auto _UFirst = _Get_unwrapped_n ( _First, _Count );
        auto _UDest = _Get_unwrapped_n ( _Dest, _Count );
        if constexpr ( _Ptr_copy_cat < decltype ( _UFirst ), decltype ( _UDest ) > :: _Trivially_copyable ) {



            {
                _UDest = _Copy_memmove ( _UFirst, _UFirst + _Count, _UDest );
                _Seek_wrapped ( _Dest, _UDest );
                return _Dest;
            }
        }

        for (;; ) {
            * _UDest = * _UFirst;
            ++ _UDest;
            -- _Count;
            if ( _Count == 0 ) {

                break;
            }

            ++ _UFirst;
        }

        _Seek_wrapped ( _Dest, _UDest );
    }

    return _Dest;
}
#line 4245 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _CtgIt1, class _CtgIt2 >
_CtgIt2 _Copy_backward_memmove ( _CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest ) {

    auto _FirstPtr = _To_address ( _First );
    auto _LastPtr = _To_address ( _Last );
    auto _DestPtr = _To_address ( _Dest );
    const char * const _First_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _FirstPtr ) );
    const char * const _Last_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _LastPtr ) );
    char * const _Dest_ch = const_cast < char * > ( reinterpret_cast < const volatile char * > ( _DestPtr ) );
    const auto _Count = static_cast < size_t > ( _Last_ch - _First_ch );
    auto _Result = :: memmove ( _Dest_ch - _Count, _First_ch, _Count );
    if constexpr ( is_pointer_v < _CtgIt2 > ) {
        return static_cast < _CtgIt2 > ( _Result );
    } else {
        return _Dest - ( _LastPtr - _FirstPtr );
    }
}
#line 4263
template < class _BidIt1, class _BidIt2 >
_BidIt2 _Copy_backward_memmove ( move_iterator < _BidIt1 > _First, move_iterator < _BidIt1 > _Last, _BidIt2 _Dest ) {
    return _Copy_backward_memmove ( _First . base ( ), _Last . base ( ), _Dest );
}
#line 4268
template < class _BidIt1, class _BidIt2 >
[ [ nodiscard ] ] inline _BidIt2 _Copy_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest ) {

    if constexpr ( _Ptr_copy_cat < _BidIt1, _BidIt2 > :: _Trivially_copyable ) {



        {
            return _Copy_backward_memmove ( _First, _Last, _Dest );
        }
    }

    while ( _First != _Last ) {
        * -- _Dest = * -- _Last;
    }

    return _Dest;
}
#line 4287
template < class _BidIt1, class _BidIt2 >
inline _BidIt2 copy_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest ) {

    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    const auto _UDest = _Get_unwrapped_n ( _Dest, - _Idl_distance < _BidIt1 > ( _UFirst, _ULast ) );
    _Seek_wrapped ( _Dest, _Copy_backward_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 4307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt, class _OutIt >
inline _OutIt _Move_unchecked ( _InIt _First, _InIt _Last, _OutIt _Dest ) {


    if constexpr ( _Ptr_move_cat < _InIt, _OutIt > :: _Trivially_copyable ) {



        {
            return _Copy_memmove ( _First, _Last, _Dest );
        }
    }

    for (; _First != _Last; ++ _Dest, ( void ) ++ _First ) {
        * _Dest = :: std :: move ( * _First );
    }

    return _Dest;
}
#line 4327
template < class _InIt, class _OutIt >
inline _OutIt move ( _InIt _First, _InIt _Last, _OutIt _Dest ) {

    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    const auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    _Seek_wrapped ( _Dest, _Move_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 4349 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _BidIt1, class _BidIt2 >
inline _BidIt2 _Move_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest ) {


    if constexpr ( _Ptr_move_cat < _BidIt1, _BidIt2 > :: _Trivially_copyable ) {



        {
            return _Copy_backward_memmove ( _First, _Last, _Dest );
        }
    }

    while ( _First != _Last ) {
        * -- _Dest = :: std :: move ( * -- _Last );
    }

    return _Dest;
}
#line 4369
template < class _BidIt1, class _BidIt2 >
inline _BidIt2 move_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest ) {

    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    const auto _UDest = _Get_unwrapped_n ( _Dest, - _Idl_distance < _BidIt1 > ( _UFirst, _ULast ) );
    _Seek_wrapped ( _Dest, _Move_backward_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 4390 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template< class _Ty> 
#line 4391
struct _Is_character : public false_type { }; 
#line 4394
template<> struct _Is_character< char>  : public true_type { }; 
#line 4397
template<> struct _Is_character< signed char>  : public true_type { }; 
#line 4400
template<> struct _Is_character< unsigned char>  : public true_type { }; 
#line 4407
template< class _Ty> 
#line 4408
struct _Is_character_or_bool : public _Is_character< _Ty> ::type { }; 
#line 4411
template<> struct _Is_character_or_bool< bool>  : public true_type { }; 
#line 4413
template< class _Ty> 
#line 4414
struct _Is_character_or_byte_or_bool : public _Is_character_or_bool< _Ty> ::type { }; 
#line 4423
template< class _FwdIt, class _Ty, bool  = _Iterator_is_contiguous< _FwdIt> > constexpr bool 
#line 4424
_Fill_memset_is_safe = conjunction_v< is_scalar< _Ty> , _Is_character_or_byte_or_bool< _Unwrap_enum_t< remove_reference_t< _Iter_ref_t< _FwdIt> > > > , negation< is_volatile< remove_reference_t< _Iter_ref_t< _FwdIt> > > > , is_assignable< _Iter_ref_t< _FwdIt> , const _Ty &> > ; 
#line 4428
template< class _FwdIt, class _Ty> constexpr bool 
#line 4429
_Fill_memset_is_safe< _FwdIt, _Ty, false>  = false; 
#line 4431
template< class _FwdIt, class _Ty, bool  = _Iterator_is_contiguous< _FwdIt> > constexpr bool 
#line 4432
_Fill_zero_memset_is_safe = conjunction_v< is_scalar< _Ty> , is_scalar< _Iter_value_t< _FwdIt> > , negation< is_member_pointer< _Iter_value_t< _FwdIt> > > , negation< is_volatile< remove_reference_t< _Iter_ref_t< _FwdIt> > > > , is_assignable< _Iter_ref_t< _FwdIt> , const _Ty &> > ; 
#line 4436
template< class _FwdIt, class _Ty> constexpr bool 
#line 4437
_Fill_zero_memset_is_safe< _FwdIt, _Ty, false>  = false; 
#line 4439
template < class _CtgIt, class _Ty >
void _Fill_memset ( _CtgIt _Dest, const _Ty _Val, const size_t _Count ) {

    _Iter_value_t < _CtgIt > _Dest_val = _Val;
    :: memset ( _To_address ( _Dest ), static_cast < unsigned char > ( _Dest_val ), _Count );
}
#line 4446
template < class _CtgIt >
void _Fill_zero_memset ( _CtgIt _Dest, const size_t _Count ) {
    :: memset ( _To_address ( _Dest ), 0, _Count * sizeof ( _Iter_value_t < _CtgIt > ) );
}
#line 4451
template < class _Ty >
[ [ nodiscard ] ] bool _Is_all_bits_zero ( const _Ty & _Val ) {

    ;
    constexpr _Ty _Zero { };
    return :: memcmp ( & _Val, & _Zero, sizeof ( _Ty ) ) == 0;
}
#line 4459
template < class _FwdIt, class _Ty >
inline void fill ( const _FwdIt _First, const _FwdIt _Last, const _Ty & _Val ) {

    _Adl_verify_range ( _First, _Last );
    if constexpr ( _Is_vb_iterator < _FwdIt, true > ) {
        _Fill_vbool ( _First, _Last, _Val );
    } else {
        auto _UFirst = _Get_unwrapped ( _First );
        const auto _ULast = _Get_unwrapped ( _Last );



        {
            if constexpr ( _Fill_memset_is_safe < decltype ( _UFirst ), _Ty > ) {
                _Fill_memset ( _UFirst, _Val, static_cast < size_t > ( _ULast - _UFirst ) );
                return;
            } else if constexpr ( _Fill_zero_memset_is_safe < decltype ( _UFirst ), _Ty > ) {
                if ( _Is_all_bits_zero ( _Val ) ) {
                    _Fill_zero_memset ( _UFirst, static_cast < size_t > ( _ULast - _UFirst ) );
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++ _UFirst ) {
            * _UFirst = _Val;
        }
    }
}
#line 4499 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _OutIt, class _Diff, class _Ty >
inline _OutIt fill_n ( _OutIt _Dest, const _Diff _Count_raw, const _Ty & _Val ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( 0 < _Count ) {
        if constexpr ( _Is_vb_iterator < _OutIt, true > ) {
            const auto _Last = _Dest + static_cast < typename _OutIt :: difference_type > ( _Count );
            _Fill_vbool ( _Dest, _Last, _Val );
            return _Last;
        } else {
            auto _UDest = _Get_unwrapped_n ( _Dest, _Count );



            {
                if constexpr ( _Fill_memset_is_safe < decltype ( _UDest ), _Ty > ) {
                    _Fill_memset ( _UDest, _Val, static_cast < size_t > ( _Count ) );
                    _Seek_wrapped ( _Dest, _UDest + _Count );
                    return _Dest;
                } else if constexpr ( _Fill_zero_memset_is_safe < decltype ( _UDest ), _Ty > ) {
                    if ( _Is_all_bits_zero ( _Val ) ) {
                        _Fill_zero_memset ( _UDest, static_cast < size_t > ( _Count ) );
                        _Seek_wrapped ( _Dest, _UDest + _Count );
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; -- _Count, ( void ) ++ _UDest ) {
                * _UDest = _Val;
            }

            _Seek_wrapped ( _Dest, _UDest );
        }
    }
    return _Dest;
}
#line 4595 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
#pragma warning(push)
#pragma warning(disable : 4806)
template< class _Elem1, class _Elem2, bool 
#line 4598
 = ((((sizeof(_Elem1) == sizeof(_Elem2)) && is_integral_v< _Elem1> ) && (!is_volatile_v< _Elem1> )) && is_integral_v< _Elem2> ) && (!is_volatile_v< _Elem2> )> constexpr bool 
#line 4601
_Can_memcmp_elements = (is_same_v< _Elem1, bool>  || is_same_v< _Elem2, bool> ) || ((static_cast< _Elem1>(-1)) == (static_cast< _Elem2>(-1))); 
#line 4603
#pragma warning(pop)
#line 4616
template< class _Ty1, class _Ty2> constexpr bool 
#line 4617
_Can_memcmp_elements< _Ty1 *, _Ty2 *, false>  = is_same_v< remove_cv_t< _Ty1> , remove_cv_t< _Ty2> > ; 
#line 4619
template< class _Elem1, class _Elem2> constexpr bool 
#line 4620
_Can_memcmp_elements< _Elem1, _Elem2, false>  = false; 
#line 4626
template< class _Elem1, class _Elem2, class _Pr> constexpr bool 
#line 4627
_Pred_is_consistent_with_memcmp = false; 
#line 4631
template< class _Elem> constexpr bool 
#line 4632
_Pred_is_consistent_with_memcmp< _Elem, _Elem, equal_to< _Elem> >  = true; 
#line 4635
template< class _Elem1, class _Elem2> constexpr bool 
#line 4636
_Pred_is_consistent_with_memcmp< _Elem1, _Elem2, equal_to<> >  = true; 
#line 4647
template< class _Elem1, class _Elem2, class _Pr> constexpr bool 
#line 4648
_Can_memcmp_elements_with_pred = _Can_memcmp_elements< _Elem1, _Elem2, ((((sizeof(_Elem1) == sizeof(_Elem2)) && is_integral_v< _Elem1> ) && (!is_volatile_v< _Elem1> )) && is_integral_v< _Elem2> ) && (!is_volatile_v< _Elem2> )>  && _Pred_is_consistent_with_memcmp< _Elem1, _Elem2, _Pr> ; 
#line 4654
template< class _Iter1, class _Iter2, class _Pr> constexpr bool 
#line 4655
_Equal_memcmp_is_safe_helper = _Iterators_are_contiguous< _Iter1, _Iter2>  && _Can_memcmp_elements_with_pred< remove_const_t< remove_reference_t< _Iter_ref_t< _Iter1> > > , remove_const_t< remove_reference_t< _Iter_ref_t< _Iter2> > > , _Pr> ; 
#line 4659
template< class _Iter1, class _Iter2, class _Pr> constexpr bool 
#line 4660
_Equal_memcmp_is_safe = _Equal_memcmp_is_safe_helper< remove_const_t< _Iter1> , remove_const_t< _Iter2> , _Pr> ; 
#line 4663
template < class _CtgIt1, class _CtgIt2 >
[ [ nodiscard ] ] int _Memcmp_ranges ( _CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2 ) {
    ;
    const auto _First1_ch = reinterpret_cast < const char * > ( _To_address ( _First1 ) );
    const auto _Last1_ch = reinterpret_cast < const char * > ( _To_address ( _Last1 ) );
    const auto _First2_ch = reinterpret_cast < const char * > ( _To_address ( _First2 ) );
    return :: memcmp ( _First1_ch, _First2_ch, static_cast < size_t > ( _Last1_ch - _First1_ch ) );
}
#line 4672
template < class _CtgIt1, class _CtgIt2 >
[ [ nodiscard ] ] int _Memcmp_count ( _CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count ) {
    ;
    const auto _First1_ch = reinterpret_cast < const char * > ( _To_address ( _First1 ) );
    const auto _First2_ch = reinterpret_cast < const char * > ( _To_address ( _First2 ) );
    return :: memcmp ( _First1_ch, _First2_ch, _Count * sizeof ( _Iter_value_t < _CtgIt1 > ) );
}
#line 4680
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped_n ( _First2, _Idl_distance < _InIt1 > ( _UFirst1, _ULast1 ) );
    if constexpr ( _Equal_memcmp_is_safe < decltype ( _UFirst1 ), decltype ( _UFirst2 ), _Pr > ) {



        {
            return _Memcmp_ranges ( _UFirst1, _ULast1, _UFirst2 ) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++ _UFirst1, ( void ) ++ _UFirst2 ) {
        if ( ! _Pred ( * _UFirst1, * _UFirst2 ) ) {
            return false;
        }
    }

    return true;
}
#line 4711 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2 ) {

    return :: std :: equal ( _First1, _Last1, _First2, equal_to < > { } );
}
#line 4726 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline bool equal (
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    if constexpr ( _Is_random_iter_v < _InIt1 > && _Is_random_iter_v < _InIt2 > ) {
        if ( _ULast1 - _UFirst1 != _ULast2 - _UFirst2 ) {
            return false;
        }

        return :: std :: equal ( _UFirst1, _ULast1, _UFirst2, _Pass_fn ( _Pred ) );
    } else {
        for (;; ) {
            if ( _UFirst1 == _ULast1 ) {
                return _UFirst2 == _ULast2;
            }

            if ( _UFirst2 == _ULast2 ) {
                return false;
            }

            if ( ! _Pred ( * _UFirst1, * _UFirst2 ) ) {
                return false;
            }

            ++ _UFirst1;
            ++ _UFirst2;
        }
    }
}
#line 4768 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline bool equal (
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2 ) {

    return :: std :: equal ( _First1, _Last1, _First2, _Last2, equal_to < > { } );
}
#line 4910 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template< class _Elem1, class _Elem2, class _FTy> 
#line 4911
struct _Lex_compare_check_element_types_helper : public bool_constant< conjunction_v< _Is_character< _Elem1> , _Is_character< _Elem2> , _Is_character< _FTy> , is_unsigned< _FTy> > >  { 
#line 4915
}; 
#line 4917
template< class _Elem1, class _Elem2> 
#line 4918
struct _Lex_compare_check_element_types_helper< _Elem1, _Elem2, void>  : public bool_constant< conjunction_v< _Is_character< _Elem1> , _Is_character< _Elem2> , is_unsigned< _Elem1> , is_unsigned< _Elem2> > >  { 
#line 4922
}; 
#line 4936
template< class _Memcmp_pr> 
#line 4937
struct _Lex_compare_optimize { 
#line 4938
explicit _Lex_compare_optimize() = default;
#line 4940
using _Pred = _Memcmp_pr; 
#line 4941
}; 
#line 4943
template< class _Memcmp_pr, class _Obj1, class _Obj2, class _FTy> using _Lex_compare_check_element_types = _Lex_compare_optimize< conditional_t< _Lex_compare_check_element_types_helper< remove_const_t< _Obj1> , remove_const_t< _Obj2> , _FTy> ::value, _Memcmp_pr, void> > ; 
#line 4948
template < class _InIt1, class _InIt2, class _Pr >
constexpr auto _Lex_compare_memcmp_classify ( const _InIt1 &, const _InIt2 &, const _Pr & ) {

    return _Lex_compare_optimize < void > { };
}
#line 4954
template < class _CtgIt1, class _CtgIt2, class _FTy, enable_if_t < _Iterators_are_contiguous < _CtgIt1, _CtgIt2 >, int > = 0 >
constexpr auto _Lex_compare_memcmp_classify ( const _CtgIt1 &, const _CtgIt2 &, const less < _FTy > & ) {

    return _Lex_compare_check_element_types < less < int >, remove_reference_t < _Iter_ref_t < _CtgIt1 >>,
        remove_reference_t < _Iter_ref_t < _CtgIt2 >>, _FTy > { };
}
#line 4961
template < class _CtgIt1, class _CtgIt2, class _FTy, enable_if_t < _Iterators_are_contiguous < _CtgIt1, _CtgIt2 >, int > = 0 >
constexpr auto _Lex_compare_memcmp_classify ( const _CtgIt1 &, const _CtgIt2 &, const greater < _FTy > & ) {

    return _Lex_compare_check_element_types < greater < int >, remove_reference_t < _Iter_ref_t < _CtgIt1 >>,
        remove_reference_t < _Iter_ref_t < _CtgIt2 >>, _FTy > { };
}
#line 4984
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] constexpr bool _Lex_compare_unchecked (
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize < void > ) {

    for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ( void ) ++ _First2 ) {
        if ( static_cast < bool > ( _Pred ( * _First1, * _First2 ) ) ) {
            return true;
        } else if ( _Pred ( * _First2, * _First1 ) ) {
            return false;
        }
    }

    return _First1 == _Last1 && _First2 != _Last2;
}
#line 4999
template < class _CtgIt1, class _CtgIt2, class _Pr, class _Memcmp_pr >
[ [ nodiscard ] ] inline bool _Lex_compare_unchecked (
    _CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2, _CtgIt2 _Last2, _Pr _Pred, _Lex_compare_optimize < _Memcmp_pr > ) {






    ( void ) _Pred;
    const auto _Num1 = static_cast < size_t > ( _Last1 - _First1 );
    const auto _Num2 = static_cast < size_t > ( _Last2 - _First2 );
    const int _Ans = _Memcmp_count ( _First1, _First2, ( :: std :: min ) ( _Num1, _Num2 ) );
    return _Memcmp_pr { } ( _Ans, 0 ) || ( _Ans == 0 && _Num1 < _Num2 );
}
#line 5015
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline bool lexicographical_compare (
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    const auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    const auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    return _Lex_compare_unchecked (
        _UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn ( _Pred ), _Lex_compare_memcmp_classify ( _UFirst1, _UFirst2, _Pred ) );
}
#line 5029
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2 ) {

    return :: std :: lexicographical_compare ( _First1, _Last1, _First2, _Last2, less < > { } );
}
#line 5116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _Ty >
[ [ nodiscard ] ] constexpr bool _Within_limits ( const _Ty & _Val, true_type, true_type, _Any_tag, false_type ) {

    return ( - 128 ) <= _Val && _Val <= 127;
}
#line 5122
template < class _Ty >
[ [ nodiscard ] ] constexpr bool _Within_limits ( const _Ty & _Val, true_type, false_type, true_type, false_type ) {

    return _Val <= 127 || static_cast < _Ty > ( ( - 128 ) ) <= _Val;
}
#line 5128
template < class _Ty >
[ [ nodiscard ] ] constexpr bool _Within_limits ( const _Ty & _Val, true_type, false_type, false_type, false_type ) {

    return _Val <= 127;
}
#line 5134
template < class _Ty >
[ [ nodiscard ] ] constexpr bool _Within_limits ( const _Ty & _Val, false_type, true_type, _Any_tag, false_type ) {

    return 0 <= _Val && _Val <= 255;
}
#line 5140
template < class _Ty >
[ [ nodiscard ] ] constexpr bool _Within_limits ( const _Ty & _Val, false_type, false_type, _Any_tag, false_type ) {

    return _Val <= 255;
}
#line 5146
template < class _Ty >
[ [ nodiscard ] ] constexpr bool _Within_limits ( const _Ty & _Val, _Any_tag, _Any_tag, _Any_tag, true_type ) {

    return _Val == true || _Val == false;
}
#line 5152
template < class _InIt, class _Ty >
[ [ nodiscard ] ] constexpr bool _Within_limits ( const _InIt &, const _Ty & _Val ) {

    using _Elem = _Iter_value_t < _InIt >;
    return _Within_limits ( _Val, bool_constant < is_signed_v < _Elem >> { }, bool_constant < is_signed_v < _Ty >> { },
        bool_constant < - 1 == static_cast < _Ty > ( - 1 ) > { }, bool_constant < is_same_v < _Elem, bool >> { } );
}
#line 5160
template < class _InIt >
[ [ nodiscard ] ] constexpr bool _Within_limits ( const _InIt &, const bool & ) {
    return true;
}
#line 5172
template< class _Iter, class _Ty> constexpr bool 
#line 5173
_Memchr_in_find_is_safe = (_Iterator_is_contiguous< _Iter>  && disjunction_v< conjunction< is_integral< _Ty> , _Is_character_or_bool< _Iter_value_t< _Iter> > > > ) && (!is_volatile_v< remove_reference_t< _Iter_ref_t< _Iter> > > ); 
#line 5182
template < class _InIt, class _Ty >
[ [ nodiscard ] ] constexpr _InIt _Find_unchecked1 ( _InIt _First, const _InIt _Last, const _Ty & _Val, false_type ) {

    for (; _First != _Last; ++ _First ) {
        if ( * _First == _Val ) {
            break;
        }
    }

    return _First;
}
#line 5194
template < class _InIt, class _Ty >
[ [ nodiscard ] ] inline _InIt _Find_unchecked1 ( _InIt _First, const _InIt _Last, const _Ty & _Val, true_type ) {

    if ( ! _Within_limits ( _First, _Val ) ) {
        return _Last;
    }







    const auto _First_ptr = _To_address ( _First );
    const auto _Result = static_cast < remove_reference_t < _Iter_ref_t < _InIt >> * > (
        :: memchr ( _First_ptr, static_cast < unsigned char > ( _Val ), static_cast < size_t > ( _Last - _First ) ) );
    if constexpr ( is_pointer_v < _InIt > ) {
        return _Result ? _Result : _Last;
    } else {
        return _Result ? _First + ( _Result - _First_ptr ) : _Last;
    }
}
#line 5217
template < class _InIt, class _Ty >
[ [ nodiscard ] ] inline _InIt _Find_unchecked ( const _InIt _First, const _InIt _Last, const _Ty & _Val ) {


    return _Find_unchecked1 ( _First, _Last, _Val, bool_constant < _Memchr_in_find_is_safe < _InIt, _Ty >> { } );
}
#line 5224
template < class _InIt, class _Ty >
[ [ nodiscard ] ] inline _InIt find ( _InIt _First, const _InIt _Last, const _Ty & _Val ) {
    _Adl_verify_range ( _First, _Last );
    _Seek_wrapped ( _First, _Find_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Val ) );
    return _First;
}
#line 5324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt, class _Ty >
[ [ nodiscard ] ] inline _Iter_diff_t < _InIt > count ( const _InIt _First, const _InIt _Last, const _Ty & _Val ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    _Iter_diff_t < _InIt > _Count = 0;

    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( * _UFirst == _Val ) {
            ++ _Count;
        }
    }

    return _Count;
}
#line 5347 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt, class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _InIt _Find_pr ( _InIt _First, const _InIt _Last, const _Ty & _Val, _Pr _Pred ) {
    for (; _First != _Last; ++ _First ) {
        if ( _Pred ( * _First, _Val ) ) {
            break;
        }
    }

    return _First;
}
#line 5358
template < class _InIt, class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Iter_diff_t < _InIt > _Count_pr ( _InIt _First, const _InIt _Last, const _Ty & _Val, _Pr _Pred ) {
    _Iter_diff_t < _InIt > _Count = 0;

    for (; _First != _Last; ++ _First ) {
        if ( _Pred ( * _First, _Val ) ) {
            ++ _Count;
        }
    }

    return _Count;
}
#line 5371
template < class _FwdIt1, class _FwdIt2, class _Pr >
[ [ nodiscard ] ] inline bool _Check_match_counts (
    const _FwdIt1 _First1, _FwdIt1 _Last1, const _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred ) {

    ;
    ;
    if constexpr ( _Is_bidi_iter_v < _FwdIt1 > && _Is_bidi_iter_v < _FwdIt2 > ) {
        do {
            -- _Last1;
            -- _Last2;
        } while ( _Pred ( * _Last1, * _Last2 ) );
        ++ _Last1;
        ++ _Last2;
    }

    for ( _FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++ _Next1 ) {
        if ( _Next1 == _Find_pr ( _First1, _Next1, * _Next1, _Pred ) ) {
            _Iter_diff_t < _FwdIt2 > _Count2 = _Count_pr ( _First2, _Last2, * _Next1, _Pred );
            if ( _Count2 == 0 ) {
                return false;
            }

            _FwdIt1 _Skip1 = _Next_iter ( _Next1 );
            _Iter_diff_t < _FwdIt1 > _Count1 = _Count_pr ( _Skip1, _Last1, * _Next1, _Pred ) + 1;
            if ( _Count2 != _Count1 ) {
                return false;
            }
        }
    }

    return true;
}
#line 5404
template < class _BidIt >
inline void reverse ( const _BidIt _First, const _BidIt _Last ) {
    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    auto _ULast = _Get_unwrapped ( _Last );

    using _Elem = remove_reference_t < _Iter_ref_t < decltype ( _UFirst ) >>;
    constexpr bool _Allow_vectorization = conjunction_v < bool_constant < _Iterator_is_contiguous < decltype ( _UFirst ) >>,
        _Is_trivially_swappable < _Elem >, negation < is_volatile < _Elem >> >;
    constexpr size_t _Nx = sizeof ( _Elem );

#pragma warning(suppress : 6326)
    if constexpr ( _Allow_vectorization && _Nx <= 8 && ( _Nx & ( _Nx - 1 ) ) == 0 ) {



        {
            if constexpr ( _Nx == 1 ) {
                __std_reverse_trivially_swappable_1 ( _To_address ( _UFirst ), _To_address ( _ULast ) );
            } else if constexpr ( _Nx == 2 ) {
                __std_reverse_trivially_swappable_2 ( _To_address ( _UFirst ), _To_address ( _ULast ) );
            } else if constexpr ( _Nx == 4 ) {
                __std_reverse_trivially_swappable_4 ( _To_address ( _UFirst ), _To_address ( _ULast ) );
            } else {
                __std_reverse_trivially_swappable_8 ( _To_address ( _UFirst ), _To_address ( _ULast ) );
            }

            return;
        }
    }


    for (; _UFirst != _ULast && _UFirst != -- _ULast; ++ _UFirst ) {
        :: std :: iter_swap ( _UFirst, _ULast );
    }
}
#line 5450 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _BidIt >
constexpr pair < _BidIt, _BidIt > _Reverse_until_sentinel_unchecked ( _BidIt _First, _BidIt _Sentinel, _BidIt _Last ) {

    while ( _First != _Sentinel && _Last != _Sentinel ) {
        :: std :: iter_swap ( _First, -- _Last );
        ++ _First;
    }

    return pair < _BidIt, _BidIt > ( _First, _Last );
}
#line 5461
template < class _FwdIt >
inline _FwdIt rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last ) {



    _Adl_verify_range ( _First, _Mid );
    _Adl_verify_range ( _Mid, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    auto _UMid = _Get_unwrapped ( _Mid );
    const auto _ULast = _Get_unwrapped ( _Last );
    if ( _UFirst == _UMid ) {
        return _Last;
    }

    if ( _UMid == _ULast ) {
        return _First;
    }

    if constexpr ( _Is_random_iter_v < _FwdIt > ) {
        :: std :: reverse ( _UFirst, _UMid );
        :: std :: reverse ( _UMid, _ULast );
        :: std :: reverse ( _UFirst, _ULast );
        _Seek_wrapped ( _First, _UFirst + ( _ULast - _UMid ) );
    } else if constexpr ( _Is_bidi_iter_v < _FwdIt > ) {
        :: std :: reverse ( _UFirst, _UMid );
        :: std :: reverse ( _UMid, _ULast );
        auto _Tmp = _Reverse_until_sentinel_unchecked ( _UFirst, _UMid, _ULast );
        :: std :: reverse ( _Tmp . first, _Tmp . second );
        _Seek_wrapped ( _First, _UMid != _Tmp . first ? _Tmp . first : _Tmp . second );
    } else {
        auto _UNext = _UMid;
        do {
            :: std :: iter_swap ( _UFirst, _UNext );
            ++ _UFirst;
            ++ _UNext;
            if ( _UFirst == _UMid ) {
                _UMid = _UNext;
            }
        } while ( _UNext != _ULast );
        _Seek_wrapped ( _First, _UFirst );
        while ( _UMid != _ULast ) {
            _UNext = _UMid;
            do {
                :: std :: iter_swap ( _UFirst, _UNext );
                ++ _UFirst;
                ++ _UNext;
                if ( _UFirst == _UMid ) {
                    _UMid = _UNext;
                }
            } while ( _UNext != _ULast );
        }
    }

    return _First;
}
#line 5526 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _InIt, class _Pr >
[ [ nodiscard ] ] inline _InIt find_if ( _InIt _First, const _InIt _Last, _Pr _Pred ) {
    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( _Pred ( * _UFirst ) ) {
            break;
        }
    }

    _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 5806
template < class _FwdIt, class _Ty, class _Pr >
[ [ nodiscard ] ] inline _FwdIt lower_bound ( _FwdIt _First, const _FwdIt _Last, const _Ty & _Val, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _UFirst, _Get_unwrapped ( _Last ) );

    while ( 0 < _Count ) {
        const _Iter_diff_t < _FwdIt > _Count2 = _Count / 2;
        const auto _UMid = :: std :: next ( _UFirst, _Count2 );
        if ( _Pred ( * _UMid, _Val ) ) {
            _UFirst = _Next_iter ( _UMid );
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 5828
template < class _FwdIt, class _Ty >
[ [ nodiscard ] ] inline _FwdIt lower_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val ) {

    return :: std :: lower_bound ( _First, _Last, _Val, less < > { } );
}
#line 5834
template < class _FwdIt1, class _FwdIt2 >
inline _FwdIt2 _Swap_ranges_unchecked ( _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2 ) {

    for (; _First1 != _Last1; ++ _First1, ( void ) ++ _First2 ) {
        :: std :: iter_swap ( _First1, _First2 );
    }

    return _First2;
}
#line 5845
template < class _Ty, enable_if_t < _Is_trivially_swappable_v < _Ty >, int > = 0 >
inline _Ty * _Swap_ranges_unchecked ( _Ty * _First1, _Ty * const _Last1, _Ty * _First2 ) {











    __std_swap_ranges_trivially_swappable_noalias ( _First1, _Last1, _First2 );
    return _First2 + ( _Last1 - _First1 );
}
#line 5863 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
template < class _Diff, class _Urng >
class _Rng_from_urng {
public :
    using _Ty0 = make_unsigned_t < _Diff >;
    using _Ty1 = typename _Urng :: result_type;

    using _Udiff = conditional_t < sizeof ( _Ty1 ) < sizeof ( _Ty0 ), _Ty0, _Ty1 >;

    explicit _Rng_from_urng ( _Urng & _Func ) : _Ref ( _Func ), _Bits ( 8 * sizeof ( _Udiff ) ), _Bmask ( _Udiff ( - 1 ) ) {
        for (; ( _Urng :: max ) ( ) - ( _Urng :: min ) ( ) < _Bmask; _Bmask >>= 1 ) {
            -- _Bits;
        }
    }

    _Diff operator ( ) ( _Diff _Index ) {
        for (;; ) {
            _Udiff _Ret = 0;
            _Udiff _Mask = 0;

            while ( _Mask < _Udiff ( _Index - 1 ) ) {
                _Ret <<= _Bits - 1;
                _Ret <<= 1;
                _Ret |= _Get_bits ( );
                _Mask <<= _Bits - 1;
                _Mask <<= 1;
                _Mask |= _Bmask;
            }


            if ( _Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff ( _Index - 1 ) ) {
                return static_cast < _Diff > ( _Ret % _Index );
            }
        }
    }

    _Udiff _Get_all_bits ( ) {
        _Udiff _Ret = 0;

        for ( size_t _Num = 0; _Num < 8 * sizeof ( _Udiff ); _Num += _Bits ) {
            _Ret <<= _Bits - 1;
            _Ret <<= 1;
            _Ret |= _Get_bits ( );
        }

        return _Ret;
    }

    _Rng_from_urng ( const _Rng_from_urng & ) = delete;
    _Rng_from_urng & operator = ( const _Rng_from_urng & ) = delete;

private :
    _Udiff _Get_bits ( ) {
        for (;; ) {
            _Udiff _Val = _Ref ( ) - ( _Urng :: min ) ( );

            if ( _Val <= _Bmask ) {
                return _Val;
            }
        }
    }

    _Urng & _Ref;
    size_t _Bits;
    _Udiff _Bmask;
};
#line 5929
template< class _Ty, class _Alloc, class  = void> 
#line 5930
struct _Has_allocator_type : public false_type { }; 
#line 5932
template< class _Ty, class _Alloc> 
#line 5933
struct _Has_allocator_type< _Ty, _Alloc, void_t< typename _Ty::allocator_type> >  : public is_convertible< _Alloc, typename _Ty::allocator_type> ::type { 
#line 5934
}; 
#line 5936
struct allocator_arg_t { 
#line 5937
explicit allocator_arg_t() = default;
#line 5938
}; 
#line 5940
constexpr allocator_arg_t allocator_arg{}; 
#line 5942
[[noreturn]] void __cdecl _Xbad_alloc(); 
#line 5943
[[noreturn]] void __cdecl _Xinvalid_argument(const char *); 
#line 5944
[[noreturn]] void __cdecl _Xlength_error(const char *); 
#line 5945
[[noreturn]] void __cdecl _Xout_of_range(const char *); 
#line 5946
[[noreturn]] void __cdecl _Xoverflow_error(const char *); 
#line 5947
[[noreturn]] void __cdecl _Xruntime_error(const char *); 
#line 5948
[[noreturn]] void __cdecl _XGetLastError(); 
#line 5950
template< class _Ty, class _Alloc> 
#line 5951
struct uses_allocator : public _Has_allocator_type< _Ty, _Alloc> ::type { 
#line 5953
}; 
#line 5955
template< class _Ty, class _Alloc> constexpr bool 
#line 5956
uses_allocator_v = (uses_allocator< _Ty, _Alloc> ::value); 
#line 5958
template< class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty *, class _Reference = _Ty &> 
#line 5959
struct iterator { 
#line 5960
using iterator_category = _Category; 
#line 5961
using value_type = _Ty; 
#line 5962
using difference_type = _Diff; 
#line 5963
using pointer = _Pointer; 
#line 5964
using reference = _Reference; 
#line 5965
}; 
#line 5967
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline auto _Float_abs_bits ( const _Ty & _Xx ) {
    using _Traits = _Floating_type_traits < _Ty >;
    using _Uint_type = typename _Traits :: _Uint_type;
    const auto _Bits = _Bit_cast < _Uint_type > ( _Xx );
    return _Bits & ~ _Traits :: _Shifted_sign_mask;
}
#line 5975
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline _Ty _Float_abs ( const _Ty _Xx ) {
    return _Bit_cast < _Ty > ( _Float_abs_bits ( _Xx ) );
}
#line 5980
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline _Ty _Float_copysign ( const _Ty _Magnitude, const _Ty _Sign ) {
    using _Traits = _Floating_type_traits < _Ty >;
    using _Uint_type = typename _Traits :: _Uint_type;
    const auto _Signbit = _Bit_cast < _Uint_type > ( _Sign ) & _Traits :: _Shifted_sign_mask;
    return _Bit_cast < _Ty > ( _Float_abs_bits ( _Magnitude ) | _Signbit );
}
#line 5988
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline bool _Is_nan ( const _Ty _Xx ) {
    using _Traits = _Floating_type_traits < _Ty >;
    return _Float_abs_bits ( _Xx ) > _Traits :: _Shifted_exponent_mask;
}
#line 5998
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline bool _Is_signaling_nan ( const _Ty & _Xx ) {
    using _Traits = _Floating_type_traits < _Ty >;
    const auto _Abs_bits = _Float_abs_bits ( _Xx );
    return _Abs_bits > _Traits :: _Shifted_exponent_mask && ( ( _Abs_bits & _Traits :: _Special_nan_mantissa_mask ) == 0 );
}
#line 6005
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline bool _Is_inf ( const _Ty _Xx ) {
    using _Traits = _Floating_type_traits < _Ty >;
    return _Float_abs_bits ( _Xx ) == _Traits :: _Shifted_exponent_mask;
}
#line 6011
template < class _Ty, enable_if_t < is_floating_point_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] inline bool _Is_finite ( const _Ty _Xx ) {
    using _Traits = _Floating_type_traits < _Ty >;
    return _Float_abs_bits ( _Xx ) < _Traits :: _Shifted_exponent_mask;
}
#line 6017
struct _Nontrivial_dummy_type { 
#line 6018
constexpr _Nontrivial_dummy_type() noexcept { 
#line 6020
} 
#line 6021
}; 
#line 6028
}
#line 6031
#pragma warning(pop)
#pragma pack ( pop )
#line 6035 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#line 22
template < class _Container >
class back_insert_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;




    using difference_type = void;


    inline explicit back_insert_iterator ( _Container & _Cont ) noexcept
        : container ( :: std :: addressof ( _Cont ) ) { }

    inline back_insert_iterator & operator = ( const typename _Container :: value_type & _Val ) {
        container -> push_back ( _Val );
        return * this;
    }

    inline back_insert_iterator & operator = ( typename _Container :: value_type && _Val ) {
        container -> push_back ( :: std :: move ( _Val ) );
        return * this;
    }

    [ [ nodiscard ] ] inline back_insert_iterator & operator * ( ) noexcept {
        return * this;
    }

    inline back_insert_iterator & operator ++ ( ) noexcept {
        return * this;
    }

    inline back_insert_iterator operator ++ ( int ) noexcept {
        return * this;
    }

protected :
    _Container * container;
};
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Container >
[ [ nodiscard ] ] inline back_insert_iterator < _Container > back_inserter ( _Container & _Cont ) noexcept {

    return back_insert_iterator < _Container > ( _Cont );
}
#line 73
template < class _Container >
class front_insert_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;




    using difference_type = void;


    inline explicit front_insert_iterator ( _Container & _Cont ) : container ( :: std :: addressof ( _Cont ) ) { }

    inline front_insert_iterator & operator = ( const typename _Container :: value_type & _Val ) {

        container -> push_front ( _Val );
        return * this;
    }

    inline front_insert_iterator & operator = ( typename _Container :: value_type && _Val ) {
        container -> push_front ( :: std :: move ( _Val ) );
        return * this;
    }

    [ [ nodiscard ] ] inline front_insert_iterator & operator * ( ) {
        return * this;
    }

    inline front_insert_iterator & operator ++ ( ) {
        return * this;
    }

    inline front_insert_iterator operator ++ ( int ) {
        return * this;
    }

protected :
    _Container * container;
};
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Container >
[ [ nodiscard ] ] inline front_insert_iterator < _Container > front_inserter ( _Container & _Cont ) {
    return front_insert_iterator < _Container > ( _Cont );
}
#line 123
template < class _Container >
class insert_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;




    using difference_type = void;
    using _Wrapped_iter = typename _Container :: iterator;


    inline insert_iterator ( _Container & _Cont, _Wrapped_iter _Where )
        : container ( :: std :: addressof ( _Cont ) ), iter ( :: std :: move ( _Where ) ) { }

    inline insert_iterator & operator = ( const typename _Container :: value_type & _Val ) {

        iter = container -> insert ( iter, _Val );
        ++ iter;
        return * this;
    }

    inline insert_iterator & operator = ( typename _Container :: value_type && _Val ) {
        iter = container -> insert ( iter, :: std :: move ( _Val ) );
        ++ iter;
        return * this;
    }

    [ [ nodiscard ] ] inline insert_iterator & operator * ( ) {
        return * this;
    }

    inline insert_iterator & operator ++ ( ) {
        return * this;
    }

    inline insert_iterator & operator ++ ( int ) {
        return * this;
    }

protected :
    _Container * container;
    _Wrapped_iter iter;
};
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Container >
[ [ nodiscard ] ] inline insert_iterator < _Container > inserter ( _Container & _Cont, typename _Container :: iterator _Where ) {
    return insert_iterator < _Container > ( _Cont, _Where );
}
#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Ty, class _Elem = char, class _Traits = char_traits < _Elem >, class _Diff = ptrdiff_t >
class istream_iterator {
public :
    using iterator_category = input_iterator_tag;
    using value_type = _Ty;
    using difference_type = _Diff;
    using pointer = const _Ty *;
    using reference = const _Ty &;
    using char_type = _Elem;
    using traits_type = _Traits;
    using istream_type = basic_istream < _Elem, _Traits >;

    static_assert ( conjunction_v < is_default_constructible < _Ty >, is_copy_constructible < _Ty >, is_copy_assignable < _Ty >>,
        "istream_iterator<T> requires T to be default constructible, copy constructible, and copy assignable. (N4835 [istream.iterator]/2" ")"
                                      );

    constexpr istream_iterator ( ) noexcept ( is_nothrow_default_constructible_v < _Ty > ) { }






    istream_iterator ( istream_type & _Istr ) : _Myistr ( :: std :: addressof ( _Istr ) ) {
        _Getval ( );
    }

    [ [ nodiscard ] ] const _Ty & operator * ( ) const noexcept {
        ;
        return _Myval;
    }

    [ [ nodiscard ] ] const _Ty * operator -> ( ) const noexcept {
        ;
        return :: std :: addressof ( _Myval );
    }

    istream_iterator & operator ++ ( ) {
        _Getval ( );
        return * this;
    }

    istream_iterator operator ++ ( int ) {
        istream_iterator _Tmp = * this;
        _Getval ( );
        return _Tmp;
    }

    [ [ nodiscard ] ] bool _Equal ( const istream_iterator & _Right ) const noexcept {
        return _Myistr == _Right . _Myistr;
    }







private :
    void _Getval ( ) {
        ;
        if ( ! ( * _Myistr >> _Myval ) ) {
            _Myistr = nullptr;
        }
    }

    istream_type * _Myistr { nullptr };
    _Ty _Myval { };
};
#line 291
template < class _Ty, class _Elem, class _Traits, class _Diff >
[ [ nodiscard ] ] bool operator == ( const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
    const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right ) noexcept {
    return _Left . _Equal ( _Right );
}
#line 298
template < class _Ty, class _Elem, class _Traits, class _Diff >
[ [ nodiscard ] ] bool operator != ( const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
    const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right ) noexcept {
    return ! ( _Left == _Right );
}
#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Ty, class _Elem = char, class _Traits = char_traits < _Elem > >
class ostream_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;



    using difference_type = void;

    using pointer = void;
    using reference = void;
    using char_type = _Elem;
    using traits_type = _Traits;
    using ostream_type = basic_ostream < _Elem, _Traits >;

    ostream_iterator ( ostream_type & _Ostr, const _Elem * const _Delim = nullptr ) noexcept
        : _Mydelim ( _Delim ), _Myostr ( :: std :: addressof ( _Ostr ) ) { }

    ostream_iterator & operator = ( const _Ty & _Val ) {
        * _Myostr << _Val;
        if ( _Mydelim ) {
            * _Myostr << _Mydelim;
        }

        return * this;
    }

    [ [ nodiscard ] ] ostream_iterator & operator * ( ) noexcept {
        return * this;
    }

    ostream_iterator & operator ++ ( ) noexcept {
        return * this;
    }

    ostream_iterator & operator ++ ( int ) noexcept {
        return * this;
    }

private :
    const _Elem * _Mydelim;
    ostream_type * _Myostr;
};
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Elem, class _Traits >
class istreambuf_iterator {
public :
    using iterator_category = input_iterator_tag;
    using value_type = _Elem;
    using difference_type = typename _Traits :: off_type;
    using pointer = const _Elem *;
    using reference = _Elem;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename traits_type :: int_type;
    using streambuf_type = basic_streambuf < _Elem, _Traits >;
    using istream_type = basic_istream < _Elem, _Traits >;

    constexpr istreambuf_iterator ( ) noexcept : _Strbuf ( nullptr ), _Got ( true ), _Val ( ) { }




    istreambuf_iterator ( istream_type & _Istr ) noexcept : _Strbuf ( _Istr . rdbuf ( ) ), _Got ( ! _Strbuf ), _Val ( ) { }

    istreambuf_iterator ( streambuf_type * _Sb ) noexcept : _Strbuf ( _Sb ), _Got ( ! _Sb ), _Val ( ) { }

private :
    class _Istreambuf_proxy {
    public :
        [ [ nodiscard ] ] _Elem operator * ( ) const noexcept ( is_nothrow_copy_constructible_v < _Elem > ) {
            return _Keep;
        }

    private :
        friend istreambuf_iterator;
        _Istreambuf_proxy ( streambuf_type * _Strbuf_, _Elem _Keep_ ) noexcept (
            is_nothrow_copy_constructible_v < _Elem > )
            : _Strbuf ( _Strbuf_ ), _Keep ( _Keep_ ) { }

        streambuf_type * _Strbuf;
        _Elem _Keep;
    };

public :
    istreambuf_iterator ( const _Istreambuf_proxy & _Px ) noexcept : _Strbuf ( _Px . _Strbuf ), _Got ( ! _Strbuf ), _Val ( ) { }

    [ [ nodiscard ] ] _Elem operator * ( ) const {
        if ( ! _Got ) {
            _Peek ( );
        }





        return _Val;
    }

    istreambuf_iterator & operator ++ ( ) {




        _Inc ( );
        return * this;
    }

    _Istreambuf_proxy operator ++ ( int ) {
        if ( ! _Got ) {
            _Peek ( );
        }

        _Istreambuf_proxy _Tmp { _Strbuf, _Val };
        ++ * this;
        return _Tmp;
    }

    [ [ nodiscard ] ] bool equal ( const istreambuf_iterator & _Right ) const {
        if ( ! _Got ) {
            _Peek ( );
        }

        if ( ! _Right . _Got ) {
            _Right . _Peek ( );
        }

        return ( ! _Strbuf && ! _Right . _Strbuf ) || ( _Strbuf && _Right . _Strbuf );
    }











private :
    void _Inc ( ) {
        if ( ! _Strbuf || traits_type :: eq_int_type ( traits_type :: eof ( ), _Strbuf -> sbumpc ( ) ) ) {
            _Strbuf = nullptr;
            _Got = true;
        } else {
            _Got = false;
        }
    }

    _Elem _Peek ( ) const {
        int_type _Meta;
        if ( ! _Strbuf || traits_type :: eq_int_type ( traits_type :: eof ( ), _Meta = _Strbuf -> sgetc ( ) ) ) {
            _Strbuf = nullptr;
        } else {
            _Val = traits_type :: to_char_type ( _Meta );
        }

        _Got = true;
        return _Val;
    }

    mutable streambuf_type * _Strbuf;
    mutable bool _Got;
    mutable _Elem _Val;
};
#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Elem, class _Traits >
[ [ nodiscard ] ] bool operator == (
    const istreambuf_iterator < _Elem, _Traits > & _Left, const istreambuf_iterator < _Elem, _Traits > & _Right ) {
    return _Left . equal ( _Right );
}
#line 480
template < class _Elem, class _Traits >
[ [ nodiscard ] ] bool operator != (
    const istreambuf_iterator < _Elem, _Traits > & _Left, const istreambuf_iterator < _Elem, _Traits > & _Right ) {
    return ! ( _Left == _Right );
}
#line 487 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Elem, class _Traits >
class ostreambuf_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;



    using difference_type = void;

    using pointer = void;
    using reference = void;
    using char_type = _Elem;
    using traits_type = _Traits;
    using streambuf_type = basic_streambuf < _Elem, _Traits >;
    using ostream_type = basic_ostream < _Elem, _Traits >;

    ostreambuf_iterator ( streambuf_type * _Sb ) noexcept : _Strbuf ( _Sb ) { }

    ostreambuf_iterator ( ostream_type & _Ostr ) noexcept : _Strbuf ( _Ostr . rdbuf ( ) ) { }

    ostreambuf_iterator & operator = ( _Elem _Right ) {
        if ( ! _Strbuf || traits_type :: eq_int_type ( _Traits :: eof ( ), _Strbuf -> sputc ( _Right ) ) ) {
            _Failed = true;
        }

        return * this;
    }

    [ [ nodiscard ] ] ostreambuf_iterator & operator * ( ) noexcept {
        return * this;
    }

    ostreambuf_iterator & operator ++ ( ) noexcept {
        return * this;
    }

    ostreambuf_iterator & operator ++ ( int ) noexcept {
        return * this;
    }

    [ [ nodiscard ] ] bool failed ( ) const noexcept {
        return _Failed;
    }

private :
    bool _Failed = false;
    streambuf_type * _Strbuf;
};
#line 1397 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
}
#line 1399
namespace stdext { 
#line 1400
using std::iterator_traits;
#line 1401
using std::size_t;
#line 1403
template < class _Ptr >
class checked_array_iterator {
    static_assert ( :: std :: is_pointer_v < _Ptr >, "checked_array_iterator requires pointers" );

public :
    using iterator_category = typename iterator_traits < _Ptr > :: iterator_category;
    using value_type = typename iterator_traits < _Ptr > :: value_type;
    using difference_type = typename iterator_traits < _Ptr > :: difference_type;
    using pointer = typename iterator_traits < _Ptr > :: pointer;
    using reference = typename iterator_traits < _Ptr > :: reference;

    constexpr checked_array_iterator ( ) noexcept : _Myarray ( nullptr ), _Mysize ( 0 ), _Myindex ( 0 ) { }

    constexpr checked_array_iterator ( const _Ptr _Array, const size_t _Size, const size_t _Index = 0 ) noexcept
        : _Myarray ( _Array ), _Mysize ( _Size ), _Myindex ( _Index ) {
        do { if ( _Index <= _Size ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
    }

    [ [ nodiscard ] ] constexpr _Ptr base ( ) const noexcept {
        return _Myarray + _Myindex;
    }

    [ [ nodiscard ] ] constexpr reference operator * ( ) const noexcept {
        return * operator -> ( );
    }

    [ [ nodiscard ] ] constexpr pointer operator -> ( ) const noexcept {
        do { if ( _Myarray ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        do { if ( _Myindex < _Mysize ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        return _Myarray + _Myindex;
    }

    constexpr checked_array_iterator & operator ++ ( ) noexcept {
        do { if ( _Myarray ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        do { if ( _Myindex < _Mysize ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        ++ _Myindex;
        return * this;
    }

    constexpr checked_array_iterator operator ++ ( int ) noexcept {
        checked_array_iterator _Tmp = * this;
        ++ * this;
        return _Tmp;
    }

    constexpr checked_array_iterator & operator -- ( ) noexcept {
        do { if ( _Myarray ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        do { if ( _Myindex != 0 ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        -- _Myindex;
        return * this;
    }

    constexpr checked_array_iterator operator -- ( int ) noexcept {
        checked_array_iterator _Tmp = * this;
        -- * this;
        return _Tmp;
    }

    constexpr checked_array_iterator & operator += ( const difference_type _Off ) noexcept {
        if ( _Off != 0 ) {
            do { if ( _Myarray ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        }

        if ( _Off < 0 ) {
            do { if ( _Myindex >= size_t { 0 } - static_cast < size_t > ( _Off ) ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        }

        if ( _Off > 0 ) {
            do { if ( _Mysize - _Myindex >= static_cast < size_t > ( _Off ) ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        }

        _Myindex += _Off;
        return * this;
    }

    [ [ nodiscard ] ] constexpr checked_array_iterator operator + ( const difference_type _Off ) const noexcept {
        checked_array_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }




    friend constexpr checked_array_iterator operator + (
        const difference_type _Off, const checked_array_iterator < _Ptr > & _Next ) noexcept {
        return _Next + _Off;
    }

    constexpr checked_array_iterator & operator -= ( const difference_type _Off ) noexcept {
        if ( _Off != 0 ) {
            do { if ( _Myarray ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        }

        if ( _Off > 0 ) {
            do { if ( _Myindex >= static_cast < size_t > ( _Off ) ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        }

        if ( _Off < 0 ) {
            do { if ( _Mysize - _Myindex >= size_t { 0 } - static_cast < size_t > ( _Off ) ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        }

        _Myindex -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] constexpr checked_array_iterator operator - ( const difference_type _Off ) const noexcept {
        checked_array_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] constexpr difference_type operator - ( const checked_array_iterator & _Right ) const noexcept {
        do { if ( _Myarray == _Right . _Myarray && _Mysize == _Right . _Mysize ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        return static_cast < difference_type > ( _Myindex - _Right . _Myindex );
    }

    [ [ nodiscard ] ] constexpr reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] constexpr bool operator == ( const checked_array_iterator & _Right ) const noexcept {
        do { if ( _Myarray == _Right . _Myarray && _Mysize == _Right . _Mysize ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        return _Myindex == _Right . _Myindex;
    }








    [ [ nodiscard ] ] constexpr bool operator != ( const checked_array_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] constexpr bool operator < ( const checked_array_iterator & _Right ) const noexcept {
        do { if ( _Myarray == _Right . _Myarray && _Mysize == _Right . _Mysize ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        return _Myindex < _Right . _Myindex;
    }

    [ [ nodiscard ] ] constexpr bool operator > ( const checked_array_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] constexpr bool operator <= ( const checked_array_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] constexpr bool operator >= ( const checked_array_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }


    friend constexpr void _Verify_range (
        const checked_array_iterator & _First, const checked_array_iterator & _Last ) noexcept {
        do { if ( _First . _Myarray == _Last . _Myarray && _First . _Mysize == _Last . _Mysize ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        do { if ( _First . _Myindex <= _Last . _Myindex ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
    }

    constexpr void _Verify_offset ( const difference_type _Off ) const noexcept {
        if ( _Off < 0 ) {
            do { if ( _Myindex >= size_t { 0 } - static_cast < size_t > ( _Off ) ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        }

        if ( _Off > 0 ) {
            do { if ( _Mysize - _Myindex >= static_cast < size_t > ( _Off ) ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );

        }
    }

    using _Prevent_inheriting_unwrap = checked_array_iterator;

    [ [ nodiscard ] ] constexpr _Ptr _Unwrapped ( ) const noexcept {
        return _Myarray + _Myindex;
    }

    constexpr void _Seek_to ( _Ptr _It ) noexcept {
        _Myindex = static_cast < size_t > ( _It - _Myarray );
    }

private :
    _Ptr _Myarray;
    size_t _Mysize;
    size_t _Myindex;
};
#line 1599 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Ptr >
[ [ nodiscard ] ] constexpr checked_array_iterator < _Ptr > make_checked_array_iterator (
    const _Ptr _Array, const size_t _Size, const size_t _Index = 0 ) {
    return checked_array_iterator < _Ptr > ( _Array, _Size, _Index );
}
#line 1605
template < class _Ptr >
class unchecked_array_iterator {
    static_assert ( :: std :: is_pointer_v < _Ptr >, "unchecked_array_iterator requires pointers" );

public :
    using iterator_category = typename iterator_traits < _Ptr > :: iterator_category;
    using value_type = typename iterator_traits < _Ptr > :: value_type;
    using difference_type = typename iterator_traits < _Ptr > :: difference_type;
    using pointer = typename iterator_traits < _Ptr > :: pointer;
    using reference = typename iterator_traits < _Ptr > :: reference;

    constexpr unchecked_array_iterator ( ) noexcept : _Myptr ( nullptr ) { }

    constexpr explicit unchecked_array_iterator ( const _Ptr _Src ) noexcept : _Myptr ( _Src ) { }

    [ [ nodiscard ] ] constexpr _Ptr base ( ) const noexcept {
        return _Myptr;
    }

    [ [ nodiscard ] ] constexpr reference operator * ( ) const noexcept {
        return * _Myptr;
    }

    [ [ nodiscard ] ] constexpr pointer operator -> ( ) const noexcept {
        return _Myptr;
    }

    constexpr unchecked_array_iterator & operator ++ ( ) noexcept {
        ++ _Myptr;
        return * this;
    }

    constexpr unchecked_array_iterator operator ++ ( int ) noexcept {
        unchecked_array_iterator _Tmp = * this;
        ++ _Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator & operator -- ( ) noexcept {
        -- _Myptr;
        return * this;
    }

    constexpr unchecked_array_iterator operator -- ( int ) noexcept {
        unchecked_array_iterator _Tmp = * this;
        -- _Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator & operator += ( const difference_type _Off ) noexcept {
        _Myptr += _Off;
        return * this;
    }

    [ [ nodiscard ] ] constexpr unchecked_array_iterator operator + ( const difference_type _Off ) const noexcept {
        unchecked_array_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }




    friend constexpr unchecked_array_iterator operator + (
        const difference_type _Off, const unchecked_array_iterator & _Next ) noexcept {
        return _Next + _Off;
    }

    constexpr unchecked_array_iterator & operator -= ( const difference_type _Off ) noexcept {
        return * this += - _Off;
    }

    [ [ nodiscard ] ] constexpr unchecked_array_iterator operator - ( const difference_type _Off ) const noexcept {
        unchecked_array_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] constexpr difference_type operator - ( const unchecked_array_iterator & _Right ) const noexcept {
        return _Myptr - _Right . _Myptr;
    }

    [ [ nodiscard ] ] constexpr reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] constexpr bool operator == ( const unchecked_array_iterator & _Right ) const noexcept {
        return _Myptr == _Right . _Myptr;
    }






    [ [ nodiscard ] ] constexpr bool operator != ( const unchecked_array_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] constexpr bool operator < ( const unchecked_array_iterator & _Right ) const noexcept {
        return _Myptr < _Right . _Myptr;
    }

    [ [ nodiscard ] ] constexpr bool operator > ( const unchecked_array_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] constexpr bool operator <= ( const unchecked_array_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] constexpr bool operator >= ( const unchecked_array_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }









    using _Prevent_inheriting_unwrap = unchecked_array_iterator;

    static constexpr bool _Unwrap_when_unverified = true;

    [ [ nodiscard ] ] constexpr _Ptr _Unwrapped ( ) const noexcept {
        return _Myptr;
    }

    constexpr void _Seek_to ( _Ptr _It ) noexcept {
        _Myptr = _It;
    }

private :
    _Ptr _Myptr;
};
#line 1744 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
template < class _Ptr >
[ [ nodiscard ] ] unchecked_array_iterator < _Ptr > make_unchecked_array_iterator ( const _Ptr _It ) noexcept {
    return unchecked_array_iterator < _Ptr > ( _It );
}
#line 1748
}
#line 1752
#pragma warning(pop)
#pragma pack ( pop )
#line 1756 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\share.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_system_error_abi.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_system_error_abi.hpp"
extern "C" {
#line 27
[[nodiscard]] size_t __stdcall __std_get_string_size_without_trailing_whitespace(const char * _Str, size_t _Size) noexcept; 
#line 30
[[nodiscard]] size_t __stdcall __std_system_error_allocate_message(unsigned long _Message_id, char ** _Ptr_str) noexcept; 
#line 32
void __stdcall __std_system_error_deallocate_message(char * _Str) noexcept; 
#line 33
}
#line 37
#pragma warning(pop)
#pragma pack ( pop )
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_system_error_abi.hpp"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cerrno"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#line 24
bool __cdecl uncaught_exception() noexcept; 
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
int __cdecl uncaught_exceptions() noexcept; 
#line 28
}
#line 32
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
typedef 
#line 42
struct _heapinfo { 
#line 44
int *_pentry; 
#line 45
size_t _size; 
#line 46
int _useflag; 
#line 47
} _HEAPINFO; 
#line 55
void *__cdecl _alloca(size_t _Size); 
#line 61
intptr_t __cdecl _get_heap_handle(); 
#line 64
int __cdecl _heapmin(); 
#line 67
int __cdecl _heapwalk(_HEAPINFO * _EntryInfo); 
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
int __cdecl _heapchk(); 
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
int __cdecl _resetstkoflw(); 
#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
static_assert((sizeof(unsigned) <= (16)), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE");
#line 89
#pragma warning(push)
#pragma warning(disable: 6540)
#line 93
__inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
#line 94
{ 
#line 95
if (_Ptr) 
#line 96
{ 
#line 97
(*((unsigned *)_Ptr)) = _Marker; 
#line 98
_Ptr = (((char *)_Ptr) + 16); 
#line 99
}  
#line 100
return _Ptr; 
#line 101
} 
#line 103
__inline size_t _MallocaComputeSize(size_t _Size) 
#line 104
{ 
#line 105
size_t _MarkedSize = _Size + (16); 
#line 106
return (_MarkedSize > _Size) ? _MarkedSize : (0); 
#line 107
} 
#line 109
#pragma warning(pop)
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
#pragma warning(push)
#pragma warning(disable: 6014)
__inline void __cdecl _freea(void *_Memory) 
#line 151
{ 
#line 152
unsigned _Marker; 
#line 153
if (_Memory) 
#line 154
{ 
#line 155
_Memory = (((char *)_Memory) - 16); 
#line 156
_Marker = (*((unsigned *)_Memory)); 
#line 157
if (_Marker == (56797)) 
#line 158
{ 
#line 159
free(_Memory); 
#line 160
} else { 
#line 162
if (_Marker != (52428)) 
#line 163
{ 
#line 164
(void)0; 
#line 165
}  }  
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
}  
#line 168
} 
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
}
#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
#pragma warning(pop)
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
__pragma( pack ( pop )) 
#line 183
#pragma warning(pop)
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
#pragma external_header(pop)
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
#pragma external_header(push)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_exception.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 22
typedef void (__cdecl *terminate_handler)(void); 
#line 23
typedef void (__cdecl *terminate_function)(void); 
#line 32
__declspec(noreturn) void __cdecl abort(); 
#line 33
__declspec(noreturn) void __cdecl terminate() throw(); 
#line 37
terminate_handler __cdecl set_terminate(terminate_handler _NewTerminateHandler) throw(); 
#line 41
terminate_handler __cdecl _get_terminate(); 
#line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"
}__pragma( pack ( pop )) 
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"
#pragma warning(pop)
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 23
typedef void (__cdecl *unexpected_handler)(void); 
#line 24
typedef void (__cdecl *unexpected_function)(void); 
#line 31
struct _EXCEPTION_POINTERS; 
#line 35
__declspec(noreturn) void __cdecl unexpected() noexcept(false); 
#line 39
unexpected_handler __cdecl set_unexpected(unexpected_handler _NewUnexpectedHandler) noexcept; 
#line 43
unexpected_handler __cdecl _get_unexpected() noexcept; 
#line 45
typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 
#line 47
_se_translator_function __cdecl _set_se_translator(_se_translator_function _NewSETranslator); 
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"
class type_info; 
#line 55
int __cdecl _is_exception_typeof(const type_info & _Type, _EXCEPTION_POINTERS * _ExceptionPtr); 
#line 60
bool __cdecl __uncaught_exception(); 
#line 61
int __cdecl __uncaught_exceptions(); 
#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"
}__pragma( pack ( pop )) 
#line 67
#pragma warning(pop)
#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_exception.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 21
#pragma pack ( push, 8 )
#line 23
__pragma( pack ( push, 8 )) extern "C" {
#line 25
struct __std_exception_data { 
#line 27
const char *_What; 
#line 28
bool _DoFree; 
#line 29
}; 
#line 31
void __cdecl __std_exception_copy(const __std_exception_data * _From, __std_exception_data * _To); 
#line 36
void __cdecl __std_exception_destroy(__std_exception_data * _Data); 
#line 40
}__pragma( pack ( pop )) 
#line 44
namespace std { 
#line 46
#pragma warning(push)
#pragma warning(disable: 4577)
class exception { 
#line 52
public: exception() noexcept : _Data() 
#line 54
{ 
#line 55
} 
#line 57
explicit exception(const char *const _Message) noexcept : _Data() 
#line 59
{ 
#line 60
__std_exception_data _InitData = {_Message, true}; 
#line 61
__std_exception_copy(&_InitData, &(_Data)); 
#line 62
} 
#line 64
exception(const char *const _Message, int) noexcept : _Data() 
#line 66
{ 
#line 67
((_Data)._What) = _Message; 
#line 68
} 
#line 70
exception(const exception &_Other) noexcept : _Data() 
#line 72
{ 
#line 73
__std_exception_copy(&(_Other._Data), &(_Data)); 
#line 74
} 
#line 76
exception &operator=(const exception &_Other) noexcept 
#line 77
{ 
#line 78
if (this == (&_Other)) 
#line 79
{ 
#line 80
return *this; 
#line 81
}  
#line 83
__std_exception_destroy(&(_Data)); 
#line 84
__std_exception_copy(&(_Other._Data), &(_Data)); 
#line 85
return *this; 
#line 86
} 
#line 88
virtual ~exception() noexcept 
#line 89
{ 
#line 90
__std_exception_destroy(&(_Data)); 
#line 91
} 
#line 93
[[nodiscard]] virtual const char *what() const 
#line 94
{ 
#line 95
return ((_Data)._What) ? (_Data)._What : ("Unknown exception"); 
#line 96
} 
#line 100
private: __std_exception_data _Data; 
#line 101
}; 
#line 103
class bad_exception : public exception { 
#line 108
public: bad_exception() noexcept : exception("bad exception", 1) 
#line 110
{ 
#line 111
} 
#line 112
}; 
#line 114
class bad_alloc : public exception { 
#line 119
public: bad_alloc() noexcept : exception("bad allocation", 1) 
#line 121
{ 
#line 122
} 
#line 126
friend class bad_array_new_length; 
#line 128
private: bad_alloc(const char *const _Message) noexcept : exception(_Message, 1) 
#line 130
{ 
#line 131
} 
#line 132
}; 
#line 134
class bad_array_new_length : public bad_alloc { 
#line 139
public: bad_array_new_length() noexcept : bad_alloc("bad array new length") 
#line 141
{ 
#line 142
} 
#line 143
}; 
#line 145
#pragma warning(pop)
#line 147
}
#line 149
#pragma pack ( pop )
#line 151
#pragma warning(pop)
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_exception.h"
#pragma external_header(pop)
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
namespace std { 
#line 37
using ::terminate;
#line 40
using ::set_terminate;
#line 41
using ::terminate_handler;
#line 43
[[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept { 
#line 44
return _get_terminate(); 
#line 45
} 
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
using ::unexpected;
#line 52
using ::set_unexpected;
#line 53
using ::unexpected_handler;
#line 55
[[nodiscard]] inline unexpected_handler __cdecl get_unexpected() noexcept { 
#line 56
return _get_unexpected(); 
#line 57
} 
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
}
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
void __cdecl __ExceptionPtrCreate(void *) noexcept; 
#line 197
void __cdecl __ExceptionPtrDestroy(void *) noexcept; 
#line 198
void __cdecl __ExceptionPtrCopy(void *, const void *) noexcept; 
#line 199
void __cdecl __ExceptionPtrAssign(void *, const void *) noexcept; 
#line 200
bool __cdecl __ExceptionPtrCompare(const void *, const void *) noexcept; 
#line 201
bool __cdecl __ExceptionPtrToBool(const void *) noexcept; 
#line 202
void __cdecl __ExceptionPtrSwap(void *, void *) noexcept; 
#line 203
void __cdecl __ExceptionPtrCurrentException(void *) noexcept; 
#line 204
[[noreturn]] void __cdecl __ExceptionPtrRethrow(const void *); 
#line 205
void __cdecl __ExceptionPtrCopyException(void *, const void *, const void *) noexcept; 
#line 208
namespace std { 
#line 210
class exception_ptr { 
#line 212
public: exception_ptr() noexcept { 
#line 213
__ExceptionPtrCreate(this); 
#line 214
} 
#line 216
exception_ptr(nullptr_t) noexcept { 
#line 217
__ExceptionPtrCreate(this); 
#line 218
} 
#line 220
~exception_ptr() noexcept { 
#line 221
__ExceptionPtrDestroy(this); 
#line 222
} 
#line 224
exception_ptr(const exception_ptr &_Rhs) noexcept { 
#line 225
__ExceptionPtrCopy(this, &_Rhs); 
#line 226
} 
#line 228
exception_ptr &operator=(const exception_ptr &_Rhs) noexcept { 
#line 229
__ExceptionPtrAssign(this, &_Rhs); 
#line 230
return *this; 
#line 231
} 
#line 233
exception_ptr &operator=(nullptr_t) noexcept { 
#line 234
exception_ptr _Ptr; 
#line 235
__ExceptionPtrAssign(this, &_Ptr); 
#line 236
return *this; 
#line 237
} 
#line 239
explicit operator bool() const noexcept { 
#line 240
return __ExceptionPtrToBool(this); 
#line 241
} 
#line 243
static exception_ptr _Current_exception() noexcept { 
#line 244
exception_ptr _Retval; 
#line 245
__ExceptionPtrCurrentException(&_Retval); 
#line 246
return _Retval; 
#line 247
} 
#line 249
static exception_ptr _Copy_exception(void *_Except, const void *_Ptr) { 
#line 250
exception_ptr _Retval; 
#line 251
if (!_Ptr) { 
#line 253
return _Retval; 
#line 254
}  
#line 255
__ExceptionPtrCopyException(&_Retval, _Except, _Ptr); 
#line 256
return _Retval; 
#line 257
} 
#line 259
friend inline void swap(exception_ptr &_Lhs, exception_ptr &_Rhs) noexcept { 
#line 260
__ExceptionPtrSwap(&_Lhs, &_Rhs); 
#line 261
} 
#line 263
friend inline bool operator==(const exception_ptr &_Lhs, const exception_ptr &_Rhs) noexcept { 
#line 264
return __ExceptionPtrCompare(&_Lhs, &_Rhs); 
#line 265
} 
#line 267
friend inline bool operator==(std::nullptr_t, const exception_ptr &_Rhs) noexcept { 
#line 268
return !_Rhs; 
#line 269
} 
#line 271
friend inline bool operator==(const exception_ptr &_Lhs, std::nullptr_t) noexcept { 
#line 272
return !_Lhs; 
#line 273
} 
#line 275
friend inline bool operator!=(const exception_ptr &_Lhs, const exception_ptr &_Rhs) noexcept { 
#line 276
return !(_Lhs == _Rhs); 
#line 277
} 
#line 279
friend inline bool operator!=(std::nullptr_t _Lhs, const exception_ptr &_Rhs) noexcept { 
#line 280
return !(_Lhs == _Rhs); 
#line 281
} 
#line 283
friend inline bool operator!=(const exception_ptr &_Lhs, std::nullptr_t _Rhs) noexcept { 
#line 284
return !(_Lhs == _Rhs); 
#line 285
} 
#line 292
private: void *_Data1; 
#line 293
void *_Data2; 
#line 297
}; 
#line 299
[[nodiscard]] inline exception_ptr current_exception() noexcept { 
#line 300
return exception_ptr::_Current_exception(); 
#line 301
} 
#line 303
[[noreturn]] inline void rethrow_exception(exception_ptr _Ptr) { 
#line 304
__ExceptionPtrRethrow(&_Ptr); 
#line 305
} 
#line 307
template< class _Ex> void *__GetExceptionInfo(_Ex); 
#line 310
template < class _Ex >
[ [ nodiscard ] ] exception_ptr make_exception_ptr ( _Ex _Except ) noexcept {
    return exception_ptr :: _Copy_exception ( :: std :: addressof ( _Except ), __GetExceptionInfo ( _Except ) );
}
#line 315
[[noreturn]] inline void _Throw_bad_array_new_length() { 
#line 316
throw bad_array_new_length{}; 
#line 317
} 
#line 319
class nested_exception { 
#line 321
public: nested_exception() noexcept : _Exc(::std::current_exception()) { } 
#line 323
nested_exception(const nested_exception &) noexcept = default;
#line 324
nested_exception &operator=(const nested_exception &) noexcept = default;
#line 325
virtual ~nested_exception() noexcept { } 
#line 327
[[noreturn]] void rethrow_nested() const { 
#line 328
if ((_Exc)) { 
#line 329
::std::rethrow_exception(_Exc); 
#line 330
} else { 
#line 331
::std::terminate(); 
#line 332
}  
#line 333
} 
#line 335
[[nodiscard]] exception_ptr nested_ptr() const noexcept { 
#line 336
return _Exc; 
#line 337
} 
#line 340
private: exception_ptr _Exc; 
#line 341
}; 
#line 343
template < class _Ty, class _Uty >
struct _With_nested : _Uty, nested_exception {
    explicit _With_nested ( _Ty && _Arg )
        : _Uty ( :: std :: forward < _Ty > ( _Arg ) ), nested_exception ( ) { }
};
#line 349
template < class _Ty >
[ [ noreturn ] ] void throw_with_nested ( _Ty && _Arg ) {
    using _Uty = decay_t < _Ty >;

    if constexpr ( is_class_v < _Uty > && ! is_base_of_v < nested_exception, _Uty > && ! is_final_v < _Uty > ) {

        using _Glued = _With_nested < _Ty, _Uty >;
        throw _Glued ( :: std :: forward < _Ty > ( _Arg ) );
    } else {

        throw :: std :: forward < _Ty > ( _Arg );
    }
}
#line 364
template < class _Ty >
void _Rethrow_if_nested ( const _Ty * _Ptr, true_type ) {
    const auto _Nested = dynamic_cast < const nested_exception * > ( _Ptr );

    if ( _Nested ) {
        _Nested -> rethrow_nested ( );
    }
}
#line 373
template < class _Ty >
void _Rethrow_if_nested ( const _Ty *, false_type ) { }
#line 376
template < class _Ty >
void rethrow_if_nested ( const _Ty & _Arg ) {
    bool_constant <
        is_polymorphic_v < _Ty > && ( ! is_base_of_v < nested_exception, _Ty > || is_convertible_v < _Ty *, nested_exception * > ) >
        _Tag;

    _Rethrow_if_nested ( :: std :: addressof ( _Arg ), _Tag );
}
#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
}
#line 393
#pragma warning(pop)
#pragma pack ( pop )
#line 398 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cfloat"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
unsigned __cdecl _clearfp(); 
#line 233
#pragma warning(push)
#pragma warning(disable: 4141)
#line 237
unsigned __cdecl _controlfp(unsigned _NewValue, unsigned _Mask); 
#line 242
#pragma warning(pop)
#line 245
void __cdecl _set_controlfp(unsigned _NewValue, unsigned _Mask); 
#line 251
errno_t __cdecl _controlfp_s(unsigned * _CurrentState, unsigned _NewValue, unsigned _Mask); 
#line 258
unsigned __cdecl _statusfp(); 
#line 261
void __cdecl _fpreset(); 
#line 277
unsigned __cdecl _control87(unsigned _NewValue, unsigned _Mask); 
#line 294
int *__cdecl __fpecode(); 
#line 299
int __cdecl __fpe_flt_rounds(); 
#line 312
double __cdecl _copysign(double _Number, double _Sign); 
#line 313
double __cdecl _chgsign(double _X); 
#line 314
double __cdecl _scalb(double _X, long _Y); 
#line 315
double __cdecl _logb(double _X); 
#line 316
double __cdecl _nextafter(double _X, double _Y); 
#line 317
int __cdecl _finite(double _X); 
#line 318
int __cdecl _isnan(double _X); 
#line 319
int __cdecl _fpclass(double _X); 
#line 322
float __cdecl _scalbf(float _X, long _Y); 
#line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
void __cdecl fpreset(); 
#line 406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
}__pragma( pack ( pop )) 
#line 408
#pragma warning(pop)
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cfloat"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
#pragma external_header(push)
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.h"
#pragma external_header(push)
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 24
extern "C" {
#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask); 
#line 124
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask); 
#line 126
unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask); 
#line 127
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask); 
#line 129
unsigned char _bittest(const long *, long); 
#line 132
long _InterlockedAnd(volatile long * _Value, long _Mask); 
#line 133
short _InterlockedAnd16(volatile short * _Value, short _Mask); 
#line 137
__int64 _InterlockedAnd64(volatile __int64 * _Value, __int64 _Mask); 
#line 138
__int64 _interlockedand64(volatile __int64 * _Value, __int64 _Mask); 
#line 142
char _InterlockedAnd8(volatile char * _Value, char _Mask); 
#line 149
long _InterlockedCompareExchange(volatile long * _Destination, long _Exchange, long _Comparand); 
#line 151
short _InterlockedCompareExchange16(volatile short * _Destination, short _Exchange, short _Comparand); 
#line 155
__int64 _InterlockedCompareExchange64(volatile __int64 * _Destination, __int64 _Exchange, __int64 _Comparand); 
#line 159
char _InterlockedCompareExchange8(volatile char * _Destination, char _Exchange, char _Comparand); 
#line 166
unsigned char _InterlockedCompareExchange128(volatile __int64 * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult); 
#line 170
long _InterlockedDecrement(volatile long * _Addend); 
#line 172
short _InterlockedDecrement16(volatile short * _Addend); 
#line 173
__int64 _InterlockedDecrement64(volatile __int64 * _Addend); 
#line 174
__int64 _interlockeddecrement64(volatile __int64 * _Addend); 
#line 175
long _InterlockedExchange(volatile long * _Target, long _Value); 
#line 177
short _InterlockedExchange16(volatile short * _Target, short _Value); 
#line 181
__int64 _InterlockedExchange64(volatile __int64 * _Target, __int64 _Value); 
#line 182
__int64 _interlockedexchange64(volatile __int64 * _Target, __int64 _Value); 
#line 186
char _InterlockedExchange8(volatile char * _Target, char _Value); 
#line 190
long _InterlockedExchangeAdd(volatile long * _Addend, long _Value); 
#line 191
short _InterlockedExchangeAdd16(volatile short * _Addend, short _Value); 
#line 195
__int64 _InterlockedExchangeAdd64(volatile __int64 * _Addend, __int64 _Value); 
#line 196
__int64 _interlockedexchangeadd64(volatile __int64 * _Addend, __int64 _Value); 
#line 200
char _InterlockedExchangeAdd8(volatile char * _Addend, char _Value); 
#line 210
long _InterlockedIncrement(volatile long * _Addend); 
#line 212
short _InterlockedIncrement16(volatile short * _Addend); 
#line 213
__int64 _InterlockedIncrement64(volatile __int64 * _Addend); 
#line 214
__int64 _interlockedincrement64(volatile __int64 * _Addend); 
#line 216
long _InterlockedOr(volatile long * _Value, long _Mask); 
#line 217
short _InterlockedOr16(volatile short * _Value, short _Mask); 
#line 221
__int64 _InterlockedOr64(volatile __int64 * _Value, __int64 _Mask); 
#line 222
__int64 _interlockedor64(volatile __int64 * _Value, __int64 _Mask); 
#line 226
char _InterlockedOr8(volatile char * _Value, char _Mask); 
#line 233
long _InterlockedXor(volatile long * _Value, long _Mask); 
#line 234
short _InterlockedXor16(volatile short * _Value, short _Mask); 
#line 238
__int64 _InterlockedXor64(volatile __int64 * _Value, __int64 _Mask); 
#line 239
__int64 _interlockedxor64(volatile __int64 * _Value, __int64 _Mask); 
#line 243
char _InterlockedXor8(volatile char * _Value, char _Mask); 
#line 250
void _ReadWriteBarrier(); 
#line 251
short __iso_volatile_load16(const volatile short *); 
#line 252
int __iso_volatile_load32(const volatile int *); 
#line 253
__int64 __iso_volatile_load64(const volatile __int64 *); 
#line 254
char __iso_volatile_load8(const volatile char *); 
#line 255
void __iso_volatile_store16(volatile short *, short); 
#line 256
void __iso_volatile_store32(volatile int *, int); 
#line 257
void __iso_volatile_store64(volatile __int64 *, __int64); 
#line 258
void __iso_volatile_store8(volatile char *, char); 
#line 261
unsigned char _interlockedbittestandset(volatile long *, long); 
#line 265
void _mm_pause(); 
#line 266
unsigned __lzcnt(unsigned); 
#line 267
unsigned short __lzcnt16(unsigned short); 
#line 268
unsigned __int64 __lzcnt64(unsigned __int64); 
#line 269
unsigned __popcnt(unsigned); 
#line 270
unsigned short __popcnt16(unsigned short); 
#line 271
unsigned __int64 __popcnt64(unsigned __int64); 
#line 272
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift); 
#line 274
unsigned _tzcnt_u32(unsigned); 
#line 275
unsigned __int64 _tzcnt_u64(unsigned __int64); 
#line 277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct); 
#line 278
double __ceil(double); 
#line 279
float __ceilf(float); 
#line 280
double __floor(double); 
#line 281
float __floorf(float); 
#line 282
double __round(double); 
#line 283
float __roundf(float); 
#line 284
double __trunc(double); 
#line 285
float __truncf(float); 
#line 286
double __copysign(double, double); 
#line 287
float __copysignf(float, float); 
#line 288
unsigned __signbitvalue(double); 
#line 289
unsigned __signbitvaluef(float); 
#line 290
int _cvt_ftoi_sat(float a); 
#line 291
unsigned _cvt_ftoui_sat(float a); 
#line 292
__int64 _cvt_ftoll_sat(float a); 
#line 293
unsigned __int64 _cvt_ftoull_sat(float a); 
#line 294
int _cvt_ftoi_sent(float a); 
#line 295
unsigned _cvt_ftoui_sent(float a); 
#line 296
__int64 _cvt_ftoll_sent(float a); 
#line 297
unsigned __int64 _cvt_ftoull_sent(float a); 
#line 298
int _cvt_dtoi_sat(double a); 
#line 299
unsigned _cvt_dtoui_sat(double a); 
#line 300
__int64 _cvt_dtoll_sat(double a); 
#line 301
unsigned __int64 _cvt_dtoull_sat(double a); 
#line 302
int _cvt_dtoi_sent(double a); 
#line 303
unsigned _cvt_dtoui_sent(double a); 
#line 304
__int64 _cvt_dtoll_sent(double a); 
#line 305
unsigned __int64 _cvt_dtoull_sent(double a); 
#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
void *__cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept; 
#line 321 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
}
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
#pragma warning(pop)
#line 325 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
#pragma external_header(pop)
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\isa_availability.h"
enum ISA_AVAILABILITY { 
#line 17
__ISA_AVAILABLE_X86, 
#line 18
__ISA_AVAILABLE_SSE2, 
#line 19
__ISA_AVAILABLE_SSE42, 
#line 20
__ISA_AVAILABLE_AVX, 
#line 21
__ISA_AVAILABLE_ENFSTRG, 
#line 22
__ISA_AVAILABLE_AVX2, 
#line 23
__ISA_AVAILABLE_AVX512, 
#line 25
__ISA_AVAILABLE_ARMNT = 0, 
#line 26
__ISA_AVAILABLE_NEON, 
#line 27
__ISA_AVAILABLE_NEON_ARM64
#line 29
}; 
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\isa_availability.h"
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 25
namespace std { 
#line 26
enum float_denorm_style { 
#line 27
denorm_indeterminate = (-1), 
#line 28
denorm_absent = 0, 
#line 29
denorm_present
#line 30
}; 
#line 32
enum float_round_style { 
#line 33
round_indeterminate = (-1), 
#line 34
round_toward_zero = 0, 
#line 35
round_to_nearest, 
#line 36
round_toward_infinity, 
#line 37
round_toward_neg_infinity
#line 38
}; 
#line 40
struct _Num_base { 
#line 41
static constexpr float_denorm_style has_denorm = denorm_absent; 
#line 42
static constexpr bool has_denorm_loss = false; 
#line 43
static constexpr bool has_infinity = false; 
#line 44
static constexpr bool has_quiet_NaN = false; 
#line 45
static constexpr bool has_signaling_NaN = false; 
#line 46
static constexpr bool is_bounded = false; 
#line 47
static constexpr bool is_exact = false; 
#line 48
static constexpr bool is_iec559 = false; 
#line 49
static constexpr bool is_integer = false; 
#line 50
static constexpr bool is_modulo = false; 
#line 51
static constexpr bool is_signed = false; 
#line 52
static constexpr bool is_specialized = false; 
#line 53
static constexpr bool tinyness_before = false; 
#line 54
static constexpr bool traps = false; 
#line 55
static constexpr float_round_style round_style = round_toward_zero; 
#line 56
static constexpr int digits = 0; 
#line 57
static constexpr int digits10 = 0; 
#line 58
static constexpr int max_digits10 = 0; 
#line 59
static constexpr int max_exponent = 0; 
#line 60
static constexpr int max_exponent10 = 0; 
#line 61
static constexpr int min_exponent = 0; 
#line 62
static constexpr int min_exponent10 = 0; 
#line 63
static constexpr int radix = 0; 
#line 64
}; 
#line 66
template < class _Ty >
class numeric_limits : public _Num_base {
public :
    [ [ nodiscard ] ] static constexpr _Ty ( min ) ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty ( max ) ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty lowest ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty epsilon ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty round_error ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty denorm_min ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty infinity ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty quiet_NaN ( ) noexcept {
        return _Ty ( );
    }

    [ [ nodiscard ] ] static constexpr _Ty signaling_NaN ( ) noexcept {
        return _Ty ( );
    }
};
#line 106
template< class _Ty> 
#line 107
class numeric_limits< const _Ty>  : public std::numeric_limits< _Ty>  { }; 
#line 109
template< class _Ty> 
#line 110
class numeric_limits< volatile _Ty>  : public std::numeric_limits< _Ty>  { }; 
#line 112
template< class _Ty> 
#line 113
class numeric_limits< const volatile _Ty>  : public std::numeric_limits< _Ty>  { }; 
#line 115
struct _Num_int_base : public _Num_base { 
#line 116
static constexpr bool is_bounded = true; 
#line 117
static constexpr bool is_exact = true; 
#line 118
static constexpr bool is_integer = true; 
#line 119
static constexpr bool is_specialized = true; 
#line 120
static constexpr int radix = 2; 
#line 121
}; 
#line 123
struct _Num_float_base : public _Num_base { 
#line 124
static constexpr float_denorm_style has_denorm = denorm_present; 
#line 125
static constexpr bool has_infinity = true; 
#line 126
static constexpr bool has_quiet_NaN = true; 
#line 127
static constexpr bool has_signaling_NaN = true; 
#line 128
static constexpr bool is_bounded = true; 
#line 129
static constexpr bool is_iec559 = true; 
#line 130
static constexpr bool is_signed = true; 
#line 131
static constexpr bool is_specialized = true; 
#line 132
static constexpr float_round_style round_style = round_to_nearest; 
#line 133
static constexpr int radix = 2; 
#line 134
}; 
#line 137
template<> class numeric_limits< bool>  : public _Num_int_base { 
#line 139
public: [[nodiscard]] static constexpr bool min() noexcept { 
#line 140
return false; 
#line 141
} 
#line 143
[[nodiscard]] static constexpr bool max() noexcept { 
#line 144
return true; 
#line 145
} 
#line 147
[[nodiscard]] static constexpr bool lowest() noexcept { 
#line 148
return min(); 
#line 149
} 
#line 151
[[nodiscard]] static constexpr bool epsilon() noexcept { 
#line 152
return 0; 
#line 153
} 
#line 155
[[nodiscard]] static constexpr bool round_error() noexcept { 
#line 156
return 0; 
#line 157
} 
#line 159
[[nodiscard]] static constexpr bool denorm_min() noexcept { 
#line 160
return 0; 
#line 161
} 
#line 163
[[nodiscard]] static constexpr bool infinity() noexcept { 
#line 164
return 0; 
#line 165
} 
#line 167
[[nodiscard]] static constexpr bool quiet_NaN() noexcept { 
#line 168
return 0; 
#line 169
} 
#line 171
[[nodiscard]] static constexpr bool signaling_NaN() noexcept { 
#line 172
return 0; 
#line 173
} 
#line 175
static constexpr int digits = 1; 
#line 176
}; 
#line 179
template<> class numeric_limits< char>  : public _Num_int_base { 
#line 181
public: [[nodiscard]] static constexpr char min() noexcept { 
#line 182
return (-128); 
#line 183
} 
#line 185
[[nodiscard]] static constexpr char max() noexcept { 
#line 186
return 127; 
#line 187
} 
#line 189
[[nodiscard]] static constexpr char lowest() noexcept { 
#line 190
return min(); 
#line 191
} 
#line 193
[[nodiscard]] static constexpr char epsilon() noexcept { 
#line 194
return 0; 
#line 195
} 
#line 197
[[nodiscard]] static constexpr char round_error() noexcept { 
#line 198
return 0; 
#line 199
} 
#line 201
[[nodiscard]] static constexpr char denorm_min() noexcept { 
#line 202
return 0; 
#line 203
} 
#line 205
[[nodiscard]] static constexpr char infinity() noexcept { 
#line 206
return 0; 
#line 207
} 
#line 209
[[nodiscard]] static constexpr char quiet_NaN() noexcept { 
#line 210
return 0; 
#line 211
} 
#line 213
[[nodiscard]] static constexpr char signaling_NaN() noexcept { 
#line 214
return 0; 
#line 215
} 
#line 217
static constexpr bool is_signed = ((-128) != 0); 
#line 218
static constexpr bool is_modulo = ((-128) == 0); 
#line 219
static constexpr int digits = (8 - ((-128) != 0)); 
#line 220
static constexpr int digits10 = 2; 
#line 221
}; 
#line 224
template<> class numeric_limits< signed char>  : public _Num_int_base { 
#line 226
public: [[nodiscard]] static constexpr signed char min() noexcept { 
#line 227
return (-128); 
#line 228
} 
#line 230
[[nodiscard]] static constexpr signed char max() noexcept { 
#line 231
return 127; 
#line 232
} 
#line 234
[[nodiscard]] static constexpr signed char lowest() noexcept { 
#line 235
return min(); 
#line 236
} 
#line 238
[[nodiscard]] static constexpr signed char epsilon() noexcept { 
#line 239
return 0; 
#line 240
} 
#line 242
[[nodiscard]] static constexpr signed char round_error() noexcept { 
#line 243
return 0; 
#line 244
} 
#line 246
[[nodiscard]] static constexpr signed char denorm_min() noexcept { 
#line 247
return 0; 
#line 248
} 
#line 250
[[nodiscard]] static constexpr signed char infinity() noexcept { 
#line 251
return 0; 
#line 252
} 
#line 254
[[nodiscard]] static constexpr signed char quiet_NaN() noexcept { 
#line 255
return 0; 
#line 256
} 
#line 258
[[nodiscard]] static constexpr signed char signaling_NaN() noexcept { 
#line 259
return 0; 
#line 260
} 
#line 262
static constexpr bool is_signed = true; 
#line 263
static constexpr int digits = 7; 
#line 264
static constexpr int digits10 = 2; 
#line 265
}; 
#line 268
template<> class numeric_limits< unsigned char>  : public _Num_int_base { 
#line 270
public: [[nodiscard]] static constexpr unsigned char min() noexcept { 
#line 271
return 0; 
#line 272
} 
#line 274
[[nodiscard]] static constexpr unsigned char max() noexcept { 
#line 275
return 255; 
#line 276
} 
#line 278
[[nodiscard]] static constexpr unsigned char lowest() noexcept { 
#line 279
return min(); 
#line 280
} 
#line 282
[[nodiscard]] static constexpr unsigned char epsilon() noexcept { 
#line 283
return 0; 
#line 284
} 
#line 286
[[nodiscard]] static constexpr unsigned char round_error() noexcept { 
#line 287
return 0; 
#line 288
} 
#line 290
[[nodiscard]] static constexpr unsigned char denorm_min() noexcept { 
#line 291
return 0; 
#line 292
} 
#line 294
[[nodiscard]] static constexpr unsigned char infinity() noexcept { 
#line 295
return 0; 
#line 296
} 
#line 298
[[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept { 
#line 299
return 0; 
#line 300
} 
#line 302
[[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept { 
#line 303
return 0; 
#line 304
} 
#line 306
static constexpr bool is_modulo = true; 
#line 307
static constexpr int digits = 8; 
#line 308
static constexpr int digits10 = 2; 
#line 309
}; 
#line 358
template<> class numeric_limits< char16_t>  : public _Num_int_base { 
#line 360
public: [[nodiscard]] static constexpr char16_t min() noexcept { 
#line 361
return 0; 
#line 362
} 
#line 364
[[nodiscard]] static constexpr char16_t max() noexcept { 
#line 365
return 65535; 
#line 366
} 
#line 368
[[nodiscard]] static constexpr char16_t lowest() noexcept { 
#line 369
return min(); 
#line 370
} 
#line 372
[[nodiscard]] static constexpr char16_t epsilon() noexcept { 
#line 373
return 0; 
#line 374
} 
#line 376
[[nodiscard]] static constexpr char16_t round_error() noexcept { 
#line 377
return 0; 
#line 378
} 
#line 380
[[nodiscard]] static constexpr char16_t denorm_min() noexcept { 
#line 381
return 0; 
#line 382
} 
#line 384
[[nodiscard]] static constexpr char16_t infinity() noexcept { 
#line 385
return 0; 
#line 386
} 
#line 388
[[nodiscard]] static constexpr char16_t quiet_NaN() noexcept { 
#line 389
return 0; 
#line 390
} 
#line 392
[[nodiscard]] static constexpr char16_t signaling_NaN() noexcept { 
#line 393
return 0; 
#line 394
} 
#line 396
static constexpr bool is_modulo = true; 
#line 397
static constexpr int digits = 16; 
#line 398
static constexpr int digits10 = 4; 
#line 399
}; 
#line 402
template<> class numeric_limits< char32_t>  : public _Num_int_base { 
#line 404
public: [[nodiscard]] static constexpr char32_t min() noexcept { 
#line 405
return 0; 
#line 406
} 
#line 408
[[nodiscard]] static constexpr char32_t max() noexcept { 
#line 409
return 4294967295U; 
#line 410
} 
#line 412
[[nodiscard]] static constexpr char32_t lowest() noexcept { 
#line 413
return min(); 
#line 414
} 
#line 416
[[nodiscard]] static constexpr char32_t epsilon() noexcept { 
#line 417
return 0; 
#line 418
} 
#line 420
[[nodiscard]] static constexpr char32_t round_error() noexcept { 
#line 421
return 0; 
#line 422
} 
#line 424
[[nodiscard]] static constexpr char32_t denorm_min() noexcept { 
#line 425
return 0; 
#line 426
} 
#line 428
[[nodiscard]] static constexpr char32_t infinity() noexcept { 
#line 429
return 0; 
#line 430
} 
#line 432
[[nodiscard]] static constexpr char32_t quiet_NaN() noexcept { 
#line 433
return 0; 
#line 434
} 
#line 436
[[nodiscard]] static constexpr char32_t signaling_NaN() noexcept { 
#line 437
return 0; 
#line 438
} 
#line 440
static constexpr bool is_modulo = true; 
#line 441
static constexpr int digits = 32; 
#line 442
static constexpr int digits10 = 9; 
#line 443
}; 
#line 446
template<> class numeric_limits< __wchar_t>  : public _Num_int_base { 
#line 448
public: [[nodiscard]] static constexpr __wchar_t min() noexcept { 
#line 449
return 0; 
#line 450
} 
#line 452
[[nodiscard]] static constexpr __wchar_t max() noexcept { 
#line 453
return 65535; 
#line 454
} 
#line 456
[[nodiscard]] static constexpr __wchar_t lowest() noexcept { 
#line 457
return min(); 
#line 458
} 
#line 460
[[nodiscard]] static constexpr __wchar_t epsilon() noexcept { 
#line 461
return 0; 
#line 462
} 
#line 464
[[nodiscard]] static constexpr __wchar_t round_error() noexcept { 
#line 465
return 0; 
#line 466
} 
#line 468
[[nodiscard]] static constexpr __wchar_t denorm_min() noexcept { 
#line 469
return 0; 
#line 470
} 
#line 472
[[nodiscard]] static constexpr __wchar_t infinity() noexcept { 
#line 473
return 0; 
#line 474
} 
#line 476
[[nodiscard]] static constexpr __wchar_t quiet_NaN() noexcept { 
#line 477
return 0; 
#line 478
} 
#line 480
[[nodiscard]] static constexpr __wchar_t signaling_NaN() noexcept { 
#line 481
return 0; 
#line 482
} 
#line 484
static constexpr bool is_modulo = true; 
#line 485
static constexpr int digits = 16; 
#line 486
static constexpr int digits10 = 4; 
#line 487
}; 
#line 490
template<> class numeric_limits< short>  : public _Num_int_base { 
#line 492
public: [[nodiscard]] static constexpr short min() noexcept { 
#line 493
return (-32768); 
#line 494
} 
#line 496
[[nodiscard]] static constexpr short max() noexcept { 
#line 497
return 32767; 
#line 498
} 
#line 500
[[nodiscard]] static constexpr short lowest() noexcept { 
#line 501
return min(); 
#line 502
} 
#line 504
[[nodiscard]] static constexpr short epsilon() noexcept { 
#line 505
return 0; 
#line 506
} 
#line 508
[[nodiscard]] static constexpr short round_error() noexcept { 
#line 509
return 0; 
#line 510
} 
#line 512
[[nodiscard]] static constexpr short denorm_min() noexcept { 
#line 513
return 0; 
#line 514
} 
#line 516
[[nodiscard]] static constexpr short infinity() noexcept { 
#line 517
return 0; 
#line 518
} 
#line 520
[[nodiscard]] static constexpr short quiet_NaN() noexcept { 
#line 521
return 0; 
#line 522
} 
#line 524
[[nodiscard]] static constexpr short signaling_NaN() noexcept { 
#line 525
return 0; 
#line 526
} 
#line 528
static constexpr bool is_signed = true; 
#line 529
static constexpr int digits = 15; 
#line 530
static constexpr int digits10 = 4; 
#line 531
}; 
#line 534
template<> class numeric_limits< int>  : public _Num_int_base { 
#line 536
public: [[nodiscard]] static constexpr int min() noexcept { 
#line 537
return ((-2147483647) - 1); 
#line 538
} 
#line 540
[[nodiscard]] static constexpr int max() noexcept { 
#line 541
return 2147483647; 
#line 542
} 
#line 544
[[nodiscard]] static constexpr int lowest() noexcept { 
#line 545
return min(); 
#line 546
} 
#line 548
[[nodiscard]] static constexpr int epsilon() noexcept { 
#line 549
return 0; 
#line 550
} 
#line 552
[[nodiscard]] static constexpr int round_error() noexcept { 
#line 553
return 0; 
#line 554
} 
#line 556
[[nodiscard]] static constexpr int denorm_min() noexcept { 
#line 557
return 0; 
#line 558
} 
#line 560
[[nodiscard]] static constexpr int infinity() noexcept { 
#line 561
return 0; 
#line 562
} 
#line 564
[[nodiscard]] static constexpr int quiet_NaN() noexcept { 
#line 565
return 0; 
#line 566
} 
#line 568
[[nodiscard]] static constexpr int signaling_NaN() noexcept { 
#line 569
return 0; 
#line 570
} 
#line 572
static constexpr bool is_signed = true; 
#line 573
static constexpr int digits = 31; 
#line 574
static constexpr int digits10 = 9; 
#line 575
}; 
#line 578
template<> class numeric_limits< long>  : public _Num_int_base { 
#line 580
public: [[nodiscard]] static constexpr long min() noexcept { 
#line 581
return ((-2147483647L) - (1)); 
#line 582
} 
#line 584
[[nodiscard]] static constexpr long max() noexcept { 
#line 585
return 2147483647L; 
#line 586
} 
#line 588
[[nodiscard]] static constexpr long lowest() noexcept { 
#line 589
return min(); 
#line 590
} 
#line 592
[[nodiscard]] static constexpr long epsilon() noexcept { 
#line 593
return 0; 
#line 594
} 
#line 596
[[nodiscard]] static constexpr long round_error() noexcept { 
#line 597
return 0; 
#line 598
} 
#line 600
[[nodiscard]] static constexpr long denorm_min() noexcept { 
#line 601
return 0; 
#line 602
} 
#line 604
[[nodiscard]] static constexpr long infinity() noexcept { 
#line 605
return 0; 
#line 606
} 
#line 608
[[nodiscard]] static constexpr long quiet_NaN() noexcept { 
#line 609
return 0; 
#line 610
} 
#line 612
[[nodiscard]] static constexpr long signaling_NaN() noexcept { 
#line 613
return 0; 
#line 614
} 
#line 616
static_assert((sizeof(int) == sizeof(long)), "LLP64 assumption");
#line 617
static constexpr bool is_signed = true; 
#line 618
static constexpr int digits = 31; 
#line 619
static constexpr int digits10 = 9; 
#line 620
}; 
#line 623
template<> class numeric_limits< __int64>  : public _Num_int_base { 
#line 625
public: [[nodiscard]] static constexpr __int64 min() noexcept { 
#line 626
return ((-9223372036854775807i64) - (1)); 
#line 627
} 
#line 629
[[nodiscard]] static constexpr __int64 max() noexcept { 
#line 630
return 9223372036854775807i64; 
#line 631
} 
#line 633
[[nodiscard]] static constexpr __int64 lowest() noexcept { 
#line 634
return min(); 
#line 635
} 
#line 637
[[nodiscard]] static constexpr __int64 epsilon() noexcept { 
#line 638
return 0; 
#line 639
} 
#line 641
[[nodiscard]] static constexpr __int64 round_error() noexcept { 
#line 642
return 0; 
#line 643
} 
#line 645
[[nodiscard]] static constexpr __int64 denorm_min() noexcept { 
#line 646
return 0; 
#line 647
} 
#line 649
[[nodiscard]] static constexpr __int64 infinity() noexcept { 
#line 650
return 0; 
#line 651
} 
#line 653
[[nodiscard]] static constexpr __int64 quiet_NaN() noexcept { 
#line 654
return 0; 
#line 655
} 
#line 657
[[nodiscard]] static constexpr __int64 signaling_NaN() noexcept { 
#line 658
return 0; 
#line 659
} 
#line 661
static constexpr bool is_signed = true; 
#line 662
static constexpr int digits = 63; 
#line 663
static constexpr int digits10 = 18; 
#line 664
}; 
#line 668
template<> class numeric_limits< unsigned short>  : public _Num_int_base { 
#line 670
public: [[nodiscard]] static constexpr unsigned short min() noexcept { 
#line 671
return 0; 
#line 672
} 
#line 674
[[nodiscard]] static constexpr unsigned short max() noexcept { 
#line 675
return 65535; 
#line 676
} 
#line 678
[[nodiscard]] static constexpr unsigned short lowest() noexcept { 
#line 679
return min(); 
#line 680
} 
#line 682
[[nodiscard]] static constexpr unsigned short epsilon() noexcept { 
#line 683
return 0; 
#line 684
} 
#line 686
[[nodiscard]] static constexpr unsigned short round_error() noexcept { 
#line 687
return 0; 
#line 688
} 
#line 690
[[nodiscard]] static constexpr unsigned short denorm_min() noexcept { 
#line 691
return 0; 
#line 692
} 
#line 694
[[nodiscard]] static constexpr unsigned short infinity() noexcept { 
#line 695
return 0; 
#line 696
} 
#line 698
[[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept { 
#line 699
return 0; 
#line 700
} 
#line 702
[[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept { 
#line 703
return 0; 
#line 704
} 
#line 706
static constexpr bool is_modulo = true; 
#line 707
static constexpr int digits = 16; 
#line 708
static constexpr int digits10 = 4; 
#line 709
}; 
#line 713 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
template<> class numeric_limits< unsigned>  : public _Num_int_base { 
#line 715
public: [[nodiscard]] static constexpr unsigned min() noexcept { 
#line 716
return 0; 
#line 717
} 
#line 719
[[nodiscard]] static constexpr unsigned max() noexcept { 
#line 720
return 4294967295U; 
#line 721
} 
#line 723
[[nodiscard]] static constexpr unsigned lowest() noexcept { 
#line 724
return min(); 
#line 725
} 
#line 727
[[nodiscard]] static constexpr unsigned epsilon() noexcept { 
#line 728
return 0; 
#line 729
} 
#line 731
[[nodiscard]] static constexpr unsigned round_error() noexcept { 
#line 732
return 0; 
#line 733
} 
#line 735
[[nodiscard]] static constexpr unsigned denorm_min() noexcept { 
#line 736
return 0; 
#line 737
} 
#line 739
[[nodiscard]] static constexpr unsigned infinity() noexcept { 
#line 740
return 0; 
#line 741
} 
#line 743
[[nodiscard]] static constexpr unsigned quiet_NaN() noexcept { 
#line 744
return 0; 
#line 745
} 
#line 747
[[nodiscard]] static constexpr unsigned signaling_NaN() noexcept { 
#line 748
return 0; 
#line 749
} 
#line 751
static constexpr bool is_modulo = true; 
#line 752
static constexpr int digits = 32; 
#line 753
static constexpr int digits10 = 9; 
#line 754
}; 
#line 757
template<> class numeric_limits< unsigned long>  : public _Num_int_base { 
#line 759
public: [[nodiscard]] static constexpr unsigned long min() noexcept { 
#line 760
return 0; 
#line 761
} 
#line 763
[[nodiscard]] static constexpr unsigned long max() noexcept { 
#line 764
return 4294967295UL; 
#line 765
} 
#line 767
[[nodiscard]] static constexpr unsigned long lowest() noexcept { 
#line 768
return min(); 
#line 769
} 
#line 771
[[nodiscard]] static constexpr unsigned long epsilon() noexcept { 
#line 772
return 0; 
#line 773
} 
#line 775
[[nodiscard]] static constexpr unsigned long round_error() noexcept { 
#line 776
return 0; 
#line 777
} 
#line 779
[[nodiscard]] static constexpr unsigned long denorm_min() noexcept { 
#line 780
return 0; 
#line 781
} 
#line 783
[[nodiscard]] static constexpr unsigned long infinity() noexcept { 
#line 784
return 0; 
#line 785
} 
#line 787
[[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept { 
#line 788
return 0; 
#line 789
} 
#line 791
[[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept { 
#line 792
return 0; 
#line 793
} 
#line 795
static_assert((sizeof(unsigned) == sizeof(unsigned long)), "LLP64 assumption");
#line 796
static constexpr bool is_modulo = true; 
#line 797
static constexpr int digits = 32; 
#line 798
static constexpr int digits10 = 9; 
#line 799
}; 
#line 802
template<> class numeric_limits< unsigned __int64>  : public _Num_int_base { 
#line 804
public: [[nodiscard]] static constexpr unsigned __int64 min() noexcept { 
#line 805
return 0; 
#line 806
} 
#line 808
[[nodiscard]] static constexpr unsigned __int64 max() noexcept { 
#line 809
return 18446744073709551615Ui64; 
#line 810
} 
#line 812
[[nodiscard]] static constexpr unsigned __int64 lowest() noexcept { 
#line 813
return min(); 
#line 814
} 
#line 816
[[nodiscard]] static constexpr unsigned __int64 epsilon() noexcept { 
#line 817
return 0; 
#line 818
} 
#line 820
[[nodiscard]] static constexpr unsigned __int64 round_error() noexcept { 
#line 821
return 0; 
#line 822
} 
#line 824
[[nodiscard]] static constexpr unsigned __int64 denorm_min() noexcept { 
#line 825
return 0; 
#line 826
} 
#line 828
[[nodiscard]] static constexpr unsigned __int64 infinity() noexcept { 
#line 829
return 0; 
#line 830
} 
#line 832
[[nodiscard]] static constexpr unsigned __int64 quiet_NaN() noexcept { 
#line 833
return 0; 
#line 834
} 
#line 836
[[nodiscard]] static constexpr unsigned __int64 signaling_NaN() noexcept { 
#line 837
return 0; 
#line 838
} 
#line 840
static constexpr bool is_modulo = true; 
#line 841
static constexpr int digits = 64; 
#line 842
static constexpr int digits10 = 19; 
#line 843
}; 
#line 846
template<> class numeric_limits< float>  : public _Num_float_base { 
#line 848
public: [[nodiscard]] static constexpr float min() noexcept { 
#line 849
return (1.175494351e-38F); 
#line 850
} 
#line 852
[[nodiscard]] static constexpr float max() noexcept { 
#line 853
return (3.402823466e+38F); 
#line 854
} 
#line 856
[[nodiscard]] static constexpr float lowest() noexcept { 
#line 857
return -max(); 
#line 858
} 
#line 860
[[nodiscard]] static constexpr float epsilon() noexcept { 
#line 861
return (1.192092896e-07F); 
#line 862
} 
#line 864
[[nodiscard]] static constexpr float round_error() noexcept { 
#line 865
return (0.5F); 
#line 866
} 
#line 868
[[nodiscard]] static constexpr float denorm_min() noexcept { 
#line 869
return (1.401298464e-45F); 
#line 870
} 
#line 872
[[nodiscard]] static constexpr float infinity() noexcept { 
#line 873
return __builtin_huge_valf(); 
#line 874
} 
#line 876
[[nodiscard]] static constexpr float quiet_NaN() noexcept { 
#line 877
return __builtin_nanf("0"); 
#line 878
} 
#line 880
[[nodiscard]] static constexpr float signaling_NaN() noexcept { 
#line 881
return __builtin_nansf("1"); 
#line 882
} 
#line 884
static constexpr int digits = 24; 
#line 885
static constexpr int digits10 = 6; 
#line 886
static constexpr int max_digits10 = 9; 
#line 887
static constexpr int max_exponent = 128; 
#line 888
static constexpr int max_exponent10 = 38; 
#line 889
static constexpr int min_exponent = (-125); 
#line 890
static constexpr int min_exponent10 = (-37); 
#line 891
}; 
#line 894
template<> class numeric_limits< double>  : public _Num_float_base { 
#line 896
public: [[nodiscard]] static constexpr double min() noexcept { 
#line 897
return (2.225073858507201383e-308); 
#line 898
} 
#line 900
[[nodiscard]] static constexpr double max() noexcept { 
#line 901
return (1.797693134862315708e+308); 
#line 902
} 
#line 904
[[nodiscard]] static constexpr double lowest() noexcept { 
#line 905
return -max(); 
#line 906
} 
#line 908
[[nodiscard]] static constexpr double epsilon() noexcept { 
#line 909
return (2.220446049250313081e-16); 
#line 910
} 
#line 912
[[nodiscard]] static constexpr double round_error() noexcept { 
#line 913
return (0.5); 
#line 914
} 
#line 916
[[nodiscard]] static constexpr double denorm_min() noexcept { 
#line 917
return (4.940656458412465442e-324); 
#line 918
} 
#line 920
[[nodiscard]] static constexpr double infinity() noexcept { 
#line 921
return __builtin_huge_val(); 
#line 922
} 
#line 924
[[nodiscard]] static constexpr double quiet_NaN() noexcept { 
#line 925
return __builtin_nan("0"); 
#line 926
} 
#line 928
[[nodiscard]] static constexpr double signaling_NaN() noexcept { 
#line 929
return __builtin_nans("1"); 
#line 930
} 
#line 932
static constexpr int digits = 53; 
#line 933
static constexpr int digits10 = 15; 
#line 934
static constexpr int max_digits10 = 17; 
#line 935
static constexpr int max_exponent = 1024; 
#line 936
static constexpr int max_exponent10 = 308; 
#line 937
static constexpr int min_exponent = (-1021); 
#line 938
static constexpr int min_exponent10 = (-307); 
#line 939
}; 
#line 942
template<> class numeric_limits< long double>  : public _Num_float_base { 
#line 944
public: [[nodiscard]] static constexpr long double min() noexcept { 
#line 945
return (2.225073858507201383e-308); 
#line 946
} 
#line 948
[[nodiscard]] static constexpr long double max() noexcept { 
#line 949
return (1.797693134862315708e+308); 
#line 950
} 
#line 952
[[nodiscard]] static constexpr long double lowest() noexcept { 
#line 953
return -max(); 
#line 954
} 
#line 956
[[nodiscard]] static constexpr long double epsilon() noexcept { 
#line 957
return (2.220446049250313081e-16); 
#line 958
} 
#line 960
[[nodiscard]] static constexpr long double round_error() noexcept { 
#line 961
return (0.5L); 
#line 962
} 
#line 964
[[nodiscard]] static constexpr long double denorm_min() noexcept { 
#line 965
return (4.940656458412465442e-324); 
#line 966
} 
#line 968
[[nodiscard]] static constexpr long double infinity() noexcept { 
#line 969
return __builtin_huge_val(); 
#line 970
} 
#line 972
[[nodiscard]] static constexpr long double quiet_NaN() noexcept { 
#line 973
return __builtin_nan("0"); 
#line 974
} 
#line 976
[[nodiscard]] static constexpr long double signaling_NaN() noexcept { 
#line 977
return __builtin_nans("1"); 
#line 978
} 
#line 980
static constexpr int digits = 53; 
#line 981
static constexpr int digits10 = 15; 
#line 982
static constexpr int max_digits10 = 17; 
#line 983
static constexpr int max_exponent = 1024; 
#line 984
static constexpr int max_exponent10 = 308; 
#line 985
static constexpr int min_exponent = (-1021); 
#line 986
static constexpr int min_exponent10 = (-307); 
#line 987
}; 
#line 992
template < class _Ty >
[ [ nodiscard ] ] constexpr int _Countl_zero_fallback ( _Ty _Val ) noexcept {
    _Ty _Yy = 0;

    unsigned int _Nn = numeric_limits < _Ty > :: digits;
    unsigned int _Cc = numeric_limits < _Ty > :: digits / 2;
    do {
        _Yy = static_cast < _Ty > ( _Val >> _Cc );
        if ( _Yy != 0 ) {
            _Nn -= _Cc;
            _Val = _Yy;
        }
        _Cc >>= 1;
    } while ( _Cc != 0 );
    return static_cast < int > ( _Nn ) - static_cast < int > ( _Val );
}
#line 1012
template < class _Ty >
[ [ nodiscard ] ] constexpr int _Countr_zero_fallback ( const _Ty _Val ) noexcept {
    constexpr int _Digits = std :: numeric_limits < _Ty > :: digits;
    return _Digits - _Countl_zero_fallback ( static_cast < _Ty > ( static_cast < _Ty > ( ~ _Val ) & static_cast < _Ty > ( _Val - 1 ) ) );
}
#line 1019
extern "C" {
#line 1020
extern int __isa_available; 
#line 1028 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
}
#line 1030
template < class _Ty >
[ [ nodiscard ] ] int _Countr_zero_tzcnt ( const _Ty _Val ) noexcept {
    constexpr int _Digits = numeric_limits < _Ty > :: digits;
    constexpr _Ty _Max = ( numeric_limits < _Ty > :: max ) ( );

    if constexpr ( _Digits <= 32 ) {



        return static_cast < int > ( _tzcnt_u32 ( static_cast < unsigned int > ( ~ _Max | _Val ) ) );
    } else {









        return static_cast < int > ( _tzcnt_u64 ( _Val ) );

    }
}
#line 1055 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
template < class _Ty >
[ [ nodiscard ] ] int _Countr_zero_bsf ( const _Ty _Val ) noexcept {
    constexpr int _Digits = numeric_limits < _Ty > :: digits;
    constexpr _Ty _Max = ( numeric_limits < _Ty > :: max ) ( );

    unsigned long _Result;
    if constexpr ( _Digits <= 32 ) {



        if ( ! _BitScanForward ( & _Result, static_cast < unsigned int > ( ~ _Max | _Val ) ) ) {
            return _Digits;
        }
    } else {













        if ( ! _BitScanForward64 ( & _Result, _Val ) ) {
            return _Digits;
        }

    }
    return static_cast < int > ( _Result );
}
#line 1090 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
template < class _Ty >
[ [ nodiscard ] ] int _Checked_x86_x64_countr_zero ( const _Ty _Val ) noexcept {



    const bool _Definitely_have_tzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
    if ( _Definitely_have_tzcnt ) {
        return _Countr_zero_tzcnt ( _Val );
    } else {
        return _Countr_zero_bsf ( _Val );
    }

}
#line 1108 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
template< class _Ty> constexpr bool 
#line 1109
_Is_standard_unsigned_integer = _Is_any_of_v< remove_cv_t< _Ty> , unsigned char, unsigned short, unsigned, unsigned long, unsigned __int64> ; 
#line 1112
template < class _Ty, enable_if_t < _Is_standard_unsigned_integer < _Ty >, int > = 0 >
[ [ nodiscard ] ] constexpr int _Countr_zero ( const _Ty _Val ) noexcept {








    return _Countr_zero_fallback ( _Val );
}
#line 1125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
}
#line 1128
#pragma warning(pop)
#pragma pack ( pop )
#line 1132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"
using new_handler = void (__cdecl *)(void); 
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"
new_handler __cdecl set_new_handler(new_handler) noexcept; 
#line 52
[[nodiscard]] new_handler __cdecl get_new_handler() noexcept; 
#line 53
}
#line 57
#pragma warning(pop)
#pragma pack ( pop )
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"
namespace std { 
#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"
enum memory_order { 
#line 80
memory_order_relaxed, 
#line 81
memory_order_consume, 
#line 82
memory_order_acquire, 
#line 83
memory_order_release, 
#line 84
memory_order_acq_rel, 
#line 85
memory_order_seq_cst
#line 86
}; 
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"
using _Atomic_counter_t = unsigned long; 
#line 91
template < class _Integral, class _Ty >
[ [ nodiscard ] ] volatile _Integral * _Atomic_address_as ( _Ty & _Source ) noexcept {

    static_assert ( is_integral_v < _Integral >, "Tried to reinterpret memory as non-integral" );
    return & reinterpret_cast < volatile _Integral & > ( _Source );
}
#line 98
template < class _Integral, class _Ty >
[ [ nodiscard ] ] const volatile _Integral * _Atomic_address_as ( const _Ty & _Source ) noexcept {

    static_assert ( is_integral_v < _Integral >, "Tried to reinterpret memory as non-integral" );
    return & reinterpret_cast < const volatile _Integral & > ( _Source );
}
#line 105
}
#line 109
#pragma warning(pop)
#pragma pack ( pop )
#line 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"
#pragma external_header(pop)
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 29
namespace std { 
#line 30
template < class _Ty >
struct [ [ nodiscard ] ] _Tidy_guard {
    _Ty * _Target;
    inline ~ _Tidy_guard ( ) {
        if ( _Target ) {
            _Target -> _Tidy ( );
        }
    }
};
#line 40
template < class _Ty >
struct [ [ nodiscard ] ] _Tidy_deallocate_guard {
    _Ty * _Target;
    inline ~ _Tidy_deallocate_guard ( ) {
        if ( _Target ) {
            _Target -> _Tidy_deallocate ( );
        }
    }
};
#line 50
template< class _Keycmp, class _Lhs, class _Rhs> constexpr bool 
#line 51
_Nothrow_compare = noexcept((static_cast< bool>(std::declval< const _Keycmp &> ()(std::declval< const _Lhs &> (), std::declval< const _Rhs &> ())))); 
#line 54
template < size_t _Ty_size >
[ [ nodiscard ] ] constexpr size_t _Get_size_of_n ( const size_t _Count ) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if constexpr ( _Overflow_is_possible ) {
        constexpr size_t _Max_possible = static_cast < size_t > ( - 1 ) / _Ty_size;
        if ( _Count > _Max_possible ) {
            _Throw_bad_array_new_length ( );
        }
    }

    return _Count * _Ty_size;
}
#line 68
template< class _Ty> constexpr size_t 
#line 69
_New_alignof = (::std::max)(__alignof(_Ty), static_cast< size_t>(16Ui64)); 
#line 73
struct _Default_allocate_traits { 
#line 74
__declspec(allocator) static void *
#line 78
_Allocate(const size_t _Bytes) { 
#line 79
return ::operator new(_Bytes); 
#line 80
} 
#line 100
}; 
#line 102
constexpr bool _Is_pow_2(const size_t _Value) noexcept { 
#line 103
return (_Value != (0)) && ((_Value & (_Value - (1))) == (0)); 
#line 104
} 
#line 107
constexpr size_t _Big_allocation_threshold = (4096); 
#line 108
constexpr size_t _Big_allocation_alignment = (32); 
#line 110
static_assert((((2) * sizeof(void *)) <= _Big_allocation_alignment), "Big allocation alignment should at least match vector register alignment");
#line 112
static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");
#line 117
constexpr size_t _Non_user_size = ((sizeof(void *) + _Big_allocation_alignment) - (1)); 
#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
constexpr size_t _Big_allocation_sentinel = 18085043209519168250Ui64; 
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template < class _Traits >
__declspec ( allocator ) void * _Allocate_manually_vector_aligned ( const size_t _Bytes ) {

    const size_t _Block_size = _Non_user_size + _Bytes;
    if ( _Block_size <= _Bytes ) {
        _Throw_bad_array_new_length ( );
    }

    const uintptr_t _Ptr_container = reinterpret_cast < uintptr_t > ( _Traits :: _Allocate ( _Block_size ) );
    do { if ( _Ptr_container != 0 ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
    void * const _Ptr = reinterpret_cast < void * > ( ( _Ptr_container + _Non_user_size ) & ~ ( _Big_allocation_alignment - 1 ) );
    static_cast < uintptr_t * > ( _Ptr ) [ - 1 ] = _Ptr_container;




    return _Ptr;
}
#line 145
inline void _Adjust_manually_vector_aligned(void *&_Ptr, size_t &_Bytes) { 
#line 147
_Bytes += _Non_user_size; 
#line 149
const uintptr_t *const _Ptr_user = reinterpret_cast< uintptr_t *>(_Ptr); 
#line 150
const uintptr_t _Ptr_container = _Ptr_user[-1]; 
#line 154
; 
#line 161
constexpr uintptr_t _Min_back_shift = sizeof(void *); 
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
const uintptr_t _Back_shift = (reinterpret_cast< uintptr_t>(_Ptr)) - _Ptr_container; 
#line 164
do { if ((_Back_shift >= _Min_back_shift) && (_Back_shift <= _Non_user_size)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); }  ; } while (false); 
#line 165
_Ptr = (reinterpret_cast< void *>(_Ptr_container)); 
#line 166
} 
#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template < size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t < ( ! 0 || _Align <= 16Ui64 ), int > = 0 >
__declspec ( allocator ) inline void * _Allocate ( const size_t _Bytes ) {





    {
        if ( _Bytes >= _Big_allocation_threshold ) {
            return _Allocate_manually_vector_aligned < _Traits > ( _Bytes );
        }
    }


    if ( _Bytes != 0 ) {
        return _Traits :: _Allocate ( _Bytes );
    }

    return nullptr;
}
#line 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template < size_t _Align, enable_if_t < ( ! 0 || _Align <= 16Ui64 ), int > = 0 >
inline void _Deallocate ( void * _Ptr, size_t _Bytes ) noexcept {






    {

        if ( _Bytes >= _Big_allocation_threshold ) {
            _Adjust_manually_vector_aligned ( _Ptr, _Bytes );
        }

        :: operator delete ( _Ptr, _Bytes );
    }
}
#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template < class _Ty, class ... _Types >
_Ty * _Global_new ( _Types && ... _Args ) {
    struct [ [ nodiscard ] ] _Guard_type {
        void * _Result;
        ~ _Guard_type ( ) {
            if ( _Result ) {
                _Deallocate < _New_alignof < _Ty >> ( _Result, sizeof ( _Ty ) );
            }
        }
    };

    _Guard_type _Guard { _Allocate < _New_alignof < _Ty >> ( sizeof ( _Ty ) ) };
    :: new ( _Guard . _Result ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );
    return static_cast < _Ty * > ( :: std :: exchange ( _Guard . _Result, nullptr ) );
}
#line 277
template< class _Ptr, class _Ty> using _Rebind_pointer_t = typename pointer_traits< _Ptr> ::template rebind< _Ty> ; 
#line 280
template < class _Pointer, enable_if_t < ! is_pointer_v < _Pointer >, int > = 0 >
inline _Pointer _Refancy ( typename pointer_traits < _Pointer > :: element_type * _Ptr ) noexcept {
    return pointer_traits < _Pointer > :: pointer_to ( * _Ptr );
}
#line 285
template < class _Pointer, enable_if_t < is_pointer_v < _Pointer >, int > = 0 >
inline _Pointer _Refancy ( _Pointer _Ptr ) noexcept {
    return _Ptr;
}
#line 290
template < class _NoThrowFwdIt, class _NoThrowSentinel >
inline void _Destroy_range ( _NoThrowFwdIt _First, _NoThrowSentinel _Last ) noexcept;
#line 293
template < class _Ty >
inline void _Destroy_in_place ( _Ty & _Obj ) noexcept {
    if constexpr ( is_array_v < _Ty > ) {
        _Destroy_range ( _Obj, _Obj + extent_v < _Ty > );
    } else {
        _Obj . ~ _Ty ( );
    }
}
#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template < class _Ptrty >
auto _Const_cast ( _Ptrty _Ptr ) noexcept {
    using _Elem = typename pointer_traits < _Ptrty > :: element_type;
    using _Modifiable = remove_const_t < _Elem >;
    using _Dest = typename pointer_traits < _Ptrty > :: template rebind < _Modifiable >;

    return pointer_traits < _Dest > :: pointer_to ( const_cast < _Modifiable & > ( * _Ptr ) );
}
#line 325
template < class _Ty >
auto _Const_cast ( _Ty * _Ptr ) noexcept {
    return const_cast < remove_const_t < _Ty > * > ( _Ptr );
}
#line 330
template< class _Ty, class  = void> 
#line 331
struct _Get_pointer_type { 
#line 332
using type = typename _Ty::value_type *; 
#line 333
}; 
#line 335
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 336
template< class _Ty> 
#line 337
struct _Get_pointer_type< _Ty, void_t< typename _Ty::pointer> >  { 
#line 338
using type = typename _Ty::pointer; 
#line 339
}; 
#line 340
__pragma( warning(pop)) 
#line 342
template< class _Ty, class  = void> 
#line 343
struct _Get_const_pointer_type { 
#line 344
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 345
using _Valty = typename _Ty::value_type; 
#line 346
using type = typename pointer_traits< _Ptrty> ::template rebind< const _Valty> ; 
#line 347
}; 
#line 349
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 350
template< class _Ty> 
#line 351
struct _Get_const_pointer_type< _Ty, void_t< typename _Ty::const_pointer> >  { 
#line 352
using type = typename _Ty::const_pointer; 
#line 353
}; 
#line 354
__pragma( warning(pop)) 
#line 356
template< class _Ty, class  = void> 
#line 357
struct _Get_void_pointer_type { 
#line 358
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 359
using type = typename pointer_traits< _Ptrty> ::template rebind< void> ; 
#line 360
}; 
#line 362
template< class _Ty> 
#line 363
struct _Get_void_pointer_type< _Ty, void_t< typename _Ty::void_pointer> >  { 
#line 364
using type = typename _Ty::void_pointer; 
#line 365
}; 
#line 367
template< class _Ty, class  = void> 
#line 368
struct _Get_const_void_pointer_type { 
#line 369
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 370
using type = typename pointer_traits< _Ptrty> ::template rebind< const void> ; 
#line 371
}; 
#line 373
template< class _Ty> 
#line 374
struct _Get_const_void_pointer_type< _Ty, void_t< typename _Ty::const_void_pointer> >  { 
#line 375
using type = typename _Ty::const_void_pointer; 
#line 376
}; 
#line 378
template< class _Ty, class  = void> 
#line 379
struct _Get_difference_type { 
#line 380
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 381
using type = typename pointer_traits< _Ptrty> ::difference_type; 
#line 382
}; 
#line 384
template< class _Ty> 
#line 385
struct _Get_difference_type< _Ty, void_t< typename _Ty::difference_type> >  { 
#line 386
using type = typename _Ty::difference_type; 
#line 387
}; 
#line 389
template< class _Ty, class  = void> 
#line 390
struct _Get_size_type { 
#line 391
using type = make_unsigned_t< typename _Get_difference_type< _Ty> ::type> ; 
#line 392
}; 
#line 394
template< class _Ty> 
#line 395
struct _Get_size_type< _Ty, void_t< typename _Ty::size_type> >  { 
#line 396
using type = typename _Ty::size_type; 
#line 397
}; 
#line 399
template< class _Ty, class  = void> 
#line 400
struct _Get_propagate_on_container_copy { 
#line 401
using type = false_type; 
#line 402
}; 
#line 404
template< class _Ty> 
#line 405
struct _Get_propagate_on_container_copy< _Ty, void_t< typename _Ty::propagate_on_container_copy_assignment> >  { 
#line 406
using type = typename _Ty::propagate_on_container_copy_assignment; 
#line 407
}; 
#line 409
template< class _Ty, class  = void> 
#line 410
struct _Get_propagate_on_container_move { 
#line 411
using type = false_type; 
#line 412
}; 
#line 414
template< class _Ty> 
#line 415
struct _Get_propagate_on_container_move< _Ty, void_t< typename _Ty::propagate_on_container_move_assignment> >  { 
#line 416
using type = typename _Ty::propagate_on_container_move_assignment; 
#line 417
}; 
#line 419
template< class _Ty, class  = void> 
#line 420
struct _Get_propagate_on_container_swap { 
#line 421
using type = false_type; 
#line 422
}; 
#line 424
template< class _Ty> 
#line 425
struct _Get_propagate_on_container_swap< _Ty, void_t< typename _Ty::propagate_on_container_swap> >  { 
#line 426
using type = typename _Ty::propagate_on_container_swap; 
#line 427
}; 
#line 429
template< class _Ty, class  = void> 
#line 430
struct _Get_is_always_equal { 
#line 431
using type = bool_constant< is_empty_v< _Ty> > ; 
#line 432
}; 
#line 434
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 435
template< class _Ty> 
#line 436
struct _Get_is_always_equal< _Ty, void_t< typename _Ty::is_always_equal> >  { 
#line 437
using type = typename _Ty::is_always_equal; 
#line 438
}; 
#line 439
__pragma( warning(pop)) 
#line 441
template< class _Ty, class _Other, class  = void> 
#line 442
struct _Get_rebind_type { 
#line 443
using type = typename _Replace_first_parameter< _Other, _Ty> ::type; 
#line 444
}; 
#line 446
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 447
template< class _Ty, class _Other> 
#line 448
struct _Get_rebind_type< _Ty, _Other, void_t< typename _Ty::template rebind< _Other> ::other> >  { 
#line 449
using type = typename _Ty::template rebind< _Other> ::other; 
#line 450
}; 
#line 451
__pragma( warning(pop)) 
#line 453
template< class _Ty> class allocator; 
#line 456
template< class _Alloc, class  = void> 
#line 457
struct _Is_default_allocator : public false_type { }; 
#line 459
template< class _Ty> 
#line 460
struct _Is_default_allocator< allocator< _Ty> , void_t< typename allocator< _Ty> ::_From_primary> >  : public is_same< typename allocator< _Ty> ::_From_primary, allocator< _Ty> > ::type { 
#line 461
}; 
#line 463
template< class _Void, class ..._Types> 
#line 464
struct _Has_no_allocator_construct : public true_type { }; 
#line 466
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 467
template< class _Alloc, class _Ptr, class ..._Args> 
#line 468
struct _Has_no_allocator_construct< void_t< decltype(std::declval< _Alloc &> ().construct(std::declval< _Ptr> (), std::declval< _Args> ()...))> , _Alloc, _Ptr, _Args...>  : public false_type { 
#line 470
}; 
#line 471
__pragma( warning(pop)) 
#line 473
template< class _Alloc, class _Ptr, class ..._Args> using _Uses_default_construct = disjunction< _Is_default_allocator< _Alloc> , _Has_no_allocator_construct< void, _Alloc, _Ptr, _Args...> > ; 
#line 477
template< class _Alloc, class _Ptr, class  = void> 
#line 478
struct _Has_no_alloc_destroy : public true_type { }; 
#line 480
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 481
template< class _Alloc, class _Ptr> 
#line 482
struct _Has_no_alloc_destroy< _Alloc, _Ptr, void_t< decltype(std::declval< _Alloc &> ().destroy(std::declval< _Ptr> ()))> >  : public false_type { 
#line 483
}; 
#line 484
__pragma( warning(pop)) 
#line 486
template< class _Alloc, class _Ptr> using _Uses_default_destroy = disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_destroy< _Alloc, _Ptr> > ; 
#line 489
template< class _Alloc, class _Ptr> using _Uses_default_destroy_t = typename disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_destroy< _Alloc, _Ptr> > ::type; 
#line 492
template< class _Alloc, class _Size_type, class _Const_void_pointer, class  = void> 
#line 493
struct _Has_allocate_hint : public false_type { }; 
#line 495
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 496
template< class _Alloc, class _Size_type, class _Const_void_pointer> 
#line 497
struct _Has_allocate_hint< _Alloc, _Size_type, _Const_void_pointer, void_t< decltype(std::declval< _Alloc &> ().allocate(std::declval< const _Size_type &> (), std::declval< const _Const_void_pointer &> ()))> >  : public true_type { 
#line 499
}; 
#line 500
__pragma( warning(pop)) 
#line 502
template< class _Alloc, class  = void> 
#line 503
struct _Has_max_size : public false_type { }; 
#line 505
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 506
template< class _Alloc> 
#line 507
struct _Has_max_size< _Alloc, void_t< decltype(std::declval< const _Alloc &> ().max_size())> >  : public true_type { }; 
#line 508
__pragma( warning(pop)) 
#line 510
template< class _Alloc, class  = void> 
#line 511
struct _Has_select_on_container_copy_construction : public false_type { }; 
#line 513
template< class _Alloc> 
#line 514
struct _Has_select_on_container_copy_construction< _Alloc, void_t< decltype(std::declval< const _Alloc &> ().select_on_container_copy_construction())> >  : public true_type { 
#line 515
}; 
#line 517
template< class _Alloc> struct allocator_traits; 
#line 520
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 521
template < class _Alloc >
struct _Normal_allocator_traits {
    using allocator_type = _Alloc;
    using value_type = typename _Alloc :: value_type;

    using pointer = typename _Get_pointer_type < _Alloc > :: type;
    using const_pointer = typename _Get_const_pointer_type < _Alloc > :: type;
    using void_pointer = typename _Get_void_pointer_type < _Alloc > :: type;
    using const_void_pointer = typename _Get_const_void_pointer_type < _Alloc > :: type;

    using size_type = typename _Get_size_type < _Alloc > :: type;
    using difference_type = typename _Get_difference_type < _Alloc > :: type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy < _Alloc > :: type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move < _Alloc > :: type;
    using propagate_on_container_swap = typename _Get_propagate_on_container_swap < _Alloc > :: type;
    using is_always_equal = typename _Get_is_always_equal < _Alloc > :: type;

    template < class _Other >
    using rebind_alloc = typename _Get_rebind_type < _Alloc, _Other > :: type;

    template < class _Other >
    using rebind_traits = allocator_traits < rebind_alloc < _Other >>;

    [ [ nodiscard ] ] static inline __declspec ( allocator ) pointer
        allocate ( _Alloc & _Al, const size_type _Count ) {
        return _Al . allocate ( _Count );
    }

    [ [ nodiscard ] ] static inline __declspec ( allocator ) pointer
        allocate ( _Alloc & _Al, const size_type _Count, const const_void_pointer _Hint ) {
        if constexpr ( _Has_allocate_hint < _Alloc, size_type, const_void_pointer > :: value ) {
            return _Al . allocate ( _Count, _Hint );
        } else {
            return _Al . allocate ( _Count );
        }
    }

    static inline void deallocate ( _Alloc & _Al, pointer _Ptr, size_type _Count ) {
        _Al . deallocate ( _Ptr, _Count );
    }

    template < class _Ty, class ... _Types >
    static inline void construct ( _Alloc & _Al, _Ty * _Ptr, _Types && ... _Args ) {
        if constexpr ( _Uses_default_construct < _Alloc, _Ty *, _Types ... > :: value ) {
            ( void ) _Al;



            :: new ( static_cast < void * > ( _Ptr ) ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );

        } else {
            _Al . construct ( _Ptr, :: std :: forward < _Types > ( _Args ) ... );
        }
    }

    template < class _Ty >
    static inline void destroy ( _Alloc & _Al, _Ty * _Ptr ) {
        if constexpr ( _Uses_default_destroy < _Alloc, _Ty * > :: value ) {



            _Ptr -> ~ _Ty ( );

        } else {
            _Al . destroy ( _Ptr );
        }
    }

    [ [ nodiscard ] ] static inline size_type max_size ( const _Alloc & _Al ) noexcept {
        if constexpr ( _Has_max_size < _Alloc > :: value ) {
            return _Al . max_size ( );
        } else {
            return ( numeric_limits < size_type > :: max ) ( ) / sizeof ( value_type );
        }
    }

    [ [ nodiscard ] ] static inline _Alloc select_on_container_copy_construction ( const _Alloc & _Al ) {
        if constexpr ( _Has_select_on_container_copy_construction < _Alloc > :: value ) {
            return _Al . select_on_container_copy_construction ( );
        } else {
            return _Al;
        }
    }
};
#line 606 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
__pragma( warning(pop)) 
#line 608
template < class _Alloc >
struct _Default_allocator_traits {
    using allocator_type = _Alloc;
    using value_type = typename _Alloc :: value_type;

    using pointer = value_type *;
    using const_pointer = const value_type *;
    using void_pointer = void *;
    using const_void_pointer = const void *;

    using size_type = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap = false_type;
    using is_always_equal = true_type;

    template < class _Other >
    using rebind_alloc = allocator < _Other >;

    template < class _Other >
    using rebind_traits = allocator_traits < allocator < _Other >>;

    [ [ nodiscard ] ] static inline __declspec ( allocator ) pointer
        allocate ( _Alloc & _Al, const size_type _Count ) {





        {
            ( void ) _Al;
            return static_cast < pointer > (
                _Allocate < _New_alignof < value_type >> ( _Get_size_of_n < sizeof ( value_type ) > ( _Count ) ) );
        }
    }

    [ [ nodiscard ] ] static inline __declspec ( allocator ) pointer
        allocate ( _Alloc & _Al, const size_type _Count, const_void_pointer ) {





        {
            ( void ) _Al;
            return static_cast < pointer > (
                _Allocate < _New_alignof < value_type >> ( _Get_size_of_n < sizeof ( value_type ) > ( _Count ) ) );
        }
    }

    static inline void deallocate ( _Alloc & _Al, const pointer _Ptr, const size_type _Count ) {






        {
            ( void ) _Al;
            _Deallocate < _New_alignof < value_type >> ( _Ptr, sizeof ( value_type ) * _Count );
        }
    }

    template < class _Objty, class ... _Types >
    static inline void construct ( _Alloc &, _Objty * const _Ptr, _Types && ... _Args ) {





        {
            :: new ( _Voidify_iter ( _Ptr ) ) _Objty ( :: std :: forward < _Types > ( _Args ) ... );
        }
    }

    template < class _Uty >
    static inline void destroy ( _Alloc &, _Uty * const _Ptr ) {



        _Ptr -> ~ _Uty ( );

    }

    [ [ nodiscard ] ] static inline size_type max_size ( const _Alloc & ) noexcept {
        return static_cast < size_t > ( - 1 ) / sizeof ( value_type );
    }

    [ [ nodiscard ] ] static inline _Alloc select_on_container_copy_construction ( const _Alloc & _Al ) {
        return _Al;
    }
};
#line 703 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template< class _Alloc> 
#line 704
struct allocator_traits : public conditional_t< _Is_default_allocator< _Alloc> ::value, _Default_allocator_traits< _Alloc> , _Normal_allocator_traits< _Alloc> >  { 
#line 705
}; 
#line 709
template< class _Alloc> using _Choose_pocca = bool_constant< allocator_traits< _Alloc> ::propagate_on_container_copy_assignment::value && (!allocator_traits< _Alloc> ::is_always_equal::value)> ; 
#line 713
struct _Equal_allocators { }; 
#line 714
using _Propagate_allocators = true_type; 
#line 715
using _No_propagate_allocators = false_type; 
#line 717
template< class _Alloc> using _Choose_pocma = conditional_t< allocator_traits< _Alloc> ::is_always_equal::value, _Equal_allocators, typename allocator_traits< _Alloc> ::propagate_on_container_move_assignment::type> ; 
#line 721
template< class _Alloc, class _Value_type> using _Rebind_alloc_t = typename allocator_traits< _Alloc> ::template rebind_alloc< _Value_type> ; 
#line 726
template< class _Alloc, class _Value_type> using _Maybe_rebind_alloc_t = typename _Select< is_same_v< typename _Alloc::value_type, _Value_type> > ::template _Apply< _Alloc &, _Rebind_alloc_t< _Alloc, _Value_type> > ; 
#line 731
template< class _Alloc> constexpr bool 
#line 732
_Is_simple_alloc_v = ((is_same_v< typename allocator_traits< _Alloc> ::size_type, unsigned __int64>  && is_same_v< typename allocator_traits< _Alloc> ::difference_type, __int64> ) && is_same_v< typename allocator_traits< _Alloc> ::pointer, typename _Alloc::value_type *> ) && is_same_v< typename allocator_traits< _Alloc> ::const_pointer, const typename _Alloc::value_type *> ; 
#line 737
template< class _Value_type> 
#line 738
struct _Simple_types { 
#line 740
using value_type = _Value_type; 
#line 741
using size_type = size_t; 
#line 742
using difference_type = ptrdiff_t; 
#line 743
using pointer = value_type *; 
#line 744
using const_pointer = const value_type *; 
#line 745
}; 
#line 747
template < class _Ty >
class allocator {
public :
    static_assert ( ! is_const_v < _Ty >, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed."
                                                                               );

    using _From_primary = allocator;

    using value_type = _Ty;


     typedef _Ty * pointer;
     typedef const _Ty * const_pointer;

     typedef _Ty & reference;
     typedef const _Ty & const_reference;


    using size_type = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;


    using is_always_equal = true_type;

    template < class _Other >
    struct rebind {
        using other = allocator < _Other >;
    };

     [ [ nodiscard ] ] _Ty * address ( _Ty & _Val ) const noexcept {
        return :: std :: addressof ( _Val );
    }

     [ [ nodiscard ] ] const _Ty * address ( const _Ty & _Val ) const noexcept {
        return :: std :: addressof ( _Val );
    }


    constexpr allocator ( ) noexcept { }

    constexpr allocator ( const allocator & ) noexcept = default;
    template < class _Other >
    constexpr allocator ( const allocator < _Other > & ) noexcept { }
    inline ~ allocator ( ) = default;
    inline allocator & operator = ( const allocator & ) = default;

    inline void deallocate ( _Ty * const _Ptr, const size_t _Count ) {

        _Deallocate < _New_alignof < _Ty >> ( _Ptr, sizeof ( _Ty ) * _Count );
    }

    [ [ nodiscard ] ] inline __declspec ( allocator ) _Ty * allocate ( const size_t _Count ) {
        return static_cast < _Ty * > ( _Allocate < _New_alignof < _Ty >> ( _Get_size_of_n < sizeof ( _Ty ) > ( _Count ) ) );
    }


     [ [ nodiscard ] ] __declspec ( allocator ) _Ty * allocate (
         const size_t _Count, const void * ) {
        return allocate ( _Count );
    }

    template < class _Objty, class ... _Types >
     void construct ( _Objty * const _Ptr, _Types && ... _Args ) {
        :: new ( _Voidify_iter ( _Ptr ) ) _Objty ( :: std :: forward < _Types > ( _Args ) ... );
    }

    template < class _Uty >
     void destroy ( _Uty * const _Ptr ) {
        _Ptr -> ~ _Uty ( );
    }

     [ [ nodiscard ] ] size_t max_size ( ) const noexcept {
        return static_cast < size_t > ( - 1 ) / sizeof ( _Ty );
    }

};
#line 827 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
#pragma pack(8)
template<> 
#line 827
class allocator< void>  { 
#line 829
public: using value_type = void; 
#line 831
typedef void *pointer; 
#line 832
typedef const void *const_pointer; 
#line 835 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
using size_type = size_t; 
#line 836
using difference_type = ptrdiff_t; 
#line 838
using propagate_on_container_move_assignment = true_type; 
#line 841
using is_always_equal = true_type; 
#line 843
template< class _Other> 
#line 844
struct rebind { 
#line 845
using other = std::allocator< _Other> ; 
#line 846
}; 
#line 848 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
}; 
#pragma pack()
template < class _Ty, class _Other >
[ [ nodiscard ] ] inline bool operator == ( const allocator < _Ty > &, const allocator < _Other > & ) noexcept {
    return true;
}
#line 856
template < class _Ty, class _Other >
[ [ nodiscard ] ] bool operator != ( const allocator < _Ty > &, const allocator < _Other > & ) noexcept {
    return false;
}
#line 869 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template< class _Alloc> using _Alloc_ptr_t = typename allocator_traits< _Alloc> ::pointer; 
#line 872
template< class _Alloc> using _Alloc_size_t = typename allocator_traits< _Alloc> ::size_type; 
#line 875
template < class _Alloc >
inline void _Pocca ( _Alloc & _Left, const _Alloc & _Right ) noexcept {
    if constexpr ( allocator_traits < _Alloc > :: propagate_on_container_copy_assignment :: value ) {
        _Left = _Right;
    }
}
#line 882
template < class _Alloc >
inline void _Pocma ( _Alloc & _Left, _Alloc & _Right ) noexcept {
    if constexpr ( allocator_traits < _Alloc > :: propagate_on_container_move_assignment :: value ) {
        _Left = :: std :: move ( _Right );
    }
}
#line 889
template < class _Alloc >
inline void _Pocs ( _Alloc & _Left, _Alloc & _Right ) noexcept {
    if constexpr ( allocator_traits < _Alloc > :: propagate_on_container_swap :: value ) {
        _Swap_adl ( _Left, _Right );
    } else {
        ;
    }
}
#line 898
template < class _Alloc >
inline void _Destroy_range (
    _Alloc_ptr_t < _Alloc > _First, const _Alloc_ptr_t < _Alloc > _Last, _Alloc & _Al ) noexcept {

    using _Ty = typename _Alloc :: value_type;
    if constexpr ( ! conjunction_v < is_trivially_destructible < _Ty >, _Uses_default_destroy < _Alloc, _Ty * >> ) {
        for (; _First != _Last; ++ _First ) {
            allocator_traits < _Alloc > :: destroy ( _Al, _Unfancy ( _First ) );
        }
    }
}
#line 910
template < class _NoThrowFwdIt, class _NoThrowSentinel >
inline void _Destroy_range ( _NoThrowFwdIt _First, const _NoThrowSentinel _Last ) noexcept {

    if constexpr ( ! is_trivially_destructible_v < _Iter_value_t < _NoThrowFwdIt >> ) {
        for (; _First != _Last; ++ _First ) {
            _Destroy_in_place ( * _First );
        }
    }
}
#line 920
template < class _Size_type >
[ [ nodiscard ] ] constexpr _Size_type _Convert_size ( const size_t _Len ) noexcept ( is_same_v < _Size_type, size_t > ) {

    if constexpr ( ! is_same_v < _Size_type, size_t > ) {
        if ( _Len > ( numeric_limits < _Size_type > :: max ) ( ) ) {
            _Xlength_error ( "size_t too long for _Size_type" );
        }
    }

    return static_cast < _Size_type > ( _Len );
}
#line 932
template < class _Alloc >
inline void _Deallocate_plain ( _Alloc & _Al, typename _Alloc :: value_type * const _Ptr ) noexcept {

    using _Alloc_traits = allocator_traits < _Alloc >;
    if constexpr ( is_same_v < _Alloc_ptr_t < _Alloc >, typename _Alloc :: value_type * > ) {
        _Alloc_traits :: deallocate ( _Al, _Ptr, 1 );
    } else {
        using _Ptr_traits = pointer_traits < _Alloc_ptr_t < _Alloc >>;
        _Alloc_traits :: deallocate ( _Al, _Ptr_traits :: pointer_to ( * _Ptr ), 1 );
    }
}
#line 944
template < class _Alloc >
inline void _Delete_plain_internal ( _Alloc & _Al, typename _Alloc :: value_type * const _Ptr ) noexcept {

    using _Ty = typename _Alloc :: value_type;
    _Ptr -> ~ _Ty ( );
    _Deallocate_plain ( _Al, _Ptr );
}
#line 952
template < class _Alloc >
struct _Alloc_construct_ptr {
    using pointer = _Alloc_ptr_t < _Alloc >;
    _Alloc & _Al;
    pointer _Ptr;

    inline explicit _Alloc_construct_ptr ( _Alloc & _Al_ ) : _Al ( _Al_ ), _Ptr ( nullptr ) { }

    [ [ nodiscard ] ] inline pointer _Release ( ) noexcept {
        return :: std :: exchange ( _Ptr, nullptr );
    }

    inline void _Allocate ( ) {
        _Ptr = nullptr;
        _Ptr = _Al . allocate ( 1 );
    }

    inline ~ _Alloc_construct_ptr ( ) {
        if ( _Ptr ) {
            _Al . deallocate ( _Ptr, 1 );
        }
    }

    _Alloc_construct_ptr ( const _Alloc_construct_ptr & ) = delete;
    _Alloc_construct_ptr & operator = ( const _Alloc_construct_ptr & ) = delete;
};
#line 979
struct _Fake_allocator { }; 
#line 981
struct _Container_base0 { 
#line 982
void _Orphan_all() noexcept { } 
#line 983
void _Swap_proxy_and_iterators(_Container_base0 &) noexcept { } 
#line 984
void _Alloc_proxy(const _Fake_allocator &) noexcept { } 
#line 985
void _Reload_proxy(const _Fake_allocator &, const _Fake_allocator &) noexcept { } 
#line 986
}; 
#line 988
struct _Iterator_base0 { 
#line 989
void _Adopt(const void *) noexcept { } 
#line 990
const _Container_base0 *_Getcont() const noexcept { 
#line 991
return nullptr; 
#line 992
} 
#line 994
static constexpr bool _Unwrap_when_unverified = true; 
#line 995
}; 
#line 997
struct _Container_base12; 
#line 998
struct _Container_proxy { 
#line 999
_Container_proxy() noexcept = default;
#line 1000
_Container_proxy(_Container_base12 *_Mycont_) noexcept : _Mycont(_Mycont_) { } 
#line 1002
const _Container_base12 *_Mycont = (nullptr); 
#line 1003
mutable _Iterator_base12 *_Myfirstiter = (nullptr); 
#line 1004
}; 
#line 1006
struct _Container_base12 { 
#line 1008
_Container_base12() noexcept = default;
#line 1010
_Container_base12(const _Container_base12 &) = delete;
#line 1011
_Container_base12 &operator=(const _Container_base12 &) = delete;
#line 1013
inline void _Orphan_all() noexcept; 
#line 1014
inline void _Swap_proxy_and_iterators(_Container_base12 &) noexcept; 
#line 1016
template < class _Alloc >
    inline void _Alloc_proxy ( _Alloc && _Al ) {
        _Container_proxy * const _New_proxy = _Unfancy ( _Al . allocate ( 1 ) );
        _Construct_in_place ( * _New_proxy, this );
        _Myproxy = _New_proxy;
        _New_proxy -> _Mycont = this;
    }
#line 1024
template < class _Alloc >
    inline void _Reload_proxy ( _Alloc && _Old_alloc, _Alloc && _New_alloc ) {

        _Container_proxy * const _New_proxy = _Unfancy ( _New_alloc . allocate ( 1 ) );
        _Construct_in_place ( * _New_proxy, this );
        _New_proxy -> _Mycont = this;
        _Delete_plain_internal ( _Old_alloc, :: std :: exchange ( _Myproxy, _New_proxy ) );
    }
#line 1033
_Container_proxy *_Myproxy = (nullptr); 
#line 1036
private: inline void _Orphan_all_unlocked_v3() noexcept; 
#line 1037
inline void _Swap_proxy_and_iterators_unlocked(_Container_base12 &) noexcept; 
#line 1039
void _Orphan_all_locked_v3() noexcept { 
#line 1040
_Lockit _Lock(3); 
#line 1041
this->_Orphan_all_unlocked_v3(); 
#line 1042
} 
#line 1044
void _Swap_proxy_and_iterators_locked(_Container_base12 &_Right) noexcept { 
#line 1045
_Lockit _Lock(3); 
#line 1046
this->_Swap_proxy_and_iterators_unlocked(_Right); 
#line 1047
} 
#line 1048
}; 
#line 1050
struct _Iterator_base12 { 
#line 1052
_Iterator_base12() noexcept = default;
#line 1054
_Iterator_base12(const _Iterator_base12 &_Right) noexcept { 
#line 1055
((*this) = _Right); 
#line 1056
} 
#line 1058
_Iterator_base12 &operator=(const _Iterator_base12 &_Right) noexcept { 
#line 1069 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
(_Myproxy) = (_Right._Myproxy); 
#line 1071 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
return *this; 
#line 1072
} 
#line 1097 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
void _Adopt(const _Container_base12 *_Parent) noexcept { 
#line 1098
if (_Parent) { 
#line 1099
(_Myproxy) = (_Parent->_Myproxy); 
#line 1100
} else { 
#line 1101
(_Myproxy) = (nullptr); 
#line 1102
}  
#line 1103
} 
#line 1106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
const _Container_base12 *_Getcont() const noexcept { 
#line 1107
return (_Myproxy) ? (_Myproxy)->_Mycont : (nullptr); 
#line 1108
} 
#line 1110
static constexpr bool _Unwrap_when_unverified = (0 == 0); 
#line 1112
mutable _Container_proxy *_Myproxy = (nullptr); 
#line 1113
mutable _Iterator_base12 *_Mynextiter = (nullptr); 
#line 1178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
}; 
#line 1180
inline void _Container_base12::_Orphan_all_unlocked_v3() noexcept { 
#line 1181
if (!(_Myproxy)) { 
#line 1182
return; 
#line 1183
}  
#line 1186
for (auto &_Pnext = (_Myproxy)->_Myfirstiter; _Pnext; _Pnext = (_Pnext->_Mynextiter)) { 
#line 1187
(_Pnext->_Myproxy) = (nullptr); 
#line 1188
}  
#line 1189
((_Myproxy)->_Myfirstiter) = (nullptr); 
#line 1190
} 
#line 1192
inline void _Container_base12::_Orphan_all() noexcept { 
#line 1203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
} 
#line 1205
inline void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12 &_Right) noexcept { 
#line 1206
_Container_proxy *_Temp = _Myproxy; 
#line 1207
(_Myproxy) = (_Right._Myproxy); 
#line 1208
(_Right._Myproxy) = _Temp; 
#line 1210
if (_Myproxy) { 
#line 1211
((_Myproxy)->_Mycont) = this; 
#line 1212
}  
#line 1214
if (_Right._Myproxy) { 
#line 1215
((_Right._Myproxy)->_Mycont) = (&_Right); 
#line 1216
}  
#line 1217
} 
#line 1219
inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12 &_Right) noexcept { 
#line 1230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
this->_Swap_proxy_and_iterators_unlocked(_Right); 
#line 1232 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
} 
#line 1235
using _Container_base = _Container_base0; 
#line 1236
using _Iterator_base = _Iterator_base0; 
#line 1242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
struct _Leave_proxy_unbound { 
#line 1243
explicit _Leave_proxy_unbound() = default;
#line 1244
}; 
#line 1246
struct _Fake_proxy_ptr_impl { 
#line 1247
_Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl &) = delete;
#line 1248
_Fake_proxy_ptr_impl &operator=(const _Fake_proxy_ptr_impl &) = delete;
#line 1249
_Fake_proxy_ptr_impl(const _Fake_allocator &, _Leave_proxy_unbound) noexcept { } 
#line 1250
_Fake_proxy_ptr_impl(const _Fake_allocator &, const _Container_base0 &) noexcept { } 
#line 1252
void _Bind(const _Fake_allocator &, _Container_base0 *) noexcept { } 
#line 1253
void _Release() noexcept { } 
#line 1254
}; 
#line 1256
struct _Basic_container_proxy_ptr12 { 
#line 1258
_Container_proxy *_Ptr = (nullptr); 
#line 1260
constexpr void _Release() noexcept { 
#line 1261
(_Ptr) = (nullptr); 
#line 1262
} 
#line 1265
protected: _Basic_container_proxy_ptr12() = default;
#line 1266
_Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12 &) = delete;
#line 1267
_Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12 &&) = delete;
#line 1268
}; 
#line 1270
template < class _Alloc >
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {

    _Alloc & _Al;

    inline _Container_proxy_ptr12 ( _Alloc & _Al_, _Leave_proxy_unbound ) : _Al ( _Al_ ) {

        _Ptr = _Unfancy ( _Al_ . allocate ( 1 ) );
        _Construct_in_place ( * _Ptr );
    }

    inline _Container_proxy_ptr12 ( _Alloc & _Al_, _Container_base12 & _Mycont ) : _Al ( _Al_ ) {

        _Ptr = _Unfancy ( _Al_ . allocate ( 1 ) );
        _Construct_in_place ( * _Ptr, :: std :: addressof ( _Mycont ) );
        _Mycont . _Myproxy = _Ptr;
    }

    inline void _Bind ( _Alloc & _Old_alloc, _Container_base12 * _Mycont ) noexcept {


        _Ptr -> _Mycont = _Mycont;
        _Delete_plain_internal ( _Old_alloc, :: std :: exchange ( _Mycont -> _Myproxy, :: std :: exchange ( _Ptr, nullptr ) ) );
    }

    inline ~ _Container_proxy_ptr12 ( ) {
        if ( _Ptr ) {
            _Delete_plain_internal ( _Al, _Ptr );
        }
    }
};
#line 1303
constexpr _Fake_allocator _Fake_alloc{}; 
#line 1305
template< class _Alloc> using _Container_proxy_ptr = _Fake_proxy_ptr_impl; 
#line 1313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
struct _Zero_then_variadic_args_t { 
#line 1314
explicit _Zero_then_variadic_args_t() = default;
#line 1315
}; 
#line 1317
struct _One_then_variadic_args_t { 
#line 1318
explicit _One_then_variadic_args_t() = default;
#line 1319
}; 
#line 1321
template < class _Ty1, class _Ty2, bool = is_empty_v < _Ty1 > && ! is_final_v < _Ty1 > >
class _Compressed_pair : private _Ty1 {
public :
    _Ty2 _Myval2;

    using _Mybase = _Ty1;

    template < class ... _Other2 >
    constexpr explicit _Compressed_pair ( _Zero_then_variadic_args_t, _Other2 && ... _Val2 ) noexcept (
        conjunction_v < is_nothrow_default_constructible < _Ty1 >, is_nothrow_constructible < _Ty2, _Other2 ... >> )
        : _Ty1 ( ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... ) { }

    template < class _Other1, class ... _Other2 >
    constexpr _Compressed_pair ( _One_then_variadic_args_t, _Other1 && _Val1, _Other2 && ... _Val2 ) noexcept (
        conjunction_v < is_nothrow_constructible < _Ty1, _Other1 >, is_nothrow_constructible < _Ty2, _Other2 ... >> )
        : _Ty1 ( :: std :: forward < _Other1 > ( _Val1 ) ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... ) { }

    constexpr _Ty1 & _Get_first ( ) noexcept {
        return * this;
    }

    constexpr const _Ty1 & _Get_first ( ) const noexcept {
        return * this;
    }
};
#line 1347
template < class _Ty1, class _Ty2 >
class _Compressed_pair < _Ty1, _Ty2, false > {
public :
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template < class ... _Other2 >
    constexpr explicit _Compressed_pair ( _Zero_then_variadic_args_t, _Other2 && ... _Val2 ) noexcept (
        conjunction_v < is_nothrow_default_constructible < _Ty1 >, is_nothrow_constructible < _Ty2, _Other2 ... >> )
        : _Myval1 ( ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... ) { }

    template < class _Other1, class ... _Other2 >
    constexpr _Compressed_pair ( _One_then_variadic_args_t, _Other1 && _Val1, _Other2 && ... _Val2 ) noexcept (
        conjunction_v < is_nothrow_constructible < _Ty1, _Other1 >, is_nothrow_constructible < _Ty2, _Other2 ... >> )
        : _Myval1 ( :: std :: forward < _Other1 > ( _Val1 ) ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... ) { }

    constexpr _Ty1 & _Get_first ( ) noexcept {
        return _Myval1;
    }

    constexpr const _Ty1 & _Get_first ( ) const noexcept {
        return _Myval1;
    }
};
#line 1372
struct _Move_allocator_tag { 
#line 1373
explicit _Move_allocator_tag() = default;
#line 1374
}; 
#line 1376
template < class _Ty >
pair < _Ty *, ptrdiff_t > _Get_temporary_buffer ( ptrdiff_t _Count ) noexcept {
    if ( static_cast < size_t > ( _Count ) <= static_cast < size_t > ( - 1 ) / sizeof ( _Ty ) ) {
        for (; 0 < _Count; _Count /= 2 ) {
            const auto _Size = static_cast < size_t > ( _Count ) * sizeof ( _Ty );
            void * _Pbuf;





            {
                _Pbuf = :: operator new ( _Size, nothrow );
            }

            if ( _Pbuf ) {
                return { static_cast < _Ty * > ( _Pbuf ), _Count };
            }
        }
    }

    return { nullptr, 0 };
}
#line 1400
template < class _Ty >
void _Return_temporary_buffer ( _Ty * const _Pbuf ) noexcept {





    {
        :: operator delete ( _Pbuf );
    }
}
#line 1412
template < class _NoThrowFwdIt >
struct [ [ nodiscard ] ] _Uninitialized_backout {

    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout ( _NoThrowFwdIt _Dest ) : _First ( _Dest ), _Last ( _Dest ) { }

    constexpr _Uninitialized_backout ( _NoThrowFwdIt _First_, _NoThrowFwdIt _Last_ ) : _First ( _First_ ), _Last ( _Last_ ) { }

    _Uninitialized_backout ( const _Uninitialized_backout & ) = delete;
    _Uninitialized_backout & operator = ( const _Uninitialized_backout & ) = delete;

    inline ~ _Uninitialized_backout ( ) {
        _Destroy_range ( _First, _Last );
    }

    template < class ... _Types >
    inline void _Emplace_back ( _Types && ... _Vals ) {

        _Construct_in_place ( * _Last, :: std :: forward < _Types > ( _Vals ) ... );
        ++ _Last;
    }

    constexpr _NoThrowFwdIt _Release ( ) {
        _First = _Last;
        return _Last;
    }
};
#line 1442
template < class _InIt, class _NoThrowFwdIt >
inline _NoThrowFwdIt _Uninitialized_move_unchecked (
    _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest ) {

    if constexpr ( _Ptr_move_cat < _InIt, _NoThrowFwdIt > :: _Really_trivial ) {



        {
            return _Copy_memmove ( _First, _Last, _Dest );
        }
    }
    _Uninitialized_backout < _NoThrowFwdIt > _Backout { _Dest };
    for (; _First != _Last; ++ _First ) {
        _Backout . _Emplace_back ( :: std :: move ( * _First ) );
    }

    return _Backout . _Release ( );
}
#line 1602
template < class _Alloc >
class [ [ nodiscard ] ] _Uninitialized_backout_al {

    using pointer = _Alloc_ptr_t < _Alloc >;

public :
    inline _Uninitialized_backout_al ( pointer _Dest, _Alloc & _Al_ )
        : _First ( _Dest ), _Last ( _Dest ), _Al ( _Al_ ) { }

    _Uninitialized_backout_al ( const _Uninitialized_backout_al & ) = delete;
    _Uninitialized_backout_al & operator = ( const _Uninitialized_backout_al & ) = delete;

    inline ~ _Uninitialized_backout_al ( ) {
        _Destroy_range ( _First, _Last, _Al );
    }

    template < class ... _Types >
    inline void _Emplace_back ( _Types && ... _Vals ) {
        allocator_traits < _Alloc > :: construct ( _Al, _Unfancy ( _Last ), :: std :: forward < _Types > ( _Vals ) ... );
        ++ _Last;
    }

    constexpr pointer _Release ( ) {
        _First = _Last;
        return _Last;
    }

private :
    pointer _First;
    pointer _Last;
    _Alloc & _Al;
};
#line 1635
template < class _InIt, class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_copy (
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t < _Alloc > _Dest, _Alloc & _Al ) {


    using _Ptrval = typename _Alloc :: value_type *;

    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );

    if constexpr ( conjunction_v < bool_constant < _Ptr_copy_cat < decltype ( _UFirst ), _Ptrval > :: _Really_trivial >,
                      _Uses_default_construct < _Alloc, _Ptrval, decltype ( * _UFirst ) >> ) {



        {
            _Copy_memmove ( _UFirst, _ULast, _Unfancy ( _Dest ) );
            _Dest += _ULast - _UFirst;
            return _Dest;
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _Dest, _Al };
    for (; _UFirst != _ULast; ++ _UFirst ) {
        _Backout . _Emplace_back ( * _UFirst );
    }

    return _Backout . _Release ( );
}
#line 1665
template < class _InIt, class _NoThrowFwdIt >
inline _NoThrowFwdIt _Uninitialized_copy_unchecked (
    _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest ) {

    if constexpr ( _Ptr_copy_cat < _InIt, _NoThrowFwdIt > :: _Really_trivial ) {



        {
            return _Copy_memmove ( _First, _Last, _Dest );
        }
    }

    _Uninitialized_backout < _NoThrowFwdIt > _Backout { _Dest };
    for (; _First != _Last; ++ _First ) {
        _Backout . _Emplace_back ( * _First );
    }

    return _Backout . _Release ( );
}
#line 1686
template < class _InIt, class _NoThrowFwdIt >
_NoThrowFwdIt uninitialized_copy ( const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    _Seek_wrapped ( _Dest, _Uninitialized_copy_unchecked ( _UFirst, _ULast, _UDest ) );
    return _Dest;
}
#line 1697
template < class _InIt, class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_move (
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t < _Alloc > _Dest, _Alloc & _Al ) {


    using _Ptrval = typename _Alloc :: value_type *;
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    if constexpr ( conjunction_v < bool_constant < _Ptr_move_cat < decltype ( _UFirst ), _Ptrval > :: _Really_trivial >,
                      _Uses_default_construct < _Alloc, _Ptrval, decltype ( :: std :: move ( * _UFirst ) ) >> ) {



        {
            _Copy_memmove ( _UFirst, _ULast, _Unfancy ( _Dest ) );
            return _Dest + ( _ULast - _UFirst );
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _Dest, _Al };
    for (; _UFirst != _ULast; ++ _UFirst ) {
        _Backout . _Emplace_back ( :: std :: move ( * _UFirst ) );
    }

    return _Backout . _Release ( );
}
#line 1724
template < class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_fill_n (
    _Alloc_ptr_t < _Alloc > _First, _Alloc_size_t < _Alloc > _Count, const typename _Alloc :: value_type & _Val, _Alloc & _Al ) {

    using _Ty = typename _Alloc :: value_type;
    if constexpr ( _Fill_memset_is_safe < _Ty *, _Ty > && _Uses_default_construct < _Alloc, _Ty *, _Ty > :: value ) {



        {
            _Fill_memset ( _Unfancy ( _First ), _Val, static_cast < size_t > ( _Count ) );
            return _First + _Count;
        }
    } else if constexpr ( _Fill_zero_memset_is_safe < _Ty *, _Ty > && _Uses_default_construct < _Alloc, _Ty *, _Ty > :: value ) {



        {
            if ( _Is_all_bits_zero ( _Val ) ) {
                _Fill_zero_memset ( _Unfancy ( _First ), static_cast < size_t > ( _Count ) );
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _First, _Al };
    for (; 0 < _Count; -- _Count ) {
        _Backout . _Emplace_back ( _Val );
    }

    return _Backout . _Release ( );
}
#line 1757
template < class _NoThrowFwdIt, class _Tval >
void uninitialized_fill ( const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval & _Val ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    if constexpr ( _Fill_memset_is_safe < _Unwrapped_t < const _NoThrowFwdIt & >, _Tval > ) {
        _Fill_memset ( _UFirst, _Val, static_cast < size_t > ( _ULast - _UFirst ) );
    } else {
        if constexpr ( _Fill_zero_memset_is_safe < _Unwrapped_t < const _NoThrowFwdIt & >, _Tval > ) {
            if ( _Is_all_bits_zero ( _Val ) ) {
                _Fill_zero_memset ( _UFirst, static_cast < size_t > ( _ULast - _UFirst ) );
                return;
            }
        }

        _Uninitialized_backout < _Unwrapped_t < const _NoThrowFwdIt & >> _Backout { _UFirst };
        while ( _Backout . _Last != _ULast ) {
            _Backout . _Emplace_back ( _Val );
        }

        _Backout . _Release ( );
    }
}
#line 1782
template< class _NoThrowFwdIt> constexpr bool 
#line 1783
_Use_memset_value_construct_v = conjunction_v< bool_constant< _Iterator_is_contiguous< _NoThrowFwdIt> > , is_scalar< _Iter_value_t< _NoThrowFwdIt> > , negation< is_volatile< remove_reference_t< _Iter_ref_t< _NoThrowFwdIt> > > > , negation< is_member_pointer< _Iter_value_t< _NoThrowFwdIt> > > > ; 
#line 1788
template < class _Ptr >
_Ptr _Zero_range ( const _Ptr _First, const _Ptr _Last ) {
    char * const _First_ch = reinterpret_cast < char * > ( _To_address ( _First ) );
    char * const _Last_ch = reinterpret_cast < char * > ( _To_address ( _Last ) );
    :: memset ( _First_ch, 0, static_cast < size_t > ( _Last_ch - _First_ch ) );
    return _Last;
}
#line 1796
template < class _Alloc >
inline _Alloc_ptr_t < _Alloc > _Uninitialized_value_construct_n (
    _Alloc_ptr_t < _Alloc > _First, _Alloc_size_t < _Alloc > _Count, _Alloc & _Al ) {

    using _Ptrty = typename _Alloc :: value_type *;
    if constexpr ( _Use_memset_value_construct_v < _Ptrty > && _Uses_default_construct < _Alloc, _Ptrty > :: value ) {



        {
            auto _PFirst = _Unfancy ( _First );
            _Zero_range ( _PFirst, _PFirst + _Count );
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al < _Alloc > _Backout { _First, _Al };
    for (; 0 < _Count; -- _Count ) {
        _Backout . _Emplace_back ( );
    }

    return _Backout . _Release ( );
}
#line 1820
template < class _NoThrowFwdIt, class _Diff >
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1 ( _NoThrowFwdIt _UFirst, _Diff _Count ) {

    ;
    if constexpr ( _Use_memset_value_construct_v < _NoThrowFwdIt > ) {
        return _Zero_range ( _UFirst, _UFirst + _Count );
    } else {
        _Uninitialized_backout < _NoThrowFwdIt > _Backout { _UFirst };
        for (; 0 < _Count; -- _Count ) {
            _Backout . _Emplace_back ( );
        }

        return _Backout . _Release ( );
    }
}
#line 1837
template < class _Ty >
 [ [ nodiscard ] ] pair < _Ty *, ptrdiff_t > get_temporary_buffer ( ptrdiff_t _Count ) noexcept {
    return _Get_temporary_buffer < _Ty > ( _Count );
}
#line 1842
template < class _Ty >
 void return_temporary_buffer ( _Ty * _Pbuf ) {
    _Return_temporary_buffer ( _Pbuf );
}
#line 1849 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template< class _Key, class ..._Args> 
#line 1850
struct _In_place_key_extract_set { 
#line 1852
static constexpr bool _Extractable = false; 
#line 1853
}; 
#line 1855
template < class _Key >
struct _In_place_key_extract_set < _Key, _Key > {

    static constexpr bool _Extractable = true;
    static const _Key & _Extract ( const _Key & _Val ) noexcept {
        return _Val;
    }
};
#line 1865
template< class _Key, class ..._Args> 
#line 1866
struct _In_place_key_extract_map { 
#line 1868
static constexpr bool _Extractable = false; 
#line 1869
}; 
#line 1871
template < class _Key, class _Second >
struct _In_place_key_extract_map < _Key, _Key, _Second > {

    static constexpr bool _Extractable = true;
    static const _Key & _Extract ( const _Key & _Val, const _Second & ) noexcept {
        return _Val;
    }
};
#line 1880
template < class _Key, class _First, class _Second >
struct _In_place_key_extract_map < _Key, pair < _First, _Second > > {

    static constexpr bool _Extractable = is_same_v < _Key, _Remove_cvref_t < _First >>;
    static const _Key & _Extract ( const pair < _First, _Second > & _Val ) {
        return _Val . first;
    }
};
#line 1889
#pragma warning(push)
#pragma warning(disable : 4624)
template< class _Ty> 
#line 1892
struct _Wrap { 
#line 1893
_Ty _Value; 
#line 1894
}; 
#pragma warning(pop)
#line 1897
template < class _Alloc >
struct _Alloc_temporary2 {
    using value_type = typename _Alloc :: value_type;
    using _Traits = allocator_traits < _Alloc >;

    _Alloc & _Al;














    union {
        value_type _Value;
    };

    [ [ nodiscard ] ] inline value_type & _Get_value ( ) noexcept {
        return _Value;
    }

    [ [ nodiscard ] ] inline const value_type & _Get_value ( ) const noexcept {
        return _Value;
    }


    template < class ... _Args >
    inline explicit _Alloc_temporary2 ( _Alloc & _Al_, _Args && ... _Vals ) noexcept (
        noexcept ( _Traits :: construct ( _Al_, :: std :: addressof ( _Get_value ( ) ), :: std :: forward < _Args > ( _Vals ) ... ) ) )
        : _Al ( _Al_ ) {
        _Traits :: construct ( _Al, :: std :: addressof ( _Get_value ( ) ), :: std :: forward < _Args > ( _Vals ) ... );
    }

    _Alloc_temporary2 ( const _Alloc_temporary2 & ) = delete;
    _Alloc_temporary2 & operator = ( const _Alloc_temporary2 & ) = delete;

    inline ~ _Alloc_temporary2 ( ) {
        _Traits :: destroy ( _Al, :: std :: addressof ( _Get_value ( ) ) );
    }
};
#line 1945 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
template < class _Alloc >
[ [ nodiscard ] ] constexpr bool _Allocators_equal ( const _Alloc & _Lhs, const _Alloc & _Rhs ) noexcept {
    if constexpr ( allocator_traits < _Alloc > :: is_always_equal :: value ) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}
#line 1954
template < class _FwdIt, class _Ty >
[ [ nodiscard ] ] inline _FwdIt remove ( _FwdIt _First, const _FwdIt _Last, const _Ty & _Val ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    _UFirst = _Find_unchecked ( _UFirst, _ULast, _Val );
    auto _UNext = _UFirst;
    if ( _UFirst != _ULast ) {
        while ( ++ _UFirst != _ULast ) {
            if ( ! ( * _UFirst == _Val ) ) {
                * _UNext = :: std :: move ( * _UFirst );
                ++ _UNext;
            }
        }
    }

    _Seek_wrapped ( _First, _UNext );
    return _First;
}
#line 1975
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] inline _FwdIt remove_if ( _FwdIt _First, const _FwdIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    _UFirst = :: std :: find_if ( _UFirst, _ULast, _Pass_fn ( _Pred ) );
    auto _UNext = _UFirst;
    if ( _UFirst != _ULast ) {
        while ( ++ _UFirst != _ULast ) {
            if ( ! _Pred ( * _UFirst ) ) {
                * _UNext = :: std :: move ( * _UFirst );
                ++ _UNext;
            }
        }
    }

    _Seek_wrapped ( _First, _UNext );
    return _First;
}
#line 1996
template < class _Container, class _Uty >
inline typename _Container :: size_type _Erase_remove ( _Container & _Cont, const _Uty & _Val ) {

    auto _First = _Cont . begin ( );
    const auto _Last = _Cont . end ( );
    const auto _Old_size = _Cont . size ( );
    _Seek_wrapped ( _First, :: std :: remove ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Val ) );
    _Cont . erase ( _First, _Last );
    return _Old_size - _Cont . size ( );
}
#line 2007
template < class _Container, class _Pr >
inline typename _Container :: size_type _Erase_remove_if ( _Container & _Cont, _Pr _Pred ) {

    auto _First = _Cont . begin ( );
    const auto _Last = _Cont . end ( );
    const auto _Old_size = _Cont . size ( );
    _Seek_wrapped ( _First, :: std :: remove_if ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Pred ) );
    _Cont . erase ( _First, _Last );
    return _Old_size - _Cont . size ( );
}
#line 2018
template < class _Container, class _Pr >
typename _Container :: size_type _Erase_nodes_if ( _Container & _Cont, _Pr _Pred ) {

    auto _First = _Cont . begin ( );
    const auto _Last = _Cont . end ( );
    const auto _Old_size = _Cont . size ( );
    while ( _First != _Last ) {
        if ( _Pred ( * _First ) ) {
            _First = _Cont . erase ( _First );
        } else {
            ++ _First;
        }
    }
    return _Old_size - _Cont . size ( );
}
#line 2125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
}
#line 2129
#pragma warning(pop)
#pragma pack ( pop )
#line 2133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
namespace std { 
#line 34
template < class _Elem, class _Int_type >
struct _Char_traits {
    using char_type = _Elem;
    using int_type = _Int_type;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = _Mbstatet;






    static inline _Elem * copy ( _Elem * const _First1,
          const _Elem * const _First2, const size_t _Count ) noexcept {















        :: memcpy ( _First1, _First2, _Count * sizeof ( _Elem ) );


        return _First1;
    }

      static inline _Elem * _Copy_s (
                                                                                 _Elem * const _First1,
        const size_t _Dest_size, const _Elem * const _First2, const size_t _Count ) noexcept {

        do { if ( _Count <= _Dest_size ) { } else { do {; :: _invalid_parameter_noinfo_noreturn ( ); } while ( false ); }; } while ( false );
        return copy ( _First1, _First2, _Count );
    }

    static inline _Elem * move ( _Elem * const _First1,
          const _Elem * const _First2, const size_t _Count ) noexcept {









































        :: memmove ( _First1, _First2, _Count * sizeof ( _Elem ) );


        return _First1;
    }




    [ [ nodiscard ] ] static inline int compare ( const _Elem * _First1,
          const _Elem * _First2, size_t _Count ) noexcept {

        for (; 0 < _Count; -- _Count, ++ _First1, ++ _First2 ) {
            if ( * _First1 != * _First2 ) {
                return * _First1 < * _First2 ? - 1 : + 1;
            }
        }

        return 0;
    }

    [ [ nodiscard ] ] static inline size_t length ( const _Elem * _First ) noexcept {

        size_t _Count = 0;
        while ( * _First != _Elem ( ) ) {
            ++ _Count;
            ++ _First;
        }

        return _Count;
    }

    [ [ nodiscard ] ] static inline const _Elem * find (
          const _Elem * _First, size_t _Count, const _Elem & _Ch ) noexcept {

        for (; 0 < _Count; -- _Count, ++ _First ) {
            if ( * _First == _Ch ) {
                return _First;
            }
        }

        return nullptr;
    }

    static inline _Elem * assign (
          _Elem * const _First, size_t _Count, const _Elem _Ch ) noexcept {








        {
            for ( _Elem * _Next = _First; _Count > 0; -- _Count, ++ _Next ) {
                * _Next = _Ch;
            }
        }

        return _First;
    }

    static inline void assign ( _Elem & _Left, const _Elem & _Right ) noexcept {





        {
            _Left = _Right;
        }
    }

    [ [ nodiscard ] ] static constexpr bool eq ( const _Elem & _Left, const _Elem & _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr bool lt ( const _Elem & _Left, const _Elem & _Right ) noexcept {
        return _Left < _Right;
    }

    [ [ nodiscard ] ] static constexpr _Elem to_char_type ( const int_type & _Meta ) noexcept {
        return static_cast < _Elem > ( _Meta );
    }

    [ [ nodiscard ] ] static constexpr int_type to_int_type ( const _Elem & _Ch ) noexcept {
        return static_cast < int_type > ( _Ch );
    }

    [ [ nodiscard ] ] static constexpr bool eq_int_type ( const int_type & _Left, const int_type & _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr int_type not_eof ( const int_type & _Meta ) noexcept {
        return _Meta != eof ( ) ? _Meta : ! eof ( );
    }

    [ [ nodiscard ] ] static constexpr int_type eof ( ) noexcept {
        return static_cast < int_type > ( ( - 1 ) );
    }
};
#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template < class _Elem >
struct _WChar_traits : private _Char_traits < _Elem, unsigned short > {

private :
    using _Primary_char_traits = _Char_traits < _Elem, unsigned short >;

public :
    using char_type = _Elem;
    using int_type = unsigned short;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = mbstate_t;




    using _Primary_char_traits :: _Copy_s;
    using _Primary_char_traits :: copy;
    using _Primary_char_traits :: move;

    [ [ nodiscard ] ] static inline int compare ( const _Elem * const _First1,
          const _Elem * const _First2, const size_t _Count ) noexcept {








        return :: wmemcmp (
            reinterpret_cast < const wchar_t * > ( _First1 ), reinterpret_cast < const wchar_t * > ( _First2 ), _Count );

    }

    [ [ nodiscard ] ] static inline size_t length ( const _Elem * _First ) noexcept {








        return :: wcslen ( reinterpret_cast < const wchar_t * > ( _First ) );

    }

    [ [ nodiscard ] ] static inline const _Elem * find (
          const _Elem * _First, const size_t _Count, const _Elem & _Ch ) noexcept {








        return reinterpret_cast < const _Elem * > ( :: wmemchr ( reinterpret_cast < const wchar_t * > ( _First ), _Ch, _Count ) );

    }

    static inline _Elem * assign (
          _Elem * const _First, size_t _Count, const _Elem _Ch ) noexcept {







        return reinterpret_cast < _Elem * > ( :: wmemset ( reinterpret_cast < wchar_t * > ( _First ), _Ch, _Count ) );
    }

    static inline void assign ( _Elem & _Left, const _Elem & _Right ) noexcept {
        _Left = _Right;
    }

    [ [ nodiscard ] ] static constexpr bool eq ( const _Elem & _Left, const _Elem & _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr bool lt ( const _Elem & _Left, const _Elem & _Right ) noexcept {
        return _Left < _Right;
    }

    [ [ nodiscard ] ] static constexpr _Elem to_char_type ( const int_type & _Meta ) noexcept {
        return _Meta;
    }

    [ [ nodiscard ] ] static constexpr int_type to_int_type ( const _Elem & _Ch ) noexcept {
        return _Ch;
    }

    [ [ nodiscard ] ] static constexpr bool eq_int_type ( const int_type & _Left, const int_type & _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr int_type not_eof ( const int_type & _Meta ) noexcept {
        return _Meta != eof ( ) ? _Meta : static_cast < int_type > ( ! eof ( ) );
    }

    [ [ nodiscard ] ] static constexpr int_type eof ( ) noexcept {
        return ( ( wint_t ) ( 65535 ) );
    }
};
#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template< class _Elem> 
#line 332
struct char_traits : public _Char_traits< _Elem, long>  { }; 
#line 335
template<> struct char_traits< char16_t>  : public _WChar_traits< char16_t>  { }; 
#line 337
using u16streampos = streampos; 
#line 340
template<> struct char_traits< char32_t>  : public _Char_traits< char32_t, unsigned>  { }; 
#line 342
using u32streampos = streampos; 
#line 345
template<> struct char_traits< __wchar_t>  : public _WChar_traits< __wchar_t>  { }; 
#line 349
template<> struct char_traits< unsigned short>  : public _WChar_traits< unsigned short>  { }; 
#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template < class _Elem, class _Int_type >
struct _Narrow_char_traits : private _Char_traits < _Elem, _Int_type > {

private :
    using _Primary_char_traits = _Char_traits < _Elem, _Int_type >;

public :
    using char_type = _Elem;
    using int_type = _Int_type;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = mbstate_t;




    using _Primary_char_traits :: _Copy_s;
    using _Primary_char_traits :: copy;
    using _Primary_char_traits :: move;

    [ [ nodiscard ] ] static inline int compare ( const _Elem * const _First1,
          const _Elem * const _First2, const size_t _Count ) noexcept {




        return :: memcmp ( _First1, _First2, _Count );

    }

    [ [ nodiscard ] ] static inline size_t length ( const _Elem * const _First ) noexcept {















        return :: strlen ( reinterpret_cast < const char * > ( _First ) );

    }

    [ [ nodiscard ] ] static inline const _Elem * find ( const _Elem * const _First, const size_t _Count,
        const _Elem & _Ch ) noexcept {















        return static_cast < const _Elem * > ( :: memchr ( _First, _Ch, _Count ) );

    }

    static inline _Elem * assign (
          _Elem * const _First, size_t _Count, const _Elem _Ch ) noexcept {







        return static_cast < _Elem * > ( :: memset ( _First, _Ch, _Count ) );
    }

    static inline void assign ( _Elem & _Left, const _Elem & _Right ) noexcept {
        _Left = _Right;
    }

    [ [ nodiscard ] ] static constexpr bool eq ( const _Elem & _Left, const _Elem & _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr bool lt ( const _Elem & _Left, const _Elem & _Right ) noexcept {
        return static_cast < unsigned char > ( _Left ) < static_cast < unsigned char > ( _Right );
    }

    [ [ nodiscard ] ] static constexpr _Elem to_char_type ( const int_type & _Meta ) noexcept {
        return static_cast < _Elem > ( _Meta );
    }

    [ [ nodiscard ] ] static constexpr int_type to_int_type ( const _Elem & _Ch ) noexcept {
        return static_cast < unsigned char > ( _Ch );
    }

    [ [ nodiscard ] ] static constexpr bool eq_int_type ( const int_type & _Left, const int_type & _Right ) noexcept {
        return _Left == _Right;
    }

    [ [ nodiscard ] ] static constexpr int_type not_eof ( const int_type & _Meta ) noexcept {
        return _Meta != eof ( ) ? _Meta : ! eof ( );
    }

    [ [ nodiscard ] ] static constexpr int_type eof ( ) noexcept {
        return static_cast < int_type > ( ( - 1 ) );
    }
};
#line 478 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template<> struct char_traits< char>  : public _Narrow_char_traits< char, int>  { }; 
#line 489
template < class _Elem, class _Traits, class _SizeT >
basic_ostream < _Elem, _Traits > & _Insert_string (
    basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * const _Data, const _SizeT _Size ) {

    using _Ostr_t = basic_ostream < _Elem, _Traits >;
    typename _Ostr_t :: iostate _State = _Ostr_t :: goodbit;

    _SizeT _Pad;
    if ( _Ostr . width ( ) <= 0 || static_cast < _SizeT > ( _Ostr . width ( ) ) <= _Size ) {
        _Pad = 0;
    } else {
        _Pad = static_cast < _SizeT > ( _Ostr . width ( ) ) - _Size;
    }

    const typename _Ostr_t :: sentry _Ok ( _Ostr );

    if ( ! _Ok ) {
        _State |= _Ostr_t :: badbit;
    } else {
        try {
        if ( ( _Ostr . flags ( ) & _Ostr_t :: adjustfield ) != _Ostr_t :: left ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= _Ostr_t :: badbit;
                    break;
                }
            }
        }

        if ( _State == _Ostr_t :: goodbit
            && _Ostr . rdbuf ( ) -> sputn ( _Data, static_cast < streamsize > ( _Size ) ) != static_cast < streamsize > ( _Size ) ) {
            _State |= _Ostr_t :: badbit;
        } else {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= _Ostr_t :: badbit;
                    break;
                }
            }
        }

        _Ostr . width ( 0 );
        } catch ( ... ) { ( _Ostr ) . setstate ( _Ostr_t :: badbit, true ); }
    }

    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 538
template < class _Traits >
struct _Char_traits_eq {
    using _Elem = typename _Traits :: char_type;

    bool operator ( ) ( _Elem _Left, _Elem _Right ) const {
        return _Traits :: eq ( _Left, _Right );
    }
};
#line 547
template < class _Traits >
struct _Char_traits_lt {
    using _Elem = typename _Traits :: char_type;

    bool operator ( ) ( _Elem _Left, _Elem _Right ) const {
        return _Traits :: lt ( _Left, _Right );
    }
};
#line 558
template< class _Elem> constexpr bool 
#line 559
_Pred_is_consistent_with_memcmp< _Elem, _Elem, _Char_traits_eq< char_traits< _Elem> > >  = true; 
#line 561
template< class _Traits> using _Traits_ch_t = typename _Traits::char_type; 
#line 564
template< class _Traits> using _Traits_ptr_t = const typename _Traits::char_type *; 
#line 567
template < class _Traits >
constexpr bool _Traits_equal ( const _Traits_ptr_t < _Traits > _Left, const size_t _Left_size,
      const _Traits_ptr_t < _Traits > _Right, const size_t _Right_size ) noexcept {

    return _Left_size == _Right_size && _Traits :: compare ( _Left, _Right, _Left_size ) == 0;
}
#line 574
template < class _Traits >
constexpr int _Traits_compare ( const _Traits_ptr_t < _Traits > _Left, const size_t _Left_size,
      const _Traits_ptr_t < _Traits > _Right, const size_t _Right_size ) noexcept {

    const int _Ans = _Traits :: compare ( _Left, _Right, ( :: std :: min ) ( _Left_size, _Right_size ) );

    if ( _Ans != 0 ) {
        return _Ans;
    }

    if ( _Left_size < _Right_size ) {
        return - 1;
    }

    if ( _Left_size > _Right_size ) {
        return 1;
    }

    return 0;
}
#line 595
template < class _Traits >
constexpr size_t _Traits_find ( const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size ) noexcept {

    if ( _Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size ) {








        return static_cast < size_t > ( - 1 );
    }

    if ( _Needle_size == 0 ) {
        return _Start_at;
    }

    const auto _Possible_matches_end = _Haystack + ( _Hay_size - _Needle_size ) + 1;
    for ( auto _Match_try = _Haystack + _Start_at;; ++ _Match_try ) {
        _Match_try = _Traits :: find ( _Match_try, static_cast < size_t > ( _Possible_matches_end - _Match_try ), * _Needle );
        if ( ! _Match_try ) {
            return static_cast < size_t > ( - 1 );
        }

        if ( _Traits :: compare ( _Match_try, _Needle, _Needle_size ) == 0 ) {
            return static_cast < size_t > ( _Match_try - _Haystack );
        }
    }
}
#line 629
template < class _Traits >
constexpr size_t _Traits_find_ch ( const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t < _Traits > _Ch ) noexcept {

    if ( _Start_at < _Hay_size ) {
        const auto _Found_at = _Traits :: find ( _Haystack + _Start_at, _Hay_size - _Start_at, _Ch );
        if ( _Found_at ) {
            return static_cast < size_t > ( _Found_at - _Haystack );
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 643
template < class _Traits >
constexpr size_t _Traits_rfind ( const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size ) noexcept {

    if ( _Needle_size == 0 ) {
        return ( :: std :: min ) ( _Start_at, _Hay_size );
    }

    if ( _Needle_size <= _Hay_size ) {
        for ( auto _Match_try = _Haystack + ( :: std :: min ) ( _Start_at, _Hay_size - _Needle_size );; -- _Match_try ) {
            if ( _Traits :: eq ( * _Match_try, * _Needle ) && _Traits :: compare ( _Match_try, _Needle, _Needle_size ) == 0 ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }

            if ( _Match_try == _Haystack ) {
                break;
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 667
template < class _Traits >
constexpr size_t _Traits_rfind_ch ( const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t < _Traits > _Ch ) noexcept {

    if ( _Hay_size != 0 ) {
        for ( auto _Match_try = _Haystack + ( :: std :: min ) ( _Start_at, _Hay_size - 1 );; -- _Match_try ) {
            if ( _Traits :: eq ( * _Match_try, _Ch ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }

            if ( _Match_try == _Haystack ) {
                break;
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 686
template < class _Elem, bool = _Is_character < _Elem > :: value >
class _String_bitmap {
public :
    constexpr bool _Mark ( const _Elem * _First, const _Elem * const _Last ) {


        for (; _First != _Last; ++ _First ) {
            _Matches [ static_cast < unsigned char > ( * _First ) ] = true;
        }

        return true;
    }

    constexpr bool _Match ( const _Elem _Ch ) const {
        return _Matches [ static_cast < unsigned char > ( _Ch ) ];
    }

private :
    bool _Matches [ 256 ] = { };
};
#line 707
template < class _Elem >
class _String_bitmap < _Elem, false > {
public :
    static_assert ( is_unsigned_v < _Elem >,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. Visual C++ accepts oth" "er unsigned integral types as an extension."
                                                                           );

    constexpr bool _Mark ( const _Elem * _First, const _Elem * const _Last ) {


        for (; _First != _Last; ++ _First ) {
            const auto _Ch = * _First;
            if ( _Ch >= 256U ) {
                return false;
            }

            _Matches [ static_cast < unsigned char > ( _Ch ) ] = true;
        }

        return true;
    }

    constexpr bool _Match ( const _Elem _Ch ) const {
        return _Ch < 256U && _Matches [ _Ch ];
    }

private :
    bool _Matches [ 256 ] = { };
};
#line 737
template < class _Traits >
constexpr size_t _Traits_find_first_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size, false_type ) noexcept {


    if ( _Needle_size != 0 && _Start_at < _Hay_size ) {
        const auto _End = _Haystack + _Hay_size;
        for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try ) {
            if ( _Traits :: find ( _Needle, _Needle_size, * _Match_try ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 755
template < class _Traits >
constexpr size_t _Traits_find_first_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size, true_type ) noexcept {


    if ( _Needle_size != 0 && _Start_at < _Hay_size ) {
        _String_bitmap < typename _Traits :: char_type > _Matches;
        if ( ! _Matches . _Mark ( _Needle, _Needle + _Needle_size ) ) {

            return _Traits_find_first_of < _Traits > ( _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type { } );
        }

        const auto _End = _Haystack + _Hay_size;
        for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try ) {
            if ( _Matches . _Match ( * _Match_try ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 779
template < class _Traits >
constexpr size_t _Traits_find_last_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size, false_type ) noexcept {


    if ( _Needle_size != 0 && _Hay_size != 0 ) {
        for ( auto _Match_try = _Haystack + ( :: std :: min ) ( _Start_at, _Hay_size - 1 );; -- _Match_try ) {
            if ( _Traits :: find ( _Needle, _Needle_size, * _Match_try ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }

            if ( _Match_try == _Haystack ) {
                break;
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 800
template < class _Traits >
constexpr size_t _Traits_find_last_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size, true_type ) noexcept {


    if ( _Needle_size != 0 && _Hay_size != 0 ) {
        _String_bitmap < typename _Traits :: char_type > _Matches;
        if ( ! _Matches . _Mark ( _Needle, _Needle + _Needle_size ) ) {

            return _Traits_find_last_of < _Traits > ( _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type { } );
        }

        for ( auto _Match_try = _Haystack + ( :: std :: min ) ( _Start_at, _Hay_size - 1 );; -- _Match_try ) {
            if ( _Matches . _Match ( * _Match_try ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }

            if ( _Match_try == _Haystack ) {
                break;
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 827
template < class _Traits >
constexpr size_t _Traits_find_first_not_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size, false_type ) noexcept {


    if ( _Start_at < _Hay_size ) {
        const auto _End = _Haystack + _Hay_size;
        for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try ) {
            if ( ! _Traits :: find ( _Needle, _Needle_size, * _Match_try ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 845
template < class _Traits >
constexpr size_t _Traits_find_first_not_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size, true_type ) noexcept {


    if ( _Start_at < _Hay_size ) {
        _String_bitmap < typename _Traits :: char_type > _Matches;
        if ( ! _Matches . _Mark ( _Needle, _Needle + _Needle_size ) ) {

            return _Traits_find_first_not_of < _Traits > (
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type { } );
        }

        const auto _End = _Haystack + _Hay_size;
        for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try ) {
            if ( ! _Matches . _Match ( * _Match_try ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 870
template < class _Traits >
constexpr size_t _Traits_find_not_ch ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t < _Traits > _Ch ) noexcept {

    if ( _Start_at < _Hay_size ) {
        const auto _End = _Haystack + _Hay_size;
        for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try ) {
            if ( ! _Traits :: eq ( * _Match_try, _Ch ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 886
template < class _Traits >
constexpr size_t _Traits_find_last_not_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size, false_type ) noexcept {


    if ( _Hay_size != 0 ) {
        for ( auto _Match_try = _Haystack + ( :: std :: min ) ( _Start_at, _Hay_size - 1 );; -- _Match_try ) {
            if ( ! _Traits :: find ( _Needle, _Needle_size, * _Match_try ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }

            if ( _Match_try == _Haystack ) {
                break;
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 907
template < class _Traits >
constexpr size_t _Traits_find_last_not_of ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t < _Traits > _Needle,
    const size_t _Needle_size, true_type ) noexcept {


    if ( _Hay_size != 0 ) {
        _String_bitmap < typename _Traits :: char_type > _Matches;
        if ( ! _Matches . _Mark ( _Needle, _Needle + _Needle_size ) ) {

            return _Traits_find_last_not_of < _Traits > (
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type { } );
        }

        for ( auto _Match_try = _Haystack + ( :: std :: min ) ( _Start_at, _Hay_size - 1 );; -- _Match_try ) {
            if ( ! _Matches . _Match ( * _Match_try ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }

            if ( _Match_try == _Haystack ) {
                break;
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 935
template < class _Traits >
constexpr size_t _Traits_rfind_not_ch ( const _Traits_ptr_t < _Traits > _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t < _Traits > _Ch ) noexcept {

    if ( _Hay_size != 0 ) {
        for ( auto _Match_try = _Haystack + ( :: std :: min ) ( _Start_at, _Hay_size - 1 );; -- _Match_try ) {
            if ( ! _Traits :: eq ( * _Match_try, _Ch ) ) {
                return static_cast < size_t > ( _Match_try - _Haystack );
            }

            if ( _Match_try == _Haystack ) {
                break;
            }
        }
    }

    return static_cast < size_t > ( - 1 );
}
#line 1874 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template < class _Mystr >
class _String_const_iterator : public _Iterator_base {
public :



    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Mystr :: value_type;
    using difference_type = typename _Mystr :: difference_type;
    using pointer = typename _Mystr :: const_pointer;
    using reference = const value_type &;

    inline _String_const_iterator ( ) noexcept : _Ptr ( ) { }

    inline _String_const_iterator ( pointer _Parg, const _Container_base * _Pstring ) noexcept
        : _Ptr ( _Parg ) {
        this -> _Adopt ( _Pstring );
    }

    [ [ nodiscard ] ] inline reference operator * ( ) const noexcept {











        ;
        return * _Ptr;
    }

    [ [ nodiscard ] ] inline pointer operator -> ( ) const noexcept {
        return pointer_traits < pointer > :: pointer_to ( * * this );
    }

    inline _String_const_iterator & operator ++ ( ) noexcept {








        ++ _Ptr;
        return * this;
    }

    inline _String_const_iterator operator ++ ( int ) noexcept {
        _String_const_iterator _Tmp = * this;
        ++ * this;
        return _Tmp;
    }

    inline _String_const_iterator & operator -- ( ) noexcept {








        -- _Ptr;
        return * this;
    }

    inline _String_const_iterator operator -- ( int ) noexcept {
        _String_const_iterator _Tmp = * this;
        -- * this;
        return _Tmp;
    }

    inline void _Verify_offset ( const difference_type _Off ) const noexcept {






















        ( void ) _Off;

    }

    inline _String_const_iterator & operator += ( const difference_type _Off ) noexcept {



        _Ptr += _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline _String_const_iterator operator + ( const difference_type _Off ) const noexcept {
        _String_const_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _String_const_iterator & operator -= ( const difference_type _Off ) noexcept {
        return * this += - _Off;
    }

    [ [ nodiscard ] ] inline _String_const_iterator operator - ( const difference_type _Off ) const noexcept {
        _String_const_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline difference_type operator - ( const _String_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return _Ptr - _Right . _Ptr;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] inline bool operator == ( const _String_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return _Ptr == _Right . _Ptr;
    }







    [ [ nodiscard ] ] bool operator != ( const _String_const_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] bool operator < ( const _String_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return _Ptr < _Right . _Ptr;
    }

    [ [ nodiscard ] ] bool operator > ( const _String_const_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] bool operator <= ( const _String_const_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] bool operator >= ( const _String_const_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }


    inline void _Compat ( const _String_const_iterator & _Right ) const noexcept {





        ( void ) _Right;

    }









    using _Prevent_inheriting_unwrap = _String_const_iterator;

    [ [ nodiscard ] ] inline const value_type * _Unwrapped ( ) const noexcept {
        return _Unfancy ( _Ptr );
    }

    inline void _Seek_to ( const value_type * _It ) noexcept {
        _Ptr = _Refancy < pointer > ( const_cast < value_type * > ( _It ) );
    }

    pointer _Ptr;
};
#line 2075 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template < class _Mystr >
[ [ nodiscard ] ] inline _String_const_iterator < _Mystr > operator + (
    typename _String_const_iterator < _Mystr > :: difference_type _Off, _String_const_iterator < _Mystr > _Next ) noexcept {
    return _Next += _Off;
}
#line 2112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template < class _Mystr >
class _String_iterator : public _String_const_iterator < _Mystr > {
public :
    using _Mybase = _String_const_iterator < _Mystr >;




    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Mystr :: value_type;
    using difference_type = typename _Mystr :: difference_type;
    using pointer = typename _Mystr :: pointer;
    using reference = value_type &;

    using _Mybase :: _Mybase;

    [ [ nodiscard ] ] inline reference operator * ( ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator * ( ) );
    }

    [ [ nodiscard ] ] inline pointer operator -> ( ) const noexcept {
        return pointer_traits < pointer > :: pointer_to ( * * this );
    }

    inline _String_iterator & operator ++ ( ) noexcept {
        _Mybase :: operator ++ ( );
        return * this;
    }

    inline _String_iterator operator ++ ( int ) noexcept {
        _String_iterator _Tmp = * this;
        _Mybase :: operator ++ ( );
        return _Tmp;
    }

    inline _String_iterator & operator -- ( ) noexcept {
        _Mybase :: operator -- ( );
        return * this;
    }

    inline _String_iterator operator -- ( int ) noexcept {
        _String_iterator _Tmp = * this;
        _Mybase :: operator -- ( );
        return _Tmp;
    }

    inline _String_iterator & operator += ( const difference_type _Off ) noexcept {
        _Mybase :: operator += ( _Off );
        return * this;
    }

    [ [ nodiscard ] ] inline _String_iterator operator + ( const difference_type _Off ) const noexcept {
        _String_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _String_iterator & operator -= ( const difference_type _Off ) noexcept {
        _Mybase :: operator -= ( _Off );
        return * this;
    }

    using _Mybase :: operator -;

    [ [ nodiscard ] ] inline _String_iterator operator - ( const difference_type _Off ) const noexcept {
        _String_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator [ ] ( _Off ) );
    }

    using _Prevent_inheriting_unwrap = _String_iterator;

    [ [ nodiscard ] ] inline value_type * _Unwrapped ( ) const noexcept {
        return const_cast < value_type * > ( _Unfancy ( this -> _Ptr ) );
    }
};
#line 2193
template < class _Mystr >
[ [ nodiscard ] ] inline _String_iterator < _Mystr > operator + (
    typename _String_iterator < _Mystr > :: difference_type _Off, _String_iterator < _Mystr > _Next ) noexcept {
    return _Next += _Off;
}
#line 2230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template< class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class 
#line 2231
_Reference, class _Const_reference> 
#line 2232
struct _String_iter_types { 
#line 2233
using value_type = _Value_type; 
#line 2234
using size_type = _Size_type; 
#line 2235
using difference_type = _Difference_type; 
#line 2236
using pointer = _Pointer; 
#line 2237
using const_pointer = _Const_pointer; 
#line 2238
}; 
#line 2240
template < class _Val_types >
class _String_val : public _Container_base {
public :
    using value_type = typename _Val_types :: value_type;
    using size_type = typename _Val_types :: size_type;
    using difference_type = typename _Val_types :: difference_type;
    using pointer = typename _Val_types :: pointer;
    using const_pointer = typename _Val_types :: const_pointer;
    using reference = value_type &;
    using const_reference = const value_type &;

    inline _String_val ( ) noexcept : _Bx ( ) { }


    static constexpr size_type _BUF_SIZE = 16 / sizeof ( value_type ) < 1 ? 1 : 16 / sizeof ( value_type );

    static constexpr size_type _ALLOC_MASK = sizeof ( value_type ) <= 1 ? 15
                                           : sizeof ( value_type ) <= 2 ? 7
                                           : sizeof ( value_type ) <= 4 ? 3
                                           : sizeof ( value_type ) <= 8 ? 1
                                                                     : 0;

    inline value_type * _Myptr ( ) noexcept {
        value_type * _Result = _Bx . _Buf;
        if ( _Large_string_engaged ( ) ) {
            _Result = _Unfancy ( _Bx . _Ptr );
        }

        return _Result;
    }

    inline const value_type * _Myptr ( ) const noexcept {
        const value_type * _Result = _Bx . _Buf;
        if ( _Large_string_engaged ( ) ) {
            _Result = _Unfancy ( _Bx . _Ptr );
        }

        return _Result;
    }

    inline bool _Large_string_engaged ( ) const noexcept {





        return _BUF_SIZE <= _Myres;
    }

    inline void _Check_offset ( const size_type _Off ) const {

        if ( _Mysize < _Off ) {
            _Xran ( );
        }
    }

    inline void _Check_offset_exclusive ( const size_type _Off ) const {

        if ( _Mysize <= _Off ) {
            _Xran ( );
        }
    }

    [ [ noreturn ] ] static void _Xran ( ) {
        _Xout_of_range ( "invalid string position" );
    }

    inline size_type _Clamp_suffix_size ( const size_type _Off, const size_type _Size ) const noexcept {

        return ( :: std :: min ) ( _Size, _Mysize - _Off );
    }

    union _Bxty {
        inline _Bxty ( ) noexcept : _Ptr ( ) { }

        inline ~ _Bxty ( ) noexcept { }

        value_type _Buf [ _BUF_SIZE ];
        pointer _Ptr;
        char _Alias [ _BUF_SIZE ];
    } _Bx;

    size_type _Mysize = 0;
    size_type _Myres = 0;
};
#line 2326
template< class _Ty> constexpr size_t 
#line 2327
_Size_after_ebco_v = (is_empty_v< _Ty> ) ? 0 : sizeof(_Ty); 
#line 2329
struct _String_constructor_concat_tag { 
#line 2331
explicit _String_constructor_concat_tag() = default;
#line 2332
}; 
#line 2334
struct _String_constructor_rvalue_allocator_tag { 
#line 2336
explicit _String_constructor_rvalue_allocator_tag() = default;
#line 2337
}; 
#line 2339
[[noreturn]] inline void _Xlen_string() { 
#line 2340
_Xlength_error("string too long"); 
#line 2341
} 
#line 2343
template < class _Elem, class _Traits = char_traits < _Elem >, class _Alloc = allocator < _Elem > >
class basic_string {
private :
    friend _Tidy_deallocate_guard < basic_string >;
    friend basic_stringbuf < _Elem, _Traits, _Alloc >;

    using _Alty = _Rebind_alloc_t < _Alloc, _Elem >;
    using _Alty_traits = allocator_traits < _Alty >;

    using _Scary_val = _String_val < conditional_t < _Is_simple_alloc_v < _Alty >, _Simple_types < _Elem >,
        _String_iter_types < _Elem, typename _Alty_traits :: size_type, typename _Alty_traits :: difference_type,
            typename _Alty_traits :: pointer, typename _Alty_traits :: const_pointer, _Elem &, const _Elem & >> >;

    static_assert ( ! 0 || is_same_v < _Elem, typename _Alloc :: value_type >,
        "basic_string<T, Traits, Allocator> requires that Allocator\'s value_type match T (See N4659 26.2.1 [container.requirements.gener" "al]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic." "" );

    static_assert ( is_same_v < _Elem, typename _Traits :: char_type >,
        "N4659 24.3.2.1 [string.require]/3 requires that the supplied char_traits character type match the string\'s character type."
                                                                       );

    static_assert ( ! is_array_v < _Elem > && is_trivial_v < _Elem > && is_standard_layout_v < _Elem >,
        "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 [strings.general]/1."
                              );

public :
    using traits_type = _Traits;
    using allocator_type = _Alloc;

    using value_type = _Elem;
    using size_type = typename _Alty_traits :: size_type;
    using difference_type = typename _Alty_traits :: difference_type;
    using pointer = typename _Alty_traits :: pointer;
    using const_pointer = typename _Alty_traits :: const_pointer;
    using reference = value_type &;
    using const_reference = const value_type &;

    using iterator = _String_iterator < _Scary_val >;
    using const_iterator = _String_const_iterator < _Scary_val >;

    using reverse_iterator = :: std :: reverse_iterator < iterator >;
    using const_reverse_iterator = :: std :: reverse_iterator < const_iterator >;

private :
    static constexpr auto _BUF_SIZE = _Scary_val :: _BUF_SIZE;
    static constexpr auto _ALLOC_MASK = _Scary_val :: _ALLOC_MASK;











    static constexpr bool _Can_memcpy_val = _Is_specialization_v < _Traits, char_traits > && is_trivial_v < pointer >;

    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v < _Container_base >;
    static constexpr size_t _Memcpy_val_size = sizeof ( _Scary_val ) - _Memcpy_val_offset;

    template < class _Iter >
    using _Is_elem_cptr = bool_constant < _Is_any_of_v < _Iter, const _Elem * const, _Elem * const, const _Elem *, _Elem * >>;









public :
    inline basic_string ( const basic_string & _Right )
        : _Mypair ( _One_then_variadic_args_t { }, _Alty_traits :: select_on_container_copy_construction ( _Right . _Getal ( ) ) ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Construct_lv_contents ( _Right );
        _Proxy . _Release ( );
    }

    inline basic_string ( const basic_string & _Right, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Construct_lv_contents ( _Right );
        _Proxy . _Release ( );
    }

    inline basic_string ( ) noexcept ( is_nothrow_default_constructible_v < _Alty > )
        : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Mypair . _Myval2 . _Alloc_proxy ( _Fake_alloc );
        _Tidy_init ( );
    }

    inline explicit basic_string ( const _Alloc & _Al ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Mypair . _Myval2 . _Alloc_proxy ( _Fake_alloc );
        _Tidy_init ( );
    }

    inline basic_string ( const basic_string & _Right, const size_type _Roff, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Right, _Roff, npos );
        _Proxy . _Release ( );
    }

    inline basic_string (
        const basic_string & _Right, const size_type _Roff, const size_type _Count, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Right, _Roff, _Count );
        _Proxy . _Release ( );
    }

    inline basic_string (
          const _Elem * const _Ptr, const size_type _Count )
        : _Mypair ( _Zero_then_variadic_args_t { } ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Ptr, _Count );
        _Proxy . _Release ( );
    }

    inline basic_string (
          const _Elem * const _Ptr, const size_type _Count, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Ptr, _Count );
        _Proxy . _Release ( );
    }

    inline basic_string ( const _Elem * const _Ptr ) : _Mypair ( _Zero_then_variadic_args_t { } ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Ptr );
        _Proxy . _Release ( );
    }




    inline basic_string ( const _Elem * const _Ptr, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Ptr );
        _Proxy . _Release ( );
    }

    inline basic_string ( const size_type _Count, const _Elem _Ch )
        : _Mypair ( _Zero_then_variadic_args_t { } ) {

        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Count, _Ch );
        _Proxy . _Release ( );
    }




    inline basic_string ( const size_type _Count, const _Elem _Ch, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Count, _Ch );
        _Proxy . _Release ( );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline basic_string ( _Iter _First, _Iter _Last, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        _Adl_verify_range ( _First, _Last );
        _Construct ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Iter_cat_t < _Iter > { } );
        _Proxy . _Release ( );
    }

    template < class _Iter >
    inline void _Construct ( _Iter _First, const _Iter _Last, input_iterator_tag ) {

        _Tidy_deallocate_guard < basic_string > _Guard { this };
        for (; _First != _Last; ++ _First ) {
            push_back ( * _First );
        }

        _Guard . _Target = nullptr;
    }

    template < class _Iter >
    inline void _Construct ( const _Iter _First, const _Iter _Last, forward_iterator_tag ) {

        const size_type _Count = _Convert_size < size_type > ( static_cast < size_t > ( :: std :: distance ( _First, _Last ) ) );
        reserve ( _Count );
        _Construct ( _First, _Last, input_iterator_tag { } );
    }

    inline void _Construct ( _Elem * const _First, _Elem * const _Last, random_access_iterator_tag ) {

        if ( _First != _Last ) {
            assign ( _First, _Convert_size < size_type > ( static_cast < size_t > ( _Last - _First ) ) );
        }
    }

    inline void _Construct (
        const _Elem * const _First, const _Elem * const _Last, random_access_iterator_tag ) {

        if ( _First != _Last ) {
            assign ( _First, _Convert_size < size_type > ( static_cast < size_t > ( _Last - _First ) ) );
        }
    }

    inline basic_string ( basic_string && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Right . _Getal ( ) ) ) {
        _Mypair . _Myval2 . _Alloc_proxy ( _Fake_alloc );
        _Take_contents ( _Right );
    }

    inline basic_string ( basic_string && _Right, const _Alloc & _Al ) noexcept (
        _Alty_traits :: is_always_equal :: value )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        if constexpr ( ! _Alty_traits :: is_always_equal :: value ) {
            if ( _Getal ( ) != _Right . _Getal ( ) ) {
                _Construct_lv_contents ( _Right );
                _Proxy . _Release ( );
                return;
            }
        }

        _Take_contents ( _Right );
        _Proxy . _Release ( );
    }

    inline basic_string ( _String_constructor_concat_tag, const basic_string & _Source_of_al,
        const _Elem * const _Left_ptr, const size_type _Left_size, const _Elem * const _Right_ptr,
        const size_type _Right_size )
        : _Mypair (
            _One_then_variadic_args_t { }, _Alty_traits :: select_on_container_copy_construction ( _Source_of_al . _Getal ( ) ) ) {
        ;
        ;
        ;
        const auto _New_size = static_cast < size_type > ( _Left_size + _Right_size );
        size_type _New_capacity = _BUF_SIZE - 1;
        auto & _My_data = _Mypair . _Myval2;
        _Elem * _Ptr = _My_data . _Bx . _Buf;
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );




        const bool _Activate_large_mode = _New_capacity < _New_size;


        if ( _Activate_large_mode ) {

            const size_type _Requested_size = ( :: std :: max ) ( _New_size, _BUF_SIZE );
            _New_capacity = _Calculate_growth ( _Requested_size, _BUF_SIZE - 1, max_size ( ) );
            const pointer _Fancyptr = _Getal ( ) . allocate ( _New_capacity + 1 );
            _Ptr = _Unfancy ( _Fancyptr );
            _Construct_in_place ( _My_data . _Bx . _Ptr, _Fancyptr );
        }







        _My_data . _Mysize = _New_size;
        _My_data . _Myres = _New_capacity;
        _Traits :: copy ( _Ptr, _Left_ptr, _Left_size );
        _Traits :: copy ( _Ptr + static_cast < ptrdiff_t > ( _Left_size ), _Right_ptr, _Right_size );
        _Traits :: assign ( _Ptr [ _New_size ], _Elem ( ) );
        _Proxy . _Release ( );
    }

    inline basic_string ( _String_constructor_concat_tag, basic_string & _Left, basic_string & _Right )
        : _Mypair ( _One_then_variadic_args_t { }, _Left . _Getal ( ) ) {
        auto & _My_data = _Mypair . _Myval2;
        auto & _Left_data = _Left . _Mypair . _Myval2;
        auto & _Right_data = _Right . _Mypair . _Myval2;
        _Left_data . _Orphan_all ( );
        _Right_data . _Orphan_all ( );
        const auto _Left_size = _Left_data . _Mysize;
        const auto _Right_size = _Right_data . _Mysize;

        const auto _Left_capacity = _Left_data . _Myres;
        const auto _Right_capacity = _Right_data . _Myres;

        const auto _New_size = static_cast < size_type > ( _Left_size + _Right_size );
        const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
        if ( _Fits_in_left && _Right_capacity <= _Left_capacity ) {

            _My_data . _Alloc_proxy ( _Fake_alloc );
            _Take_contents ( _Left );
            const auto _Ptr = _My_data . _Myptr ( );
            _Traits :: copy ( _Ptr + _Left_size, _Right_data . _Myptr ( ), _Right_size + 1 );
            _My_data . _Mysize = _New_size;
            return;
        }

        const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
        if ( _Allocators_equal ( _Getal ( ), _Right . _Getal ( ) ) && _Fits_in_right ) {









            ;
            _My_data . _Alloc_proxy ( _Fake_alloc );
            _Take_contents ( _Right );
            const auto _Ptr = _Unfancy ( _My_data . _Bx . _Ptr );
            _Traits :: move ( _Ptr + _Left_size, _Ptr, _Right_size + 1 );
            _Traits :: copy ( _Ptr, _Left_data . _Myptr ( ), _Left_size );
            _My_data . _Mysize = _New_size;
            return;
        }


        const auto _Max = max_size ( );
        if ( _Max - _Left_size < _Right_size ) {
            _Xlen_string ( );
        }

        const auto _New_capacity = _Calculate_growth ( _New_size, _BUF_SIZE - 1, _Max );
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );
        const pointer _Fancyptr = _Getal ( ) . allocate ( _New_capacity + 1 );






        _Construct_in_place ( _My_data . _Bx . _Ptr, _Fancyptr );
        _My_data . _Mysize = _New_size;
        _My_data . _Myres = _New_capacity;
        const auto _Ptr = _Unfancy ( _Fancyptr );
        _Traits :: copy ( _Ptr, _Left_data . _Myptr ( ), _Left_size );
        _Traits :: copy ( _Ptr + _Left_size, _Right_data . _Myptr ( ), _Right_size + 1 );
        _Proxy . _Release ( );
    }

































private :
    inline void _Move_assign ( basic_string & _Right, _Equal_allocators ) noexcept {
        _Tidy_deallocate ( );
        _Pocma ( _Getal ( ), _Right . _Getal ( ) );
        _Take_contents ( _Right );
    }

    inline void _Move_assign ( basic_string & _Right, _Propagate_allocators ) noexcept {
        if ( _Getal ( ) == _Right . _Getal ( ) ) {
            _Move_assign ( _Right, _Equal_allocators { } );
        } else {

            _Mypair . _Myval2 . _Orphan_all ( );
            _Mypair . _Myval2 . _Reload_proxy (
                _Fake_alloc, _Fake_alloc );
            _Pocma ( _Getal ( ), _Right . _Getal ( ) );
            _Take_contents ( _Right );
        }
    }

    inline void _Move_assign ( basic_string & _Right, _No_propagate_allocators ) {
        if ( _Getal ( ) == _Right . _Getal ( ) ) {
            _Move_assign ( _Right, _Equal_allocators { } );
        } else {
            assign ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
        }
    }

public :













































    inline basic_string & operator = ( basic_string && _Right ) noexcept (
        noexcept ( _Move_assign ( _Right, _Choose_pocma < _Alty > { } ) ) ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Move_assign ( _Right, _Choose_pocma < _Alty > { } );
        }

        return * this;
    }

    inline basic_string & assign ( basic_string && _Right ) noexcept ( noexcept ( * this = :: std :: move ( _Right ) ) ) {
        * this = :: std :: move ( _Right );
        return * this;
    }

private :
    void _Memcpy_val_from ( const basic_string & _Right ) noexcept {
        ;
        const auto _My_data_mem =
            reinterpret_cast < unsigned char * > ( :: std :: addressof ( _Mypair . _Myval2 ) ) + _Memcpy_val_offset;
        const auto _Right_data_mem =
            reinterpret_cast < const unsigned char * > ( :: std :: addressof ( _Right . _Mypair . _Myval2 ) ) + _Memcpy_val_offset;
        :: memcpy ( _My_data_mem, _Right_data_mem, _Memcpy_val_size );
    }

    inline void _Take_contents ( basic_string & _Right ) noexcept {





        auto & _My_data = _Mypair . _Myval2;
        auto & _Right_data = _Right . _Mypair . _Myval2;

        if constexpr ( _Can_memcpy_val ) {



            {









                _Memcpy_val_from ( _Right );
                _Right . _Tidy_init ( );
                return;
            }
        }

        if ( _Right_data . _Large_string_engaged ( ) ) {
            _Construct_in_place ( _My_data . _Bx . _Ptr, _Right_data . _Bx . _Ptr );
            _Right_data . _Bx . _Ptr = nullptr;
            _Swap_proxy_and_iterators ( _Right );
        } else {
            _Traits :: copy ( _My_data . _Bx . _Buf, _Right_data . _Bx . _Buf, _Right_data . _Mysize + 1 );
            _Right_data . _Orphan_all ( );
        }

        _My_data . _Mysize = _Right_data . _Mysize;
        _My_data . _Myres = _Right_data . _Myres;
        _Right . _Tidy_init ( );
    }

    inline void _Construct_lv_contents ( const basic_string & _Right ) {




        auto & _Right_data = _Right . _Mypair . _Myval2;
        const size_type _Right_size = _Right_data . _Mysize;
        const _Elem * const _Right_ptr = _Right_data . _Myptr ( );
        auto & _My_data = _Mypair . _Myval2;




        const bool _Stay_small = _Right_size < _BUF_SIZE;




        if ( _Stay_small ) {
            _Traits :: copy ( _My_data . _Bx . _Buf, _Right_ptr, _BUF_SIZE );
            _My_data . _Mysize = _Right_size;
            _My_data . _Myres = _BUF_SIZE - 1;
            return;
        }

        auto & _Al = _Getal ( );
        const size_type _New_capacity = ( :: std :: min ) ( _Right_size | _ALLOC_MASK, max_size ( ) );
        const pointer _New_array = _Al . allocate ( _New_capacity + 1 );
        _Construct_in_place ( _My_data . _Bx . _Ptr, _New_array );






        _Traits :: copy ( _Unfancy ( _New_array ), _Right_ptr, _Right_size + 1 );
        _My_data . _Mysize = _Right_size;
        _My_data . _Myres = _New_capacity;
    }

public :
    inline basic_string ( initializer_list < _Elem > _Ilist, const _Alloc & _Al = allocator_type ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Tidy_init ( );
        assign ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
        _Proxy . _Release ( );
    }

    inline basic_string & operator = ( initializer_list < _Elem > _Ilist ) {
        return assign ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline basic_string & operator += ( initializer_list < _Elem > _Ilist ) {
        return append ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline basic_string & assign ( initializer_list < _Elem > _Ilist ) {
        return assign ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline basic_string & append ( initializer_list < _Elem > _Ilist ) {
        return append ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline iterator insert ( const const_iterator _Where, const initializer_list < _Elem > _Ilist ) {



        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        insert ( _Off, _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const initializer_list < _Elem > _Ilist ) {

        _Adl_verify_range ( _First, _Last );



        const auto _Offset = static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        const auto _Length = static_cast < size_type > ( _Last . _Ptr - _First . _Ptr );
        return replace ( _Offset, _Length, _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
    }

    inline ~ basic_string ( ) noexcept {
        _Tidy_deallocate ( );






    }

    static constexpr auto npos { static_cast < size_type > ( - 1 ) };

private :
    void _Copy_assign_val_from_small ( const basic_string & _Right ) {




        _Tidy_deallocate ( );
        if constexpr ( _Can_memcpy_val ) {
            _Memcpy_val_from ( _Right );
        } else {
            auto & _My_data = _Mypair . _Myval2;
            auto & _Right_data = _Right . _Mypair . _Myval2;

            _Traits :: copy ( _My_data . _Bx . _Buf, _Right_data . _Bx . _Buf, _Right_data . _Mysize + 1 );
            _My_data . _Mysize = _Right_data . _Mysize;
            _My_data . _Myres = _Right_data . _Myres;
        }
    }

    inline void _Copy_assign ( const basic_string & _Right, false_type ) {
        _Pocca ( _Getal ( ), _Right . _Getal ( ) );
        assign ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline void _Copy_assign ( const basic_string & _Right, true_type ) {
        auto & _Al = _Getal ( );
        const auto & _Right_al = _Right . _Getal ( );
        if ( _Al == _Right_al ) {
            _Copy_assign ( _Right, false_type { } );
            return;
        }

        auto && _Alproxy = _Fake_alloc;
        auto && _Right_alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _New_proxy ( _Right_alproxy, _Leave_proxy_unbound { } );

        if ( _Right . _Mypair . _Myval2 . _Large_string_engaged ( ) ) {
            const auto _New_size = _Right . _Mypair . _Myval2 . _Mysize;
            const auto _New_capacity = _Calculate_growth ( _New_size, 0, _Right . max_size ( ) );
            auto _Right_al_non_const = _Right_al;
            const auto _New_ptr = _Right_al_non_const . allocate ( _New_capacity );







            _Traits :: copy ( _Unfancy ( _New_ptr ), _Unfancy ( _Right . _Mypair . _Myval2 . _Bx . _Ptr ), _New_size + 1 );
            _Tidy_deallocate ( );
            _Mypair . _Myval2 . _Bx . _Ptr = _New_ptr;
            _Mypair . _Myval2 . _Mysize = _New_size;
            _Mypair . _Myval2 . _Myres = _New_capacity;
        } else {
            _Copy_assign_val_from_small ( _Right );
        }

        _Pocca ( _Al, _Right_al );
        _New_proxy . _Bind ( _Alproxy, :: std :: addressof ( _Mypair . _Myval2 ) );
    }

public :
    inline basic_string & operator = ( const basic_string & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Copy_assign ( _Right, _Choose_pocca < _Alty > { } );
        }

        return * this;
    }








    inline basic_string & operator = ( const _Elem * const _Ptr ) {
        return assign ( _Ptr );
    }

    inline basic_string & operator = ( const _Elem _Ch ) {
        _Mypair . _Myval2 . _Mysize = 1;
        _Elem * const _Ptr = _Mypair . _Myval2 . _Myptr ( );
        _Traits :: assign ( _Ptr [ 0 ], _Ch );
        _Traits :: assign ( _Ptr [ 1 ], _Elem ( ) );
        return * this;
    }

    inline basic_string & operator += ( const basic_string & _Right ) {
        return append ( _Right );
    }








    inline basic_string & operator += ( const _Elem * const _Ptr ) {
        return append ( _Ptr );
    }

    inline basic_string & operator += ( _Elem _Ch ) {
        push_back ( _Ch );
        return * this;
    }

    inline basic_string & append ( const basic_string & _Right ) {
        return append ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline basic_string & append (
        const basic_string & _Right, const size_type _Roff, size_type _Count = npos ) {

        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Count = _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count );
        return append ( _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Count );
    }

















    inline basic_string & append (
          const _Elem * const _Ptr, const size_type _Count ) {

        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Count <= _Mypair . _Myval2 . _Myres - _Old_size ) {
            _Mypair . _Myval2 . _Mysize = _Old_size + _Count;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Traits :: move ( _Old_ptr + _Old_size, _Ptr, _Count );
            _Traits :: assign ( _Old_ptr [ _Old_size + _Count ], _Elem ( ) );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const _Elem * const _Ptr,
                const size_type _Count ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
                _Traits :: copy ( _New_ptr + _Old_size, _Ptr, _Count );
                _Traits :: assign ( _New_ptr [ _Old_size + _Count ], _Elem ( ) );
            },
            _Ptr, _Count );
    }

    inline basic_string & append ( const _Elem * const _Ptr ) {
        return append ( _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }

    inline basic_string & append ( const size_type _Count, const _Elem _Ch ) {

        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Count <= _Mypair . _Myval2 . _Myres - _Old_size ) {
            _Mypair . _Myval2 . _Mysize = _Old_size + _Count;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Traits :: assign ( _Old_ptr + _Old_size, _Count, _Ch );
            _Traits :: assign ( _Old_ptr [ _Old_size + _Count ], _Elem ( ) );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
                _Traits :: assign ( _New_ptr + _Old_size, _Count, _Ch );
                _Traits :: assign ( _New_ptr [ _Old_size + _Count ], _Elem ( ) );
            },
            _Count, _Ch );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline basic_string & append ( const _Iter _First, const _Iter _Last ) {

        _Adl_verify_range ( _First, _Last );
        const auto _UFirst = _Get_unwrapped ( _First );
        const auto _ULast = _Get_unwrapped ( _Last );
        if constexpr ( _Is_elem_cptr < decltype ( _UFirst ) > :: value ) {
            return append ( _UFirst, _Convert_size < size_type > ( static_cast < size_t > ( _ULast - _UFirst ) ) );
        } else {
            const basic_string _Right ( _UFirst, _ULast, get_allocator ( ) );
            return append ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
        }
    }

    inline basic_string & assign ( const basic_string & _Right ) {
        * this = _Right;
        return * this;
    }

    inline basic_string & assign (
        const basic_string & _Right, const size_type _Roff, size_type _Count = npos ) {

        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Count = _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count );
        return assign ( _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Count );
    }

















    inline basic_string & assign (
          const _Elem * const _Ptr, const size_type _Count ) {

        if ( _Count <= _Mypair . _Myval2 . _Myres ) {
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Mypair . _Myval2 . _Mysize = _Count;
            _Traits :: move ( _Old_ptr, _Ptr, _Count );
            _Traits :: assign ( _Old_ptr [ _Count ], _Elem ( ) );
            return * this;
        }

        return _Reallocate_for (
            _Count,
            [ ] ( _Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr ) {
                _Traits :: copy ( _New_ptr, _Ptr, _Count );
                _Traits :: assign ( _New_ptr [ _Count ], _Elem ( ) );
            },
            _Ptr );
    }

    inline basic_string & assign ( const _Elem * const _Ptr ) {
        return assign ( _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }

    inline basic_string & assign ( const size_type _Count, const _Elem _Ch ) {

        if ( _Count <= _Mypair . _Myval2 . _Myres ) {
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Mypair . _Myval2 . _Mysize = _Count;
            _Traits :: assign ( _Old_ptr, _Count, _Ch );
            _Traits :: assign ( _Old_ptr [ _Count ], _Elem ( ) );
            return * this;
        }

        return _Reallocate_for (
            _Count,
            [ ] ( _Elem * const _New_ptr, const size_type _Count, const _Elem _Ch ) {
                _Traits :: assign ( _New_ptr, _Count, _Ch );
                _Traits :: assign ( _New_ptr [ _Count ], _Elem ( ) );
            },
            _Ch );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline basic_string & assign ( const _Iter _First, const _Iter _Last ) {
        _Adl_verify_range ( _First, _Last );
        const auto _UFirst = _Get_unwrapped ( _First );
        const auto _ULast = _Get_unwrapped ( _Last );
        if constexpr ( _Is_elem_cptr < decltype ( _UFirst ) > :: value ) {
            return assign ( _UFirst, _Convert_size < size_type > ( static_cast < size_t > ( _ULast - _UFirst ) ) );
        } else {
            basic_string _Right ( _UFirst, _ULast, get_allocator ( ) );
            if ( _Mypair . _Myval2 . _Myres < _Right . _Mypair . _Myval2 . _Myres ) {
                _Mypair . _Myval2 . _Orphan_all ( );
                _Swap_data ( _Right );
                return * this;
            } else {
                return assign ( _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
            }
        }
    }

    inline basic_string & insert ( const size_type _Off, const basic_string & _Right ) {

        return insert ( _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline basic_string & insert (
        const size_type _Off, const basic_string & _Right, const size_type _Roff, size_type _Count = npos ) {

        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Count = _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count );
        return insert ( _Off, _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Count );
    }


















    inline basic_string & insert (
        const size_type _Off, const _Elem * const _Ptr, const size_type _Count ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;






        const bool _Check_overlap = _Count <= _Mypair . _Myval2 . _Myres - _Old_size;


        if ( _Check_overlap ) {
            _Mypair . _Myval2 . _Mysize = _Old_size + _Count;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Elem * const _Insert_at = _Old_ptr + _Off;


            size_type _Ptr_shifted_after;
            if ( _Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size ) {

                _Ptr_shifted_after = _Count;
            } else if ( _Insert_at <= _Ptr ) {
                _Ptr_shifted_after = 0;
            } else {
                _Ptr_shifted_after = static_cast < size_type > ( _Insert_at - _Ptr );
            }

            _Traits :: move ( _Insert_at + _Count, _Insert_at, _Old_size - _Off + 1 );
            _Traits :: copy ( _Insert_at, _Ptr, _Ptr_shifted_after );
            _Traits :: copy (
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem * const _Ptr, const size_type _Count ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
                _Traits :: copy ( _New_ptr + _Off, _Ptr, _Count );
                _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1 );
            },
            _Off, _Ptr, _Count );
    }

    inline basic_string & insert ( const size_type _Off, const _Elem * const _Ptr ) {

        return insert ( _Off, _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }

    inline basic_string & insert (
        const size_type _Off, const size_type _Count, const _Elem _Ch ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Count <= _Mypair . _Myval2 . _Myres - _Old_size ) {
            _Mypair . _Myval2 . _Mysize = _Old_size + _Count;
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Elem * const _Insert_at = _Old_ptr + _Off;
            _Traits :: move ( _Insert_at + _Count, _Insert_at, _Old_size - _Off + 1 );
            _Traits :: assign ( _Insert_at, _Count, _Ch );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
                _Traits :: assign ( _New_ptr + _Off, _Count, _Ch );
                _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1 );
            },
            _Off, _Count, _Ch );
    }

    inline iterator insert ( const const_iterator _Where, const _Elem _Ch ) {



        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        insert ( _Off, 1, _Ch );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline iterator insert (
        const const_iterator _Where, const size_type _Count, const _Elem _Ch ) {




        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        insert ( _Off, _Count, _Ch );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline iterator insert ( const const_iterator _Where, const _Iter _First, const _Iter _Last ) {




        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        _Adl_verify_range ( _First, _Last );
        const auto _UFirst = _Get_unwrapped ( _First );
        const auto _ULast = _Get_unwrapped ( _Last );
        if constexpr ( _Is_elem_cptr < decltype ( _UFirst ) > :: value ) {
            insert ( _Off, _UFirst, _Convert_size < size_type > ( static_cast < size_t > ( _ULast - _UFirst ) ) );
        } else {
            const basic_string _Right ( _UFirst, _ULast, get_allocator ( ) );
            insert ( _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
        }

        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline basic_string & erase ( const size_type _Off = 0 ) {
        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Eos ( _Off );
        return * this;
    }

private :
    inline basic_string & _Erase_noexcept ( const size_type _Off, size_type _Count ) noexcept {
        _Count = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Count );
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        _Elem * const _My_ptr = _Mypair . _Myval2 . _Myptr ( );
        _Elem * const _Erase_at = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Mypair . _Myval2 . _Mysize = _New_size;
        _Traits :: move ( _Erase_at, _Erase_at + _Count, _New_size - _Off + 1 );
        return * this;
    }

public :
    inline basic_string & erase ( const size_type _Off, const size_type _Count ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        return _Erase_noexcept ( _Off, _Count );
    }

    inline iterator erase ( const const_iterator _Where ) noexcept {



        const auto _Off = static_cast < size_type > ( _Unfancy ( _Where . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        _Erase_noexcept ( _Off, 1 );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline iterator erase ( const const_iterator _First, const const_iterator _Last ) noexcept
     {
        _Adl_verify_range ( _First, _Last );



        const auto _Off = static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        _Erase_noexcept ( _Off, static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ) );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    inline void clear ( ) noexcept {
        _Eos ( 0 );
    }

    inline basic_string & replace (
        const size_type _Off, const size_type _Nx, const basic_string & _Right ) {

        return replace ( _Off, _Nx, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline basic_string & replace ( const size_type _Off, size_type _Nx, const basic_string & _Right,
        const size_type _Roff, size_type _Count = npos ) {

        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        _Count = _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count );
        return replace ( _Off, _Nx, _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Count );
    }



















    inline basic_string & replace (
        const size_type _Off, size_type _Nx, const _Elem * const _Ptr, const size_type _Count ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Nx = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx );
        if ( _Nx == _Count ) {
            _Traits :: move ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Ptr, _Count );
            return * this;
        }

        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
        if ( _Count < _Nx ) {
            _Mypair . _Myval2 . _Mysize = _Old_size - ( _Nx - _Count );
            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Elem * const _Insert_at = _Old_ptr + _Off;
            _Traits :: move ( _Insert_at, _Ptr, _Count );
            _Traits :: move ( _Insert_at + _Count, _Insert_at + _Nx, _Suffix_size );
            return * this;
        }

        const size_type _Growth = static_cast < size_type > ( _Count - _Nx );






        {
            if ( _Growth <= _Mypair . _Myval2 . _Myres - _Old_size ) {
                _Mypair . _Myval2 . _Mysize = _Old_size + _Growth;
                _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
                _Elem * const _Insert_at = _Old_ptr + _Off;
                _Elem * const _Suffix_at = _Insert_at + _Nx;

                size_type _Ptr_shifted_after;
                if ( _Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size ) {
                    _Ptr_shifted_after = _Count;
                } else if ( _Suffix_at <= _Ptr ) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast < size_type > ( _Suffix_at - _Ptr );
                }

                _Traits :: move ( _Suffix_at + _Growth, _Suffix_at, _Suffix_size );



                _Traits :: move ( _Insert_at, _Ptr, _Ptr_shifted_after );


                _Traits :: copy (
                    _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after );
                return * this;
            }
        }

        return _Reallocate_grow_by (
            _Growth,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const _Elem * const _Ptr, const size_type _Count ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
                _Traits :: copy ( _New_ptr + _Off, _Ptr, _Count );
                _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1 );
            },
            _Off, _Nx, _Ptr, _Count );
    }

    inline basic_string & replace (
        const size_type _Off, const size_type _Nx, const _Elem * const _Ptr ) {

        return replace ( _Off, _Nx, _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) );
    }

    inline basic_string & replace (
        const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch ) {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Nx = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx );
        if ( _Count == _Nx ) {
            _Traits :: assign ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Count, _Ch );
            return * this;
        }

        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Count < _Nx || _Count - _Nx <= _Mypair . _Myval2 . _Myres - _Old_size ) {

            _Mypair . _Myval2 . _Mysize = _Old_size + _Count - _Nx;

            _Elem * const _Old_ptr = _Mypair . _Myval2 . _Myptr ( );
            _Elem * const _Insert_at = _Old_ptr + _Off;
            _Traits :: move ( _Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1 );
            _Traits :: assign ( _Insert_at, _Count, _Ch );
            return * this;
        }

        return _Reallocate_grow_by (
            _Count - _Nx,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const size_type _Count, const _Elem _Ch ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
                _Traits :: assign ( _New_ptr + _Off, _Count, _Ch );
                _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1 );
            },
            _Off, _Nx, _Count, _Ch );
    }

    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const basic_string & _Right ) {

        _Adl_verify_range ( _First, _Last );



        return replace ( static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) ),
            static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ), _Right );
    }















    inline basic_string & replace ( const const_iterator _First, const const_iterator _Last,
          const _Elem * const _Ptr, const size_type _Count ) {

        _Adl_verify_range ( _First, _Last );



        return replace ( static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) ),
            static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ), _Ptr, _Count );
    }

    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const _Elem * const _Ptr ) {

        _Adl_verify_range ( _First, _Last );



        return replace ( static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) ),
            static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ), _Ptr );
    }

    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch ) {

        _Adl_verify_range ( _First, _Last );



        return replace ( static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) ),
            static_cast < size_type > ( _Last . _Ptr - _First . _Ptr ), _Count, _Ch );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline basic_string & replace (
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2 ) {

        _Adl_verify_range ( _First, _Last );



        const auto _Off = static_cast < size_type > ( _Unfancy ( _First . _Ptr ) - _Mypair . _Myval2 . _Myptr ( ) );
        const auto _Length = static_cast < size_type > ( _Last . _Ptr - _First . _Ptr );
        _Adl_verify_range ( _First2, _Last2 );
        const auto _UFirst2 = _Get_unwrapped ( _First2 );
        const auto _ULast2 = _Get_unwrapped ( _Last2 );
        if constexpr ( _Is_elem_cptr < decltype ( _UFirst2 ) > :: value ) {
            return replace ( _Off, _Length, _UFirst2, _Convert_size < size_type > ( static_cast < size_t > ( _ULast2 - _UFirst2 ) ) );
        } else {
            const basic_string _Right ( _UFirst2, _ULast2, get_allocator ( ) );
            return replace ( _Off, _Length, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
        }
    }

    [ [ nodiscard ] ] inline iterator begin ( ) noexcept {
        return iterator ( _Refancy < pointer > ( _Mypair . _Myval2 . _Myptr ( ) ), :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline const_iterator begin ( ) const noexcept {
        return const_iterator ( _Refancy < const_pointer > ( _Mypair . _Myval2 . _Myptr ( ) ), :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline iterator end ( ) noexcept {
        return iterator (
            _Refancy < pointer > ( _Mypair . _Myval2 . _Myptr ( ) ) + static_cast < difference_type > ( _Mypair . _Myval2 . _Mysize ),
            :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline const_iterator end ( ) const noexcept {
        return const_iterator (
            _Refancy < const_pointer > ( _Mypair . _Myval2 . _Myptr ( ) ) + static_cast < difference_type > ( _Mypair . _Myval2 . _Mysize ),
            :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline _Elem * _Unchecked_begin ( ) noexcept {
        return _Mypair . _Myval2 . _Myptr ( );
    }

    [ [ nodiscard ] ] inline const _Elem * _Unchecked_begin ( ) const noexcept {
        return _Mypair . _Myval2 . _Myptr ( );
    }

    [ [ nodiscard ] ] inline _Elem * _Unchecked_end ( ) noexcept {
        return _Mypair . _Myval2 . _Myptr ( ) + _Mypair . _Myval2 . _Mysize;
    }

    [ [ nodiscard ] ] inline const _Elem * _Unchecked_end ( ) const noexcept {
        return _Mypair . _Myval2 . _Myptr ( ) + _Mypair . _Myval2 . _Mysize;
    }

    [ [ nodiscard ] ] inline reverse_iterator rbegin ( ) noexcept {
        return reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator rbegin ( ) const noexcept {
        return const_reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] inline reverse_iterator rend ( ) noexcept {
        return reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator rend ( ) const noexcept {
        return const_reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] inline const_iterator cbegin ( ) const noexcept {
        return begin ( );
    }

    [ [ nodiscard ] ] inline const_iterator cend ( ) const noexcept {
        return end ( );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator crbegin ( ) const noexcept {
        return rbegin ( );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator crend ( ) const noexcept {
        return rend ( );
    }

    inline void shrink_to_fit ( ) {
        auto & _My_data = _Mypair . _Myval2;




        {
            if ( ! _My_data . _Large_string_engaged ( ) ) {
                return;
            }

            if ( _My_data . _Mysize < _BUF_SIZE ) {
                _Become_small ( );
                return;
            }
        }

        size_type _Target_capacity = ( :: std :: min ) ( _My_data . _Mysize | _ALLOC_MASK, max_size ( ) );





        if ( _Target_capacity < _My_data . _Myres ) {
            auto & _Al = _Getal ( );
            const pointer _New_ptr = _Al . allocate ( _Target_capacity + 1 );







            _My_data . _Orphan_all ( );
            _Traits :: copy ( _Unfancy ( _New_ptr ), _Unfancy ( _My_data . _Bx . _Ptr ), _My_data . _Mysize + 1 );
            _Al . deallocate ( _My_data . _Bx . _Ptr, _My_data . _Myres + 1 );
            _My_data . _Bx . _Ptr = _New_ptr;
            _My_data . _Myres = _Target_capacity;
        }
    }

    [ [ nodiscard ] ] inline reference at ( const size_type _Off ) {
        _Mypair . _Myval2 . _Check_offset_exclusive ( _Off );
        return _Mypair . _Myval2 . _Myptr ( ) [ _Off ];
    }

    [ [ nodiscard ] ] inline const_reference at ( const size_type _Off ) const {
        _Mypair . _Myval2 . _Check_offset_exclusive ( _Off );
        return _Mypair . _Myval2 . _Myptr ( ) [ _Off ];
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const size_type _Off ) noexcept {



        return _Mypair . _Myval2 . _Myptr ( ) [ _Off ];
    }

    [ [ nodiscard ] ] inline const_reference operator [ ] ( const size_type _Off ) const noexcept
     {



        return _Mypair . _Myval2 . _Myptr ( ) [ _Off ];
    }








    inline void push_back ( const _Elem _Ch ) {
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
        if ( _Old_size < _Mypair . _Myval2 . _Myres ) {
            _Mypair . _Myval2 . _Mysize = _Old_size + 1;
            _Elem * const _Ptr = _Mypair . _Myval2 . _Myptr ( );
            _Traits :: assign ( _Ptr [ _Old_size ], _Ch );
            _Traits :: assign ( _Ptr [ _Old_size + 1 ], _Elem ( ) );
            return;
        }

        _Reallocate_grow_by (
            1,
            [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size, const _Elem _Ch ) {
                _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
                _Traits :: assign ( _New_ptr [ _Old_size ], _Ch );
                _Traits :: assign ( _New_ptr [ _Old_size + 1 ], _Elem ( ) );
            },
            _Ch );
    }

    inline void pop_back ( ) noexcept {
        const size_type _Old_size = _Mypair . _Myval2 . _Mysize;



        _Eos ( _Old_size - 1 );
    }

    [ [ nodiscard ] ] inline reference front ( ) noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ 0 ];
    }

    [ [ nodiscard ] ] inline const_reference front ( ) const noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ 0 ];
    }

    [ [ nodiscard ] ] inline reference back ( ) noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ _Mypair . _Myval2 . _Mysize - 1 ];
    }

    [ [ nodiscard ] ] inline const_reference back ( ) const noexcept {




        return _Mypair . _Myval2 . _Myptr ( ) [ _Mypair . _Myval2 . _Mysize - 1 ];
    }

    [ [ nodiscard ] ] inline const _Elem * c_str ( ) const noexcept {
        return _Mypair . _Myval2 . _Myptr ( );
    }

    [ [ nodiscard ] ] inline const _Elem * data ( ) const noexcept {
        return _Mypair . _Myval2 . _Myptr ( );
    }







    [ [ nodiscard ] ] inline size_type length ( ) const noexcept {
        return _Mypair . _Myval2 . _Mysize;
    }

    [ [ nodiscard ] ] inline size_type size ( ) const noexcept {
        return _Mypair . _Myval2 . _Mysize;
    }

    [ [ nodiscard ] ] inline size_type max_size ( ) const noexcept {
        const size_type _Alloc_max = _Alty_traits :: max_size ( _Getal ( ) );
        const size_type _Storage_max =
            ( :: std :: max ) ( _Alloc_max, static_cast < size_type > ( _BUF_SIZE ) );
        return ( :: std :: min ) ( static_cast < size_type > ( ( numeric_limits < difference_type > :: max ) ( ) ),
            _Storage_max - 1
        );
    }

    inline void resize ( const size_type _Newsize, const _Elem _Ch = _Elem ( ) ) {

        const size_type _Old_size = size ( );
        if ( _Newsize <= _Old_size ) {
            _Eos ( _Newsize );
        } else {
            append ( _Newsize - _Old_size, _Ch );
        }
    }

    [ [ nodiscard ] ] inline size_type capacity ( ) const noexcept {
        return _Mypair . _Myval2 . _Myres;
    }























    void reserve ( const size_type _Newcap = 0 ) {
        if ( _Mypair . _Myval2 . _Mysize > _Newcap ) {
            return;
        }

        if ( _Mypair . _Myval2 . _Myres == _Newcap ) {
            return;
        }

        if ( _Mypair . _Myval2 . _Myres < _Newcap ) {
            const size_type _Old_size = _Mypair . _Myval2 . _Mysize;
            _Reallocate_grow_by (
                _Newcap - _Old_size, [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size ) {
                    _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size + 1 );
                } );

            _Mypair . _Myval2 . _Mysize = _Old_size;
            return;
        }

        if ( _BUF_SIZE > _Newcap && _Mypair . _Myval2 . _Large_string_engaged ( ) ) {

            _Become_small ( );
            return;
        }


    }


    [ [ nodiscard ] ] inline bool empty ( ) const noexcept {
        return size ( ) == 0;
    }

    inline size_type copy (
          _Elem * const _Ptr, size_type _Count, const size_type _Off = 0 ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Count = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Count );
        _Traits :: copy ( _Ptr, _Mypair . _Myval2 . _Myptr ( ) + _Off, _Count );
        return _Count;
    }

    inline size_type
        _Copy_s ( _Elem * const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0 ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Count = _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Count );
        _Traits :: _Copy_s ( _Dest, _Dest_size, _Mypair . _Myval2 . _Myptr ( ) + _Off, _Count );
        return _Count;
    }

    void _Swap_bx_large_with_small ( _Scary_val & _Starts_large, _Scary_val & _Starts_small ) {



        const pointer _Ptr = _Starts_large . _Bx . _Ptr;
        _Destroy_in_place ( _Starts_large . _Bx . _Ptr );
        _Traits :: copy ( _Starts_large . _Bx . _Buf, _Starts_small . _Bx . _Buf, _BUF_SIZE );
        _Construct_in_place ( _Starts_small . _Bx . _Ptr, _Ptr );
    }

    inline void _Swap_data ( basic_string & _Right ) {
        auto & _My_data = _Mypair . _Myval2;
        auto & _Right_data = _Right . _Mypair . _Myval2;

        if constexpr ( _Can_memcpy_val ) {



            {
                const auto _My_data_mem =
                    reinterpret_cast < unsigned char * > ( :: std :: addressof ( _My_data ) ) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast < unsigned char * > ( :: std :: addressof ( _Right_data ) ) + _Memcpy_val_offset;
                unsigned char _Temp_mem [ _Memcpy_val_size ];
                :: memcpy ( _Temp_mem, _My_data_mem, _Memcpy_val_size );
                :: memcpy ( _My_data_mem, _Right_data_mem, _Memcpy_val_size );
                :: memcpy ( _Right_data_mem, _Temp_mem, _Memcpy_val_size );
                return;
            }
        }

        const bool _My_large = _My_data . _Large_string_engaged ( );
        const bool _Right_large = _Right_data . _Large_string_engaged ( );
        if ( _My_large ) {
            if ( _Right_large ) {
                _Swap_adl ( _My_data . _Bx . _Ptr, _Right_data . _Bx . _Ptr );
            } else {
                _Swap_bx_large_with_small ( _My_data, _Right_data );
            }
        } else {
            if ( _Right_large ) {
                _Swap_bx_large_with_small ( _Right_data, _My_data );
            } else {
                _Elem _Temp_buf [ _BUF_SIZE ];
                _Traits :: copy ( _Temp_buf, _My_data . _Bx . _Buf, _BUF_SIZE );
                _Traits :: copy ( _My_data . _Bx . _Buf, _Right_data . _Bx . _Buf, _BUF_SIZE );
                _Traits :: copy ( _Right_data . _Bx . _Buf, _Temp_buf, _BUF_SIZE );
            }
        }

        :: std :: swap ( _My_data . _Mysize, _Right_data . _Mysize );
        :: std :: swap ( _My_data . _Myres, _Right_data . _Myres );
    }

    inline void swap ( basic_string & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Pocs ( _Getal ( ), _Right . _Getal ( ) );
















        }

        _Swap_data ( _Right );
    }











    [ [ nodiscard ] ] inline size_type find (
        const basic_string & _Right, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off,
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize ) );
    }

    [ [ nodiscard ] ] inline size_type find ( const _Elem * const _Ptr, const size_type _Off,
        const size_type _Count ) const noexcept {

        return static_cast < size_type > (
            _Traits_find < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count ) );
    }

    [ [ nodiscard ] ] inline size_type find (
          const _Elem * const _Ptr, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
    }

    [ [ nodiscard ] ] inline size_type find ( const _Elem _Ch, const size_type _Off = 0 ) const noexcept
     {

        return static_cast < size_type > (
            _Traits_find_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }











    [ [ nodiscard ] ] inline size_type rfind (
        const basic_string & _Right, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_rfind < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off,
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize ) );
    }

    [ [ nodiscard ] ] inline size_type rfind ( const _Elem * const _Ptr, const size_type _Off,
        const size_type _Count ) const noexcept {

        return static_cast < size_type > (
            _Traits_rfind < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count ) );
    }

    [ [ nodiscard ] ] inline size_type rfind (
          const _Elem * const _Ptr, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_rfind < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
    }

    [ [ nodiscard ] ] inline size_type rfind ( const _Elem _Ch, const size_type _Off = npos ) const noexcept
     {

        return static_cast < size_type > (
            _Traits_rfind_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }












    [ [ nodiscard ] ] inline size_type find_first_of (
        const basic_string & _Right, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find_first_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize,
            _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_of ( const _Elem * const _Ptr,
        const size_type _Off, const size_type _Count ) const noexcept {

        return static_cast < size_type > ( _Traits_find_first_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Off, _Ptr, _Count, _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_of (
          const _Elem * const _Ptr, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find_first_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Off, _Ptr, _Traits :: length ( _Ptr ), _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_of ( const _Elem _Ch, const size_type _Off = 0 ) const noexcept
     {

        return static_cast < size_type > (
            _Traits_find_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }












    [ [ nodiscard ] ] inline size_type find_last_of (
        const basic_string & _Right, size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize,
            _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_of ( const _Elem * const _Ptr,
        const size_type _Off, const size_type _Count ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Off, _Ptr, _Count, _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_of (
          const _Elem * const _Ptr, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Off, _Ptr, _Traits :: length ( _Ptr ), _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_of (
        const _Elem _Ch, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > (
            _Traits_rfind_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }













    [ [ nodiscard ] ] inline size_type find_first_not_of (
        const basic_string & _Right, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find_first_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ),
            _Mypair . _Myval2 . _Mysize, _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize,
            _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_not_of ( const _Elem * const _Ptr,
        const size_type _Off, const size_type _Count ) const noexcept {

        return static_cast < size_type > ( _Traits_find_first_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ),
            _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count, _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_not_of (
          const _Elem * const _Ptr, size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > ( _Traits_find_first_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ),
            _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ), _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_first_not_of (
        const _Elem _Ch, const size_type _Off = 0 ) const noexcept {

        return static_cast < size_type > (
            _Traits_find_not_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }













    [ [ nodiscard ] ] inline size_type find_last_not_of (
        const basic_string & _Right, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ),
            _Mypair . _Myval2 . _Mysize, _Off, _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize,
            _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_not_of ( const _Elem * const _Ptr,
        const size_type _Off, const size_type _Count ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ),
            _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Count, _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_not_of (
          const _Elem * const _Ptr, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > ( _Traits_find_last_not_of < _Traits > ( _Mypair . _Myval2 . _Myptr ( ),
            _Mypair . _Myval2 . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ), _Is_specialization < _Traits, char_traits > { } ) );
    }

    [ [ nodiscard ] ] inline size_type find_last_not_of (
        const _Elem _Ch, const size_type _Off = npos ) const noexcept {

        return static_cast < size_type > (
            _Traits_rfind_not_ch < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Off, _Ch ) );
    }








    [ [ nodiscard ] ] inline basic_string substr (
        const size_type _Off = 0, const size_type _Count = npos ) const {

        return basic_string ( * this, _Off, _Count, get_allocator ( ) );
    }

    inline bool _Equal ( const basic_string & _Right ) const noexcept {

        return _Traits_equal < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    inline bool _Equal ( const _Elem * const _Ptr ) const noexcept {

        return _Traits_equal < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Ptr, _Traits :: length ( _Ptr ) );
    }
































    [ [ nodiscard ] ] inline int compare ( const basic_string & _Right ) const noexcept {

        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize,
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    [ [ nodiscard ] ] inline int compare ( size_type _Off, size_type _Nx, const basic_string & _Right ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx ),
            _Right . _Mypair . _Myval2 . _Myptr ( ), _Right . _Mypair . _Myval2 . _Mysize );
    }

    [ [ nodiscard ] ] inline int compare ( const size_type _Off, const size_type _Nx, const basic_string & _Right,
        const size_type _Roff, const size_type _Count = npos ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        _Right . _Mypair . _Myval2 . _Check_offset ( _Roff );
        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx ),
            _Right . _Mypair . _Myval2 . _Myptr ( ) + _Roff, _Right . _Mypair . _Myval2 . _Clamp_suffix_size ( _Roff, _Count ) );
    }

    [ [ nodiscard ] ] inline int compare ( const _Elem * const _Ptr ) const noexcept {

        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ), _Mypair . _Myval2 . _Mysize, _Ptr, _Traits :: length ( _Ptr ) );
    }

    [ [ nodiscard ] ] inline int compare (
        const size_type _Off, const size_type _Nx, const _Elem * const _Ptr ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        return _Traits_compare < _Traits > ( _Mypair . _Myval2 . _Myptr ( ) + _Off, _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx ),
            _Ptr, _Traits :: length ( _Ptr ) );
    }

    [ [ nodiscard ] ] inline int compare ( const size_type _Off, const size_type _Nx,
          const _Elem * const _Ptr, const size_type _Count ) const {

        _Mypair . _Myval2 . _Check_offset ( _Off );
        return _Traits_compare < _Traits > (
            _Mypair . _Myval2 . _Myptr ( ) + _Off, _Mypair . _Myval2 . _Clamp_suffix_size ( _Off, _Nx ), _Ptr, _Count );
    }



























    [ [ nodiscard ] ] inline allocator_type get_allocator ( ) const noexcept {
        return static_cast < allocator_type > ( _Getal ( ) );
    }

private :
    [ [ nodiscard ] ] static inline size_type _Calculate_growth (
        const size_type _Requested, const size_type _Old, const size_type _Max ) noexcept {
        const size_type _Masked = _Requested | _ALLOC_MASK;
        if ( _Masked > _Max ) {
            return _Max;
        }

        if ( _Old > _Max - _Old / 2 ) {
            return _Max;
        }

        return ( :: std :: max ) ( _Masked, _Old + _Old / 2 );
    }

    [ [ nodiscard ] ] inline size_type _Calculate_growth ( const size_type _Requested ) const noexcept {
        return _Calculate_growth ( _Requested, _Mypair . _Myval2 . _Myres, max_size ( ) );
    }

    template < class _Fty, class ... _ArgTys >
    inline basic_string & _Reallocate_for ( const size_type _New_size, _Fty _Fn, _ArgTys ... _Args ) {


        if ( _New_size > max_size ( ) ) {
            _Xlen_string ( );
        }

        const size_type _Old_capacity = _Mypair . _Myval2 . _Myres;
        const size_type _New_capacity = _Calculate_growth ( _New_size );
        auto & _Al = _Getal ( );
        const pointer _New_ptr = _Al . allocate ( _New_capacity + 1 );






        _Mypair . _Myval2 . _Orphan_all ( );
        _Mypair . _Myval2 . _Mysize = _New_size;
        _Mypair . _Myval2 . _Myres = _New_capacity;
        _Fn ( _Unfancy ( _New_ptr ), _New_size, _Args ... );
        if ( _BUF_SIZE <= _Old_capacity ) {
            _Al . deallocate ( _Mypair . _Myval2 . _Bx . _Ptr, _Old_capacity + 1 );
            _Mypair . _Myval2 . _Bx . _Ptr = _New_ptr;
        } else {
            _Construct_in_place ( _Mypair . _Myval2 . _Bx . _Ptr, _New_ptr );
        }

        return * this;
    }

    template < class _Fty, class ... _ArgTys >
    inline basic_string & _Reallocate_grow_by (
        const size_type _Size_increase, _Fty _Fn, _ArgTys ... _Args ) {


        auto & _My_data = _Mypair . _Myval2;
        const size_type _Old_size = _My_data . _Mysize;
        if ( max_size ( ) - _Old_size < _Size_increase ) {
            _Xlen_string ( );
        }

        const size_type _New_size = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data . _Myres;
        const size_type _New_capacity = _Calculate_growth ( _New_size );
        auto & _Al = _Getal ( );
        const pointer _New_ptr = _Al . allocate ( _New_capacity + 1 );






        _My_data . _Orphan_all ( );
        _My_data . _Mysize = _New_size;
        _My_data . _Myres = _New_capacity;
        _Elem * const _Raw_new = _Unfancy ( _New_ptr );
        if ( _BUF_SIZE <= _Old_capacity ) {
            const pointer _Old_ptr = _My_data . _Bx . _Ptr;
            _Fn ( _Raw_new, _Unfancy ( _Old_ptr ), _Old_size, _Args ... );
            _Al . deallocate ( _Old_ptr, _Old_capacity + 1 );
            _My_data . _Bx . _Ptr = _New_ptr;
        } else {
            _Fn ( _Raw_new, _My_data . _Bx . _Buf, _Old_size, _Args ... );
            _Construct_in_place ( _My_data . _Bx . _Ptr, _New_ptr );
        }

        return * this;
    }

    void _Become_small ( ) {





        _Mypair . _Myval2 . _Orphan_all ( );
        const pointer _Ptr = _Mypair . _Myval2 . _Bx . _Ptr;
        auto & _Al = _Getal ( );
        _Destroy_in_place ( _Mypair . _Myval2 . _Bx . _Ptr );
        _Traits :: copy ( _Mypair . _Myval2 . _Bx . _Buf, _Unfancy ( _Ptr ), _Mypair . _Myval2 . _Mysize + 1 );
        _Al . deallocate ( _Ptr, _Mypair . _Myval2 . _Myres + 1 );
        _Mypair . _Myval2 . _Myres = _BUF_SIZE - 1;
    }

    inline void _Eos ( const size_type _Newsize ) {
        _Traits :: assign ( _Mypair . _Myval2 . _Myptr ( ) [ _Mypair . _Myval2 . _Mysize = _Newsize ], _Elem ( ) );
    }

    inline void _Tidy_init ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;
        _My_data . _Mysize = 0;












        {
            _My_data . _Myres = _BUF_SIZE - 1;

            _Traits :: assign ( _My_data . _Bx . _Buf [ 0 ], _Elem ( ) );
        }
    }

    inline void _Tidy_deallocate ( ) noexcept {
        _Mypair . _Myval2 . _Orphan_all ( );
        if ( _Mypair . _Myval2 . _Large_string_engaged ( ) ) {
            const pointer _Ptr = _Mypair . _Myval2 . _Bx . _Ptr;
            auto & _Al = _Getal ( );
            _Destroy_in_place ( _Mypair . _Myval2 . _Bx . _Ptr );
            _Al . deallocate ( _Ptr, _Mypair . _Myval2 . _Myres + 1 );
        }








        {
            _Mypair . _Myval2 . _Mysize = 0;
            _Mypair . _Myval2 . _Myres = _BUF_SIZE - 1;

            _Traits :: assign ( _Mypair . _Myval2 . _Bx . _Buf [ 0 ], _Elem ( ) );
        }
    }

public :
    inline void _Orphan_all ( ) noexcept {
        _Mypair . _Myval2 . _Orphan_all ( );
    }

private :
    inline void _Swap_proxy_and_iterators ( basic_string & _Right ) {
        _Mypair . _Myval2 . _Swap_proxy_and_iterators ( _Right . _Mypair . _Myval2 );
    }

    inline _Alty & _Getal ( ) noexcept {
        return _Mypair . _Get_first ( );
    }

    inline const _Alty & _Getal ( ) const noexcept {
        return _Mypair . _Get_first ( );
    }

    _Compressed_pair < _Alty, _Scary_val > _Mypair;
};
#line 4644 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template < class _Elem, class _Traits, class _Alloc >
inline void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
    basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 4650
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    const auto _Left_size = _Left . size ( );
    const auto _Right_size = _Right . size ( );
    if ( _Left . max_size ( ) - _Left_size < _Right_size ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Left, _Left . c_str ( ), _Left_size, _Right . c_str ( ), _Right_size };
}
#line 4662
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
      const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    using _Size_type = typename basic_string < _Elem, _Traits, _Alloc > :: size_type;
    const auto _Left_size = _Convert_size < _Size_type > ( _Traits :: length ( _Left ) );
    const auto _Right_size = _Right . size ( );
    if ( _Right . max_size ( ) - _Right_size < _Left_size ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Right, _Left, _Left_size, _Right . c_str ( ), _Right_size };
}
#line 4675
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const _Elem _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    const auto _Right_size = _Right . size ( );
    if ( _Right_size == _Right . max_size ( ) ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Right, :: std :: addressof ( _Left ), 1, _Right . c_str ( ), _Right_size };
}
#line 4686
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) {
    using _Size_type = typename basic_string < _Elem, _Traits, _Alloc > :: size_type;
    const auto _Left_size = _Left . size ( );
    const auto _Right_size = _Convert_size < _Size_type > ( _Traits :: length ( _Right ) );
    if ( _Left . max_size ( ) - _Left_size < _Right_size ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Left, _Left . c_str ( ), _Left_size, _Right, _Right_size };
}
#line 4699
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem _Right ) {
    const auto _Left_size = _Left . size ( );
    if ( _Left_size == _Left . max_size ( ) ) {
        _Xlen_string ( );
    }

    return { _String_constructor_concat_tag { }, _Left, _Left . c_str ( ), _Left_size, :: std :: addressof ( _Right ), 1 };
}
#line 4710
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, basic_string < _Elem, _Traits, _Alloc > && _Right ) {
    return :: std :: move ( _Right . insert ( 0, _Left ) );
}
#line 4716
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    basic_string < _Elem, _Traits, _Alloc > && _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    return :: std :: move ( _Left . append ( _Right ) );
}
#line 4722
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    basic_string < _Elem, _Traits, _Alloc > && _Left, basic_string < _Elem, _Traits, _Alloc > && _Right ) {







    return { _String_constructor_concat_tag { }, _Left, _Right };
}
#line 4735 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
      const _Elem * const _Left, basic_string < _Elem, _Traits, _Alloc > && _Right ) {
    return :: std :: move ( _Right . insert ( 0, _Left ) );
}
#line 4741
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const _Elem _Left, basic_string < _Elem, _Traits, _Alloc > && _Right ) {
    return :: std :: move ( _Right . insert ( 0, 1, _Left ) );
}
#line 4747
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    basic_string < _Elem, _Traits, _Alloc > && _Left, const _Elem * const _Right ) {
    return :: std :: move ( _Left . append ( _Right ) );
}
#line 4753
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline basic_string < _Elem, _Traits, _Alloc > operator + (
    basic_string < _Elem, _Traits, _Alloc > && _Left, const _Elem _Right ) {
    _Left . push_back ( _Right );
    return :: std :: move ( _Left );
}
#line 4760
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline bool operator == (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return _Left . _Equal ( _Right );
}
#line 4766
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] inline bool operator == (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) {
    return _Left . _Equal ( _Right );
}
#line 4785 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator == ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    return _Right . _Equal ( _Left );
}
#line 4790
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator != (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return ! ( _Left == _Right );
}
#line 4796
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator != ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    return ! ( _Left == _Right );
}
#line 4801
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator != ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) {
    return ! ( _Left == _Right );
}
#line 4806
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator < (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return _Left . compare ( _Right ) < 0;
}
#line 4812
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator < ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    return _Right . compare ( _Left ) > 0;
}
#line 4817
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator < ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) {
    return _Left . compare ( _Right ) < 0;
}
#line 4822
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator > (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return _Right < _Left;
}
#line 4828
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator > ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    return _Right < _Left;
}
#line 4833
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator > ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) {
    return _Right < _Left;
}
#line 4838
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator <= (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return ! ( _Right < _Left );
}
#line 4844
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator <= ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    return ! ( _Right < _Left );
}
#line 4849
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator <= ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) {
    return ! ( _Right < _Left );
}
#line 4854
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator >= (
    const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept {
    return ! ( _Left < _Right );
}
#line 4860
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator >= ( const _Elem * const _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) {
    return ! ( _Left < _Right );
}
#line 4865
template < class _Elem, class _Traits, class _Alloc >
[ [ nodiscard ] ] bool operator >= ( const basic_string < _Elem, _Traits, _Alloc > & _Left, const _Elem * const _Right ) {
    return ! ( _Left < _Right );
}
#line 4871 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
using string = basic_string< char, char_traits< char> , allocator< char> > ; 
#line 4872
using wstring = basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 4876
using u16string = basic_string< char16_t, char_traits< char16_t> , allocator< char16_t> > ; 
#line 4877
using u32string = basic_string< char32_t, char_traits< char32_t> , allocator< char32_t> > ; 
#line 4879
template < class _Elem, class _Traits, class _Alloc >
struct hash < basic_string < _Elem, _Traits, _Alloc > > {
     typedef basic_string < _Elem, _Traits, _Alloc > argument_type;
     typedef size_t result_type;

    [ [ nodiscard ] ] size_t operator ( ) ( const basic_string < _Elem, _Traits, _Alloc > & _Keyval ) const noexcept {
        return _Hash_array_representation ( _Keyval . c_str ( ), _Keyval . size ( ) );
    }
};
#line 4889
template < class _Elem, class _Traits, class _Alloc >
basic_istream < _Elem, _Traits > & operator >> (
    basic_istream < _Elem, _Traits > && _Istr, basic_string < _Elem, _Traits, _Alloc > & _Str ) {
    using _Myis = basic_istream < _Elem, _Traits >;
    using _Ctype = typename _Myis :: _Ctype;
    using _Mystr = basic_string < _Elem, _Traits, _Alloc >;
    using _Mysizt = typename _Mystr :: size_type;

    typename _Myis :: iostate _State = _Myis :: goodbit;
    bool _Changed = false;
    const typename _Myis :: sentry _Ok ( _Istr );

    if ( _Ok ) {
        const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( _Istr . getloc ( ) );
        _Str . erase ( );

        try {
        _Mysizt _Size;
        if ( 0 < _Istr . width ( ) && static_cast < _Mysizt > ( _Istr . width ( ) ) < _Str . max_size ( ) ) {
            _Size = static_cast < _Mysizt > ( _Istr . width ( ) );
        } else {
            _Size = _Str . max_size ( );
        }

        typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );

        for (; 0 < _Size; -- _Size, _Meta = _Istr . rdbuf ( ) -> snextc ( ) ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                _State |= _Myis :: eofbit;
                break;
            } else if ( _Ctype_fac . is ( _Ctype :: space, _Traits :: to_char_type ( _Meta ) ) ) {
                break;
            } else {
                _Str . push_back ( _Traits :: to_char_type ( _Meta ) );
                _Changed = true;
            }
        }
        } catch ( ... ) { ( _Istr ) . setstate ( _Myis :: badbit, true ); }
    }

    _Istr . width ( 0 );
    if ( ! _Changed ) {
        _State |= _Myis :: failbit;
    }

    _Istr . setstate ( _State );
    return _Istr;
}
#line 4938
template < class _Elem, class _Traits, class _Alloc >
basic_istream < _Elem, _Traits > & operator >> (
    basic_istream < _Elem, _Traits > & _Istr, basic_string < _Elem, _Traits, _Alloc > & _Str ) {
    return :: std :: move ( _Istr ) >> _Str;
}
#line 4944
template < class _Elem, class _Traits, class _Alloc >
basic_ostream < _Elem, _Traits > & operator << (
    basic_ostream < _Elem, _Traits > & _Ostr, const basic_string < _Elem, _Traits, _Alloc > & _Str ) {
    return _Insert_string ( _Ostr, _Str . data ( ), _Str . size ( ) );
}
#line 4950
inline namespace literals { 
#line 4951
inline namespace string_literals { 
#line 4959 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
[[nodiscard]] inline string operator ""s(const char *_Str, size_t _Len) { 
#line 4960
return string(_Str, _Len); 
#line 4961
} 
#line 4963
[[nodiscard]] inline wstring operator ""s(const __wchar_t *_Str, size_t _Len) { 
#line 4964
return wstring(_Str, _Len); 
#line 4965
} 
#line 4973
[[nodiscard]] inline u16string operator ""s(const char16_t *_Str, size_t _Len) { 
#line 4974
return u16string(_Str, _Len); 
#line 4975
} 
#line 4977
[[nodiscard]] inline u32string operator ""s(const char32_t *_Str, size_t _Len) { 
#line 4978
return u32string(_Str, _Len); 
#line 4979
} 
#line 4983
}
#line 4984
}
#line 5014 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
}
#line 5018
#pragma warning(pop)
#pragma pack ( pop )
#line 5022 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 20
namespace std { 
#line 21
class logic_error : public exception { 
#line 23
public: using _Mybase = exception; 
#line 25
explicit logic_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 27
explicit logic_error(const char *_Message) : _Mybase(_Message) { } 
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 37
class domain_error : public logic_error { 
#line 39
public: using _Mybase = logic_error; 
#line 41
explicit domain_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 43
explicit domain_error(const char *_Message) : _Mybase(_Message) { } 
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 53
class invalid_argument : public logic_error { 
#line 55
public: using _Mybase = logic_error; 
#line 57
explicit invalid_argument(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 59
explicit invalid_argument(const char *_Message) : _Mybase(_Message) { } 
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 69
class length_error : public logic_error { 
#line 71
public: using _Mybase = logic_error; 
#line 73
explicit length_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 75
explicit length_error(const char *_Message) : _Mybase(_Message) { } 
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 85
class out_of_range : public logic_error { 
#line 87
public: using _Mybase = logic_error; 
#line 89
explicit out_of_range(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 91
explicit out_of_range(const char *_Message) : _Mybase(_Message) { } 
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 101
class runtime_error : public exception { 
#line 103
public: using _Mybase = exception; 
#line 105
explicit runtime_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 107
explicit runtime_error(const char *_Message) : _Mybase(_Message) { } 
#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 117
class overflow_error : public runtime_error { 
#line 119
public: using _Mybase = runtime_error; 
#line 121
explicit overflow_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 123
explicit overflow_error(const char *_Message) : _Mybase(_Message) { } 
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 133
class underflow_error : public runtime_error { 
#line 135
public: using _Mybase = runtime_error; 
#line 137
explicit underflow_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 139
explicit underflow_error(const char *_Message) : _Mybase(_Message) { } 
#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 149
class range_error : public runtime_error { 
#line 151
public: using _Mybase = runtime_error; 
#line 153
explicit range_error(const string &_Message) : _Mybase(_Message.c_str()) { } 
#line 155
explicit range_error(const char *_Message) : _Mybase(_Message) { } 
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
}; 
#line 165
[[noreturn]] inline void _Throw_range_error(const char *const _Message) { 
#line 166
throw range_error{_Message}; 
#line 167
} 
#line 168
}
#line 171
#pragma warning(pop)
#pragma pack ( pop )
#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xcall_once.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 19
namespace std { 
#line 20
struct once_flag { 
#line 21
constexpr once_flag() noexcept : _Opaque((nullptr)) { } 
#line 23
once_flag(const once_flag &) = delete;
#line 24
once_flag &operator=(const once_flag &) = delete;
#line 26
void *_Opaque; 
#line 27
}; 
#line 29
using _Execute_once_fp_t = int (__stdcall *)(void *, void *, void **); 
#line 31
int __cdecl _Execute_once(once_flag & _Flag, _Execute_once_fp_t _Callback, void * _Pv) noexcept; 
#line 34
template < class _Ty >
union _Immortalizer_impl {
    constexpr _Immortalizer_impl ( ) noexcept : _Storage { } { }
    _Immortalizer_impl ( const _Immortalizer_impl & ) = delete;
    _Immortalizer_impl & operator = ( const _Immortalizer_impl & ) = delete;
    ~ _Immortalizer_impl ( ) {

    }

    _Ty _Storage;
};
#line 45
}
#line 49
#pragma warning(pop)
#pragma pack ( pop )
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xcall_once.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xerrc.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 19
namespace std { 
#line 20
enum class errc { 
#line 21
address_family_not_supported = 102, 
#line 22
address_in_use = 100, 
#line 23
address_not_available, 
#line 24
already_connected = 113, 
#line 25
argument_list_too_long = 7, 
#line 26
argument_out_of_domain = 33, 
#line 27
bad_address = 14, 
#line 28
bad_file_descriptor = 9, 
#line 29
bad_message = 104, 
#line 30
broken_pipe = 32, 
#line 31
connection_aborted = 106, 
#line 32
connection_already_in_progress = 103, 
#line 33
connection_refused = 107, 
#line 34
connection_reset, 
#line 35
cross_device_link = 18, 
#line 36
destination_address_required = 109, 
#line 37
device_or_resource_busy = 16, 
#line 38
directory_not_empty = 41, 
#line 39
executable_format_error = 8, 
#line 40
file_exists = 17, 
#line 41
file_too_large = 27, 
#line 42
filename_too_long = 38, 
#line 43
function_not_supported = 40, 
#line 44
host_unreachable = 110, 
#line 45
identifier_removed, 
#line 46
illegal_byte_sequence = 42, 
#line 47
inappropriate_io_control_operation = 25, 
#line 48
interrupted = 4, 
#line 49
invalid_argument = 22, 
#line 50
invalid_seek = 29, 
#line 51
io_error = 5, 
#line 52
is_a_directory = 21, 
#line 53
message_size = 115, 
#line 54
network_down, 
#line 55
network_reset, 
#line 56
network_unreachable, 
#line 57
no_buffer_space, 
#line 58
no_child_process = 10, 
#line 59
no_link = 121, 
#line 60
no_lock_available = 39, 
#line 61
no_message_available = 120, 
#line 62
no_message = 122, 
#line 63
no_protocol_option, 
#line 64
no_space_on_device = 28, 
#line 65
no_stream_resources = 124, 
#line 66
no_such_device_or_address = 6, 
#line 67
no_such_device = 19, 
#line 68
no_such_file_or_directory = 2, 
#line 69
no_such_process, 
#line 70
not_a_directory = 20, 
#line 71
not_a_socket = 128, 
#line 72
not_a_stream = 125, 
#line 73
not_connected, 
#line 74
not_enough_memory = 12, 
#line 75
not_supported = 129, 
#line 76
operation_canceled = 105, 
#line 77
operation_in_progress = 112, 
#line 78
operation_not_permitted = 1, 
#line 79
operation_not_supported = 130, 
#line 80
operation_would_block = 140, 
#line 81
owner_dead = 133, 
#line 82
permission_denied = 13, 
#line 83
protocol_error = 134, 
#line 84
protocol_not_supported, 
#line 85
read_only_file_system = 30, 
#line 86
resource_deadlock_would_occur = 36, 
#line 87
resource_unavailable_try_again = 11, 
#line 88
result_out_of_range = 34, 
#line 89
state_not_recoverable = 127, 
#line 90
stream_timeout = 137, 
#line 91
text_file_busy = 139, 
#line 92
timed_out = 138, 
#line 93
too_many_files_open_in_system = 23, 
#line 94
too_many_files_open, 
#line 95
too_many_links = 31, 
#line 96
too_many_symbolic_link_levels = 114, 
#line 97
value_too_large = 132, 
#line 98
wrong_protocol_type = 136
#line 99
}; 
#line 101
}
#line 105
#pragma warning(pop)
#pragma pack ( pop )
#line 110 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xerrc.h"
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtimec.h"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ctime"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#line 22
using ::clock_t;
#line 24
using ::time_t;
#line 26
using ::asctime;
#line 27
using ::clock;
#line 28
using ::ctime;
#line 29
using ::difftime;
#line 30
using ::gmtime;
#line 31
using ::localtime;
#line 32
using ::mktime;
#line 33
using ::strftime;
#line 34
using ::time;
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ctime"
}
#line 43
#pragma warning(pop)
#pragma pack ( pop )
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ctime"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtimec.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
extern "C" {
#line 23
struct xtime { 
#line 24
__time64_t sec; 
#line 25
long nsec; 
#line 26
}; 
#line 28
int __cdecl xtime_get(xtime *, int); 
#line 30
long __cdecl _Xtime_diff_to_millis(const xtime *); 
#line 31
long __cdecl _Xtime_diff_to_millis2(const xtime *, const xtime *); 
#line 32
__int64 __cdecl _Xtime_get_ticks(); 
#line 34
__int64 __cdecl _Query_perf_counter(); 
#line 35
__int64 __cdecl _Query_perf_frequency(); 
#line 37
}
#line 41
#pragma warning(pop)
#pragma pack ( pop )
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtimec.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
extern "C" {
#line 22
using _Thrd_id_t = unsigned; 
#line 23
struct _Thrd_t { 
#line 24
void *_Hnd; 
#line 25
_Thrd_id_t _Id; 
#line 26
}; 
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"
using _Mtx_t = struct _Mtx_internal_imp_t *; 
#line 57
using _Cnd_t = struct _Cnd_internal_imp_t *; 
#line 59
enum { _Thrd_success, _Thrd_nomem, _Thrd_timedout, _Thrd_busy, _Thrd_error}; 
#line 62
int __cdecl _Thrd_detach(_Thrd_t); 
#line 63
int __cdecl _Thrd_join(_Thrd_t, int *); 
#line 64
void __cdecl _Thrd_sleep(const xtime *); 
#line 65
void __cdecl _Thrd_yield(); 
#line 66
unsigned __cdecl _Thrd_hardware_concurrency(); 
#line 67
_Thrd_id_t __cdecl _Thrd_id(); 
#line 70
enum { 
#line 71
_Mtx_plain = 1, 
#line 72
_Mtx_try, 
#line 73
_Mtx_timed = 4, 
#line 74
_Mtx_recursive = 256
#line 75
}; 
#line 77
int __cdecl _Mtx_init(_Mtx_t *, int); 
#line 78
void __cdecl _Mtx_destroy(_Mtx_t); 
#line 79
void __cdecl _Mtx_init_in_situ(_Mtx_t, int); 
#line 80
void __cdecl _Mtx_destroy_in_situ(_Mtx_t); 
#line 81
int __cdecl _Mtx_current_owns(_Mtx_t); 
#line 82
int __cdecl _Mtx_lock(_Mtx_t); 
#line 83
int __cdecl _Mtx_trylock(_Mtx_t); 
#line 84
int __cdecl _Mtx_timedlock(_Mtx_t, const xtime *); 
#line 85
int __cdecl _Mtx_unlock(_Mtx_t); 
#line 87
void *__cdecl _Mtx_getconcrtcs(_Mtx_t); 
#line 88
void __cdecl _Mtx_clear_owner(_Mtx_t); 
#line 89
void __cdecl _Mtx_reset_owner(_Mtx_t); 
#line 93
using _Smtx_t = void *; 
#line 94
void __cdecl _Smtx_lock_exclusive(_Smtx_t *); 
#line 95
void __cdecl _Smtx_lock_shared(_Smtx_t *); 
#line 96
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t *); 
#line 97
int __cdecl _Smtx_try_lock_shared(_Smtx_t *); 
#line 98
void __cdecl _Smtx_unlock_exclusive(_Smtx_t *); 
#line 99
void __cdecl _Smtx_unlock_shared(_Smtx_t *); 
#line 102
int __cdecl _Cnd_init(_Cnd_t *); 
#line 103
void __cdecl _Cnd_destroy(_Cnd_t); 
#line 104
void __cdecl _Cnd_init_in_situ(_Cnd_t); 
#line 105
void __cdecl _Cnd_destroy_in_situ(_Cnd_t); 
#line 106
int __cdecl _Cnd_wait(_Cnd_t, _Mtx_t); 
#line 107
int __cdecl _Cnd_timedwait(_Cnd_t, _Mtx_t, const xtime *); 
#line 108
int __cdecl _Cnd_broadcast(_Cnd_t); 
#line 109
int __cdecl _Cnd_signal(_Cnd_t); 
#line 110
void __cdecl _Cnd_register_at_thread_exit(_Cnd_t, _Mtx_t, int *); 
#line 111
void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t); 
#line 112
void __cdecl _Cnd_do_broadcast_at_thread_exit(); 
#line 113
}
#line 115
namespace std { 
#line 116
enum { 
#line 117
_DEVICE_OR_RESOURCE_BUSY, 
#line 118
_INVALID_ARGUMENT, 
#line 119
_NO_SUCH_PROCESS, 
#line 120
_NOT_ENOUGH_MEMORY, 
#line 121
_OPERATION_NOT_PERMITTED, 
#line 122
_RESOURCE_DEADLOCK_WOULD_OCCUR, 
#line 123
_RESOURCE_UNAVAILABLE_TRY_AGAIN
#line 124
}; 
#line 126
[[noreturn]] void __cdecl _Throw_C_error(int _Code); 
#line 127
[[noreturn]] void __cdecl _Throw_Cpp_error(int _Code); 
#line 129
inline int _Check_C_return(int _Res) { 
#line 130
if (_Res != (_Thrd_success)) { 
#line 131
_Throw_C_error(_Res); 
#line 132
}  
#line 134
return _Res; 
#line 135
} 
#line 136
}
#line 139
#pragma warning(pop)
#pragma pack ( pop )
#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
extern "C" [[nodiscard]] unsigned char __stdcall __std_atomic_compare_exchange_128(__int64 * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult) noexcept; 
#line 64
extern "C" [[nodiscard]] char __stdcall __std_atomic_has_cmpxchg16b() noexcept; 
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
extern "C" {
#line 196
_Smtx_t *__stdcall __std_atomic_get_mutex(const void * _Key) noexcept; 
#line 197
}
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
namespace std { 
#line 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Storage_for {

    alignas ( _Ty ) unsigned char _Storage [ sizeof ( _Ty ) ];

    _Storage_for ( ) = default;
    _Storage_for ( const _Storage_for & ) = delete;
    _Storage_for & operator = ( const _Storage_for & ) = delete;








    [ [ nodiscard ] ] _Ty & _Ref ( ) noexcept {
        return reinterpret_cast < _Ty & > ( _Storage );
    }

    [ [ nodiscard ] ] _Ty * _Ptr ( ) noexcept {
        return reinterpret_cast < _Ty * > ( & _Storage );
    }
};
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
extern "C" inline void atomic_thread_fence(const memory_order _Order) noexcept { 
#line 245
if (_Order == (memory_order_relaxed)) { 
#line 246
return; 
#line 247
}  
#line 250
__pragma( warning(push)) __pragma( warning(disable : 4996)) _ReadWriteBarrier(); __pragma( warning(pop)) 
#line 251
if (_Order == (memory_order_seq_cst)) { 
#line 252
volatile long _Guard; 
#line 257
#pragma warning(suppress : 6001)
#pragma warning(suppress : 28113)
#line 260
(void)_InterlockedIncrement(&_Guard); 
#line 261
__pragma( warning(push)) __pragma( warning(disable : 4996)) _ReadWriteBarrier(); __pragma( warning(pop)) 
#line 262
}  
#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
} 
#line 270
extern "C" inline void atomic_signal_fence(const memory_order _Order) noexcept { 
#line 271
if (_Order != (memory_order_relaxed)) { 
#line 272
__pragma( warning(push)) __pragma( warning(disable : 4996)) _ReadWriteBarrier(); __pragma( warning(pop)) 
#line 273
}  
#line 274
} 
#line 276
template < class _Ty >
_Ty kill_dependency ( _Ty _Arg ) noexcept {
    return _Arg;
}
#line 281
inline void _Check_memory_order(const memory_order _Order) noexcept { 
#line 283
if ((static_cast< unsigned>(_Order)) > (static_cast< unsigned>(memory_order_seq_cst))) { 
#line 284
; 
#line 285
}  
#line 286
} 
#line 288
inline void _Check_store_memory_order(const memory_order _Order) noexcept { 
#line 289
switch (_Order) { 
#line 290
case memory_order_relaxed:  
#line 291
case memory_order_release:  
#line 292
case memory_order_seq_cst:  
#line 294
break; 
#line 295
case memory_order_consume:  
#line 296
case memory_order_acquire:  
#line 297
case memory_order_acq_rel:  
#line 298
default:  
#line 299
; 
#line 300
break; 
#line 301
}  
#line 302
} 
#line 304
inline void _Check_load_memory_order(const memory_order _Order) noexcept { 
#line 305
switch (_Order) { 
#line 306
case memory_order_relaxed:  
#line 307
case memory_order_consume:  
#line 308
case memory_order_acquire:  
#line 309
case memory_order_seq_cst:  
#line 311
break; 
#line 312
case memory_order_release:  
#line 313
case memory_order_acq_rel:  
#line 314
default:  
#line 315
; 
#line 316
break; 
#line 317
}  
#line 318
} 
#line 320
[[nodiscard]] inline memory_order _Combine_cas_memory_orders(const memory_order 
#line 321
_Success, const memory_order _Failure) noexcept { 
#line 333
static constexpr memory_order _Combined_memory_orders[6][6] = {{memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_consume, memory_order_consume, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_acquire, memory_order_acquire, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_release, memory_order_acq_rel, memory_order_acq_rel, memory_order_release, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_seq_cst}, {memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst}}; 
#line 347
_Check_memory_order(_Success); 
#line 348
_Check_load_memory_order(_Failure); 
#line 349
return (_Combined_memory_orders[static_cast< int>(_Success)])[static_cast< int>(_Failure)]; 
#line 350
} 
#line 352
template < class _Integral, class _Ty >
[ [ nodiscard ] ] _Integral _Atomic_reinterpret_as ( const _Ty & _Source ) noexcept {

    static_assert ( is_integral_v < _Integral >, "Tried to reinterpret memory as non-integral" );
    if constexpr ( is_integral_v < _Ty > && sizeof ( _Integral ) == sizeof ( _Ty ) ) {
        return static_cast < _Integral > ( _Source );
    } else if constexpr ( is_pointer_v < _Ty > && sizeof ( _Integral ) == sizeof ( _Ty ) ) {
        return reinterpret_cast < _Integral > ( _Source );
    } else {
        _Integral _Result { };
        :: memcpy ( & _Result, :: std :: addressof ( _Source ), sizeof ( _Source ) );
        return _Result;
    }
}
#line 367
inline void _Load_barrier(const memory_order _Order) noexcept { 
#line 368
switch (_Order) { 
#line 369
case memory_order_relaxed:  
#line 371
break; 
#line 372
default:  
#line 373
case memory_order_release:  
#line 374
case memory_order_acq_rel:  
#line 375
; 
#line 377
case memory_order_consume:  
#line 378
case memory_order_acquire:  
#line 379
case memory_order_seq_cst:  
#line 380
__pragma( warning(push)) __pragma( warning(disable : 4996)) _ReadWriteBarrier(); __pragma( warning(pop)) 
#line 381
break; 
#line 382
}  
#line 383
} 
#line 386
template< class _Ty> 
#line 387
struct _Atomic_padded { 
#line 388
alignas(sizeof(_Ty)) mutable _Ty _Value; 
#line 389
}; 
#line 431 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template< class _Ty> 
#line 432
struct _Atomic_storage_types { 
#line 433
using _TStorage = _Atomic_padded< _Ty> ; 
#line 434
using _Spinlock = long; 
#line 435
}; 
#line 437
template< class _Ty> 
#line 438
struct _Atomic_storage_types< _Ty &>  { 
#line 439
using _TStorage = _Ty &; 
#line 440
using _Spinlock = _Smtx_t *; 
#line 441
}; 
#line 444
template < class _Ty, size_t = sizeof ( remove_reference_t < _Ty > ) >



struct _Atomic_storage;
#line 480 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
inline void _Atomic_lock_acquire(long &_Spinlock) noexcept { 
#line 485
int _Current_backoff = 1; 
#line 486
const int _Max_backoff = 64; 
#line 487
while (_InterlockedExchange(&_Spinlock, 1) != (0)) { 
#line 488
while (__iso_volatile_load32(&(reinterpret_cast< int &>(_Spinlock))) != 0) { 
#line 489
for (int _Count_down = _Current_backoff; _Count_down != 0; --_Count_down) { 
#line 490
_mm_pause(); 
#line 491
}  
#line 492
_Current_backoff = ((_Current_backoff < _Max_backoff) ? _Current_backoff << 1 : _Max_backoff); 
#line 493
}  
#line 494
}  
#line 504 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
} 
#line 506
inline void _Atomic_lock_release(long &_Spinlock) noexcept { 
#line 508
_InterlockedExchange(&_Spinlock, 0); 
#line 516 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
} 
#line 518
inline void _Atomic_lock_acquire(_Smtx_t *_Spinlock) noexcept { 
#line 519
_Smtx_lock_exclusive(_Spinlock); 
#line 520
} 
#line 522
inline void _Atomic_lock_release(_Smtx_t *_Spinlock) noexcept { 
#line 523
_Smtx_unlock_exclusive(_Spinlock); 
#line 524
} 
#line 526
template < class _Spinlock_t >
class [ [ nodiscard ] ] _Atomic_lock_guard {
public :
    explicit _Atomic_lock_guard ( _Spinlock_t & _Spinlock_ ) noexcept : _Spinlock ( _Spinlock_ ) {
        _Atomic_lock_acquire ( _Spinlock );
    }

    ~ _Atomic_lock_guard ( ) {
        _Atomic_lock_release ( _Spinlock );
    }

    _Atomic_lock_guard ( const _Atomic_lock_guard & ) = delete;
    _Atomic_lock_guard & operator = ( const _Atomic_lock_guard & ) = delete;

private :
    _Spinlock_t & _Spinlock;
};
#line 570 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty, size_t >
struct _Atomic_storage {



    using _TVal = remove_reference_t < _Ty >;
    using _Guard = _Atomic_lock_guard < typename _Atomic_storage_types < _Ty > :: _Spinlock >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( conditional_t < is_reference_v < _Ty >, _Ty, const _TVal > _Value ) noexcept
        : _Storage ( _Value ) {

    }

    void store ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        _Check_store_memory_order ( _Order );
        _Guard _Lock { _Spinlock };
        _Storage = _Value;
    }

    [ [ nodiscard ] ] _TVal load ( const memory_order _Order = memory_order_seq_cst ) const noexcept {

        _Check_load_memory_order ( _Order );
        _Guard _Lock { _Spinlock };
        _TVal _Local ( _Storage );
        return _Local;
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        _Check_memory_order ( _Order );
        _Guard _Lock { _Spinlock };
        _TVal _Result ( _Storage );
        _Storage = _Value;
        return _Result;
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        _Check_memory_order ( _Order );
        const auto _Storage_ptr = :: std :: addressof ( _Storage );
        const auto _Expected_ptr = :: std :: addressof ( _Expected );
        bool _Result;



        _Guard _Lock { _Spinlock };











        _Result = :: memcmp ( _Storage_ptr, _Expected_ptr, sizeof ( _TVal ) ) == 0;

        if ( _Result ) {
            :: memcpy ( _Storage_ptr, :: std :: addressof ( _Desired ), sizeof ( _TVal ) );
        } else {
            :: memcpy ( _Expected_ptr, _Storage_ptr, sizeof ( _TVal ) );
        }

        return _Result;
    }
















































protected :
    void _Init_spinlock_for_ref ( ) noexcept {
        _Spinlock = __std_atomic_get_mutex ( :: std :: addressof ( _Storage ) );
    }

private :

    mutable typename _Atomic_storage_types < _Ty > :: _Spinlock _Spinlock { };

public :
    _Ty _Storage { };





};
#line 706 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty, 1 > {

    using _TVal = remove_reference_t < _Ty >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( conditional_t < is_reference_v < _Ty >, _Ty, const _TVal > _Value ) noexcept
        : _Storage { _Value } {

    }

    void store ( const _TVal _Value ) noexcept {
        const auto _Mem = _Atomic_address_as < char > ( _Storage );
        const char _As_bytes = _Atomic_reinterpret_as < char > ( _Value );





        ( void ) _InterlockedExchange8 ( _Mem, _As_bytes );

    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        const auto _Mem = _Atomic_address_as < char > ( _Storage );
        const char _As_bytes = _Atomic_reinterpret_as < char > ( _Value );
        switch ( _Order ) {
        case memory_order_relaxed :
            __iso_volatile_store8 ( _Mem, _As_bytes );
            return;
        case memory_order_release :
            __pragma(warning(push))                                    __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                          __pragma(warning(pop));
            __iso_volatile_store8 ( _Mem, _As_bytes );
            return;
        default :
        case memory_order_consume :
        case memory_order_acquire :
        case memory_order_acq_rel :
            ;

        case memory_order_seq_cst :
            store ( _Value );
            return;
        }
    }

    [ [ nodiscard ] ] _TVal load ( ) const noexcept {
        const auto _Mem = _Atomic_address_as < char > ( _Storage );
        char _As_bytes = __iso_volatile_load8 ( _Mem );
        __pragma(warning(push))                                __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                      __pragma(warning(pop));
        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    [ [ nodiscard ] ] _TVal load ( const memory_order _Order ) const noexcept {
        const auto _Mem = _Atomic_address_as < char > ( _Storage );
        char _As_bytes = __iso_volatile_load8 ( _Mem );
        _Load_barrier ( _Order );
        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        char _As_bytes;
        _Check_memory_order ( _Order ); _As_bytes = _InterlockedExchange8 ( _Atomic_address_as < char > ( _Storage ), _Atomic_reinterpret_as < char > ( _Value ) );

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Expected_bytes = _Atomic_reinterpret_as < char > ( _Expected );
        char _Prev_bytes;





















        _Check_memory_order ( _Order ); _Prev_bytes = _InterlockedCompareExchange8 ( _Atomic_address_as < char > ( _Storage ), _Atomic_reinterpret_as < char > ( _Desired ), _Expected_bytes );

        if ( _Prev_bytes == _Expected_bytes ) {
            return true;
        }

        reinterpret_cast < char & > ( _Expected ) = _Prev_bytes;
        return false;
    }















    typename _Atomic_storage_types < _Ty > :: _TStorage _Storage;
};
#line 827 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty, 2 > {

    using _TVal = remove_reference_t < _Ty >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( conditional_t < is_reference_v < _Ty >, _Ty, const _TVal > _Value ) noexcept
        : _Storage { _Value } {

    }

    void store ( const _TVal _Value ) noexcept {
        const auto _Mem = _Atomic_address_as < short > ( _Storage );
        const short _As_bytes = _Atomic_reinterpret_as < short > ( _Value );





        ( void ) _InterlockedExchange16 ( _Mem, _As_bytes );

    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        const auto _Mem = _Atomic_address_as < short > ( _Storage );
        const short _As_bytes = _Atomic_reinterpret_as < short > ( _Value );
        switch ( _Order ) {
        case memory_order_relaxed :
            __iso_volatile_store16 ( _Mem, _As_bytes );
            return;
        case memory_order_release :
            __pragma(warning(push))                                    __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                          __pragma(warning(pop));
            __iso_volatile_store16 ( _Mem, _As_bytes );
            return;
        default :
        case memory_order_consume :
        case memory_order_acquire :
        case memory_order_acq_rel :
            ;

        case memory_order_seq_cst :
            store ( _Value );
            return;
        }
    }

    [ [ nodiscard ] ] _TVal load ( ) const noexcept {
        const auto _Mem = _Atomic_address_as < short > ( _Storage );
        short _As_bytes = __iso_volatile_load16 ( _Mem );
        __pragma(warning(push))                                __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                      __pragma(warning(pop));
        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    [ [ nodiscard ] ] _TVal load ( const memory_order _Order ) const noexcept {
        const auto _Mem = _Atomic_address_as < short > ( _Storage );
        short _As_bytes = __iso_volatile_load16 ( _Mem );
        _Load_barrier ( _Order );
        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        short _As_bytes;
        _Check_memory_order ( _Order ); _As_bytes = _InterlockedExchange16 ( _Atomic_address_as < short > ( _Storage ), _Atomic_reinterpret_as < short > ( _Value ) );

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Expected_bytes = _Atomic_reinterpret_as < short > ( _Expected );
        short _Prev_bytes;




















        _Check_memory_order ( _Order ); _Prev_bytes = _InterlockedCompareExchange16 ( _Atomic_address_as < short > ( _Storage ), _Atomic_reinterpret_as < short > ( _Desired ), _Expected_bytes );

        if ( _Prev_bytes == _Expected_bytes ) {
            return true;
        }

        :: memcpy ( :: std :: addressof ( _Expected ), & _Prev_bytes, sizeof ( _Ty ) );
        return false;
    }















    typename _Atomic_storage_types < _Ty > :: _TStorage _Storage;
};
#line 947 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty, 4 > {

    using _TVal = remove_reference_t < _Ty >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( conditional_t < is_reference_v < _Ty >, _Ty, const _TVal > _Value ) noexcept
        : _Storage { _Value } {

    }

    void store ( const _TVal _Value ) noexcept {





        ( void ) _InterlockedExchange ( _Atomic_address_as < long > ( _Storage ), _Atomic_reinterpret_as < long > ( _Value ) );

    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        const auto _Mem = _Atomic_address_as < int > ( _Storage );
        const int _As_bytes = _Atomic_reinterpret_as < int > ( _Value );
        switch ( _Order ) {
        case memory_order_relaxed :
            __iso_volatile_store32 ( _Mem, _As_bytes );
            return;
        case memory_order_release :
            __pragma(warning(push))                                    __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                          __pragma(warning(pop));
            __iso_volatile_store32 ( _Mem, _As_bytes );
            return;
        default :
        case memory_order_consume :
        case memory_order_acquire :
        case memory_order_acq_rel :
            ;

        case memory_order_seq_cst :
            store ( _Value );
            return;
        }
    }

    [ [ nodiscard ] ] _TVal load ( ) const noexcept {
        const auto _Mem = _Atomic_address_as < int > ( _Storage );
        auto _As_bytes = __iso_volatile_load32 ( _Mem );
        __pragma(warning(push))                                __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                      __pragma(warning(pop));
        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    [ [ nodiscard ] ] _TVal load ( const memory_order _Order ) const noexcept {
        const auto _Mem = _Atomic_address_as < int > ( _Storage );
        auto _As_bytes = __iso_volatile_load32 ( _Mem );
        _Load_barrier ( _Order );
        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        long _As_bytes;
        _Check_memory_order ( _Order ); _As_bytes = _InterlockedExchange ( _Atomic_address_as < long > ( _Storage ), _Atomic_reinterpret_as < long > ( _Value ) );

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Expected_bytes = _Atomic_reinterpret_as < long > ( _Expected );
        long _Prev_bytes;




















        _Check_memory_order ( _Order ); _Prev_bytes = _InterlockedCompareExchange ( _Atomic_address_as < long > ( _Storage ), _Atomic_reinterpret_as < long > ( _Desired ), _Expected_bytes );

        if ( _Prev_bytes == _Expected_bytes ) {
            return true;
        }

        :: memcpy ( :: std :: addressof ( _Expected ), & _Prev_bytes, sizeof ( _TVal ) );
        return false;
    }















    typename _Atomic_storage_types < _Ty > :: _TStorage _Storage;
};
#line 1065 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty, 8 > {

    using _TVal = remove_reference_t < _Ty >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( conditional_t < is_reference_v < _Ty >, _Ty, const _TVal > _Value ) noexcept
        : _Storage { _Value } {

    }

    void store ( const _TVal _Value ) noexcept {
        const auto _Mem = _Atomic_address_as < long long > ( _Storage );
        const long long _As_bytes = _Atomic_reinterpret_as < long long > ( _Value );









        ( void ) _InterlockedExchange64 ( _Mem, _As_bytes );

    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        const auto _Mem = _Atomic_address_as < long long > ( _Storage );
        const long long _As_bytes = _Atomic_reinterpret_as < long long > ( _Value );
        switch ( _Order ) {
        case memory_order_relaxed :
            __iso_volatile_store64 ( _Mem, _As_bytes );
            return;
        case memory_order_release :
            __pragma(warning(push))                                    __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                          __pragma(warning(pop));
            __iso_volatile_store64 ( _Mem, _As_bytes );
            return;
        default :
        case memory_order_consume :
        case memory_order_acquire :
        case memory_order_acq_rel :
            ;

        case memory_order_seq_cst :
            store ( _Value );
            return;
        }
    }

    [ [ nodiscard ] ] _TVal load ( ) const noexcept {
        const auto _Mem = _Atomic_address_as < long long > ( _Storage );
        long long _As_bytes;




        _As_bytes = __iso_volatile_load64 ( _Mem );
        __pragma(warning(push))                                __pragma(warning(disable : 4996)) _ReadWriteBarrier ( )                                                                                      __pragma(warning(pop));

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }

    [ [ nodiscard ] ] _TVal load ( const memory_order _Order ) const noexcept {
        const auto _Mem = _Atomic_address_as < long long > ( _Storage );



        long long _As_bytes = __iso_volatile_load64 ( _Mem );

        _Load_barrier ( _Order );
        return reinterpret_cast < _TVal & > ( _As_bytes );
    }











    _TVal exchange ( const _TVal _Value, const memory_order _Order = memory_order_seq_cst ) noexcept {

        long long _As_bytes;
        _Check_memory_order ( _Order ); _As_bytes = _InterlockedExchange64 ( _Atomic_address_as < long long > ( _Storage ), _Atomic_reinterpret_as < long long > ( _Value ) );

        return reinterpret_cast < _TVal & > ( _As_bytes );
    }


    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Expected_bytes = _Atomic_reinterpret_as < long long > ( _Expected );
        long long _Prev_bytes;






















        _Check_memory_order ( _Order ); _Prev_bytes = _InterlockedCompareExchange64 ( _Atomic_address_as < long long > ( _Storage ), _Atomic_reinterpret_as < long long > ( _Desired ), _Expected_bytes );

        if ( _Prev_bytes == _Expected_bytes ) {
            return true;
        }

        :: memcpy ( :: std :: addressof ( _Expected ), & _Prev_bytes, sizeof ( _TVal ) );
        return false;
    }















    typename _Atomic_storage_types < _Ty > :: _TStorage _Storage;
};
#line 1213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_storage < _Ty &, 16 > {

    using _TVal = remove_reference_t < _Ty & >;

    _Atomic_storage ( ) = default;

     constexpr _Atomic_storage ( conditional_t < is_reference_v < _Ty & >, _Ty &, const _TVal > _Value ) noexcept
        : _Storage { _Value } { }

    void store ( const _TVal _Value ) noexcept {
        ( void ) exchange ( _Value );
    }

    void store ( const _TVal _Value, const memory_order _Order ) noexcept {
        _Check_store_memory_order ( _Order );
        ( void ) exchange ( _Value, _Order );
    }

    [ [ nodiscard ] ] _TVal load ( ) const noexcept {
        long long * const _Storage_ptr = const_cast < long long * > ( _Atomic_address_as < const long long > ( _Storage ) );
        _Int128 _Result { };
        ( void ) __std_atomic_compare_exchange_128 ( _Storage_ptr, 0, 0, & _Result . _Low );
        return reinterpret_cast < _TVal & > ( _Result );
    }

    [ [ nodiscard ] ] _TVal load ( const memory_order _Order ) const noexcept {























        _Check_load_memory_order ( _Order );
        return load ( );

    }

    _TVal exchange ( const _TVal _Value ) noexcept {
        _TVal _Result { _Value };
        while ( ! compare_exchange_strong ( _Result, _Value ) ) {
        }

        return _Result;
    }

    _TVal exchange ( const _TVal _Value, const memory_order _Order ) noexcept {
        _TVal _Result { _Value };
        while ( ! compare_exchange_strong ( _Result, _Value, _Order ) ) {
        }

        return _Result;
    }

    bool compare_exchange_strong ( _TVal & _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst ) noexcept {
        _Int128 _Desired_bytes { };
        :: memcpy ( & _Desired_bytes, :: std :: addressof ( _Desired ), sizeof ( _TVal ) );
        _Int128 _Expected_temp { };
        :: memcpy ( & _Expected_temp, :: std :: addressof ( _Expected ), sizeof ( _TVal ) );
        unsigned char _Result;







































        ( void ) _Order;
        _Result = __std_atomic_compare_exchange_128 (
            & reinterpret_cast < long long & > ( _Storage ), _Desired_bytes . _High, _Desired_bytes . _Low, & _Expected_temp . _Low );

        if ( _Result == 0 ) {
            :: memcpy ( :: std :: addressof ( _Expected ), & _Expected_temp, sizeof ( _TVal ) );
        }

        return _Result != 0;
    }









































    struct _Int128 {
        alignas ( 16 ) long long _Low;
        long long _High;
    };

    typename _Atomic_storage_types < _Ty & > :: _TStorage _Storage;
};
#line 1390 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template< class _Ty, size_t  = sizeof(_Ty)> struct _Atomic_integral; 
#line 1393
template < class _Ty >
struct _Atomic_integral < _Ty, 1 > : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using typename _Base :: _TVal;






    using _Base :: _Base;


    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedExchangeAdd8 ( _Atomic_address_as < char > ( this -> _Storage ), static_cast < char > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedAnd8 ( _Atomic_address_as < char > ( this -> _Storage ), static_cast < char > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedOr8 ( _Atomic_address_as < char > ( this -> _Storage ), static_cast < char > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        char _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedXor8 ( _Atomic_address_as < char > ( this -> _Storage ), static_cast < char > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal operator ++ ( int ) noexcept {
        return static_cast < _TVal > ( _InterlockedExchangeAdd8 ( _Atomic_address_as < char > ( this -> _Storage ), 1 ) );
    }

    _TVal operator ++ ( ) noexcept {
        unsigned char _Before =
            static_cast < unsigned char > ( _InterlockedExchangeAdd8 ( _Atomic_address_as < char > ( this -> _Storage ), 1 ) );
        ++ _Before;
        return static_cast < _TVal > ( _Before );
    }

    _TVal operator -- ( int ) noexcept {
        return static_cast < _TVal > ( _InterlockedExchangeAdd8 ( _Atomic_address_as < char > ( this -> _Storage ), - 1 ) );
    }

    _TVal operator -- ( ) noexcept {
        unsigned char _Before =
            static_cast < unsigned char > ( _InterlockedExchangeAdd8 ( _Atomic_address_as < char > ( this -> _Storage ), - 1 ) );
        -- _Before;
        return static_cast < _TVal > ( _Before );
    }
};
#line 1457 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_integral < _Ty, 2 > : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using typename _Base :: _TVal;






    using _Base :: _Base;


    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedExchangeAdd16 ( _Atomic_address_as < short > ( this -> _Storage ), static_cast < short > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedAnd16 ( _Atomic_address_as < short > ( this -> _Storage ), static_cast < short > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedOr16 ( _Atomic_address_as < short > ( this -> _Storage ), static_cast < short > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        short _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedXor16 ( _Atomic_address_as < short > ( this -> _Storage ), static_cast < short > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal operator ++ ( int ) noexcept {
        unsigned short _After =
            static_cast < unsigned short > ( _InterlockedIncrement16 ( _Atomic_address_as < short > ( this -> _Storage ) ) );
        -- _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator ++ ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedIncrement16 ( _Atomic_address_as < short > ( this -> _Storage ) ) );
    }

    _TVal operator -- ( int ) noexcept {
        unsigned short _After =
            static_cast < unsigned short > ( _InterlockedDecrement16 ( _Atomic_address_as < short > ( this -> _Storage ) ) );
        ++ _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator -- ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedDecrement16 ( _Atomic_address_as < short > ( this -> _Storage ) ) );
    }
};
#line 1521 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_integral < _Ty, 4 > : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using typename _Base :: _TVal;






    using _Base :: _Base;


    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedExchangeAdd ( _Atomic_address_as < long > ( this -> _Storage ), static_cast < long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedAnd ( _Atomic_address_as < long > ( this -> _Storage ), static_cast < long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedOr ( _Atomic_address_as < long > ( this -> _Storage ), static_cast < long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedXor ( _Atomic_address_as < long > ( this -> _Storage ), static_cast < long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal operator ++ ( int ) noexcept {
        unsigned long _After =
            static_cast < unsigned long > ( _InterlockedIncrement ( _Atomic_address_as < long > ( this -> _Storage ) ) );
        -- _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator ++ ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedIncrement ( _Atomic_address_as < long > ( this -> _Storage ) ) );
    }

    _TVal operator -- ( int ) noexcept {
        unsigned long _After =
            static_cast < unsigned long > ( _InterlockedDecrement ( _Atomic_address_as < long > ( this -> _Storage ) ) );
        ++ _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator -- ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedDecrement ( _Atomic_address_as < long > ( this -> _Storage ) ) );
    }
};
#line 1585 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_integral < _Ty, 8 > : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using typename _Base :: _TVal;






    using _Base :: _Base;
























































    _TVal fetch_add ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedExchangeAdd64 ( _Atomic_address_as < long long > ( this -> _Storage ), static_cast < long long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_and ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedAnd64 ( _Atomic_address_as < long long > ( this -> _Storage ), static_cast < long long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_or ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedOr64 ( _Atomic_address_as < long long > ( this -> _Storage ), static_cast < long long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal fetch_xor ( const _TVal _Operand, const memory_order _Order = memory_order_seq_cst ) noexcept {
        long long _Result;
        _Check_memory_order ( _Order ); _Result = _InterlockedXor64 ( _Atomic_address_as < long long > ( this -> _Storage ), static_cast < long long > ( _Operand ) );

        return static_cast < _TVal > ( _Result );
    }

    _TVal operator ++ ( int ) noexcept {
        unsigned long long _After =
            static_cast < unsigned long long > ( _InterlockedIncrement64 ( _Atomic_address_as < long long > ( this -> _Storage ) ) );
        -- _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator ++ ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedIncrement64 ( _Atomic_address_as < long long > ( this -> _Storage ) ) );
    }

    _TVal operator -- ( int ) noexcept {
        unsigned long long _After =
            static_cast < unsigned long long > ( _InterlockedDecrement64 ( _Atomic_address_as < long long > ( this -> _Storage ) ) );
        ++ _After;
        return static_cast < _TVal > ( _After );
    }

    _TVal operator -- ( ) noexcept {
        return static_cast < _TVal > ( _InterlockedDecrement64 ( _Atomic_address_as < long long > ( this -> _Storage ) ) );
    }

};
#line 1705 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template< size_t _TypeSize> constexpr bool 
#line 1706
_Is_always_lock_free = ((_TypeSize <= (8)) && ((_TypeSize & (_TypeSize - (1))) == (0))); 
#line 1717 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template< class _Ty, bool _Is_lock_free = _Is_always_lock_free< sizeof(_Ty)> > constexpr bool 
#line 1718
_Deprecate_non_lock_free_volatile = true; 
#line 1720
template< class _Ty> constexpr bool 
#line 1721
_Deprecate_non_lock_free_volatile< _Ty, false>  = true; 
#line 1723
template < class _Ty >
struct _Atomic_integral_facade : _Atomic_integral < _Ty > {

    using _Base = _Atomic_integral < _Ty >;
    using difference_type = _Ty;





    using _Base :: _Base;







    using _Base :: fetch_add;
    _Ty fetch_add ( const _Ty _Operand ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand );
    }

    _Ty fetch_add ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand, _Order );
    }

    [ [ nodiscard ] ] static _Ty _Negate ( const _Ty _Value ) noexcept {
        return static_cast < _Ty > ( 0U - static_cast < make_unsigned_t < _Ty >> ( _Value ) );
    }

    _Ty fetch_sub ( const _Ty _Operand ) noexcept {
        return fetch_add ( _Negate ( _Operand ) );
    }

    _Ty fetch_sub ( const _Ty _Operand ) volatile noexcept {
        return fetch_add ( _Negate ( _Operand ) );
    }

    _Ty fetch_sub ( const _Ty _Operand, const memory_order _Order ) noexcept {
        return fetch_add ( _Negate ( _Operand ), _Order );
    }

    _Ty fetch_sub ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return fetch_add ( _Negate ( _Operand ), _Order );
    }

    using _Base :: fetch_and;
    _Ty fetch_and ( const _Ty _Operand ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand );
    }

    _Ty fetch_and ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand, _Order );
    }

    using _Base :: fetch_or;
    _Ty fetch_or ( const _Ty _Operand ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand );
    }

    _Ty fetch_or ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand, _Order );
    }

    using _Base :: fetch_xor;
    _Ty fetch_xor ( const _Ty _Operand ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand );
    }

    _Ty fetch_xor ( const _Ty _Operand, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand, _Order );
    }

    using _Base :: operator ++;
    _Ty operator ++ ( int ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator ++ ( 0 );
    }

    _Ty operator ++ ( ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator ++ ( );
    }

    using _Base :: operator --;
    _Ty operator -- ( int ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator -- ( 0 );
    }

    _Ty operator -- ( ) volatile noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator -- ( );
    }

    _Ty operator += ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( this -> _Base :: fetch_add ( _Operand ) + _Operand );
    }

    _Ty operator += ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand ) + _Operand );
    }

    _Ty operator -= ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( fetch_sub ( _Operand ) - _Operand );
    }

    _Ty operator -= ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> fetch_sub ( _Operand ) - _Operand );
    }

    _Ty operator &= ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( this -> _Base :: fetch_and ( _Operand ) & _Operand );
    }

    _Ty operator &= ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand ) & _Operand );
    }

    _Ty operator |= ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( this -> _Base :: fetch_or ( _Operand ) | _Operand );
    }

    _Ty operator |= ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand ) | _Operand );
    }

    _Ty operator ^= ( const _Ty _Operand ) noexcept {
        return static_cast < _Ty > ( this -> _Base :: fetch_xor ( _Operand ) ^ _Operand );
    }

    _Ty operator ^= ( const _Ty _Operand ) volatile noexcept {
        return static_cast < _Ty > ( const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand ) ^ _Operand );
    }
};
#line 1856 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_integral_facade < _Ty & > : _Atomic_integral < _Ty & > {

    using _Base = _Atomic_integral < _Ty & >;
    using difference_type = _Ty;





    using _Base :: _Base;


    [ [ nodiscard ] ] static _Ty _Negate ( const _Ty _Value ) noexcept {
        return static_cast < _Ty > ( 0U - static_cast < make_unsigned_t < _Ty >> ( _Value ) );
    }

    _Ty fetch_add ( const _Ty _Operand ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand );
    }

    _Ty fetch_add ( const _Ty _Operand, const memory_order _Order ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_add ( _Operand, _Order );
    }

    _Ty fetch_sub ( const _Ty _Operand ) const noexcept {
        return fetch_add ( _Negate ( _Operand ) );
    }

    _Ty fetch_sub ( const _Ty _Operand, const memory_order _Order ) const noexcept {
        return fetch_add ( _Negate ( _Operand ), _Order );
    }

    _Ty operator ++ ( int ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator ++ ( 0 );
    }

    _Ty operator ++ ( ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator ++ ( );
    }

    _Ty operator -- ( int ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator -- ( 0 );
    }

    _Ty operator -- ( ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: operator -- ( );
    }

    _Ty operator += ( const _Ty _Operand ) const noexcept {
        return static_cast < _Ty > ( fetch_add ( _Operand ) + _Operand );
    }

    _Ty operator -= ( const _Ty _Operand ) const noexcept {
        return static_cast < _Ty > ( fetch_sub ( _Operand ) - _Operand );
    }

    _Ty fetch_and ( const _Ty _Operand ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand );
    }

    _Ty fetch_and ( const _Ty _Operand, const memory_order _Order ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_and ( _Operand, _Order );
    }

    _Ty fetch_or ( const _Ty _Operand ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand );
    }

    _Ty fetch_or ( const _Ty _Operand, const memory_order _Order ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_or ( _Operand, _Order );
    }

    _Ty fetch_xor ( const _Ty _Operand ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand );
    }

    _Ty fetch_xor ( const _Ty _Operand, const memory_order _Order ) const noexcept {
        return const_cast < _Atomic_integral_facade * > ( this ) -> _Base :: fetch_xor ( _Operand, _Order );
    }

    _Ty operator &= ( const _Ty _Operand ) const noexcept {
        return static_cast < _Ty > ( fetch_and ( _Operand ) & _Operand );
    }

    _Ty operator |= ( const _Ty _Operand ) const noexcept {
        return static_cast < _Ty > ( fetch_or ( _Operand ) | _Operand );
    }

    _Ty operator ^= ( const _Ty _Operand ) const noexcept {
        return static_cast < _Ty > ( fetch_xor ( _Operand ) ^ _Operand );
    }
};
#line 2051 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_pointer : _Atomic_storage < _Ty > {
    using _Base = _Atomic_storage < _Ty >;
    using difference_type = ptrdiff_t;





    using _Base :: _Base;


    _Ty fetch_add ( const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst ) noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast < ptrdiff_t > ( static_cast < size_t > ( _Diff ) * sizeof ( remove_pointer_t < _Ty > ) );
        ptrdiff_t _Result;




        _Check_memory_order ( _Order ); _Result = _InterlockedExchangeAdd64 ( _Atomic_address_as < long long > ( this -> _Storage ), _Shift_bytes );


        return reinterpret_cast < _Ty > ( _Result );
    }



    _Ty fetch_add ( const ptrdiff_t _Diff ) volatile noexcept {
        return const_cast < _Atomic_pointer * > ( this ) -> fetch_add ( _Diff );
    }

    _Ty fetch_add ( const ptrdiff_t _Diff, const memory_order _Order ) volatile noexcept {
        return const_cast < _Atomic_pointer * > ( this ) -> fetch_add ( _Diff, _Order );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff ) volatile noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff ) noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff, const memory_order _Order ) volatile noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ), _Order );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff, const memory_order _Order ) noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ), _Order );
    }

    _Ty operator ++ ( int ) volatile noexcept {
        return fetch_add ( 1 );
    }

    _Ty operator ++ ( int ) noexcept {
        return fetch_add ( 1 );
    }

    _Ty operator ++ ( ) volatile noexcept {
        return fetch_add ( 1 ) + 1;
    }

    _Ty operator ++ ( ) noexcept {
        return fetch_add ( 1 ) + 1;
    }

    _Ty operator -- ( int ) volatile noexcept {
        return fetch_add ( - 1 );
    }

    _Ty operator -- ( int ) noexcept {
        return fetch_add ( - 1 );
    }

    _Ty operator -- ( ) volatile noexcept {
        return fetch_add ( - 1 ) - 1;
    }

    _Ty operator -- ( ) noexcept {
        return fetch_add ( - 1 ) - 1;
    }

    _Ty operator += ( const ptrdiff_t _Diff ) volatile noexcept {
        return fetch_add ( _Diff ) + _Diff;
    }

    _Ty operator += ( const ptrdiff_t _Diff ) noexcept {
        return fetch_add ( _Diff ) + _Diff;
    }

    _Ty operator -= ( const ptrdiff_t _Diff ) volatile noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) ) - _Diff;
    }

    _Ty operator -= ( const ptrdiff_t _Diff ) noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) ) - _Diff;
    }
};
#line 2153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct _Atomic_pointer < _Ty & > : _Atomic_storage < _Ty & > {
    using _Base = _Atomic_storage < _Ty & >;
    using difference_type = ptrdiff_t;





    using _Base :: _Base;


    _Ty fetch_add ( const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst ) const noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast < ptrdiff_t > ( static_cast < size_t > ( _Diff ) * sizeof ( remove_pointer_t < _Ty > ) );
        ptrdiff_t _Result;




        _Check_memory_order ( _Order ); _Result = _InterlockedExchangeAdd64 ( _Atomic_address_as < long long > ( this -> _Storage ), _Shift_bytes );


        return reinterpret_cast < _Ty > ( _Result );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff ) const noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) );
    }

    _Ty fetch_sub ( const ptrdiff_t _Diff, const memory_order _Order ) const noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ), _Order );
    }

    _Ty operator ++ ( int ) const noexcept {
        return fetch_add ( 1 );
    }

    _Ty operator ++ ( ) const noexcept {
        return fetch_add ( 1 ) + 1;
    }

    _Ty operator -- ( int ) const noexcept {
        return fetch_add ( - 1 );
    }

    _Ty operator -- ( ) const noexcept {
        return fetch_add ( - 1 ) - 1;
    }

    _Ty operator += ( const ptrdiff_t _Diff ) const noexcept {
        return fetch_add ( _Diff ) + _Diff;
    }

    _Ty operator -= ( const ptrdiff_t _Diff ) const noexcept {
        return fetch_add ( static_cast < ptrdiff_t > ( 0 - static_cast < size_t > ( _Diff ) ) ) - _Diff;
    }
};
#line 2216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template< class _TVal, class _Ty = _TVal> using _Choose_atomic_base2_t = typename _Select< is_integral_v< _TVal>  && (!is_same_v< bool, _TVal> )> ::template _Apply< _Atomic_integral_facade< _Ty> , typename _Select< is_pointer_v< _TVal>  && is_object_v< remove_pointer_t< _TVal> > > ::template _Apply< _Atomic_pointer< _Ty> , _Atomic_storage< _Ty> > > ; 
#line 2227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template< class _TVal, class _Ty = _TVal> using _Choose_atomic_base_t = _Choose_atomic_base2_t< _TVal, _Ty> ; 
#line 2231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
struct atomic : _Choose_atomic_base_t < _Ty > {
private :
    using _Base = _Choose_atomic_base_t < _Ty >;

public :

    static_assert ( is_trivially_copyable_v < _Ty > && is_copy_constructible_v < _Ty > && is_move_constructible_v < _Ty >
        && is_copy_assignable_v < _Ty > && is_move_assignable_v < _Ty >,
        "atomic<T> requires T to be trivially copyable, copy constructible, move constructible, copy assignable, and move assignable."
                              );


    using value_type = _Ty;




    using _Base :: _Base;


    constexpr atomic ( ) noexcept ( is_nothrow_default_constructible_v < _Ty > ) : _Base ( ) { }

    atomic ( const atomic & ) = delete;
    atomic & operator = ( const atomic & ) = delete;






    [ [ nodiscard ] ] bool is_lock_free ( ) const volatile noexcept {
        constexpr bool _Result = sizeof ( _Ty ) <= 8 && ( sizeof ( _Ty ) & sizeof ( _Ty ) - 1 ) == 0;
        return _Result;
    }












    [ [ nodiscard ] ] bool is_lock_free ( ) const noexcept {
        return static_cast < const volatile atomic * > ( this ) -> is_lock_free ( );
    }

    _Ty operator = ( const _Ty _Value ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        this -> store ( _Value );
        return _Value;
    }

    _Ty operator = ( const _Ty _Value ) noexcept {
        this -> store ( _Value );
        return _Value;
    }






    using _Base :: store;
    void store ( const _Ty _Value ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        const_cast < atomic * > ( this ) -> _Base :: store ( _Value );
    }

    void store ( const _Ty _Value, const memory_order _Order ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        const_cast < atomic * > ( this ) -> _Base :: store ( _Value, _Order );
    }

    using _Base :: load;
    [ [ nodiscard ] ] _Ty load ( ) const volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < const atomic * > ( this ) -> _Base :: load ( );
    }

    [ [ nodiscard ] ] _Ty load ( const memory_order _Order ) const volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < const atomic * > ( this ) -> _Base :: load ( _Order );
    }

    using _Base :: exchange;
    _Ty exchange ( const _Ty _Value ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < atomic * > ( this ) -> _Base :: exchange ( _Value );
    }

    _Ty exchange ( const _Ty _Value, const memory_order _Order ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < atomic * > ( this ) -> _Base :: exchange ( _Value, _Order );
    }

    using _Base :: compare_exchange_strong;
    bool compare_exchange_strong ( _Ty & _Expected, const _Ty _Desired ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < atomic * > ( this ) -> _Base :: compare_exchange_strong ( _Expected, _Desired );
    }

    bool compare_exchange_strong ( _Ty & _Expected, const _Ty _Desired, const memory_order _Order ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return const_cast < atomic * > ( this ) -> _Base :: compare_exchange_strong ( _Expected, _Desired, _Order );
    }

    bool compare_exchange_strong ( _Ty & _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> compare_exchange_strong ( _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
    }

    bool compare_exchange_strong (
        _Ty & _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
        return this -> compare_exchange_strong ( _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired ) volatile noexcept {

        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> compare_exchange_strong ( _Expected, _Desired );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired ) noexcept {
        return this -> compare_exchange_strong ( _Expected, _Desired );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired, const memory_order _Order ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> compare_exchange_strong ( _Expected, _Desired, _Order );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired, const memory_order _Order ) noexcept {
        return this -> compare_exchange_strong ( _Expected, _Desired, _Order );
    }

    bool compare_exchange_weak ( _Ty & _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure ) volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> compare_exchange_strong ( _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
    }

    bool compare_exchange_weak (
        _Ty & _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
        return this -> compare_exchange_strong ( _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
    }


















    operator _Ty ( ) const volatile noexcept {
        static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
        return this -> load ( );
    }

    operator _Ty ( ) const noexcept {
        return this -> load ( );
    }
};
#line 2525 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template < class _Ty >
[ [ nodiscard ] ] bool atomic_is_lock_free ( const volatile atomic < _Ty > * _Mem ) noexcept {
    return _Mem -> is_lock_free ( );
}
#line 2530
template < class _Ty >
[ [ nodiscard ] ] bool atomic_is_lock_free ( const atomic < _Ty > * _Mem ) noexcept {
    return _Mem -> is_lock_free ( );
}
#line 2535
template < class _Ty >
void atomic_store ( volatile atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    _Mem -> store ( _Value );
}
#line 2541
template < class _Ty >
void atomic_store ( atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value ) noexcept {
    _Mem -> store ( _Value );
}
#line 2546
template < class _Ty >
void atomic_store_explicit (
    volatile atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    _Mem -> store ( _Value, _Order );
}
#line 2553
template < class _Ty >
void atomic_store_explicit ( atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value, const memory_order _Order ) noexcept {
    _Mem -> store ( _Value, _Order );
}
#line 2558
template < class _Ty >
 void atomic_init (
    volatile atomic < _Ty > * const _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    :: std :: atomic_store_explicit ( _Mem, _Value, memory_order_relaxed );
}
#line 2565
template < class _Ty >
 void atomic_init (
    atomic < _Ty > * const _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    :: std :: atomic_store_explicit ( _Mem, _Value, memory_order_relaxed );
}
#line 2571
template < class _Ty >
[ [ nodiscard ] ] _Ty atomic_load ( const volatile atomic < _Ty > * const _Mem ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> load ( );
}
#line 2577
template < class _Ty >
[ [ nodiscard ] ] _Ty atomic_load ( const atomic < _Ty > * const _Mem ) noexcept {
    return _Mem -> load ( );
}
#line 2582
template < class _Ty >
[ [ nodiscard ] ] _Ty atomic_load_explicit ( const volatile atomic < _Ty > * const _Mem, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> load ( _Order );
}
#line 2588
template < class _Ty >
[ [ nodiscard ] ] _Ty atomic_load_explicit ( const atomic < _Ty > * const _Mem, const memory_order _Order ) noexcept {
    return _Mem -> load ( _Order );
}
#line 2593
template < class _Ty >
_Ty atomic_exchange ( volatile atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> exchange ( _Value );
}
#line 2599
template < class _Ty >
_Ty atomic_exchange ( atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value ) noexcept {
    return _Mem -> exchange ( _Value );
}
#line 2604
template < class _Ty >
_Ty atomic_exchange_explicit (
    volatile atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> exchange ( _Value, _Order );
}
#line 2611
template < class _Ty >
_Ty atomic_exchange_explicit (
    atomic < _Ty > * const _Mem, const _Identity_t < _Ty > _Value, const memory_order _Order ) noexcept {
    return _Mem -> exchange ( _Value, _Order );
}
#line 2617
template < class _Ty >
bool atomic_compare_exchange_strong (
    volatile atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected, const _Identity_t < _Ty > _Desired ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired );
}
#line 2624
template < class _Ty >
bool atomic_compare_exchange_strong (
    atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected, const _Identity_t < _Ty > _Desired ) noexcept {
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired );
}
#line 2630
template < class _Ty >
bool atomic_compare_exchange_strong_explicit ( volatile atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected,
    const _Identity_t < _Ty > _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
}
#line 2637
template < class _Ty >
bool atomic_compare_exchange_strong_explicit ( atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected,
    const _Identity_t < _Ty > _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
}
#line 2643
template < class _Ty >
bool atomic_compare_exchange_weak (
    volatile atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected, const _Identity_t < _Ty > _Desired ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired );
}
#line 2650
template < class _Ty >
bool atomic_compare_exchange_weak (
    atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected, const _Identity_t < _Ty > _Desired ) noexcept {
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired );
}
#line 2656
template < class _Ty >
bool atomic_compare_exchange_weak_explicit ( volatile atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected,
    const _Identity_t < _Ty > _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
}
#line 2663
template < class _Ty >
bool atomic_compare_exchange_weak_explicit ( atomic < _Ty > * const _Mem, _Identity_t < _Ty > * const _Expected,
    const _Identity_t < _Ty > _Desired, const memory_order _Success, const memory_order _Failure ) noexcept {
    return _Mem -> compare_exchange_strong ( * _Expected, _Desired, _Combine_cas_memory_orders ( _Success, _Failure ) );
}
#line 2669
template < class _Ty >
_Ty atomic_fetch_add ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_add ( _Value );
}
#line 2675
template < class _Ty >
_Ty atomic_fetch_add ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value ) noexcept {
    return _Mem -> fetch_add ( _Value );
}
#line 2680
template < class _Ty >
_Ty atomic_fetch_add_explicit ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value,
    const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_add ( _Value, _Order );
}
#line 2687
template < class _Ty >
_Ty atomic_fetch_add_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_add ( _Value, _Order );
}
#line 2693
template < class _Ty >
_Ty atomic_fetch_sub ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_sub ( _Value );
}
#line 2699
template < class _Ty >
_Ty atomic_fetch_sub ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value ) noexcept {
    return _Mem -> fetch_sub ( _Value );
}
#line 2704
template < class _Ty >
_Ty atomic_fetch_sub_explicit ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value,
    const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_sub ( _Value, _Order );
}
#line 2711
template < class _Ty >
_Ty atomic_fetch_sub_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: difference_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_sub ( _Value, _Order );
}
#line 2717
template < class _Ty >
_Ty atomic_fetch_and ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_and ( _Value );
}
#line 2723
template < class _Ty >
_Ty atomic_fetch_and ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    return _Mem -> fetch_and ( _Value );
}
#line 2728
template < class _Ty >
_Ty atomic_fetch_and_explicit (
    volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_and ( _Value, _Order );
}
#line 2735
template < class _Ty >
_Ty atomic_fetch_and_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_and ( _Value, _Order );
}
#line 2741
template < class _Ty >
_Ty atomic_fetch_or ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_or ( _Value );
}
#line 2747
template < class _Ty >
_Ty atomic_fetch_or ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    return _Mem -> fetch_or ( _Value );
}
#line 2752
template < class _Ty >
_Ty atomic_fetch_or_explicit (
    volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_or ( _Value, _Order );
}
#line 2759
template < class _Ty >
_Ty atomic_fetch_or_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_or ( _Value, _Order );
}
#line 2765
template < class _Ty >
_Ty atomic_fetch_xor ( volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_xor ( _Value );
}
#line 2771
template < class _Ty >
_Ty atomic_fetch_xor ( atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value ) noexcept {
    return _Mem -> fetch_xor ( _Value );
}
#line 2776
template < class _Ty >
_Ty atomic_fetch_xor_explicit (
    volatile atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    static_assert ( _Deprecate_non_lock_free_volatile < _Ty >, "Never fails" );
    return _Mem -> fetch_xor ( _Value, _Order );
}
#line 2783
template < class _Ty >
_Ty atomic_fetch_xor_explicit (
    atomic < _Ty > * _Mem, const typename atomic < _Ty > :: value_type _Value, const memory_order _Order ) noexcept {
    return _Mem -> fetch_xor ( _Value, _Order );
}
#line 2835 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
using atomic_bool = atomic< bool> ; 
#line 2837
using atomic_char = atomic< char> ; 
#line 2838
using atomic_schar = atomic< signed char> ; 
#line 2839
using atomic_uchar = atomic< unsigned char> ; 
#line 2840
using atomic_short = atomic< short> ; 
#line 2841
using atomic_ushort = atomic< unsigned short> ; 
#line 2842
using atomic_int = atomic< int> ; 
#line 2843
using atomic_uint = atomic< unsigned> ; 
#line 2844
using atomic_long = atomic< long> ; 
#line 2845
using atomic_ulong = atomic< unsigned long> ; 
#line 2846
using atomic_llong = atomic< __int64> ; 
#line 2847
using atomic_ullong = atomic< unsigned __int64> ; 
#line 2852
using atomic_char16_t = atomic< char16_t> ; 
#line 2853
using atomic_char32_t = atomic< char32_t> ; 
#line 2854
using atomic_wchar_t = atomic< __wchar_t> ; 
#line 2856
using atomic_int8_t = atomic< signed char> ; 
#line 2857
using atomic_uint8_t = atomic< unsigned char> ; 
#line 2858
using atomic_int16_t = atomic< short> ; 
#line 2859
using atomic_uint16_t = atomic< unsigned short> ; 
#line 2860
using atomic_int32_t = atomic< int> ; 
#line 2861
using atomic_uint32_t = atomic< unsigned> ; 
#line 2862
using atomic_int64_t = atomic< __int64> ; 
#line 2863
using atomic_uint64_t = atomic< unsigned __int64> ; 
#line 2865
using atomic_int_least8_t = atomic< signed char> ; 
#line 2866
using atomic_uint_least8_t = atomic< unsigned char> ; 
#line 2867
using atomic_int_least16_t = atomic< short> ; 
#line 2868
using atomic_uint_least16_t = atomic< unsigned short> ; 
#line 2869
using atomic_int_least32_t = atomic< int> ; 
#line 2870
using atomic_uint_least32_t = atomic< unsigned> ; 
#line 2871
using atomic_int_least64_t = atomic< __int64> ; 
#line 2872
using atomic_uint_least64_t = atomic< unsigned __int64> ; 
#line 2874
using atomic_int_fast8_t = atomic< signed char> ; 
#line 2875
using atomic_uint_fast8_t = atomic< unsigned char> ; 
#line 2876
using atomic_int_fast16_t = atomic< int> ; 
#line 2877
using atomic_uint_fast16_t = atomic< unsigned> ; 
#line 2878
using atomic_int_fast32_t = atomic< int> ; 
#line 2879
using atomic_uint_fast32_t = atomic< unsigned> ; 
#line 2880
using atomic_int_fast64_t = atomic< __int64> ; 
#line 2881
using atomic_uint_fast64_t = atomic< unsigned __int64> ; 
#line 2883
using atomic_intptr_t = atomic< __int64> ; 
#line 2884
using atomic_uintptr_t = atomic< unsigned __int64> ; 
#line 2885
using atomic_size_t = atomic< unsigned __int64> ; 
#line 2886
using atomic_ptrdiff_t = atomic< __int64> ; 
#line 2887
using atomic_intmax_t = atomic< __int64> ; 
#line 2888
using atomic_uintmax_t = atomic< unsigned __int64> ; 
#line 2899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
struct atomic_flag { 
#line 2910 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
bool test_and_set(const memory_order _Order = memory_order_seq_cst) noexcept { 
#line 2911
return (_Storage).exchange(true, _Order) != (0); 
#line 2912
} 
#line 2914
bool test_and_set(const memory_order _Order = memory_order_seq_cst) volatile noexcept { 
#line 2915
return (_Storage).exchange(true, _Order) != (0); 
#line 2916
} 
#line 2918
void clear(const memory_order _Order = memory_order_seq_cst) noexcept { 
#line 2919
(_Storage).store(false, _Order); 
#line 2920
} 
#line 2922
void clear(const memory_order _Order = memory_order_seq_cst) volatile noexcept { 
#line 2923
(_Storage).store(false, _Order); 
#line 2924
} 
#line 2926
constexpr atomic_flag() noexcept = default;
#line 2955 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
atomic< long>  _Storage; 
#line 2959 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
}; 
#line 2981 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
inline bool atomic_flag_test_and_set(atomic_flag *const _Flag) noexcept { 
#line 2982
return _Flag->test_and_set(); 
#line 2983
} 
#line 2985
inline bool atomic_flag_test_and_set(volatile atomic_flag *const _Flag) noexcept { 
#line 2986
return _Flag->test_and_set(); 
#line 2987
} 
#line 2989
inline bool atomic_flag_test_and_set_explicit(atomic_flag *const _Flag, const memory_order _Order) noexcept { 
#line 2990
return _Flag->test_and_set(_Order); 
#line 2991
} 
#line 2993
inline bool atomic_flag_test_and_set_explicit(volatile atomic_flag *const _Flag, const memory_order _Order) noexcept { 
#line 2994
return _Flag->test_and_set(_Order); 
#line 2995
} 
#line 2997
inline void atomic_flag_clear(atomic_flag *const _Flag) noexcept { 
#line 2998
_Flag->clear(); 
#line 2999
} 
#line 3001
inline void atomic_flag_clear(volatile atomic_flag *const _Flag) noexcept { 
#line 3002
_Flag->clear(); 
#line 3003
} 
#line 3005
inline void atomic_flag_clear_explicit(atomic_flag *const _Flag, const memory_order _Order) noexcept { 
#line 3006
_Flag->clear(_Order); 
#line 3007
} 
#line 3009
inline void atomic_flag_clear_explicit(volatile atomic_flag *const _Flag, const memory_order _Order) noexcept { 
#line 3010
_Flag->clear(_Order); 
#line 3011
} 
#line 3112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
}
#line 3127
#pragma warning(pop)
#pragma pack ( pop )
#line 3131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 32
namespace std { 
#line 33
enum class io_errc { 
#line 34
stream = 1
#line 35
}; 
#line 37
template< class _Enum> 
#line 38
struct is_error_code_enum : public false_type { }; 
#line 41
template<> struct is_error_code_enum< io_errc>  : public true_type { }; 
#line 43
template< class _Ty> constexpr bool 
#line 44
is_error_code_enum_v = (is_error_code_enum< _Ty> ::value); 
#line 46
template< class _Enum> 
#line 47
struct is_error_condition_enum : public false_type { }; 
#line 50
template<> struct is_error_condition_enum< errc>  : public true_type { }; 
#line 52
template< class _Ty> constexpr bool 
#line 53
is_error_condition_enum_v = (is_error_condition_enum< _Ty> ::value); 
#line 55
class error_code; 
#line 56
class error_condition; 
#line 57
[[nodiscard]] inline error_code make_error_code(errc) noexcept; 
#line 58
[[nodiscard]] inline error_code make_error_code(io_errc) noexcept; 
#line 59
[[nodiscard]] inline error_condition make_error_condition(errc) noexcept; 
#line 60
[[nodiscard]] inline error_condition make_error_condition(io_errc) noexcept; 
#line 62
class error_category; 
#line 64
[[nodiscard]] inline const error_category &generic_category() noexcept; 
#line 65
[[nodiscard]] inline const error_category &iostream_category() noexcept; 
#line 66
[[nodiscard]] inline const error_category &system_category() noexcept; 
#line 68
class __declspec(novtable) error_category { 
#line 70
public: error_category() noexcept { 
#line 71
(_Addr) = (reinterpret_cast< uintptr_t>(this)); 
#line 72
} 
#line 77
virtual ~error_category() noexcept = default;
#line 79
[[nodiscard]] virtual const char *name() const noexcept = 0; 
#line 81
[[nodiscard]] virtual string message(int _Errval) const = 0; 
#line 83
[[nodiscard]] inline virtual error_condition default_error_condition(int _Errval) const noexcept; 
#line 85
[[nodiscard]] inline virtual bool equivalent(int _Errval, const error_condition & _Cond) const noexcept; 
#line 87
[[nodiscard]] inline virtual bool equivalent(const error_code & _Code, int _Errval) const noexcept; 
#line 89
[[nodiscard]] bool operator==(const error_category &_Right) const noexcept { 
#line 90
return (_Addr) == (_Right._Addr); 
#line 91
} 
#line 94
[[nodiscard]] bool operator!=(const error_category &_Right) const noexcept { 
#line 95
return !((*this) == _Right); 
#line 96
} 
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
[[nodiscard]] bool operator<(const error_category &_Right) const noexcept { 
#line 105
return (_Addr) < (_Right._Addr); 
#line 106
} 
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
error_category(const error_category &) = delete;
#line 110
error_category &operator=(const error_category &) = delete;
#line 113
protected: uintptr_t _Addr; 
#line 115
constexpr explicit error_category(const uintptr_t _Addr_) noexcept : _Addr(_Addr_) { } 
#line 117
enum: uintptr_t { 
#line 118
_Future_addr = 1Ui64, 
#line 119
_Generic_addr = 3Ui64, 
#line 120
_Iostream_addr = 5Ui64, 
#line 121
_System_addr = 7Ui64
#line 122
}; 
#line 123
}; 
#line 126
[[nodiscard]] inline bool _System_error_equal(const error_code &, const error_condition &) noexcept; 
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
class error_code { 
#line 131
public: error_code() noexcept : _Myval(0), _Mycat(&::std::system_category()) { } 
#line 133
error_code(int _Val, const error_category &_Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) { } 
#line 135
template < class _Enum, enable_if_t < is_error_code_enum_v < _Enum >, int > = 0 >
    error_code ( _Enum _Errcode ) noexcept : _Myval ( 0 ), _Mycat ( nullptr ) {
        * this = make_error_code ( _Errcode );
    }
#line 140
void assign(int _Val, const error_category &_Cat) noexcept { 
#line 141
(_Myval) = _Val; 
#line 142
(_Mycat) = (&_Cat); 
#line 143
} 
#line 145
template < class _Enum, enable_if_t < is_error_code_enum_v < _Enum >, int > = 0 >
    error_code & operator = ( _Enum _Errcode ) noexcept {
        * this = make_error_code ( _Errcode );
        return * this;
    }
#line 151
void clear() noexcept { 
#line 152
(_Myval) = 0; 
#line 153
(_Mycat) = (&::std::system_category()); 
#line 154
} 
#line 156
[[nodiscard]] int value() const noexcept { 
#line 157
return _Myval; 
#line 158
} 
#line 160
[[nodiscard]] const error_category &category() const noexcept { 
#line 161
return *(_Mycat); 
#line 162
} 
#line 164
[[nodiscard]] inline error_condition default_error_condition() const noexcept; 
#line 166
[[nodiscard]] string message() const { 
#line 167
return this->category().message(this->value()); 
#line 168
} 
#line 170
explicit operator bool() const noexcept { 
#line 171
return this->value() != 0; 
#line 172
} 
#line 175
friend inline bool operator==(const error_code &_Left, const error_code &_Right) noexcept { 
#line 176
return ((_Left.category()) == (_Right.category())) && (_Left.value() == _Right.value()); 
#line 177
} 
#line 179
friend inline bool operator==(const error_code &_Left, const std::error_condition &_Right) noexcept { 
#line 180
return _System_error_equal(_Left, _Right); 
#line 181
} 
#line 191
friend inline bool operator<(const error_code &_Left, const error_code &_Right) noexcept { 
#line 192
return ((_Left.category()) < (_Right.category())) || (((_Left.category()) == (_Right.category())) && (_Left.value() < _Right.value())); 
#line 194
} 
#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
friend inline bool operator==(const std::error_condition &_Left, const error_code &_Right) noexcept { 
#line 198
return _System_error_equal(_Right, _Left); 
#line 199
} 
#line 201
friend inline bool operator!=(const error_code &_Left, const error_code &_Right) noexcept { 
#line 202
return !(_Left == _Right); 
#line 203
} 
#line 205
friend inline bool operator!=(const error_code &_Left, const std::error_condition &_Right) noexcept { 
#line 206
return !_System_error_equal(_Left, _Right); 
#line 207
} 
#line 209
friend inline bool operator!=(const std::error_condition &_Left, const error_code &_Right) noexcept { 
#line 210
return !_System_error_equal(_Right, _Left); 
#line 211
} 
#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
private: int _Myval; 
#line 217
const error_category *_Mycat; 
#line 218
}; 
#line 220
class error_condition { 
#line 222
public: error_condition() noexcept : _Myval(0), _Mycat(&::std::generic_category()) { } 
#line 224
error_condition(int _Val, const error_category &_Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) { } 
#line 226
template < class _Enum, enable_if_t < is_error_condition_enum_v < _Enum >, int > = 0 >
    error_condition ( _Enum _Errcode ) noexcept : _Myval ( 0 ), _Mycat ( nullptr ) {
        * this = make_error_condition ( _Errcode );
    }
#line 231
void assign(int _Val, const error_category &_Cat) noexcept { 
#line 232
(_Myval) = _Val; 
#line 233
(_Mycat) = (&_Cat); 
#line 234
} 
#line 236
template < class _Enum, enable_if_t < is_error_condition_enum_v < _Enum >, int > = 0 >
    error_condition & operator = ( _Enum _Errcode ) noexcept {
        * this = make_error_condition ( _Errcode );
        return * this;
    }
#line 242
void clear() noexcept { 
#line 243
(_Myval) = 0; 
#line 244
(_Mycat) = (&::std::generic_category()); 
#line 245
} 
#line 247
[[nodiscard]] int value() const noexcept { 
#line 248
return _Myval; 
#line 249
} 
#line 251
[[nodiscard]] const error_category &category() const noexcept { 
#line 252
return *(_Mycat); 
#line 253
} 
#line 255
[[nodiscard]] string message() const { 
#line 256
return this->category().message(this->value()); 
#line 257
} 
#line 259
explicit operator bool() const noexcept { 
#line 260
return this->value() != 0; 
#line 261
} 
#line 264
friend inline bool operator==(const error_condition &_Left, const error_condition &_Right) noexcept { 
#line 265
return ((_Left.category()) == (_Right.category())) && (_Left.value() == _Right.value()); 
#line 266
} 
#line 277
friend inline bool operator<(const error_condition &_Left, const error_condition &_Right) noexcept { 
#line 278
return ((_Left.category()) < (_Right.category())) || (((_Left.category()) == (_Right.category())) && (_Left.value() < _Right.value())); 
#line 280
} 
#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
friend inline bool operator!=(const error_condition &_Left, const error_condition &_Right) noexcept { 
#line 284
return !(_Left == _Right); 
#line 285
} 
#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
friend inline bool operator==(const std::error_code & _Left, const error_condition & _Right) noexcept; 
#line 293
friend inline bool operator==(const error_condition & _Left, const std::error_code & _Right) noexcept; 
#line 294
friend inline bool operator!=(const std::error_code & _Left, const error_condition & _Right) noexcept; 
#line 295
friend inline bool operator!=(const error_condition & _Left, const std::error_code & _Right) noexcept; 
#line 300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
private: int _Myval; 
#line 301
const error_category *_Mycat; 
#line 302
}; 
#line 305
[[nodiscard]] inline bool _System_error_equal(const error_code &_Left, const error_condition &_Right) noexcept { 
#line 306
return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value()); 
#line 307
} 
#line 370 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
[[nodiscard]] inline error_condition error_category::default_error_condition(int _Errval) const noexcept { 
#line 372
return error_condition(_Errval, *this); 
#line 373
} 
#line 375
[[nodiscard]] inline bool error_category::equivalent(int _Errval, const error_condition &_Cond) const noexcept { 
#line 376
return ((this->default_error_condition(_Errval)) == _Cond); 
#line 377
} 
#line 379
[[nodiscard]] inline bool error_category::equivalent(const error_code &_Code, int _Errval) const noexcept { 
#line 380
return ((*this) == (_Code.category())) && (_Code.value() == _Errval); 
#line 381
} 
#line 383
[[nodiscard]] inline error_condition error_code::default_error_condition() const noexcept { 
#line 385
return this->category().default_error_condition(this->value()); 
#line 386
} 
#line 388
[[nodiscard]] inline error_code make_error_code(errc _Errno) noexcept { 
#line 389
return error_code(static_cast< int>(_Errno), ::std::generic_category()); 
#line 390
} 
#line 392
[[nodiscard]] inline error_code make_error_code(io_errc _Errno) noexcept { 
#line 393
return error_code(static_cast< int>(_Errno), ::std::iostream_category()); 
#line 394
} 
#line 396
[[nodiscard]] inline error_condition make_error_condition(errc _Errno) noexcept { 
#line 397
return error_condition(static_cast< int>(_Errno), ::std::generic_category()); 
#line 398
} 
#line 400
[[nodiscard]] inline error_condition make_error_condition(io_errc _Errno) noexcept { 
#line 401
return error_condition(static_cast< int>(_Errno), ::std::iostream_category()); 
#line 402
} 
#line 405
template<> struct hash< error_code>  { 
#line 406
typedef error_code argument_type; 
#line 407
typedef size_t result_type; 
#line 409
[[nodiscard]] size_t operator()(const error_code &_Keyval) const noexcept { 
#line 410
return std::hash< int> {}(_Keyval.value()); 
#line 411
} 
#line 412
}; 
#line 415
template<> struct hash< error_condition>  { 
#line 416
typedef error_condition argument_type; 
#line 417
typedef size_t result_type; 
#line 419
[[nodiscard]] size_t operator()(const error_condition &_Keyval) const noexcept { 
#line 420
return std::hash< int> {}(_Keyval.value()); 
#line 421
} 
#line 422
}; 
#line 424
class _System_error : public runtime_error { 
#line 426
static string _Makestr(error_code _Errcode, string _Message) { 
#line 427
if (!_Message.empty()) { 
#line 428
_Message.append(": "); 
#line 429
}  
#line 431
_Message.append(_Errcode.message()); 
#line 432
return _Message; 
#line 433
} 
#line 436
protected: _System_error(error_code _Errcode, const string &_Message) : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) 
#line 437
{ } 
#line 439
error_code _Mycode; 
#line 440
}; 
#line 442
class system_error : public _System_error { 
#line 444
using _Mybase = _System_error; 
#line 447
public: system_error(error_code _Errcode) : _Mybase(_Errcode, "") { } 
#line 449
system_error(error_code _Errcode, const string &_Message) : _Mybase(_Errcode, _Message) { } 
#line 451
system_error(error_code _Errcode, const char *_Message) : _Mybase(_Errcode, _Message) { } 
#line 453
system_error(int _Errval, const error_category &_Errcat) : _Mybase(error_code(_Errval, _Errcat), "") { } 
#line 455
system_error(int _Errval, const error_category &_Errcat, const string &_Message) : _Mybase(error_code(_Errval, _Errcat), _Message) 
#line 456
{ } 
#line 458
system_error(int _Errval, const error_category &_Errcat, const char *_Message) : _Mybase(error_code(_Errval, _Errcat), _Message) 
#line 459
{ } 
#line 461
[[nodiscard]] const error_code &code() const noexcept { 
#line 462
return _Mycode; 
#line 463
} 
#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
}; 
#line 473
[[noreturn]] inline void _Throw_system_error(const errc _Errno) { 
#line 474
throw system_error{::std::make_error_code(_Errno)}; 
#line 475
} 
#line 477
const char *__cdecl _Syserror_map(int); 
#line 478
int __cdecl _Winerror_map(int); 
#line 480
struct _System_error_message { 
#line 481
char *_Str; 
#line 482
size_t _Length; 
#line 484
explicit _System_error_message(const unsigned long _Ec) noexcept : _Str((nullptr)), _Length(::__std_system_error_allocate_message(_Ec, &(_Str))) 
#line 485
{ } 
#line 487
_System_error_message(const _System_error_message &) = delete;
#line 488
_System_error_message &operator=(const _System_error_message &) = delete;
#line 490
~_System_error_message() { 
#line 491
::__std_system_error_deallocate_message(_Str); 
#line 492
} 
#line 493
}; 
#line 495
class _Generic_error_category : public error_category { 
#line 497
public: constexpr _Generic_error_category() noexcept : error_category(_Generic_addr) { } 
#line 499
[[nodiscard]] virtual const char *name() const noexcept override { 
#line 500
return "generic"; 
#line 501
} 
#line 503
[[nodiscard]] virtual string message(int _Errcode) const override { 
#line 504
return _Syserror_map(_Errcode); 
#line 505
} 
#line 506
}; 
#line 508
class _Iostream_error_category2 : public error_category { 
#line 510
public: constexpr _Iostream_error_category2() noexcept : error_category(_Iostream_addr) { } 
#line 512
[[nodiscard]] virtual const char *name() const noexcept override { 
#line 513
return "iostream"; 
#line 514
} 
#line 516
[[nodiscard]] virtual string message(int _Errcode) const override { 
#line 517
if (_Errcode == (static_cast< int>(io_errc::stream))) { 
#line 518
static constexpr char _Iostream_error[] = "iostream stream error"; 
#line 519
constexpr size_t _Iostream_error_length = (sizeof _Iostream_error - (1)); 
#line 520
return string(_Iostream_error, _Iostream_error_length); 
#line 521
} else { 
#line 522
return _Syserror_map(_Errcode); 
#line 523
}  
#line 524
} 
#line 525
}; 
#line 527
class _System_error_category : public error_category { 
#line 529
public: constexpr _System_error_category() noexcept : error_category(_System_addr) { } 
#line 531
[[nodiscard]] virtual const char *name() const noexcept override { 
#line 532
return "system"; 
#line 533
} 
#line 535
[[nodiscard]] virtual string message(int _Errcode) const override { 
#line 536
const _System_error_message _Msg(static_cast< unsigned long>(_Errcode)); 
#line 537
if ((_Msg._Length) == (0)) { 
#line 538
static constexpr char _Unknown_error[] = "unknown error"; 
#line 539
constexpr size_t _Unknown_error_length = (sizeof _Unknown_error - (1)); 
#line 540
return string(_Unknown_error, _Unknown_error_length); 
#line 541
} else { 
#line 542
return string(_Msg._Str, _Msg._Length); 
#line 543
}  
#line 544
} 
#line 546
[[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept override { 
#line 548
const int _Posv = _Winerror_map(_Errval); 
#line 549
if (_Posv == 0) { 
#line 550
return error_condition(_Errval, ::std::system_category()); 
#line 551
} else { 
#line 552
return error_condition(_Posv, ::std::generic_category()); 
#line 553
}  
#line 554
} 
#line 555
}; 
#line 606 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
template < class _Ty >
struct _Constexpr_immortalize_impl {
    union {
        _Ty _Storage;
    };

    constexpr _Constexpr_immortalize_impl ( ) noexcept : _Storage { } { }

    _Constexpr_immortalize_impl ( const _Constexpr_immortalize_impl & ) = delete;
    _Constexpr_immortalize_impl & operator = ( const _Constexpr_immortalize_impl & ) = delete;

    [ [ msvc :: noop_dtor ] ] ~ _Constexpr_immortalize_impl ( ) {

    }
};
#line 622
template < class _Ty >
[ [ nodiscard ] ] const _Ty & _Immortalize_memcpy_image ( ) noexcept {
    static _Constexpr_immortalize_impl < _Ty > _Static;
    return _Static . _Storage;
}
#line 648 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
[[nodiscard]] inline const error_category &generic_category() noexcept { 
#line 649
return _Immortalize_memcpy_image< _Generic_error_category> (); 
#line 650
} 
#line 652
[[nodiscard]] inline const error_category &iostream_category() noexcept { 
#line 653
return _Immortalize_memcpy_image< _Iostream_error_category2> (); 
#line 654
} 
#line 656
[[nodiscard]] inline const error_category &system_category() noexcept { 
#line 657
return _Immortalize_memcpy_image< _System_error_category> (); 
#line 658
} 
#line 659
}
#line 662
#pragma warning(pop)
#pragma pack ( pop )
#line 666 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
#pragma warning(disable : 4275)
#line 23
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 18
#pragma pack ( push, 8 )
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
struct __type_info_node; 
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
extern __type_info_node __type_info_root_node; 
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 38
struct __std_type_info_data { 
#line 40
const char *_UndecoratedName; 
#line 41
const char _DecoratedName[1]; 
#line 42
__std_type_info_data() = delete;
#line 43
__std_type_info_data(const __std_type_info_data &) = delete;
#line 44
__std_type_info_data(__std_type_info_data &&) = delete;
#line 46
__std_type_info_data &operator=(const __std_type_info_data &) = delete;
#line 47
__std_type_info_data &operator=(__std_type_info_data &&) = delete;
#line 48
}; 
#line 50
int __cdecl __std_type_info_compare(const __std_type_info_data * _Lhs, const __std_type_info_data * _Rhs); 
#line 55
size_t __cdecl __std_type_info_hash(const __std_type_info_data * _Data); 
#line 59
const char *__cdecl __std_type_info_name(__std_type_info_data * _Data, __type_info_node * _RootNode); 
#line 64
}__pragma( pack ( pop )) 
#line 67
#pragma warning(push)
#pragma warning(disable: 4577)
class type_info { 
#line 73
public: type_info(const type_info &) = delete;
#line 74
type_info &operator=(const type_info &) = delete;
#line 76
size_t hash_code() const noexcept 
#line 77
{ 
#line 78
return __std_type_info_hash(&(_Data)); 
#line 79
} 
#line 81
bool operator==(const type_info &_Other) const noexcept 
#line 82
{ 
#line 83
return __std_type_info_compare(&(_Data), &(_Other._Data)) == 0; 
#line 84
} 
#line 87
bool operator!=(const type_info &_Other) const noexcept 
#line 88
{ 
#line 89
return __std_type_info_compare(&(_Data), &(_Other._Data)) != 0; 
#line 90
} 
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
bool before(const type_info &_Other) const noexcept 
#line 94
{ 
#line 95
return __std_type_info_compare(&(_Data), &(_Other._Data)) < 0; 
#line 96
} 
#line 98
const char *name() const noexcept 
#line 99
{ 
#line 103
return __std_type_info_name(&(_Data), &__type_info_root_node); 
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
} 
#line 107
const char *raw_name() const noexcept 
#line 108
{ 
#line 109
return (_Data)._DecoratedName; 
#line 110
} 
#line 112
virtual ~type_info() noexcept; 
#line 116
private: mutable __std_type_info_data _Data; 
#line 117
}; 
#pragma warning(pop)
#line 120
namespace std { 
#line 121
using ::type_info;
#line 122
}
#line 126
namespace std { 
#line 128
#pragma warning(push)
#pragma warning(disable: 4577)
class bad_cast : public exception { 
#line 135
public: bad_cast() noexcept : exception("bad cast", 1) 
#line 137
{ 
#line 138
} 
#line 140
static bad_cast __construct_from_string_literal(const char *const _Message) noexcept 
#line 141
{ 
#line 142
return bad_cast(_Message, 1); 
#line 143
} 
#line 147
private: bad_cast(const char *const _Message, int) noexcept : exception(_Message, 1) 
#line 149
{ 
#line 150
} 
#line 151
}; 
#line 153
class bad_typeid : public exception { 
#line 158
public: bad_typeid() noexcept : exception("bad typeid", 1) 
#line 160
{ 
#line 161
} 
#line 163
static bad_typeid __construct_from_string_literal(const char *const _Message) noexcept 
#line 164
{ 
#line 165
return bad_typeid(_Message, 1); 
#line 166
} 
#line 170
friend class __non_rtti_object; 
#line 172
private: bad_typeid(const char *const _Message, int) noexcept : exception(_Message, 1) 
#line 174
{ 
#line 175
} 
#line 176
}; 
#line 178
class __non_rtti_object : public bad_typeid { 
#line 183
public: static __non_rtti_object __construct_from_string_literal(const char *const _Message) noexcept 
#line 184
{ 
#line 185
return __non_rtti_object(_Message, 1); 
#line 186
} 
#line 190
private: __non_rtti_object(const char *const _Message, int) noexcept : bad_typeid(_Message, 1) 
#line 192
{ 
#line 193
} 
#line 194
}; 
#line 196
#pragma warning(pop)
}
#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
#pragma pack ( pop )
#pragma warning(pop)
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"
namespace std { 
#line 28
constexpr int _Small_object_num_ptrs = ((6) + ((16) / sizeof(void *))); 
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"
[[noreturn]] inline void _Throw_bad_cast() { 
#line 63
throw bad_cast{}; 
#line 64
} 
#line 66
}
#line 70
#pragma pack ( pop )
#pragma warning(pop)
#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"
#pragma external_header(pop)
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 28
namespace std { 
#line 109
template < class _InIt, class _Diff, class _NoThrowFwdIt >
_NoThrowFwdIt uninitialized_copy_n ( const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( _Count <= 0 ) {
        return _Dest;
    }

    auto _UFirst = _Get_unwrapped_n ( _First, _Count );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Count );
    if constexpr ( _Ptr_copy_cat < decltype ( _UFirst ), decltype ( _UDest ) > :: _Really_trivial ) {
        _UDest = _Copy_memmove ( _UFirst, _UFirst + _Count, _UDest );
    } else {
        _Uninitialized_backout < decltype ( _UDest ) > _Backout { _UDest };

        for (; _Count > 0; -- _Count, ( void ) ++ _UFirst ) {
            _Backout . _Emplace_back ( * _UFirst );
        }

        _UDest = _Backout . _Release ( );
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 385 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _NoThrowFwdIt, class _Diff, class _Tval >
_NoThrowFwdIt uninitialized_fill_n ( _NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval & _Val ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( _Count <= 0 ) {
        return _First;
    }

    auto _UFirst = _Get_unwrapped_n ( _First, _Count );
    if constexpr ( _Fill_memset_is_safe < decltype ( _UFirst ), _Tval > ) {
        _Fill_memset ( _UFirst, _Val, static_cast < size_t > ( _Count ) );
        _UFirst += _Count;
    } else {
        if constexpr ( _Fill_zero_memset_is_safe < decltype ( _UFirst ), _Tval > ) {
            if ( _Is_all_bits_zero ( _Val ) ) {
                _Fill_zero_memset ( _UFirst, static_cast < size_t > ( _Count ) );
                _Seek_wrapped ( _First, _UFirst + _Count );
                return _First;
            }
        }

        _Uninitialized_backout < decltype ( _UFirst ) > _Backout { _UFirst };

        for (; _Count > 0; -- _Count ) {
            _Backout . _Emplace_back ( _Val );
        }

        _UFirst = _Backout . _Release ( );
    }

    _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 875 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _OutIt, class _Ty >
class raw_storage_iterator {
public :
    using iterator_category = output_iterator_tag;
    using value_type = void;



    using difference_type = void;

    using pointer = void;
    using reference = void;

    explicit raw_storage_iterator ( _OutIt _First ) : _Next ( _First ) { }

    [ [ nodiscard ] ] raw_storage_iterator & operator * ( ) {
        return * this;
    }

    raw_storage_iterator & operator = ( const _Ty & _Val ) {
        _Construct_in_place ( * _Next, _Val );
        return * this;
    }

    raw_storage_iterator & operator = ( _Ty && _Val ) {
        _Construct_in_place ( * _Next, :: std :: move ( _Val ) );
        return * this;
    }

    raw_storage_iterator & operator ++ ( ) {
        ++ _Next;
        return * this;
    }

    raw_storage_iterator operator ++ ( int ) {
        raw_storage_iterator _Ans = * this;
        ++ _Next;
        return _Ans;
    }

    [ [ nodiscard ] ] _OutIt base ( ) const {
        return _Next;
    }

private :
    _OutIt _Next;
};
#line 926 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty >
class auto_ptr;
#line 929
template < class _Ty >
struct auto_ptr_ref {
    explicit auto_ptr_ref ( _Ty * _Right ) : _Ref ( _Right ) { }

    _Ty * _Ref;
};
#line 936
template < class _Ty >
class auto_ptr {
public :
    using element_type = _Ty;

    explicit auto_ptr ( _Ty * _Ptr = nullptr ) noexcept : _Myptr ( _Ptr ) { }

    auto_ptr ( auto_ptr & _Right ) noexcept : _Myptr ( _Right . release ( ) ) { }

    auto_ptr ( auto_ptr_ref < _Ty > _Right ) noexcept {
        _Ty * _Ptr = _Right . _Ref;
        _Right . _Ref = nullptr;
        _Myptr = _Ptr;
    }

    template < class _Other >
    operator auto_ptr < _Other > ( ) noexcept {
        return auto_ptr < _Other > ( * this );
    }

    template < class _Other >
    operator auto_ptr_ref < _Other > ( ) noexcept {
        _Other * _Cvtptr = _Myptr;
        auto_ptr_ref < _Other > _Ans ( _Cvtptr );
        _Myptr = nullptr;
        return _Ans;
    }

    template < class _Other >
    auto_ptr & operator = ( auto_ptr < _Other > & _Right ) noexcept {
        reset ( _Right . release ( ) );
        return * this;
    }

    template < class _Other >
    auto_ptr ( auto_ptr < _Other > & _Right ) noexcept : _Myptr ( _Right . release ( ) ) { }

    auto_ptr & operator = ( auto_ptr & _Right ) noexcept {
        reset ( _Right . release ( ) );
        return * this;
    }

    auto_ptr & operator = ( auto_ptr_ref < _Ty > _Right ) noexcept {
        _Ty * _Ptr = _Right . _Ref;
        _Right . _Ref = 0;
        reset ( _Ptr );
        return * this;
    }

    ~ auto_ptr ( ) noexcept {
        delete _Myptr;
    }

    [ [ nodiscard ] ] _Ty & operator * ( ) const noexcept {




        return * get ( );
    }

    [ [ nodiscard ] ] _Ty * operator -> ( ) const noexcept {




        return get ( );
    }

    [ [ nodiscard ] ] _Ty * get ( ) const noexcept {
        return _Myptr;
    }

    _Ty * release ( ) noexcept {
        _Ty * _Tmp = _Myptr;
        _Myptr = nullptr;
        return _Tmp;
    }

    void reset ( _Ty * _Ptr = nullptr ) noexcept {
        if ( _Ptr != _Myptr ) {
            delete _Myptr;
        }

        _Myptr = _Ptr;
    }

private :
    _Ty * _Myptr;
};
#line 1028 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
#pragma pack(8)
template<> 
#line 1028
class auto_ptr< void>  { 
#line 1030
public: using element_type = void; 
#line 1031
}; 
#pragma pack()
#line 1035 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
#pragma pack(8)
#line 1035
class bad_weak_ptr : public exception { 
#line 1037
public: bad_weak_ptr() noexcept { } 
#line 1039
[[nodiscard]] virtual const char *what() const noexcept override { 
#line 1041
return "bad_weak_ptr"; 
#line 1042
} 
#line 1043
}; 
#pragma pack()
[[noreturn]] inline void _Throw_bad_weak_ptr() { 
#line 1046
throw bad_weak_ptr{}; 
#line 1047
} 
#line 1049
#pragma pack(8)
#line 1049
class __declspec(novtable) _Ref_count_base { 
#line 1061
virtual void _Destroy() noexcept = 0; 
#line 1062
virtual void _Delete_this() noexcept = 0; 
#line 1065 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
_Atomic_counter_t _Uses = (1); 
#line 1066
_Atomic_counter_t _Weaks = (1); 
#line 1069
protected: constexpr _Ref_count_base() noexcept = default;
#line 1072
public: _Ref_count_base(const _Ref_count_base &) = delete;
#line 1073
_Ref_count_base &operator=(const _Ref_count_base &) = delete;
#line 1075
virtual ~_Ref_count_base() noexcept { } 
#line 1077
bool _Incref_nz() noexcept { 
#line 1078
auto &_Volatile_uses = reinterpret_cast< volatile long &>(_Uses); 
#line 1082
long _Count = __iso_volatile_load32(reinterpret_cast< volatile int *>(&_Volatile_uses)); 
#line 1084 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
while (_Count != (0)) { 
#line 1085
const long _Old_value = _InterlockedCompareExchange(&_Volatile_uses, _Count + (1), _Count); 
#line 1086
if (_Old_value == _Count) { 
#line 1087
return true; 
#line 1088
}  
#line 1090
_Count = _Old_value; 
#line 1091
}  
#line 1093
return false; 
#line 1094
} 
#line 1096
void _Incref() noexcept { 
#line 1097
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Uses))); 
#line 1098
} 
#line 1100
void _Incwref() noexcept { 
#line 1101
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Weaks))); 
#line 1102
} 
#line 1104
void _Decref() noexcept { 
#line 1105
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Uses))) == (0)) { 
#line 1106
this->_Destroy(); 
#line 1107
this->_Decwref(); 
#line 1108
}  
#line 1109
} 
#line 1111
void _Decwref() noexcept { 
#line 1112
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Weaks))) == (0)) { 
#line 1113
this->_Delete_this(); 
#line 1114
}  
#line 1115
} 
#line 1117
long _Use_count() const noexcept { 
#line 1118
return static_cast< long>(_Uses); 
#line 1119
} 
#line 1121
virtual void *_Get_deleter(const type_info &) const noexcept { 
#line 1122
return nullptr; 
#line 1123
} 
#line 1124
}; 
#pragma pack()
template < class _Ty >
class _Ref_count : public _Ref_count_base {
public :
    explicit _Ref_count ( _Ty * _Px ) : _Ref_count_base ( ), _Ptr ( _Px ) { }

private :
    virtual void _Destroy ( ) noexcept override {
        delete _Ptr;
    }

    virtual void _Delete_this ( ) noexcept override {
        delete this;
    }

    _Ty * _Ptr;
};
#line 1143
template < class _Resource, class _Dx >
class _Ref_count_resource : public _Ref_count_base {
public :
    _Ref_count_resource ( _Resource _Px, _Dx _Dt )
        : _Ref_count_base ( ), _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Dt ), _Px ) { }




    virtual ~ _Ref_count_resource ( ) noexcept override = default;


    virtual void * _Get_deleter ( const type_info & _Typeid ) const noexcept override {

        if ( _Typeid == typeid ( _Dx ) ) {
            return const_cast < _Dx * > ( :: std :: addressof ( _Mypair . _Get_first ( ) ) );
        }




        return nullptr;
    }

private :
    virtual void _Destroy ( ) noexcept override {
        _Mypair . _Get_first ( ) ( _Mypair . _Myval2 );
    }

    virtual void _Delete_this ( ) noexcept override {
        delete this;
    }

    _Compressed_pair < _Dx, _Resource > _Mypair;
};
#line 1179 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Resource, class _Dx, class _Alloc >
class _Ref_count_resource_alloc : public _Ref_count_base {

public :
    _Ref_count_resource_alloc ( _Resource _Px, _Dx _Dt, const _Alloc & _Ax )
        : _Ref_count_base ( ),
          _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Dt ), _One_then_variadic_args_t { }, _Ax, _Px ) { }




    virtual ~ _Ref_count_resource_alloc ( ) noexcept override = default;


    virtual void * _Get_deleter ( const type_info & _Typeid ) const noexcept override {

        if ( _Typeid == typeid ( _Dx ) ) {
            return const_cast < _Dx * > ( :: std :: addressof ( _Mypair . _Get_first ( ) ) );
        }




        return nullptr;
    }

private :
    using _Myalty = _Rebind_alloc_t < _Alloc, _Ref_count_resource_alloc >;

    virtual void _Destroy ( ) noexcept override {
        _Mypair . _Get_first ( ) ( _Mypair . _Myval2 . _Myval2 );
    }

    virtual void _Delete_this ( ) noexcept override {
        _Myalty _Al = _Mypair . _Myval2 . _Get_first ( );
        this -> ~ _Ref_count_resource_alloc ( );
        _Deallocate_plain ( _Al, this );
    }

    _Compressed_pair < _Dx, _Compressed_pair < _Myalty, _Resource >> _Mypair;
};
#line 1221 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty >
struct default_delete;
#line 1224
template < class _Ty, class _Dx = default_delete < _Ty > >
class unique_ptr;
#line 1227
template < class _Ty >
class shared_ptr;
#line 1230
template < class _Ty >
class weak_ptr;
#line 1233
template< class _Yty, class  = void> 
#line 1234
struct _Can_enable_shared : public false_type { }; 
#line 1236
template< class _Yty> 
#line 1237
struct _Can_enable_shared< _Yty, void_t< typename _Yty::_Esft_type> >  : public is_convertible< remove_cv_t< _Yty>  *, typename _Yty::_Esft_type *> ::type { 
#line 1240
}; 
#line 1242
struct _Exception_ptr_access; 
#line 1244
template < class _Ty >
class _Ptr_base {
public :
    using element_type = remove_extent_t < _Ty >;

    [ [ nodiscard ] ] long use_count ( ) const noexcept {
        return _Rep ? _Rep -> _Use_count ( ) : 0;
    }

    template < class _Ty2 >
    [ [ nodiscard ] ] bool owner_before ( const _Ptr_base < _Ty2 > & _Right ) const noexcept {
        return _Rep < _Right . _Rep;
    }

    _Ptr_base ( const _Ptr_base & ) = delete;
    _Ptr_base & operator = ( const _Ptr_base & ) = delete;

protected :
    [ [ nodiscard ] ] element_type * get ( ) const noexcept {
        return _Ptr;
    }

    constexpr _Ptr_base ( ) noexcept = default;

    ~ _Ptr_base ( ) = default;

    template < class _Ty2 >
    void _Move_construct_from ( _Ptr_base < _Ty2 > && _Right ) noexcept {

        _Ptr = _Right . _Ptr;
        _Rep = _Right . _Rep;

        _Right . _Ptr = nullptr;
        _Right . _Rep = nullptr;
    }

    template < class _Ty2 >
    void _Copy_construct_from ( const shared_ptr < _Ty2 > & _Other ) noexcept {

        _Other . _Incref ( );

        _Ptr = _Other . _Ptr;
        _Rep = _Other . _Rep;
    }

    template < class _Ty2 >
    void _Alias_construct_from ( const shared_ptr < _Ty2 > & _Other, element_type * _Px ) noexcept {

        _Other . _Incref ( );

        _Ptr = _Px;
        _Rep = _Other . _Rep;
    }

    template < class _Ty2 >
    void _Alias_move_construct_from ( shared_ptr < _Ty2 > && _Other, element_type * _Px ) noexcept {

        _Ptr = _Px;
        _Rep = _Other . _Rep;

        _Other . _Ptr = nullptr;
        _Other . _Rep = nullptr;
    }

    template < class _Ty0 >
    friend class weak_ptr;

    template < class _Ty2 >
    bool _Construct_from_weak ( const weak_ptr < _Ty2 > & _Other ) noexcept {

        if ( _Other . _Rep && _Other . _Rep -> _Incref_nz ( ) ) {
            _Ptr = _Other . _Ptr;
            _Rep = _Other . _Rep;
            return true;
        }

        return false;
    }

    void _Incref ( ) const noexcept {
        if ( _Rep ) {
            _Rep -> _Incref ( );
        }
    }

    void _Decref ( ) noexcept {
        if ( _Rep ) {
            _Rep -> _Decref ( );
        }
    }

    void _Swap ( _Ptr_base & _Right ) noexcept {
        :: std :: swap ( _Ptr, _Right . _Ptr );
        :: std :: swap ( _Rep, _Right . _Rep );
    }

    template < class _Ty2 >
    void _Weakly_construct_from ( const _Ptr_base < _Ty2 > & _Other ) noexcept {
        if ( _Other . _Rep ) {
            _Ptr = _Other . _Ptr;
            _Rep = _Other . _Rep;
            _Rep -> _Incwref ( );
        } else {
            ;
        }
    }

    template < class _Ty2 >
    void _Weakly_convert_lvalue_avoiding_expired_conversions ( const _Ptr_base < _Ty2 > & _Other ) noexcept {

        if ( _Other . _Rep ) {
            _Rep = _Other . _Rep;
            _Rep -> _Incwref ( );

            if ( _Rep -> _Incref_nz ( ) ) {
                _Ptr = _Other . _Ptr;
                _Rep -> _Decref ( );
            } else {
                ;
            }
        } else {
            ;
        }
    }

    template < class _Ty2 >
    void _Weakly_convert_rvalue_avoiding_expired_conversions ( _Ptr_base < _Ty2 > && _Other ) noexcept {

        _Rep = _Other . _Rep;
        _Other . _Rep = nullptr;

        if ( _Rep && _Rep -> _Incref_nz ( ) ) {
            _Ptr = _Other . _Ptr;
            _Rep -> _Decref ( );
        } else {
            ;
        }

        _Other . _Ptr = nullptr;
    }

    void _Incwref ( ) const noexcept {
        if ( _Rep ) {
            _Rep -> _Incwref ( );
        }
    }

    void _Decwref ( ) noexcept {
        if ( _Rep ) {
            _Rep -> _Decwref ( );
        }
    }

private :
    element_type * _Ptr { nullptr };
    _Ref_count_base * _Rep { nullptr };

    template < class _Ty0 >
    friend class _Ptr_base;

    friend shared_ptr < _Ty >;

    template < class _Ty0 >
    friend struct atomic;

    friend _Exception_ptr_access;


    template < class _Dx, class _Ty0 >
    friend _Dx * get_deleter ( const shared_ptr < _Ty0 > & _Sx ) noexcept;

};
#line 1417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template< class _Yty, class  = void> 
#line 1418
struct _Can_scalar_delete : public false_type { }; 
#line 1419
template< class _Yty> 
#line 1420
struct _Can_scalar_delete< _Yty, void_t< decltype(delete std::declval< _Yty *> ())> >  : public true_type { }; 
#line 1422
template< class _Yty, class  = void> 
#line 1423
struct _Can_array_delete : public false_type { }; 
#line 1424
template< class _Yty> 
#line 1425
struct _Can_array_delete< _Yty, void_t< decltype(delete [] std::declval< _Yty *> ())> >  : public true_type { }; 
#line 1427
template< class _Fx, class _Arg, class  = void> 
#line 1428
struct _Can_call_function_object : public false_type { }; 
#line 1429
template< class _Fx, class _Arg> 
#line 1430
struct _Can_call_function_object< _Fx, _Arg, void_t< decltype(std::declval< _Fx> ()(std::declval< _Arg> ()))> >  : public true_type { }; 
#line 1432
template< class _Yty, class _Ty> 
#line 1433
struct _SP_convertible : public is_convertible< _Yty *, _Ty *> ::type { }; 
#line 1434
template< class _Yty, class _Uty> 
#line 1435
struct _SP_convertible< _Yty, _Uty []>  : public is_convertible< _Yty (*)[], _Uty (*)[]> ::type { }; 
#line 1436
template< class _Yty, class _Uty, size_t _Ext> 
#line 1437
struct _SP_convertible< _Yty, _Uty [_Ext]>  : public is_convertible< _Yty (*)[_Ext], _Uty (*)[_Ext]> ::type { }; 
#line 1439
template< class _Yty, class _Ty> 
#line 1440
struct _SP_pointer_compatible : public is_convertible< _Yty *, _Ty *> ::type { 
#line 1443
}; 
#line 1444
template< class _Uty, size_t _Ext> 
#line 1445
struct _SP_pointer_compatible< _Uty [_Ext], _Uty []>  : public true_type { 
#line 1447
}; 
#line 1448
template< class _Uty, size_t _Ext> 
#line 1449
struct _SP_pointer_compatible< _Uty [_Ext], const _Uty []>  : public true_type { 
#line 1451
}; 
#line 1452
template< class _Uty, size_t _Ext> 
#line 1453
struct _SP_pointer_compatible< _Uty [_Ext], volatile _Uty []>  : public true_type { 
#line 1455
}; 
#line 1456
template< class _Uty, size_t _Ext> 
#line 1457
struct _SP_pointer_compatible< _Uty [_Ext], const volatile _Uty []>  : public true_type { 
#line 1459
}; 
#line 1461
template < class _Ux >
struct _Temporary_owner {
    _Ux * _Ptr;

    explicit _Temporary_owner ( _Ux * const _Ptr_ ) noexcept : _Ptr ( _Ptr_ ) { }
    _Temporary_owner ( const _Temporary_owner & ) = delete;
    _Temporary_owner & operator = ( const _Temporary_owner & ) = delete;
    ~ _Temporary_owner ( ) {
        delete _Ptr;
    }
};
#line 1473
template < class _UxptrOrNullptr, class _Dx >
struct _Temporary_owner_del {
    _UxptrOrNullptr _Ptr;
    _Dx & _Dt;
    bool _Call_deleter = true;

    explicit _Temporary_owner_del ( const _UxptrOrNullptr _Ptr_, _Dx & _Dt_ ) noexcept : _Ptr ( _Ptr_ ), _Dt ( _Dt_ ) { }
    _Temporary_owner_del ( const _Temporary_owner_del & ) = delete;
    _Temporary_owner_del & operator = ( const _Temporary_owner_del & ) = delete;
    ~ _Temporary_owner_del ( ) {
        if ( _Call_deleter ) {
            _Dt ( _Ptr );
        }
    }
};
#line 1489
template < class _Ty >
class shared_ptr : public _Ptr_base < _Ty > {
private :
    using _Mybase = _Ptr_base < _Ty >;

public :
    using typename _Mybase :: element_type;





    constexpr shared_ptr ( ) noexcept = default;

    constexpr shared_ptr ( nullptr_t ) noexcept { }

    template < class _Ux,
        enable_if_t < conjunction_v < conditional_t < is_array_v < _Ty >, _Can_array_delete < _Ux >, _Can_scalar_delete < _Ux >>,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    explicit shared_ptr ( _Ux * _Px ) {
        if constexpr ( is_array_v < _Ty > ) {
            _Setpd ( _Px, default_delete < _Ux [ ] > { } );
        } else {
            _Temporary_owner < _Ux > _Owner ( _Px );
            _Set_ptr_rep_and_enable_shared ( _Owner . _Ptr, new _Ref_count < _Ux > ( _Owner . _Ptr ) );
            _Owner . _Ptr = nullptr;
        }
    }

    template < class _Ux, class _Dx,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, _Ux * & >,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    shared_ptr ( _Ux * _Px, _Dx _Dt ) {
        _Setpd ( _Px, :: std :: move ( _Dt ) );
    }

    template < class _Ux, class _Dx, class _Alloc,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, _Ux * & >,
                        _SP_convertible < _Ux, _Ty >>,
            int > = 0 >
    shared_ptr ( _Ux * _Px, _Dx _Dt, _Alloc _Ax ) {
        _Setpda ( _Px, :: std :: move ( _Dt ), _Ax );
    }

    template < class _Dx,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, nullptr_t & >>, int > = 0 >
    shared_ptr ( nullptr_t, _Dx _Dt ) {
        _Setpd ( nullptr, :: std :: move ( _Dt ) );
    }

    template < class _Dx, class _Alloc,
        enable_if_t < conjunction_v < is_move_constructible < _Dx >, _Can_call_function_object < _Dx &, nullptr_t & >>, int > = 0 >
    shared_ptr ( nullptr_t, _Dx _Dt, _Alloc _Ax ) {
        _Setpda ( nullptr, :: std :: move ( _Dt ), _Ax );
    }

    template < class _Ty2 >
    shared_ptr ( const shared_ptr < _Ty2 > & _Right, element_type * _Px ) noexcept {

        this -> _Alias_construct_from ( _Right, _Px );
    }

    template < class _Ty2 >
    shared_ptr ( shared_ptr < _Ty2 > && _Right, element_type * _Px ) noexcept {

        this -> _Alias_move_construct_from ( :: std :: move ( _Right ), _Px );
    }

    shared_ptr ( const shared_ptr & _Other ) noexcept {
        this -> _Copy_construct_from ( _Other );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    shared_ptr ( const shared_ptr < _Ty2 > & _Other ) noexcept {

        this -> _Copy_construct_from ( _Other );
    }

    shared_ptr ( shared_ptr && _Right ) noexcept {
        this -> _Move_construct_from ( :: std :: move ( _Right ) );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    shared_ptr ( shared_ptr < _Ty2 > && _Right ) noexcept {
        this -> _Move_construct_from ( :: std :: move ( _Right ) );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    explicit shared_ptr ( const weak_ptr < _Ty2 > & _Other ) {
        if ( ! this -> _Construct_from_weak ( _Other ) ) {
            _Throw_bad_weak_ptr ( );
        }
    }


    template < class _Ty2, enable_if_t < is_convertible_v < _Ty2 *, _Ty * >, int > = 0 >
    shared_ptr ( auto_ptr < _Ty2 > && _Other ) {
        _Ty2 * _Px = _Other . get ( );
        _Set_ptr_rep_and_enable_shared ( _Px, new _Ref_count < _Ty2 > ( _Px ) );
        _Other . release ( );
    }


    template < class _Ux, class _Dx,
        enable_if_t < conjunction_v < _SP_pointer_compatible < _Ux, _Ty >,
                        is_convertible < typename unique_ptr < _Ux, _Dx > :: pointer, element_type * >>,
            int > = 0 >
    shared_ptr ( unique_ptr < _Ux, _Dx > && _Other ) {
        using _Fancy_t = typename unique_ptr < _Ux, _Dx > :: pointer;
        using _Raw_t = typename unique_ptr < _Ux, _Dx > :: element_type *;
        using _Deleter_t = conditional_t < is_reference_v < _Dx >, decltype ( :: std :: ref ( _Other . get_deleter ( ) ) ), _Dx >;

        const _Fancy_t _Fancy = _Other . get ( );

        if ( _Fancy ) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx = new _Ref_count_resource < _Fancy_t, _Deleter_t > ( _Fancy, _Other . get_deleter ( ) );
            _Set_ptr_rep_and_enable_shared ( _Raw, _Rx );
            _Other . release ( );
        }
    }

    ~ shared_ptr ( ) noexcept {
        this -> _Decref ( );
    }

    shared_ptr & operator = ( const shared_ptr & _Right ) noexcept {
        shared_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    template < class _Ty2 >
    shared_ptr & operator = ( const shared_ptr < _Ty2 > & _Right ) noexcept {
        shared_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    shared_ptr & operator = ( shared_ptr && _Right ) noexcept {
        shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }

    template < class _Ty2 >
    shared_ptr & operator = ( shared_ptr < _Ty2 > && _Right ) noexcept {
        shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }


    template < class _Ty2 >
    shared_ptr & operator = ( auto_ptr < _Ty2 > && _Right ) {
        shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }


    template < class _Ux, class _Dx >
    shared_ptr & operator = ( unique_ptr < _Ux, _Dx > && _Right ) {
        shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }

    void swap ( shared_ptr & _Other ) noexcept {
        this -> _Swap ( _Other );
    }

    void reset ( ) noexcept {
        shared_ptr ( ) . swap ( * this );
    }

    template < class _Ux >
    void reset ( _Ux * _Px ) {
        shared_ptr ( _Px ) . swap ( * this );
    }

    template < class _Ux, class _Dx >
    void reset ( _Ux * _Px, _Dx _Dt ) {
        shared_ptr ( _Px, _Dt ) . swap ( * this );
    }

    template < class _Ux, class _Dx, class _Alloc >
    void reset ( _Ux * _Px, _Dx _Dt, _Alloc _Ax ) {
        shared_ptr ( _Px, _Dt, _Ax ) . swap ( * this );
    }

    using _Mybase :: get;

    template < class _Ty2 = _Ty, enable_if_t < ! disjunction_v < is_array < _Ty2 >, is_void < _Ty2 >>, int > = 0 >
    [ [ nodiscard ] ] _Ty2 & operator * ( ) const noexcept {
        return * get ( );
    }

    template < class _Ty2 = _Ty, enable_if_t < ! is_array_v < _Ty2 >, int > = 0 >
    [ [ nodiscard ] ] _Ty2 * operator -> ( ) const noexcept {
        return get ( );
    }

    template < class _Ty2 = _Ty, class _Elem = element_type, enable_if_t < is_array_v < _Ty2 >, int > = 0 >
    [ [ nodiscard ] ] _Elem & operator [ ] ( ptrdiff_t _Idx ) const noexcept {
        return get ( ) [ _Idx ];
    }


     [ [ nodiscard ] ] bool unique ( ) const noexcept {

        return this -> use_count ( ) == 1;
    }


    explicit operator bool ( ) const noexcept {
        return get ( ) != nullptr;
    }

private :
    template < class _UxptrOrNullptr, class _Dx >
    void _Setpd ( const _UxptrOrNullptr _Px, _Dx _Dt ) {
        _Temporary_owner_del < _UxptrOrNullptr, _Dx > _Owner ( _Px, _Dt );
        _Set_ptr_rep_and_enable_shared (
            _Owner . _Ptr, new _Ref_count_resource < _UxptrOrNullptr, _Dx > ( _Owner . _Ptr, :: std :: move ( _Dt ) ) );
        _Owner . _Call_deleter = false;
    }

    template < class _UxptrOrNullptr, class _Dx, class _Alloc >
    void _Setpda ( const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax ) {
        using _Alref_alloc = _Rebind_alloc_t < _Alloc, _Ref_count_resource_alloc < _UxptrOrNullptr, _Dx, _Alloc >>;

        _Temporary_owner_del < _UxptrOrNullptr, _Dx > _Owner ( _Px, _Dt );
        _Alref_alloc _Alref ( _Ax );
        _Alloc_construct_ptr < _Alref_alloc > _Constructor ( _Alref );
        _Constructor . _Allocate ( );
        _Construct_in_place ( * _Constructor . _Ptr, _Owner . _Ptr, :: std :: move ( _Dt ), _Ax );
        _Set_ptr_rep_and_enable_shared ( _Owner . _Ptr, _Unfancy ( _Constructor . _Ptr ) );
        _Constructor . _Ptr = nullptr;
        _Owner . _Call_deleter = false;
    }



































    template < class _Ty0, class ... _Types >
    friend shared_ptr < _Ty0 > make_shared ( _Types && ... _Args );

    template < class _Ty0, class _Alloc, class ... _Types >
    friend shared_ptr < _Ty0 > allocate_shared ( const _Alloc & _Al_arg, _Types && ... _Args );


    template < class _Ux >
    void _Set_ptr_rep_and_enable_shared ( _Ux * const _Px, _Ref_count_base * const _Rx ) noexcept {
        this -> _Ptr = _Px;
        this -> _Rep = _Rx;
        if constexpr ( conjunction_v < negation < is_array < _Ty >>, negation < is_volatile < _Ux >>, _Can_enable_shared < _Ux >> ) {
            if ( _Px && _Px -> _Wptr . expired ( ) ) {
                _Px -> _Wptr = shared_ptr < remove_cv_t < _Ux >> ( * this, const_cast < remove_cv_t < _Ux > * > ( _Px ) );
            }
        }
    }

    void _Set_ptr_rep_and_enable_shared ( nullptr_t, _Ref_count_base * const _Rx ) noexcept {
        this -> _Ptr = nullptr;
        this -> _Rep = _Rx;
    }
};
#line 1793 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator == ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) == _Right . get ( );
}
#line 1804 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator != ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) != _Right . get ( );
}
#line 1809
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator < ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) < _Right . get ( );
}
#line 1814
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator >= ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) >= _Right . get ( );
}
#line 1819
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator > ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) > _Right . get ( );
}
#line 1824
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] bool operator <= ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept {
    return _Left . get ( ) <= _Right . get ( );
}
#line 1830 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) == nullptr;
}
#line 1841 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return nullptr == _Right . get ( );
}
#line 1846
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) != nullptr;
}
#line 1851
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return nullptr != _Right . get ( );
}
#line 1856
template < class _Ty >
[ [ nodiscard ] ] bool operator < ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) < static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr );
}
#line 1861
template < class _Ty >
[ [ nodiscard ] ] bool operator < ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) < _Right . get ( );
}
#line 1866
template < class _Ty >
[ [ nodiscard ] ] bool operator >= ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) >= static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr );
}
#line 1871
template < class _Ty >
[ [ nodiscard ] ] bool operator >= ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) >= _Right . get ( );
}
#line 1876
template < class _Ty >
[ [ nodiscard ] ] bool operator > ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) > static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr );
}
#line 1881
template < class _Ty >
[ [ nodiscard ] ] bool operator > ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) > _Right . get ( );
}
#line 1886
template < class _Ty >
[ [ nodiscard ] ] bool operator <= ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept {
    return _Left . get ( ) <= static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr );
}
#line 1891
template < class _Ty >
[ [ nodiscard ] ] bool operator <= ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept {
    return static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) <= _Right . get ( );
}
#line 1897 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Out, const shared_ptr < _Ty > & _Px ) {

    return _Out << _Px . get ( );
}
#line 1903
template < class _Ty >
void swap ( shared_ptr < _Ty > & _Left, shared_ptr < _Ty > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 1908
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > static_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept {

    const auto _Ptr = static_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( _Other, _Ptr );
}
#line 1915
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > static_pointer_cast ( shared_ptr < _Ty2 > && _Other ) noexcept {

    const auto _Ptr = static_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( :: std :: move ( _Other ), _Ptr );
}
#line 1922
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > const_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept {

    const auto _Ptr = const_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( _Other, _Ptr );
}
#line 1929
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > const_pointer_cast ( shared_ptr < _Ty2 > && _Other ) noexcept {

    const auto _Ptr = const_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( :: std :: move ( _Other ), _Ptr );
}
#line 1936
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > reinterpret_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept {

    const auto _Ptr = reinterpret_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( _Other, _Ptr );
}
#line 1943
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > reinterpret_pointer_cast ( shared_ptr < _Ty2 > && _Other ) noexcept {

    const auto _Ptr = reinterpret_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
    return shared_ptr < _Ty1 > ( :: std :: move ( _Other ), _Ptr );
}
#line 1951
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > dynamic_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept {

    const auto _Ptr = dynamic_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );

    if ( _Ptr ) {
        return shared_ptr < _Ty1 > ( _Other, _Ptr );
    }

    return { };
}
#line 1963
template < class _Ty1, class _Ty2 >
[ [ nodiscard ] ] shared_ptr < _Ty1 > dynamic_pointer_cast ( shared_ptr < _Ty2 > && _Other ) noexcept {

    const auto _Ptr = dynamic_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );

    if ( _Ptr ) {
        return shared_ptr < _Ty1 > ( :: std :: move ( _Other ), _Ptr );
    }

    return { };
}
#line 1982 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Dx, class _Ty >
[ [ nodiscard ] ] _Dx * get_deleter ( const shared_ptr < _Ty > & _Sx ) noexcept {

    if ( _Sx . _Rep ) {
        return static_cast < _Dx * > ( _Sx . _Rep -> _Get_deleter ( typeid ( _Dx ) ) );
    }

    return nullptr;
}
#line 2002 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty >
class _Ref_count_obj2 : public _Ref_count_base {
public :
    template < class ... _Types >
    explicit _Ref_count_obj2 ( _Types && ... _Args ) : _Ref_count_base ( ) {






        {
            _Construct_in_place ( _Storage . _Value, :: std :: forward < _Types > ( _Args ) ... );
        }
    }

    virtual ~ _Ref_count_obj2 ( ) noexcept override {





    }

    union {
        _Wrap < _Ty > _Storage;
    };

private :
    virtual void _Destroy ( ) noexcept override {
        _Destroy_in_place ( _Storage . _Value );
    }

    virtual void _Delete_this ( ) noexcept override {
        delete this;
    }
};
#line 2383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty,
    bool = is_empty_v < _Ty > && ! is_final_v < _Ty > >
class _Ebco_base : private _Ty {
private :
    using _Mybase = _Ty;

protected :
    template < class _Other, enable_if_t < ! is_same_v < _Remove_cvref_t < _Other >, _Ebco_base >, int > = 0 >
    constexpr explicit _Ebco_base ( _Other && _Val ) noexcept ( is_nothrow_constructible_v < _Ty, _Other > )
        : _Ty ( :: std :: forward < _Other > ( _Val ) ) { }

    constexpr _Ty & _Get_val ( ) noexcept {
        return * this;
    }

    constexpr const _Ty & _Get_val ( ) const noexcept {
        return * this;
    }
};
#line 2403
template < class _Ty >
class _Ebco_base < _Ty, false > {
private :
    _Ty _Myval;

protected :
    template < class _Other, enable_if_t < ! is_same_v < _Remove_cvref_t < _Other >, _Ebco_base >, int > = 0 >
    constexpr explicit _Ebco_base ( _Other && _Val ) noexcept ( is_nothrow_constructible_v < _Ty, _Other > )
        : _Myval ( :: std :: forward < _Other > ( _Val ) ) { }

    constexpr _Ty & _Get_val ( ) noexcept {
        return _Myval;
    }

    constexpr const _Ty & _Get_val ( ) const noexcept {
        return _Myval;
    }
};
#line 2422
template < class _Ty, class _Alloc >
class _Ref_count_obj_alloc3 : public _Ebco_base < _Rebind_alloc_t < _Alloc, _Ty > >, public _Ref_count_base {

private :
    static_assert ( is_same_v < _Ty, remove_cv_t < _Ty >>, "allocate_shared should remove_cv_t" );

    using _Rebound = _Rebind_alloc_t < _Alloc, _Ty >;

public :
    template < class ... _Types >
    explicit _Ref_count_obj_alloc3 ( const _Alloc & _Al_arg, _Types && ... _Args )
        : _Ebco_base < _Rebound > ( _Al_arg ), _Ref_count_base ( ) {






        {
            allocator_traits < _Rebound > :: construct (
                this -> _Get_val ( ), :: std :: addressof ( _Storage . _Value ), :: std :: forward < _Types > ( _Args ) ... );
        }
    }

    union {
        _Wrap < _Ty > _Storage;
    };

private :
    virtual ~ _Ref_count_obj_alloc3 ( ) noexcept override {



    }

    virtual void _Destroy ( ) noexcept override {
        allocator_traits < _Rebound > :: destroy ( this -> _Get_val ( ), :: std :: addressof ( _Storage . _Value ) );
    }

    virtual void _Delete_this ( ) noexcept override {
        _Rebind_alloc_t < _Alloc, _Ref_count_obj_alloc3 > _Al ( this -> _Get_val ( ) );
        this -> ~ _Ref_count_obj_alloc3 ( );
        _Deallocate_plain ( _Al, this );
    }
};
#line 2718 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty, class ... _Types >
[ [ nodiscard ] ]



    shared_ptr < _Ty >

    make_shared ( _Types && ... _Args ) {
    const auto _Rx = new _Ref_count_obj2 < _Ty > ( :: std :: forward < _Types > ( _Args ) ... );
    shared_ptr < _Ty > _Ret;
    _Ret . _Set_ptr_rep_and_enable_shared ( :: std :: addressof ( _Rx -> _Storage . _Value ), _Rx );
    return _Ret;
}
#line 2811 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty, class _Alloc, class ... _Types >
[ [ nodiscard ] ]



    shared_ptr < _Ty >

    allocate_shared ( const _Alloc & _Al, _Types && ... _Args ) {


    using _Refoa = _Ref_count_obj_alloc3 < remove_cv_t < _Ty >, _Alloc >;
    using _Alblock = _Rebind_alloc_t < _Alloc, _Refoa >;
    _Alblock _Rebound ( _Al );
    _Alloc_construct_ptr < _Alblock > _Constructor { _Rebound };
    _Constructor . _Allocate ( );
    _Construct_in_place ( * _Constructor . _Ptr, _Al, :: std :: forward < _Types > ( _Args ) ... );
    shared_ptr < _Ty > _Ret;
    const auto _Ptr = reinterpret_cast < _Ty * > ( :: std :: addressof ( _Constructor . _Ptr -> _Storage . _Value ) );
    _Ret . _Set_ptr_rep_and_enable_shared ( _Ptr, _Unfancy ( _Constructor . _Release ( ) ) );
    return _Ret;
}
#line 2950 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty >
class weak_ptr : public _Ptr_base < _Ty > {
public :
    constexpr weak_ptr ( ) noexcept { }

    weak_ptr ( const weak_ptr & _Other ) noexcept {
        this -> _Weakly_construct_from ( _Other );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr ( const shared_ptr < _Ty2 > & _Other ) noexcept {
        this -> _Weakly_construct_from ( _Other );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr ( const weak_ptr < _Ty2 > & _Other ) noexcept {
        this -> _Weakly_convert_lvalue_avoiding_expired_conversions ( _Other );
    }

    weak_ptr ( weak_ptr && _Other ) noexcept {
        this -> _Move_construct_from ( :: std :: move ( _Other ) );
    }

    template < class _Ty2, enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
    weak_ptr ( weak_ptr < _Ty2 > && _Other ) noexcept {
        this -> _Weakly_convert_rvalue_avoiding_expired_conversions ( :: std :: move ( _Other ) );
    }

    ~ weak_ptr ( ) noexcept {
        this -> _Decwref ( );
    }

    weak_ptr & operator = ( const weak_ptr & _Right ) noexcept {
        weak_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    template < class _Ty2 >
    weak_ptr & operator = ( const weak_ptr < _Ty2 > & _Right ) noexcept {
        weak_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    weak_ptr & operator = ( weak_ptr && _Right ) noexcept {
        weak_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }

    template < class _Ty2 >
    weak_ptr & operator = ( weak_ptr < _Ty2 > && _Right ) noexcept {
        weak_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
        return * this;
    }

    template < class _Ty2 >
    weak_ptr & operator = ( const shared_ptr < _Ty2 > & _Right ) noexcept {
        weak_ptr ( _Right ) . swap ( * this );
        return * this;
    }

    void reset ( ) noexcept {
        weak_ptr { } . swap ( * this );
    }

    void swap ( weak_ptr & _Other ) noexcept {
        this -> _Swap ( _Other );
    }

    [ [ nodiscard ] ] bool expired ( ) const noexcept {
        return this -> use_count ( ) == 0;
    }

    [ [ nodiscard ] ] shared_ptr < _Ty > lock ( ) const noexcept {
        shared_ptr < _Ty > _Ret;
        ( void ) _Ret . _Construct_from_weak ( * this );
        return _Ret;
    }
};
#line 3034 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty >
void swap ( weak_ptr < _Ty > & _Left, weak_ptr < _Ty > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 3039
template < class _Ty >
class enable_shared_from_this {
public :
    using _Esft_type = enable_shared_from_this;

    [ [ nodiscard ] ] shared_ptr < _Ty > shared_from_this ( ) {
        return shared_ptr < _Ty > ( _Wptr );
    }

    [ [ nodiscard ] ] shared_ptr < const _Ty > shared_from_this ( ) const {
        return shared_ptr < const _Ty > ( _Wptr );
    }

    [ [ nodiscard ] ] weak_ptr < _Ty > weak_from_this ( ) noexcept {
        return _Wptr;
    }

    [ [ nodiscard ] ] weak_ptr < const _Ty > weak_from_this ( ) const noexcept {
        return _Wptr;
    }

protected :
    constexpr enable_shared_from_this ( ) noexcept : _Wptr ( ) { }

    enable_shared_from_this ( const enable_shared_from_this & ) noexcept : _Wptr ( ) {

    }

    enable_shared_from_this & operator = ( const enable_shared_from_this & ) noexcept {
        return * this;
    }

    ~ enable_shared_from_this ( ) = default;

private :
    template < class _Yty >
    friend class shared_ptr;

    mutable weak_ptr < _Ty > _Wptr;
};
#line 3081
template < class _Ty >
struct default_delete {
    constexpr default_delete ( ) noexcept = default;

    template < class _Ty2, enable_if_t < is_convertible_v < _Ty2 *, _Ty * >, int > = 0 >
    default_delete ( const default_delete < _Ty2 > & ) noexcept { }

    void operator ( ) ( _Ty * _Ptr ) const noexcept {
        static_assert ( 0 < sizeof ( _Ty ), "can\'t delete an incomplete type" );
        delete _Ptr;
    }
};
#line 3094
template< class _Ty> 
#pragma pack(8)
#line 3095
struct default_delete< _Ty []>  { 
#line 3096
constexpr default_delete() noexcept = default;
#line 3098
template < class _Uty, enable_if_t < is_convertible_v < _Uty ( * ) [ ], _Ty ( * ) [ ] >, int > = 0 >
    default_delete ( const default_delete < _Uty [ ] > & ) noexcept { }
#line 3101
template < class _Uty, enable_if_t < is_convertible_v < _Uty ( * ) [ ], _Ty ( * ) [ ] >, int > = 0 >
    void operator ( ) ( _Uty * _Ptr ) const noexcept {
        static_assert ( 0 < sizeof ( _Uty ), "can\'t delete an incomplete type" );
        delete [ ] _Ptr;
    }
#line 3106
}; 
#pragma pack(8)
template< class _Ty, class _Dx_noref, class  = void> 
#line 3109
struct _Get_deleter_pointer_type { 
#line 3110
using type = _Ty *; 
#line 3111
}; 
#line 3113
template< class _Ty, class _Dx_noref> 
#line 3114
struct _Get_deleter_pointer_type< _Ty, _Dx_noref, void_t< typename _Dx_noref::pointer> >  { 
#line 3115
using type = typename _Dx_noref::pointer; 
#line 3116
}; 
#line 3118
template< class _Dx2> using _Unique_ptr_enable_default_t = enable_if_t< conjunction_v< negation< is_pointer< _Dx2> > , is_default_constructible< _Dx2> > , int> ; 
#line 3122
template < class _Ty, class _Dx >
class unique_ptr {
public :
    using pointer = typename _Get_deleter_pointer_type < _Ty, remove_reference_t < _Dx >> :: type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    constexpr unique_ptr ( ) noexcept : _Mypair ( _Zero_then_variadic_args_t { } ) { }

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    constexpr unique_ptr ( nullptr_t ) noexcept : _Mypair ( _Zero_then_variadic_args_t { } ) { }

    unique_ptr & operator = ( nullptr_t ) noexcept {
        reset ( );
        return * this;
    }

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    explicit unique_ptr ( pointer _Ptr ) noexcept : _Mypair ( _Zero_then_variadic_args_t { }, _Ptr ) { }

    template < class _Dx2 = _Dx, enable_if_t < is_constructible_v < _Dx2, const _Dx2 & >, int > = 0 >
    unique_ptr ( pointer _Ptr, const _Dx & _Dt ) noexcept : _Mypair ( _One_then_variadic_args_t { }, _Dt, _Ptr ) { }

    template < class _Dx2 = _Dx,
        enable_if_t < conjunction_v < negation < is_reference < _Dx2 >>, is_constructible < _Dx2, _Dx2 >>, int > = 0 >
    unique_ptr ( pointer _Ptr, _Dx && _Dt ) noexcept : _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Dt ), _Ptr ) { }

    template < class _Dx2 = _Dx,
        enable_if_t < conjunction_v < is_reference < _Dx2 >, is_constructible < _Dx2, remove_reference_t < _Dx2 >> >, int > = 0 >
    unique_ptr ( pointer, remove_reference_t < _Dx > && ) = delete;

    template < class _Dx2 = _Dx, enable_if_t < is_move_constructible_v < _Dx2 >, int > = 0 >
    unique_ptr ( unique_ptr && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: forward < _Dx > ( _Right . get_deleter ( ) ), _Right . release ( ) ) { }

    template < class _Ty2, class _Dx2,
        enable_if_t <
            conjunction_v < negation < is_array < _Ty2 >>, is_convertible < typename unique_ptr < _Ty2, _Dx2 > :: pointer, pointer >,
                conditional_t < is_reference_v < _Dx >, is_same < _Dx2, _Dx >, is_convertible < _Dx2, _Dx >> >,
            int > = 0 >
    unique_ptr ( unique_ptr < _Ty2, _Dx2 > && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: forward < _Dx2 > ( _Right . get_deleter ( ) ), _Right . release ( ) ) { }


    template < class _Ty2,
        enable_if_t < conjunction_v < is_convertible < _Ty2 *, _Ty * >, is_same < _Dx, default_delete < _Ty >> >, int > = 0 >
    unique_ptr ( auto_ptr < _Ty2 > && _Right ) noexcept : _Mypair ( _Zero_then_variadic_args_t { }, _Right . release ( ) ) { }


    template < class _Ty2, class _Dx2,
        enable_if_t < conjunction_v < negation < is_array < _Ty2 >>, is_assignable < _Dx &, _Dx2 >,
                        is_convertible < typename unique_ptr < _Ty2, _Dx2 > :: pointer, pointer >>,
            int > = 0 >
    unique_ptr & operator = ( unique_ptr < _Ty2, _Dx2 > && _Right ) noexcept {
        reset ( _Right . release ( ) );
        _Mypair . _Get_first ( ) = :: std :: forward < _Dx2 > ( _Right . _Mypair . _Get_first ( ) );
        return * this;
    }

    template < class _Dx2 = _Dx, enable_if_t < is_move_assignable_v < _Dx2 >, int > = 0 >
    unique_ptr & operator = ( unique_ptr && _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            reset ( _Right . release ( ) );
            _Mypair . _Get_first ( ) = :: std :: forward < _Dx > ( _Right . _Mypair . _Get_first ( ) );
        }
        return * this;
    }

    void swap ( unique_ptr & _Right ) noexcept {
        _Swap_adl ( _Mypair . _Myval2, _Right . _Mypair . _Myval2 );
        _Swap_adl ( _Mypair . _Get_first ( ), _Right . _Mypair . _Get_first ( ) );
    }

    ~ unique_ptr ( ) noexcept {
        if ( _Mypair . _Myval2 ) {
            _Mypair . _Get_first ( ) ( _Mypair . _Myval2 );
        }
    }

    [ [ nodiscard ] ] _Dx & get_deleter ( ) noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] const _Dx & get_deleter ( ) const noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] add_lvalue_reference_t < _Ty > operator * ( ) const noexcept {
        return * _Mypair . _Myval2;
    }

    [ [ nodiscard ] ] pointer operator -> ( ) const noexcept {
        return _Mypair . _Myval2;
    }

    [ [ nodiscard ] ] pointer get ( ) const noexcept {
        return _Mypair . _Myval2;
    }

    explicit operator bool ( ) const noexcept {
        return static_cast < bool > ( _Mypair . _Myval2 );
    }

    pointer release ( ) noexcept {
        return :: std :: exchange ( _Mypair . _Myval2, nullptr );
    }

    void reset ( pointer _Ptr = nullptr ) noexcept {
        pointer _Old = :: std :: exchange ( _Mypair . _Myval2, _Ptr );
        if ( _Old ) {
            _Mypair . _Get_first ( ) ( _Old );
        }
    }

    unique_ptr ( const unique_ptr & ) = delete;
    unique_ptr & operator = ( const unique_ptr & ) = delete;

private :
    template < class, class >
    friend class unique_ptr;

    _Compressed_pair < _Dx, pointer > _Mypair;
};
#line 3247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty, class _Dx >
class unique_ptr < _Ty [ ], _Dx > {
public :
    using pointer = typename _Get_deleter_pointer_type < _Ty, remove_reference_t < _Dx >> :: type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    constexpr unique_ptr ( ) noexcept : _Mypair ( _Zero_then_variadic_args_t { } ) { }

    template < class _Uty, class _Is_nullptr = is_same < _Uty, nullptr_t >>
    using _Enable_ctor_reset =
        enable_if_t < is_same_v < _Uty, pointer >
                    || _Is_nullptr :: value
                    || ( is_same_v < pointer, element_type * >
                        && is_pointer_v < _Uty >
                        && is_convertible_v < remove_pointer_t < _Uty > ( * ) [ ], element_type ( * ) [ ] > ) >;

    template < class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0, class = _Enable_ctor_reset < _Uty >>
    explicit unique_ptr ( _Uty _Ptr ) noexcept : _Mypair ( _Zero_then_variadic_args_t { }, _Ptr ) { }

    template < class _Uty, class _Dx2 = _Dx, enable_if_t < is_constructible_v < _Dx2, const _Dx2 & >, int > = 0,
        class = _Enable_ctor_reset < _Uty >>
    unique_ptr ( _Uty _Ptr, const _Dx & _Dt ) noexcept : _Mypair ( _One_then_variadic_args_t { }, _Dt, _Ptr ) { }

    template < class _Uty, class _Dx2 = _Dx,
        enable_if_t < conjunction_v < negation < is_reference < _Dx2 >>, is_constructible < _Dx2, _Dx2 >>, int > = 0,
        class = _Enable_ctor_reset < _Uty >>
    unique_ptr ( _Uty _Ptr, _Dx && _Dt ) noexcept : _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Dt ), _Ptr ) { }

    template < class _Uty, class _Dx2 = _Dx,
        enable_if_t < conjunction_v < is_reference < _Dx2 >, is_constructible < _Dx2, remove_reference_t < _Dx2 >> >, int > = 0 >
    unique_ptr ( _Uty, remove_reference_t < _Dx > && ) = delete;

    template < class _Dx2 = _Dx, enable_if_t < is_move_constructible_v < _Dx2 >, int > = 0 >
    unique_ptr ( unique_ptr && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: forward < _Dx > ( _Right . get_deleter ( ) ), _Right . release ( ) ) { }

    template < class _Dx2 = _Dx, enable_if_t < is_move_assignable_v < _Dx2 >, int > = 0 >
    unique_ptr & operator = ( unique_ptr && _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            reset ( _Right . release ( ) );
            _Mypair . _Get_first ( ) = :: std :: move ( _Right . _Mypair . _Get_first ( ) );
        }

        return * this;
    }

    template < class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr < _Uty, _Ex > :: pointer,
        class _UP_element_type = typename unique_ptr < _Uty, _Ex > :: element_type >
    using _Enable_conversion = enable_if_t <
        conjunction_v < is_array < _Uty >, is_same < pointer, element_type * >, is_same < _UP_pointer, _UP_element_type * >,
            is_convertible < _UP_element_type ( * ) [ ], element_type ( * ) [ ] >, _More >>;

    template < class _Uty, class _Ex,
        class = _Enable_conversion < _Uty, _Ex,
            conditional_t < is_reference_v < _Dx >, is_same < _Ex, _Dx >, is_convertible < _Ex, _Dx >> >>
    unique_ptr ( unique_ptr < _Uty, _Ex > && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: forward < _Ex > ( _Right . get_deleter ( ) ), _Right . release ( ) ) { }

    template < class _Uty, class _Ex, class = _Enable_conversion < _Uty, _Ex, is_assignable < _Dx &, _Ex >> >
    unique_ptr & operator = ( unique_ptr < _Uty, _Ex > && _Right ) noexcept {
        reset ( _Right . release ( ) );
        _Mypair . _Get_first ( ) = :: std :: forward < _Ex > ( _Right . _Mypair . _Get_first ( ) );
        return * this;
    }

    template < class _Dx2 = _Dx, _Unique_ptr_enable_default_t < _Dx2 > = 0 >
    constexpr unique_ptr ( nullptr_t ) noexcept : _Mypair ( _Zero_then_variadic_args_t { } ) { }

    unique_ptr & operator = ( nullptr_t ) noexcept {
        reset ( );
        return * this;
    }

    void reset ( nullptr_t = nullptr ) noexcept {
        reset ( pointer ( ) );
    }

    void swap ( unique_ptr & _Right ) noexcept {
        _Swap_adl ( _Mypair . _Myval2, _Right . _Mypair . _Myval2 );
        _Swap_adl ( _Mypair . _Get_first ( ), _Right . _Mypair . _Get_first ( ) );
    }

    ~ unique_ptr ( ) noexcept {
        if ( _Mypair . _Myval2 ) {
            _Mypair . _Get_first ( ) ( _Mypair . _Myval2 );
        }
    }

    [ [ nodiscard ] ] _Dx & get_deleter ( ) noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] const _Dx & get_deleter ( ) const noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] _Ty & operator [ ] ( size_t _Idx ) const noexcept {
        return _Mypair . _Myval2 [ _Idx ];
    }

    [ [ nodiscard ] ] pointer get ( ) const noexcept {
        return _Mypair . _Myval2;
    }

    explicit operator bool ( ) const noexcept {
        return static_cast < bool > ( _Mypair . _Myval2 );
    }

    pointer release ( ) noexcept {
        return :: std :: exchange ( _Mypair . _Myval2, nullptr );
    }

    template < class _Uty, class = _Enable_ctor_reset < _Uty, false_type >>
    void reset ( _Uty _Ptr ) noexcept {
        pointer _Old = :: std :: exchange ( _Mypair . _Myval2, _Ptr );
        if ( _Old ) {
            _Mypair . _Get_first ( ) ( _Old );
        }
    }

    unique_ptr ( const unique_ptr & ) = delete;
    unique_ptr & operator = ( const unique_ptr & ) = delete;

private :
    template < class, class >
    friend class unique_ptr;

    _Compressed_pair < _Dx, pointer > _Mypair;
};
#line 3380
template < class _Ty, class ... _Types, enable_if_t < ! is_array_v < _Ty >, int > = 0 >
[ [ nodiscard ] ] unique_ptr < _Ty > make_unique ( _Types && ... _Args ) {
    return unique_ptr < _Ty > ( new _Ty ( :: std :: forward < _Types > ( _Args ) ... ) );
}
#line 3385
template < class _Ty, enable_if_t < is_array_v < _Ty > && extent_v < _Ty > == 0, int > = 0 >
[ [ nodiscard ] ] unique_ptr < _Ty > make_unique ( const size_t _Size ) {
    using _Elem = remove_extent_t < _Ty >;
    return unique_ptr < _Ty > ( new _Elem [ _Size ] ( ) );
}
#line 3391
template < class _Ty, class ... _Types, enable_if_t < extent_v < _Ty > != 0, int > = 0 >
void make_unique ( _Types && ... ) = delete;
#line 3411 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty, class _Dx, enable_if_t < _Is_swappable < _Dx > :: value, int > = 0 >
void swap ( unique_ptr < _Ty, _Dx > & _Left, unique_ptr < _Ty, _Dx > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 3416
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator == ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return _Left . get ( ) == _Right . get ( );
}
#line 3422
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator != ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3428 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator < ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    using _Ptr1 = typename unique_ptr < _Ty1, _Dx1 > :: pointer;
    using _Ptr2 = typename unique_ptr < _Ty2, _Dx2 > :: pointer;
    using _Common = common_type_t < _Ptr1, _Ptr2 >;
    return less < _Common > { } ( _Left . get ( ), _Right . get ( ) );
}
#line 3436
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator >= ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return ! ( _Left < _Right );
}
#line 3441
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator > ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return _Right < _Left;
}
#line 3446
template < class _Ty1, class _Dx1, class _Ty2, class _Dx2 >
[ [ nodiscard ] ] bool operator <= ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right ) {
    return ! ( _Right < _Left );
}
#line 3464
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator == ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t ) noexcept {
    return ! _Left;
}
#line 3470
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator == ( nullptr_t, const unique_ptr < _Ty, _Dx > & _Right ) noexcept {
    return ! _Right;
}
#line 3475
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator != ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right ) noexcept {
    return ! ( _Left == _Right );
}
#line 3480
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator != ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right ) noexcept {
    return ! ( _Left == _Right );
}
#line 3486 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator < ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right ) {
    using _Ptr = typename unique_ptr < _Ty, _Dx > :: pointer;
    return less < _Ptr > { } ( _Left . get ( ), _Right );
}
#line 3492
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator < ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right ) {
    using _Ptr = typename unique_ptr < _Ty, _Dx > :: pointer;
    return less < _Ptr > { } ( _Left, _Right . get ( ) );
}
#line 3498
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator >= ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right ) {
    return ! ( _Left < _Right );
}
#line 3503
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator >= ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right ) {
    return ! ( _Left < _Right );
}
#line 3508
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator > ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right ) {
    return _Right < _Left;
}
#line 3513
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator > ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right ) {
    return _Right < _Left;
}
#line 3518
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator <= ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right ) {
    return ! ( _Right < _Left );
}
#line 3523
template < class _Ty, class _Dx >
[ [ nodiscard ] ] bool operator <= ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right ) {
    return ! ( _Right < _Left );
}
#line 3539
template< class _OutTy, class _PxTy, class  = void> 
#line 3540
struct _Can_stream_unique_ptr : public false_type { }; 
#line 3541
template< class _OutTy, class _PxTy> 
#line 3542
struct _Can_stream_unique_ptr< _OutTy, _PxTy, void_t< decltype(std::declval< _OutTy> () << std::declval< _PxTy> ().get())> >  : public true_type { 
#line 3543
}; 
#line 3545
template < class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t < _Can_stream_unique_ptr < basic_ostream < _Elem, _Traits > &, const unique_ptr < _Yty, _Dx > & > :: value, int > = 0 >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Out, const unique_ptr < _Yty, _Dx > & _Px ) {

    _Out << _Px . get ( );
    return _Out;
}
#line 3553
enum class pointer_safety { relaxed, preferred, strict}; 
#line 3555
inline void declare_reachable(void *) { } 
#line 3557
template < class _Ty >
_Ty * undeclare_reachable ( _Ty * _Ptr ) {
    return _Ptr;
}
#line 3562
inline void declare_no_pointers(char *, size_t) { } 
#line 3564
inline void undeclare_no_pointers(char *, size_t) { } 
#line 3566
inline pointer_safety get_pointer_safety() noexcept { 
#line 3567
return pointer_safety::relaxed; 
#line 3568
} 
#line 3570
template< class _Ty = void> struct owner_less; 
#line 3573
template < class _Ty >
struct owner_less < shared_ptr < _Ty > > {
     typedef shared_ptr < _Ty > first_argument_type;
     typedef shared_ptr < _Ty > second_argument_type;
     typedef bool result_type;

    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }

    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }

    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
};
#line 3592
template < class _Ty >
struct owner_less < weak_ptr < _Ty > > {
     typedef weak_ptr < _Ty > first_argument_type;
     typedef weak_ptr < _Ty > second_argument_type;
     typedef bool result_type;

    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }

    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }

    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
};
#line 3612
template<> struct owner_less< void>  { 
#line 3613
template < class _Ty, class _Uty >
    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const shared_ptr < _Uty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
#line 3618
template < class _Ty, class _Uty >
    [ [ nodiscard ] ] bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Uty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
#line 3623
template < class _Ty, class _Uty >
    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Uty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
#line 3628
template < class _Ty, class _Uty >
    [ [ nodiscard ] ] bool operator ( ) ( const weak_ptr < _Ty > & _Left, const weak_ptr < _Uty > & _Right ) const noexcept {
        return _Left . owner_before ( _Right );
    }
#line 3633
using is_transparent = int; 
#line 3634
}; 
#line 3636
template < class _Ty, class _Dx >
struct hash < unique_ptr < _Ty, _Dx > > : _Conditionally_enabled_hash < unique_ptr < _Ty, _Dx >,
                                        is_default_constructible_v < hash < typename unique_ptr < _Ty, _Dx > :: pointer > > > {
    static size_t _Do_hash ( const unique_ptr < _Ty, _Dx > & _Keyval ) noexcept (
        _Is_nothrow_hashable < typename unique_ptr < _Ty, _Dx > :: pointer > :: value ) {
        return hash < typename unique_ptr < _Ty, _Dx > :: pointer > { } ( _Keyval . get ( ) );
    }
};
#line 3645
template < class _Ty >
struct hash < shared_ptr < _Ty > > {
     typedef shared_ptr < _Ty > argument_type;
     typedef size_t result_type;

    [ [ nodiscard ] ] size_t operator ( ) ( const shared_ptr < _Ty > & _Keyval ) const noexcept {
        return hash < typename shared_ptr < _Ty > :: element_type * > ( ) ( _Keyval . get ( ) );
    }
};
#line 3655
inline void *align(size_t _Bound, size_t _Size, void *&_Ptr, size_t &_Space) noexcept { 
#line 3657
size_t _Off = static_cast< size_t>((reinterpret_cast< uintptr_t>(_Ptr)) & (_Bound - (1))); 
#line 3658
if (_Off != (0)) { 
#line 3659
_Off = (_Bound - _Off); 
#line 3660
}  
#line 3662
if ((_Space < _Off) || ((_Space - _Off) < _Size)) { 
#line 3663
return nullptr; 
#line 3664
}  
#line 3667
_Ptr = ((static_cast< char *>(_Ptr)) + _Off); 
#line 3668
_Space -= _Off; 
#line 3669
return _Ptr; 
#line 3670
} 
#line 3684 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
extern "C" {
#line 3685
void __cdecl _Lock_shared_ptr_spin_lock(); 
#line 3686
void __cdecl _Unlock_shared_ptr_spin_lock(); 
#line 3687
}
#line 3689
struct _Shared_ptr_spin_lock { 
#line 3690
_Shared_ptr_spin_lock() { 
#line 3691
_Lock_shared_ptr_spin_lock(); 
#line 3692
} 
#line 3694
~_Shared_ptr_spin_lock() noexcept { 
#line 3695
_Unlock_shared_ptr_spin_lock(); 
#line 3696
} 
#line 3697
}; 
#line 3699
template < class _Ty >
 [ [ nodiscard ] ] bool atomic_is_lock_free ( const shared_ptr < _Ty > * ) {

    return false;
}
#line 3705
template < class _Ty >
 [ [ nodiscard ] ] shared_ptr < _Ty > atomic_load_explicit (
    const shared_ptr < _Ty > * _Ptr, memory_order ) {

    _Shared_ptr_spin_lock _Lock;
    shared_ptr < _Ty > _Result = * _Ptr;
    return _Result;
}
#line 3714
template < class _Ty >
 [ [ nodiscard ] ] shared_ptr < _Ty > atomic_load (
    const shared_ptr < _Ty > * _Ptr ) {
    return :: std :: atomic_load_explicit ( _Ptr, memory_order_seq_cst );
}
#line 3720
template < class _Ty >
 void atomic_store_explicit (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other, memory_order ) {

    _Shared_ptr_spin_lock _Lock;
    _Ptr -> swap ( _Other );
}
#line 3728
template < class _Ty >
 void atomic_store (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other ) {
    :: std :: atomic_store_explicit ( _Ptr, :: std :: move ( _Other ), memory_order_seq_cst );
}
#line 3734
template < class _Ty >
 shared_ptr < _Ty > atomic_exchange_explicit (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other, memory_order ) {

    _Shared_ptr_spin_lock _Lock;
    _Ptr -> swap ( _Other );
    return _Other;
}
#line 3743
template < class _Ty >
 shared_ptr < _Ty > atomic_exchange (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other ) {

    return :: std :: atomic_exchange_explicit ( _Ptr, :: std :: move ( _Other ), memory_order_seq_cst );
}
#line 3750
template < class _Ty >
 bool atomic_compare_exchange_weak_explicit ( shared_ptr < _Ty > * _Ptr,
    shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value, memory_order, memory_order ) {
    shared_ptr < _Ty > _Old_exp;
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr -> get ( ) == _Exp -> get ( ) && ! _Ptr -> owner_before ( * _Exp ) && ! _Exp -> owner_before ( * _Ptr );
    if ( _Success ) {
        _Ptr -> swap ( _Value );
    } else {
        _Exp -> swap ( _Old_exp );
        * _Exp = * _Ptr;
    }
    return _Success;
}
#line 3765
template < class _Ty >
 bool atomic_compare_exchange_weak (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value ) {

    return :: std :: atomic_compare_exchange_weak_explicit (
        _Ptr, _Exp, :: std :: move ( _Value ), memory_order_seq_cst, memory_order_seq_cst );
}
#line 3773
template < class _Ty >
 bool atomic_compare_exchange_strong_explicit ( shared_ptr < _Ty > * _Ptr,
    shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value, memory_order, memory_order ) {
    return :: std :: atomic_compare_exchange_weak_explicit (
        _Ptr, _Exp, :: std :: move ( _Value ), memory_order_seq_cst, memory_order_seq_cst );
}
#line 3780
template < class _Ty >
 bool atomic_compare_exchange_strong (
    shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value ) {

    return :: std :: atomic_compare_exchange_strong_explicit (
        _Ptr, _Exp, :: std :: move ( _Value ), memory_order_seq_cst, memory_order_seq_cst );
}
#line 4057 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 4058
using std::allocate_shared;
#line 4059
using std::bad_weak_ptr;
#line 4060
using std::const_pointer_cast;
#line 4061
using std::dynamic_pointer_cast;
#line 4062
using std::enable_shared_from_this;
#line 4063
using std::get_deleter;
#line 4064
using std::make_shared;
#line 4065
using std::shared_ptr;
#line 4066
using std::static_pointer_cast;
#line 4067
using std::swap;
#line 4068
using std::weak_ptr;
#line 4069
}
#line 4072 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
}
#line 4075
#pragma warning(pop)
#pragma pack ( pop )
#line 4079 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 24
namespace std { 
#line 25
class _Facet_base { 
#line 27
public: virtual ~_Facet_base() noexcept { } 
#line 30
virtual void _Incref() noexcept = 0; 
#line 33
virtual _Facet_base *_Decref() noexcept = 0; 
#line 34
}; 
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base *); 
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"
}
#line 45
#pragma warning(pop)
#pragma pack ( pop )
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cctype"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 29
int __cdecl _isctype(int _C, int _Type); 
#line 30
int __cdecl _isctype_l(int _C, int _Type, _locale_t _Locale); 
#line 31
int __cdecl isalpha(int _C); 
#line 32
int __cdecl _isalpha_l(int _C, _locale_t _Locale); 
#line 33
int __cdecl isupper(int _C); 
#line 34
int __cdecl _isupper_l(int _C, _locale_t _Locale); 
#line 35
int __cdecl islower(int _C); 
#line 36
int __cdecl _islower_l(int _C, _locale_t _Locale); 
#line 39
int __cdecl isdigit(int _C); 
#line 41
int __cdecl _isdigit_l(int _C, _locale_t _Locale); 
#line 42
int __cdecl isxdigit(int _C); 
#line 43
int __cdecl _isxdigit_l(int _C, _locale_t _Locale); 
#line 46
int __cdecl isspace(int _C); 
#line 48
int __cdecl _isspace_l(int _C, _locale_t _Locale); 
#line 49
int __cdecl ispunct(int _C); 
#line 50
int __cdecl _ispunct_l(int _C, _locale_t _Locale); 
#line 51
int __cdecl isblank(int _C); 
#line 52
int __cdecl _isblank_l(int _C, _locale_t _Locale); 
#line 53
int __cdecl isalnum(int _C); 
#line 54
int __cdecl _isalnum_l(int _C, _locale_t _Locale); 
#line 55
int __cdecl isprint(int _C); 
#line 56
int __cdecl _isprint_l(int _C, _locale_t _Locale); 
#line 57
int __cdecl isgraph(int _C); 
#line 58
int __cdecl _isgraph_l(int _C, _locale_t _Locale); 
#line 59
int __cdecl iscntrl(int _C); 
#line 60
int __cdecl _iscntrl_l(int _C, _locale_t _Locale); 
#line 63
int __cdecl toupper(int _C); 
#line 66
int __cdecl tolower(int _C); 
#line 68
int __cdecl _tolower(int _C); 
#line 69
int __cdecl _tolower_l(int _C, _locale_t _Locale); 
#line 70
int __cdecl _toupper(int _C); 
#line 71
int __cdecl _toupper_l(int _C, _locale_t _Locale); 
#line 73
int __cdecl __isascii(int _C); 
#line 74
int __cdecl __toascii(int _C); 
#line 75
int __cdecl __iscsymf(int _C); 
#line 76
int __cdecl __iscsym(int _C); 
#line 85
__inline int __cdecl __acrt_locale_get_ctype_array_value(const unsigned short *const 
#line 86
_Locale_pctype_array, const int 
#line 87
_Char_value, const int 
#line 88
_Mask) 
#line 90
{ 
#line 95
if ((_Char_value >= (-1)) && (_Char_value <= 255)) 
#line 96
{ 
#line 97
return (_Locale_pctype_array[_Char_value]) & _Mask; 
#line 98
}  
#line 100
return 0; 
#line 101
} 
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
__forceinline int __cdecl __ascii_tolower(const int _C) 
#line 152
{ 
#line 153
if ((_C >= ('A')) && (_C <= ('Z'))) 
#line 154
{ 
#line 155
return _C - (('A') - ('a')); 
#line 156
}  
#line 157
return _C; 
#line 158
} 
#line 160
__forceinline int __cdecl __ascii_toupper(const int _C) 
#line 161
{ 
#line 162
if ((_C >= ('a')) && (_C <= ('z'))) 
#line 163
{ 
#line 164
return _C - (('a') - ('A')); 
#line 165
}  
#line 166
return _C; 
#line 167
} 
#line 169
__forceinline int __cdecl __ascii_iswalpha(const int _C) 
#line 170
{ 
#line 171
return ((_C >= ('A')) && (_C <= ('Z'))) || ((_C >= ('a')) && (_C <= ('z'))); 
#line 172
} 
#line 174
__forceinline int __cdecl __ascii_iswdigit(const int _C) 
#line 175
{ 
#line 176
return (_C >= ('0')) && (_C <= ('9')); 
#line 177
} 
#line 179
__forceinline int __cdecl __ascii_towlower(const int _C) 
#line 180
{ 
#line 181
return __ascii_tolower(_C); 
#line 182
} 
#line 184
__forceinline int __cdecl __ascii_towupper(const int _C) 
#line 185
{ 
#line 186
return __ascii_toupper(_C); 
#line 187
} 
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
__inline __crt_locale_data_public *__cdecl __acrt_get_locale_data_prefix(const volatile void *const _LocalePointers) 
#line 208
{ 
#line 209
const _locale_t _TypedLocalePointers = (_locale_t)_LocalePointers; 
#line 210
return (__crt_locale_data_public *)(_TypedLocalePointers->locinfo); 
#line 211
} 
#line 217
__inline int __cdecl _chvalidchk_l(const int 
#line 218
_C, const int 
#line 219
_Mask, const _locale_t 
#line 220
_Locale) 
#line 222
{ 
#line 226
if (_Locale) 
#line 227
{ 
#line 228
return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask); 
#line 229
}  
#line 231
return __acrt_locale_get_ctype_array_value(__pctype_func(), _C, _Mask); 
#line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
} 
#line 238
__inline int __cdecl _ischartype_l(const int 
#line 239
_C, const int 
#line 240
_Mask, const _locale_t 
#line 241
_Locale) 
#line 243
{ 
#line 244
if (_Locale) { 
#line 245
if ((_C >= (-1)) && (_C <= 255)) 
#line 246
{ 
#line 247
return ((__acrt_get_locale_data_prefix(_Locale)->_locale_pctype)[_C]) & _Mask; 
#line 248
}  
#line 250
if ((__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max) > 1) 
#line 251
{ 
#line 252
return _isctype_l(_C, _Mask, _Locale); 
#line 253
}  
#line 255
return 0; 
#line 256
}  
#line 258
return _chvalidchk_l(_C, _Mask, 0); 
#line 259
} 
#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
}__pragma( pack ( pop )) 
#line 307
#pragma warning(pop)
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cctype"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 37
namespace std { 
#line 38
using ::isalnum;
#line 39
using ::isalpha;
#line 40
using ::iscntrl;
#line 41
using ::isdigit;
#line 42
using ::isgraph;
#line 43
using ::islower;
#line 44
using ::isprint;
#line 45
using ::ispunct;
#line 46
using ::isspace;
#line 47
using ::isupper;
#line 48
using ::isxdigit;
#line 49
using ::tolower;
#line 50
using ::toupper;
#line 52
using ::isblank;
#line 53
}
#line 57
#pragma warning(pop)
#pragma pack ( pop )
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cctype"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\clocale"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 34
struct lconv { 
#line 36
char *decimal_point; 
#line 37
char *thousands_sep; 
#line 38
char *grouping; 
#line 39
char *int_curr_symbol; 
#line 40
char *currency_symbol; 
#line 41
char *mon_decimal_point; 
#line 42
char *mon_thousands_sep; 
#line 43
char *mon_grouping; 
#line 44
char *positive_sign; 
#line 45
char *negative_sign; 
#line 46
char int_frac_digits; 
#line 47
char frac_digits; 
#line 48
char p_cs_precedes; 
#line 49
char p_sep_by_space; 
#line 50
char n_cs_precedes; 
#line 51
char n_sep_by_space; 
#line 52
char p_sign_posn; 
#line 53
char n_sign_posn; 
#line 54
__wchar_t *_W_decimal_point; 
#line 55
__wchar_t *_W_thousands_sep; 
#line 56
__wchar_t *_W_int_curr_symbol; 
#line 57
__wchar_t *_W_currency_symbol; 
#line 58
__wchar_t *_W_mon_decimal_point; 
#line 59
__wchar_t *_W_mon_thousands_sep; 
#line 60
__wchar_t *_W_positive_sign; 
#line 61
__wchar_t *_W_negative_sign; 
#line 62
}; 
#line 64
struct tm; 
#line 88
void __cdecl _lock_locales(); 
#line 89
void __cdecl _unlock_locales(); 
#line 92
int __cdecl _configthreadlocale(int _Flag); 
#line 97
char *__cdecl setlocale(int _Category, const char * _Locale); 
#line 103
lconv *__cdecl localeconv(); 
#line 106
_locale_t __cdecl _get_current_locale(); 
#line 109
_locale_t __cdecl _create_locale(int _Category, const char * _Locale); 
#line 114
void __cdecl _free_locale(_locale_t _Locale); 
#line 120
__wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); 
#line 126
_locale_t __cdecl _wcreate_locale(int _Category, const __wchar_t * _Locale); 
#line 133
__wchar_t **__cdecl ___lc_locale_name_func(); 
#line 134
unsigned __cdecl ___lc_codepage_func(); 
#line 135
unsigned __cdecl ___lc_collate_cp_func(); 
#line 143
char *__cdecl _Getdays(); 
#line 147
char *__cdecl _Getmonths(); 
#line 149
void *__cdecl _Gettnames(); 
#line 153
__wchar_t *__cdecl _W_Getdays(); 
#line 157
__wchar_t *__cdecl _W_Getmonths(); 
#line 159
void *__cdecl _W_Gettnames(); 
#line 162
size_t __cdecl _Strftime(char * _Buffer, size_t _Max_size, const char * _Format, const tm * _Timeptr, void * _Lc_time_arg); 
#line 170
size_t __cdecl _Wcsftime(__wchar_t * _Buffer, size_t _Max_size, const __wchar_t * _Format, const tm * _Timeptr, void * _Lc_time_arg); 
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"
}__pragma( pack ( pop )) 
#line 183
#pragma warning(pop)
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\clocale"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#line 22
using ::lconv;
#line 23
using ::localeconv;
#line 24
using ::setlocale;
#line 25
}
#line 29
#pragma warning(pop)
#pragma pack ( pop )
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\clocale"
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 24
extern "C" {
#line 46
struct _Collvec { 
#line 47
unsigned _Page; 
#line 48
__wchar_t *_LocaleName; 
#line 49
}; 
#line 51
struct _Ctypevec { 
#line 52
unsigned _Page; 
#line 53
const short *_Table; 
#line 54
int _Delfl; 
#line 55
__wchar_t *_LocaleName; 
#line 56
}; 
#line 58
struct _Cvtvec { 
#line 59
unsigned _Page; 
#line 60
unsigned _Mbcurmax; 
#line 61
int _Isclocale; 
#line 62
unsigned char _Isleadbyte[32]; 
#line 63
}; 
#line 66
_Collvec __cdecl _Getcoll(); 
#line 67
_Ctypevec __cdecl _Getctype(); 
#line 68
_Cvtvec __cdecl _Getcvt(); 
#line 69
int __cdecl _Getdateorder(); 
#line 77
int __cdecl _Mbrtowc(__wchar_t *, const char *, size_t _Max_multibyte, mbstate_t *, const _Cvtvec *); 
#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
float __cdecl _Stof(const char *, char **, long); 
#line 82
double __cdecl _Stod(const char *, char **, long); 
#line 83
long double __cdecl _Stold(const char *, char **, long); 
#line 85
int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *); 
#line 86
size_t __cdecl _Strxfrm(char * _String1, char * _End1, const char *, const char *, const _Collvec *); 
#line 89
int __cdecl _Tolower(int, const _Ctypevec *); 
#line 90
int __cdecl _Toupper(int, const _Ctypevec *); 
#line 92
int __cdecl _Wcrtomb(char *, __wchar_t, mbstate_t *, const _Cvtvec *); 
#line 93
int __cdecl _Wcscoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); 
#line 95
size_t __cdecl _Wcsxfrm(__wchar_t * _String1, __wchar_t * _End1, const __wchar_t *, const __wchar_t *, const _Collvec *); 
#line 99
short __cdecl _Getwctype(__wchar_t, const _Ctypevec *); 
#line 100
const __wchar_t *__cdecl _Getwctypes(const __wchar_t *, const __wchar_t *, short *, const _Ctypevec *); 
#line 102
__wchar_t __cdecl _Towlower(__wchar_t, const _Ctypevec *); 
#line 103
__wchar_t __cdecl _Towupper(__wchar_t, const _Ctypevec *); 
#line 105
}
#line 107
extern "C" {
#line 108
char *__cdecl _Getdays(); 
#line 110
char *__cdecl _Getmonths(); 
#line 112
void *__cdecl _Gettnames(); 
#line 114
size_t __cdecl _Strftime(char *, size_t _Maxsize, const char *, const tm *, void *); 
#line 117
__wchar_t *__cdecl _W_Getdays(); 
#line 119
__wchar_t *__cdecl _W_Getmonths(); 
#line 121
void *__cdecl _W_Gettnames(); 
#line 123
size_t __cdecl _Wcsftime(__wchar_t *, size_t _Maxsize, const __wchar_t *, const tm *, void *); 
#line 125
}
#line 132
_locale_t __cdecl _GetLocaleForCP(unsigned); 
#line 137 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 23
namespace std { 
#line 24
class _Timevec { 
#line 26
public: explicit _Timevec(void *_Ptr = 0) : _Timeptr(_Ptr) { } 
#line 28
_Timevec(const _Timevec &_Right) : _Timeptr((nullptr)) { 
#line 29
((*this) = _Right); 
#line 30
} 
#line 32
~_Timevec() noexcept { 
#line 33
::free(_Timeptr); 
#line 34
} 
#line 36
_Timevec &operator=(const _Timevec &_Right) { 
#line 37
if (this != (&_Right)) { 
#line 38
::free(_Timeptr); 
#line 39
(_Timeptr) = (_Right._Timeptr); 
#line 40
((const_cast< _Timevec &>(_Right))._Timeptr) = (nullptr); 
#line 41
}  
#line 43
return *this; 
#line 44
} 
#line 46
void *_Getptr() const { 
#line 47
return _Timeptr; 
#line 48
} 
#line 51
private: void *_Timeptr; 
#line 52
}; 
#line 54
template < class _Elem >
class _Yarn {
public :
     _Yarn ( ) noexcept : _Myptr ( nullptr ), _Nul ( 0 ) { }

     _Yarn ( const _Yarn & _Right ) noexcept : _Myptr ( nullptr ), _Nul ( 0 ) {
        * this = _Right;
    }

     _Yarn ( const _Elem * _Right ) noexcept : _Myptr ( nullptr ), _Nul ( 0 ) {
        * this = _Right;
    }

    _Yarn & operator = ( const _Yarn & _Right ) noexcept {
        return * this = _Right . _Myptr;
    }

    _Yarn & operator = ( const _Elem * _Right ) noexcept {
        if ( _Myptr != _Right ) {
            _Tidy ( );

            if ( _Right ) {
                const _Elem * _Ptr = _Right;
                while ( * _Ptr != _Elem { } ) {
                    ++ _Ptr;
                }

                const auto _Count = ( ++ _Ptr - _Right ) * sizeof ( _Elem );




                _Myptr = static_cast < _Elem * > ( :: malloc ( _Count ) );


                if ( _Myptr ) {
                    :: memcpy ( _Myptr, _Right, _Count );
                }
            }
        }

        return * this;
    }

     ~ _Yarn ( ) noexcept {
        _Tidy ( );
    }

    [ [ nodiscard ] ] bool empty ( ) const noexcept {
        return _Myptr == nullptr;
    }

      const _Elem * c_str ( ) const noexcept {
        return _Myptr ? _Myptr : & _Nul;
    }

    [ [ nodiscard ] ] bool _Empty ( ) const noexcept {
        return _Myptr == nullptr;
    }

      const _Elem * _C_str ( ) const noexcept {
        return _Myptr ? _Myptr : & _Nul;
    }

private :
    void _Tidy ( ) noexcept {
        if ( _Myptr ) {



            :: free ( _Myptr );

        }

        _Myptr = nullptr;
    }

    _Elem * _Myptr;
    _Elem _Nul;
};
#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
class _Locinfo { 
#line 137
public: using _Collvec = ::_Collvec; 
#line 138
using _Ctypevec = ::_Ctypevec; 
#line 139
using _Cvtvec = ::_Cvtvec; 
#line 140
using _Timevec = std::_Timevec; 
#line 142
static void __cdecl _Locinfo_ctor(_Locinfo *, const char *); 
#line 143
static void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *); 
#line 144
static void __cdecl _Locinfo_dtor(_Locinfo *); 
#line 145
static _Locinfo &__cdecl _Locinfo_Addcats(_Locinfo *, int, const char *); 
#line 147
_Locinfo(const char *_Pch = "C") : _Lock(0) 
#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
{ 
#line 153
if (_Pch) { 
#line 154
_Locinfo_ctor(this, _Pch); 
#line 155
return; 
#line 156
}  
#line 158
_Xruntime_error("bad locale name"); 
#line 159
} 
#line 161
_Locinfo(int _Cat, const char *_Pch) : _Lock(0) 
#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
{ 
#line 167
if (_Pch) { 
#line 168
_Locinfo_ctor(this, _Cat, _Pch); 
#line 169
return; 
#line 170
}  
#line 172
_Xruntime_error("bad locale name"); 
#line 173
} 
#line 175
~_Locinfo() noexcept { 
#line 176
_Locinfo_dtor(this); 
#line 177
} 
#line 179
_Locinfo &_Addcats(int _Cat, const char *_Pch) { 
#line 180
if (_Pch) { 
#line 181
return _Locinfo_Addcats(this, _Cat, _Pch); 
#line 182
}  
#line 184
_Xruntime_error("bad locale name"); 
#line 185
} 
#line 187
const char *_Getname() const { 
#line 188
return (_Newlocname)._C_str(); 
#line 189
} 
#line 191
_Collvec _Getcoll() const { 
#line 192
return ::_Getcoll(); 
#line 193
} 
#line 195
_Ctypevec _Getctype() const { 
#line 196
return ::_Getctype(); 
#line 197
} 
#line 199
_Cvtvec _Getcvt() const { 
#line 200
return ::_Getcvt(); 
#line 201
} 
#line 203
const lconv *_Getlconv() const { 
#line 204
return localeconv(); 
#line 205
} 
#line 207
_Timevec _Gettnames() const { 
#line 208
return ((std::_Timevec)(::_Gettnames())); 
#line 209
} 
#line 211
const char *_Getdays() const { 
#line 212
const char *_Ptr = ::_Getdays(); 
#line 213
if (_Ptr) { 
#line 214
(((const_cast< _Locinfo *>(this))->_Days) = _Ptr); 
#line 215
::free(const_cast< char *>(_Ptr)); 
#line 216
}  
#line 218
return (!(_Days)._Empty()) ? (_Days)._C_str() : (":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday"); 
#line 221
} 
#line 223
const char *_Getmonths() const { 
#line 224
const char *_Ptr = ::_Getmonths(); 
#line 225
if (_Ptr) { 
#line 226
(((const_cast< _Locinfo *>(this))->_Months) = _Ptr); 
#line 227
::free(const_cast< char *>(_Ptr)); 
#line 228
}  
#line 230
return (!(_Months)._Empty()) ? (_Months)._C_str() : (":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:De" "cember"); 
#line 235
} 
#line 237
const char *_Getfalse() const { 
#line 238
return "false"; 
#line 239
} 
#line 241
const char *_Gettrue() const { 
#line 242
return "true"; 
#line 243
} 
#line 245
int _Getdateorder() const { 
#line 246
return ::_Getdateorder(); 
#line 247
} 
#line 249
_Timevec _W_Gettnames() const { 
#line 250
return ((std::_Timevec)(::_W_Gettnames())); 
#line 251
} 
#line 253
const unsigned short *_W_Getdays() const { 
#line 254
const __wchar_t *_Ptr = ::_W_Getdays(); 
#line 255
if (_Ptr) { 
#line 256
(((const_cast< _Locinfo *>(this))->_W_Days) = _Ptr); 
#line 257
::free(const_cast< __wchar_t *>(_Ptr)); 
#line 258
}  
#line 260
const __wchar_t *_Ret; 
#line 262
if ((_W_Days)._Empty()) { 
#line 263
_Ret = (L"\x3a\x53\x75\x6e\x3a\x53\x75\x6e\x64\x61\x79\x3a\x4d\x6f\x6e\x3a\x4d\x6f\x6e\x64\x61\x79\x3a\x54\x75\x65\x3a\x54\x75\x65\x73\x64" L"\x61\x79\x3a\x57\x65\x64\x3a\x57\x65\x64\x6e\x65\x73\x64\x61\x79\x3a\x54\x68\x75\x3a\x54\x68\x75\x72\x73\x64\x61\x79\x3a\x46\x72" L"\x69\x3a\x46\x72\x69\x64\x61\x79\x3a\x53\x61\x74\x3a\x53\x61\x74\x75\x72\x64\x61\x79"); 
#line 264
} else { 
#line 265
_Ret = (_W_Days)._C_str(); 
#line 266
}  
#line 268
return reinterpret_cast< const unsigned short *>(_Ret); 
#line 269
} 
#line 271
const unsigned short *_W_Getmonths() const { 
#line 272
const __wchar_t *_Ptr = ::_W_Getmonths(); 
#line 273
if (_Ptr) { 
#line 274
(((const_cast< _Locinfo *>(this))->_W_Months) = _Ptr); 
#line 275
::free(const_cast< __wchar_t *>(_Ptr)); 
#line 276
}  
#line 278
const __wchar_t *_Ret; 
#line 280
if ((_W_Months)._Empty()) { 
#line 281
_Ret = (L"\x3a\x4a\x61\x6e\x3a\x4a\x61\x6e\x75\x61\x72\x79\x3a\x46\x65\x62\x3a\x46\x65\x62\x72\x75\x61\x72\x79\x3a\x4d\x61\x72\x3a\x4d\x61" L"\x72\x63\x68\x3a\x41\x70\x72\x3a\x41\x70\x72\x69\x6c\x3a\x4d\x61\x79\x3a\x4d\x61\x79\x3a\x4a\x75\x6e\x3a\x4a\x75\x6e\x65\x3a\x4a" L"\x75\x6c\x3a\x4a\x75\x6c\x79\x3a\x41\x75\x67\x3a\x41\x75\x67\x75\x73\x74\x3a\x53\x65\x70\x3a\x53\x65\x70\x74\x65\x6d\x62\x65\x72" L"\x3a\x4f\x63\x74\x3a\x4f\x63\x74\x6f\x62\x65\x72\x3a\x4e\x6f\x76\x3a\x4e\x6f\x76\x65\x6d\x62\x65\x72\x3a\x44\x65\x63\x3a\x44\x65" L"\x63\x65\x6d\x62\x65\x72"); 
#line 283
} else { 
#line 284
_Ret = (_W_Months)._C_str(); 
#line 285
}  
#line 287
return reinterpret_cast< const unsigned short *>(_Ret); 
#line 288
} 
#line 290
_Locinfo(const _Locinfo &) = delete;
#line 291
_Locinfo &operator=(const _Locinfo &) = delete;
#line 298
private: _Lockit _Lock; 
#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
_Yarn< char>  _Days; 
#line 302
_Yarn< char>  _Months; 
#line 303
_Yarn< __wchar_t>  _W_Days; 
#line 304
_Yarn< __wchar_t>  _W_Months; 
#line 305
_Yarn< char>  _Oldlocname; 
#line 306
_Yarn< char>  _Newlocname; 
#line 307
}; 
#line 309
template < class _Elem >
int __cdecl _LStrcoll ( const _Elem * _First1, const _Elem * _Last1, const _Elem * _First2, const _Elem * _Last2,
    const _Locinfo :: _Collvec * ) {
    for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 ) {
        if ( * _First1 < * _First2 ) {
            return - 1;
        } else if ( * _First2 < * _First1 ) {
            return + 1;
        }
    }

    return _First2 != _Last2 ? - 1 : _First1 != _Last1 ? + 1 : 0;
}
#line 324
template<> inline int __cdecl _LStrcoll(const char *_First1, const char *_Last1, const char *_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 325
_Vector) { 
#line 326
return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 327
} 
#line 330
template<> inline int __cdecl _LStrcoll(const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *_First2, const __wchar_t *
#line 331
_Last2, const _Locinfo::_Collvec *
#line 332
_Vector) { 
#line 333
return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 334
} 
#line 336
template < class _Elem >
size_t __cdecl _LStrxfrm ( _Elem * _First1, _Elem * _Last1, const _Elem * _First2, const _Elem * _Last2,
    const _Locinfo :: _Collvec * ) {
    const ptrdiff_t _Count = _Last2 - _First2;
    if ( _Count <= _Last1 - _First1 ) {
        :: memcpy ( _First1, _First2, _Count * sizeof ( _Elem ) );
    }

    return _Count;
}
#line 348
template<> inline size_t __cdecl _LStrxfrm(char *_First1, char *
#line 349
_Last1, const char *_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 350
_Vector) { 
#line 351
return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 352
} 
#line 355
template<> inline size_t __cdecl _LStrxfrm(__wchar_t *_First1, __wchar_t *
#line 356
_Last1, const __wchar_t *_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
#line 357
_Vector) { 
#line 358
return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 359
} 
#line 360
}
#line 363
#pragma warning(pop)
#pragma pack ( pop )
#line 367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 25
namespace std { 
#line 26
template< class _Dummy> 
#line 27
class _Locbase { 
#line 29
public: static const int collate = ((1 << 1) >> 1); 
#line 30
static const int ctype = ((1 << 2) >> 1); 
#line 31
static const int monetary = ((1 << 3) >> 1); 
#line 32
static const int numeric = ((1 << 4) >> 1); 
#line 33
static const int time = ((1 << 5) >> 1); 
#line 34
static const int messages = ((1 << 6) >> 1); 
#line 35
static const int all = (((1 << (6 + 1)) >> 1) - 1); 
#line 36
static const int none = 0; 
#line 37
}; 
#line 39
template< class _Dummy> const int _Locbase< _Dummy> ::collate; 
#line 41
template< class _Dummy> const int _Locbase< _Dummy> ::ctype; 
#line 43
template< class _Dummy> const int _Locbase< _Dummy> ::monetary; 
#line 45
template< class _Dummy> const int _Locbase< _Dummy> ::numeric; 
#line 47
template< class _Dummy> const int _Locbase< _Dummy> ::time; 
#line 49
template< class _Dummy> const int _Locbase< _Dummy> ::messages; 
#line 51
template< class _Dummy> const int _Locbase< _Dummy> ::all; 
#line 53
template< class _Dummy> const int _Locbase< _Dummy> ::none; 
#line 56
template< class _Elem> class collate; 
#line 59
struct _Crt_new_delete { 
#line 88
}; 
#line 90
class locale : public _Locbase< int> , public _Crt_new_delete { 
#line 92
public: using category = int; 
#line 94
class id { 
#line 96
public: id(size_t _Val = 0) : _Id(_Val) { } 
#line 98
id(const id &) = delete;
#line 99
id &operator=(const id &) = delete;
#line 101
operator size_t() { 
#line 102
if ((_Id) == (0)) { 
#line 103
{ _Lockit _Lock(0); 
#line 104
if ((_Id) == (0)) { 
#line 105
(_Id) = (static_cast< size_t>(++_Id_cnt)); 
#line 106
}  
#line 107
} 
#line 108
}  
#line 109
return _Id; 
#line 110
} 
#line 113
private: size_t _Id; 
#line 115
static int _Id_cnt; 
#line 116
}; 
#line 118
class _Locimp; 
#line 120
class facet : public _Facet_base, public _Crt_new_delete { 
#line 123
friend struct _Facet_guard; 
#line 126
public: static size_t __cdecl _Getcat(const facet ** = 0, const locale * = 0) { 
#line 128
return static_cast< size_t>(-1); 
#line 129
} 
#line 131
virtual void _Incref() noexcept override { 
#line 132
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Myrefs))); 
#line 133
} 
#line 135
virtual _Facet_base *_Decref() noexcept override { 
#line 136
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Myrefs))) == (0)) { 
#line 137
return this; 
#line 138
}  
#line 140
return nullptr; 
#line 141
} 
#line 144
private: _Atomic_counter_t _Myrefs; 
#line 147
protected: explicit facet(size_t _Initrefs = 0) : _Myrefs(static_cast< _Atomic_counter_t>(_Initrefs)) 
#line 149
{ } 
#line 151
virtual ~facet() noexcept override { } 
#line 154
public: facet(const facet &) = delete;
#line 155
facet &operator=(const facet &) = delete;
#line 156
}; 
#line 158
struct [[nodiscard]] _Facet_guard { 
#line 159
facet *_Target; 
#line 160
~_Facet_guard() { 
#line 161
if (_Target) { 
#line 162
delete (_Target)->_Decref(); 
#line 163
}  
#line 164
} 
#line 165
}; 
#line 167
class _Locimp : public facet { 
#line 169
protected: virtual ~_Locimp() noexcept { 
#line 170
_Locimp_dtor(this); 
#line 171
} 
#line 174
private: static _Locimp *__cdecl _New_Locimp(bool _Transparent = false); 
#line 175
static _Locimp *__cdecl _New_Locimp(const _Locimp & _Right); 
#line 177
static void __cdecl _Locimp_dtor(_Locimp *); 
#line 178
static void __cdecl _Locimp_Addfac(_Locimp *, facet *, size_t); 
#line 179
static void __cdecl _Locimp_ctor(_Locimp *, const _Locimp &); 
#line 181
friend class locale; 
#line 183
_Locimp(bool _Transparent) : facet(1), _Facetvec((nullptr)), _Facetcount((0)), _Catmask(none), _Xparent(_Transparent), _Name("*") 
#line 184
{ 
#line 185
} 
#line 187
_Locimp(const _Locimp &_Right) : facet(1), _Facetvec((nullptr)), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name((_Right._Name).c_str()) 
#line 189
{ 
#line 190
_Locimp_ctor(this, _Right); 
#line 191
} 
#line 193
void _Addfac(facet *_Pfacet, size_t _Id) { 
#line 194
_Locimp_Addfac(this, _Pfacet, _Id); 
#line 195
} 
#line 197
static _Locimp *__cdecl _Makeloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 200
static void __cdecl _Makewloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 204
static void __cdecl _Makeushloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
static void __cdecl _Makexloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 211
facet **_Facetvec; 
#line 212
size_t _Facetcount; 
#line 213
category _Catmask; 
#line 214
bool _Xparent; 
#line 215
_Yarn< char>  _Name; 
#line 217
static _Locimp *_Clocptr; 
#line 220
public: _Locimp &operator=(const _Locimp &) = delete;
#line 221
}; 
#line 223
template < class _Elem, class _Traits, class _Alloc >
    bool operator ( ) (
        const basic_string < _Elem, _Traits, _Alloc > & _Left, const basic_string < _Elem, _Traits, _Alloc > & _Right ) const {

        const auto & _Coll_fac = :: std :: use_facet < :: std :: collate < _Elem >> ( * this );

        const _Elem * const _Left_data = _Left . data ( );
        const _Elem * const _Right_data = _Right . data ( );
        return _Coll_fac . compare ( _Left_data, _Left_data + _Left . size ( ), _Right_data, _Right_data + _Right . size ( ) ) < 0;
    }
#line 234
template < class _Facet >
    locale combine ( const locale & _Loc ) const {
        _Facet * _Facptr;

        try {
        _Facptr = const_cast < _Facet * > ( :: std :: addressof ( :: std :: use_facet < _Facet > ( _Loc ) ) );
        } catch ( ... ) {
        _Xruntime_error ( "locale::combine facet missing" );
        }

        _Locimp * _Newimp = _Locimp :: _New_Locimp ( * _Ptr );
        _Newimp -> _Addfac ( _Facptr, _Facet :: id );
        _Newimp -> _Catmask = none;
        _Newimp -> _Name = "*";
        return locale ( _Newimp );
    }
#line 251
template < class _Facet >
    locale ( const locale & _Loc, const _Facet * _Facptr ) : _Ptr ( _Locimp :: _New_Locimp ( * _Loc . _Ptr ) ) {
        if ( _Facptr ) {
            _Ptr -> _Addfac ( const_cast < _Facet * > ( _Facptr ), _Facet :: id );
            _Ptr -> _Catmask = none;
            _Ptr -> _Name = "*";
        }
    }
#line 260
locale(_Uninitialized) { } 
#line 262
locale(const locale &_Right) noexcept : _Ptr(_Right._Ptr) { 
#line 263
(_Ptr)->_Incref(); 
#line 264
} 
#line 266
locale() noexcept : _Ptr(_Init(true)) { } 
#line 269
locale(const locale &_Loc, const locale &_Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) { 
#line 271
if (_Cat != none) { 
#line 272
_Facet_guard _Guard{_Ptr}; 
#line 273
{ _Locinfo _Lobj; 
#line 274
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other); 
#line 275
_Lobj._Addcats((_Loc._Ptr)->_Catmask, (_Loc.name()).c_str()); 
#line 276
_Lobj._Addcats((_Other._Ptr)->_Catmask, (_Other.name()).c_str()); 
#line 277
((_Ptr)->_Catmask) = (((_Loc._Ptr)->_Catmask) | ((_Other._Ptr)->_Catmask)); 
#line 278
(((_Ptr)->_Name) = (_Lobj._Getname())); 
#line 279
} 
#line 280
(_Guard._Target) = (nullptr); 
#line 281
}  
#line 282
} 
#line 285
private: void _Construct(const string &_Str, category _Cat) { 
#line 287
bool _Bad = false; 
#line 288
_Init(); 
#line 289
if (_Cat != none) { 
#line 290
_Facet_guard _Guard{_Ptr}; 
#line 291
{ _Locinfo _Lobj(_Cat, _Str.c_str()); 
#line 292
if (this->_Badname(_Lobj)) { 
#line 293
_Bad = true; 
#line 294
} else { 
#line 295
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr); 
#line 296
((_Ptr)->_Catmask) = _Cat; 
#line 297
(((_Ptr)->_Name) = (_Str.c_str())); 
#line 298
}  
#line 299
} 
#line 300
(_Guard._Target) = (nullptr); 
#line 301
}  
#line 303
if (_Bad) { 
#line 304
delete (_Ptr)->_Decref(); 
#line 305
_Xruntime_error("bad locale name"); 
#line 306
}  
#line 307
} 
#line 310
public: explicit locale(const char *_Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) { 
#line 314
if (_Locname) { 
#line 315
this->_Construct(_Locname, _Cat); 
#line 316
return; 
#line 317
}  
#line 319
_Xruntime_error("bad locale name"); 
#line 320
} 
#line 322
locale(const locale &_Loc, const char *_Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) { 
#line 326
if (_Locname) { 
#line 327
this->_Construct(_Locname, _Cat); 
#line 328
return; 
#line 329
}  
#line 331
_Xruntime_error("bad locale name"); 
#line 332
} 
#line 334
explicit locale(const string &_Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) { 
#line 336
this->_Construct(_Str, _Cat); 
#line 337
} 
#line 339
locale(const locale &_Loc, const string &_Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) { 
#line 341
this->_Construct(_Str, _Cat); 
#line 342
} 
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
~locale() noexcept { 
#line 346
if (_Ptr) { 
#line 347
delete (_Ptr)->_Decref(); 
#line 348
}  
#line 349
} 
#line 351
const locale &operator=(const locale &_Right) noexcept { 
#line 352
if ((_Ptr) != (_Right._Ptr)) { 
#line 353
delete (_Ptr)->_Decref(); 
#line 354
(_Ptr) = (_Right._Ptr); 
#line 355
(_Ptr)->_Incref(); 
#line 356
}  
#line 357
return *this; 
#line 358
} 
#line 360
string name() const { 
#line 361
return ((_Ptr) ? ((_Ptr)->_Name).c_str() : string()); 
#line 362
} 
#line 364
const char *c_str() const { 
#line 365
return (_Ptr) ? ((_Ptr)->_Name).c_str() : (""); 
#line 366
} 
#line 368
const facet *_Getfacet(size_t _Id) const { 
#line 369
const facet *_Facptr = (_Id < ((_Ptr)->_Facetcount)) ? ((_Ptr)->_Facetvec)[_Id] : (nullptr); 
#line 370
if (_Facptr || (!((_Ptr)->_Xparent))) { 
#line 371
return _Facptr; 
#line 372
}  
#line 375
_Locimp *_Ptr0 = _Getgloballocale(); 
#line 376
if (_Id < (_Ptr0->_Facetcount)) { 
#line 377
return (_Ptr0->_Facetvec)[_Id]; 
#line 378
}  
#line 380
return nullptr; 
#line 381
} 
#line 383
[[nodiscard]] bool operator==(const locale &_Loc) const { 
#line 384
return ((_Ptr) == (_Loc._Ptr)) || (((this->name()).compare("*") != 0) && ((this->name()).compare(_Loc.name()) == 0)); 
#line 385
} 
#line 388
[[nodiscard]] bool operator!=(const locale &_Right) const { 
#line 389
return !((*this) == _Right); 
#line 390
} 
#line 393 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
static const locale &__cdecl classic(); 
#line 395
static locale __cdecl global(const locale &); 
#line 397
static locale __cdecl empty(); 
#line 400
private: locale(_Locimp *_Ptrimp) : _Ptr(_Ptrimp) { } 
#line 402
static _Locimp *__cdecl _Init(bool _Do_incref = false); 
#line 403
static _Locimp *__cdecl _Getgloballocale(); 
#line 404
static void __cdecl _Setgloballocale(void *); 
#line 406
bool _Badname(const _Locinfo &_Lobj) { 
#line 407
return ::strcmp(_Lobj._Getname(), "*") == 0; 
#line 408
} 
#line 410
_Locimp *_Ptr; 
#line 411
}; 
#line 413
template< class _Facet> 
#line 414
struct _Facetptr { 
#line 415
static const locale::facet *_Psave; 
#line 416
}; 
#line 418
template< class _Facet> const locale::facet *
#line 419
_Facetptr< _Facet> ::_Psave = (nullptr); 
#line 421
template < class _Facet >
const _Facet & __cdecl use_facet ( const locale & _Loc ) {
    { :: std :: _Lockit _Lock ( 0 );
    const locale :: facet * _Psave = _Facetptr < _Facet > :: _Psave;

    const size_t _Id = _Facet :: id;
    const locale :: facet * _Pf = _Loc . _Getfacet ( _Id );

    if ( ! _Pf ) {
        if ( _Psave ) {
            _Pf = _Psave;
        } else if ( _Facet :: _Getcat ( & _Psave, & _Loc ) == static_cast < size_t > ( - 1 ) ) {

            _Throw_bad_cast ( );



        } else {
            auto _Pfmod = const_cast < locale :: facet * > ( _Psave );
            unique_ptr < _Facet_base > _Psave_guard ( static_cast < _Facet_base * > ( _Pfmod ) );




            _Facet_Register ( _Pfmod );


            _Pfmod -> _Incref ( );
            _Facetptr < _Facet > :: _Psave = _Psave;
            _Pf = _Psave;

            ( void ) _Psave_guard . release ( );
        }
    }

    return static_cast < const _Facet & > ( * _Pf );
    }
}
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
template < class _Elem >
char __cdecl _Maklocbyte ( _Elem _Char, const _Locinfo :: _Cvtvec & ) {

    return static_cast < char > ( static_cast < unsigned char > ( _Char ) );
}
#line 467
template<> inline char __cdecl _Maklocbyte(__wchar_t _Char, const _Locinfo::_Cvtvec &_Cvt) { 
#line 469
char _Byte = '\000'; 
#line 470
mbstate_t _Mbst1 = {}; 
#line 471
_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt); 
#line 472
return _Byte; 
#line 473
} 
#line 477
template<> inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec &_Cvt) { 
#line 479
char _Byte = '\000'; 
#line 480
mbstate_t _Mbst1 = {}; 
#line 481
_Wcrtomb(&_Byte, static_cast< __wchar_t>(_Char), &_Mbst1, &_Cvt); 
#line 482
return _Byte; 
#line 483
} 
#line 486 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
template < class _Elem >
_Elem __cdecl _Maklocchr ( char _Byte, _Elem *, const _Locinfo :: _Cvtvec & ) {

    return static_cast < _Elem > ( static_cast < unsigned char > ( _Byte ) );
}
#line 493
template<> inline __wchar_t __cdecl _Maklocchr(char _Byte, __wchar_t *, const _Locinfo::_Cvtvec &_Cvt) { 
#line 495
__wchar_t _Wc = L'\x0'; 
#line 496
mbstate_t _Mbst1 = {}; 
#line 497
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt); 
#line 498
return _Wc; 
#line 499
} 
#line 503
template<> inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *, const _Locinfo::_Cvtvec &_Cvt) { 
#line 505
unsigned short _Wc = (0); 
#line 506
mbstate_t _Mbst1 = {}; 
#line 507
_Mbrtowc(reinterpret_cast< __wchar_t *>(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt); 
#line 508
return _Wc; 
#line 509
} 
#line 512 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
template < class _Elem >
_Elem * __cdecl _Maklocstr ( const char * _Ptr, _Elem *, const _Locinfo :: _Cvtvec & ) {

    size_t _Count = :: strlen ( _Ptr ) + 1;

    _Elem * _Ptrdest = static_cast < _Elem * > ( calloc ( _Count, sizeof ( _Elem ) ) );

    if ( ! _Ptrdest ) {
        _Xbad_alloc ( );
    }

    for ( _Elem * _Ptrnext = _Ptrdest; 0 < _Count; -- _Count, ++ _Ptrnext, ++ _Ptr ) {
        * _Ptrnext = static_cast < _Elem > ( static_cast < unsigned char > ( * _Ptr ) );
    }

    return _Ptrdest;
}
#line 531
template<> inline __wchar_t *__cdecl _Maklocstr(const char *_Ptr, __wchar_t *, const _Locinfo::_Cvtvec &_Cvt) { 
#line 533
size_t _Count; 
#line 534
size_t _Count1; 
#line 535
size_t _Wchars; 
#line 536
const char *_Ptr1; 
#line 537
int _Bytes; 
#line 538
__wchar_t _Wc; 
#line 539
mbstate_t _Mbst1 = {}; 
#line 541
_Count1 = (::strlen(_Ptr) + (1)); 
#line 542
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 543
if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 544
break; 
#line 545
}  
#line 546
}  
#line 548
++_Wchars; 
#line 550
__wchar_t *_Ptrdest = static_cast< __wchar_t *>(calloc(_Wchars, sizeof(__wchar_t))); 
#line 552
if (!_Ptrdest) { 
#line 553
_Xbad_alloc(); 
#line 554
}  
#line 556
__wchar_t *_Ptrnext = _Ptrdest; 
#line 557
mbstate_t _Mbst2 = {}; 
#line 559
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 560
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 561
break; 
#line 562
}  
#line 563
}  
#line 565
(*_Ptrnext) = L'\x0'; 
#line 567
return _Ptrdest; 
#line 568
} 
#line 572
template<> inline unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *, const _Locinfo::_Cvtvec &_Cvt) { 
#line 574
size_t _Count; 
#line 575
size_t _Count1; 
#line 576
size_t _Wchars; 
#line 577
const char *_Ptr1; 
#line 578
int _Bytes; 
#line 579
unsigned short _Wc; 
#line 580
mbstate_t _Mbst1 = {}; 
#line 582
_Count1 = (::strlen(_Ptr) + (1)); 
#line 583
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 584
if ((_Bytes = _Mbrtowc(reinterpret_cast< __wchar_t *>(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 585
break; 
#line 586
}  
#line 587
}  
#line 589
++_Wchars; 
#line 591
__wchar_t *_Ptrdest = static_cast< __wchar_t *>(calloc(_Wchars, sizeof(__wchar_t))); 
#line 593
if (!_Ptrdest) { 
#line 594
_Xbad_alloc(); 
#line 595
}  
#line 597
__wchar_t *_Ptrnext = _Ptrdest; 
#line 598
mbstate_t _Mbst2 = {}; 
#line 599
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 600
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 601
break; 
#line 602
}  
#line 603
}  
#line 605
(*_Ptrnext) = L'\x0'; 
#line 606
return reinterpret_cast< unsigned short *>(_Ptrdest); 
#line 607
} 
#line 610 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
class codecvt_base : public locale::facet { 
#line 612
public: enum { 
#line 613
ok, 
#line 614
partial, 
#line 615
error, 
#line 616
noconv
#line 617
}; 
#line 618
using result = int; 
#line 620
codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) { } 
#line 622
bool always_noconv() const noexcept { 
#line 624
return this->do_always_noconv(); 
#line 625
} 
#line 627
int max_length() const noexcept { 
#line 629
return this->do_max_length(); 
#line 630
} 
#line 632
int encoding() const noexcept { 
#line 633
return this->do_encoding(); 
#line 634
} 
#line 636
virtual ~codecvt_base() noexcept { } 
#line 639
protected: virtual bool do_always_noconv() const noexcept { 
#line 641
return false; 
#line 642
} 
#line 644
virtual int do_max_length() const noexcept { 
#line 646
return 1; 
#line 647
} 
#line 649
virtual int do_encoding() const noexcept { 
#line 650
return 1; 
#line 651
} 
#line 652
}; 
#line 654
template < class _Elem, class _Byte, class _Statype >
class codecvt : public codecvt_base {
public :








    static_assert ( ! 0 || is_same_v < codecvt, codecvt < char, char, mbstate_t >>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORC" "E_FACET_SPECIALIZATIONS=0 to suppress this diagnostic." );

    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type = _Statype;

    result in ( _Statype & _State, const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
        _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const {
        return do_in ( _State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 );
    }

    result out ( _Statype & _State, const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
        _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const {
        return do_out ( _State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 );
    }

    result unshift ( _Statype & _State, _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const {

        return do_unshift ( _State, _First2, _Last2, _Mid2 );
    }

    int length ( _Statype & _State, const _Byte * _First1, const _Byte * _Last1, size_t _Count ) const {


        return do_length ( _State, _First1, _Last1, _Count );
    }

     static locale :: id id;

    explicit codecvt ( size_t _Refs = 0 ) : codecvt_base ( _Refs ) {
        _Init ( _Locinfo ( ) );
    }

    explicit codecvt ( const _Locinfo & _Lobj, size_t _Refs = 0 ) : codecvt_base ( _Refs ) {
        _Init ( _Lobj );
    }

    static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {

        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new codecvt ( _Locinfo ( _Ploc -> c_str ( ) ) );
        }

        return 2;
    }

protected :
    virtual ~ codecvt ( ) noexcept { }

    void _Init ( const _Locinfo & ) { }

    virtual bool do_always_noconv ( ) const noexcept override {

        return is_same_v < _Byte, _Elem >;
    }

    virtual result do_in ( _Statype &, const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
        _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const {
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr ( is_same_v < _Byte, _Elem > ) {
            return noconv;
        } else {

            for (; _Mid1 != _Last1; ++ _Mid1, ++ _Mid2 ) {
                if ( _Mid2 == _Last2 ) {
                    return partial;
                }
                * _Mid2 = static_cast < _Elem > ( * _Mid1 );
            }

            return ok;
        }
    }

    virtual result do_out ( _Statype &, const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
        _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const {
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr ( is_same_v < _Byte, _Elem > ) {
            return noconv;
        } else {

            for (; _Mid1 != _Last1; ++ _Mid1, ++ _Mid2 ) {
                if ( _Mid2 == _Last2 ) {
                    return partial;
                }
                * _Mid2 = static_cast < _Byte > ( * _Mid1 );
            }

            return ok;
        }
    }

    virtual result do_unshift ( _Statype &, _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const {

        _Mid2 = _First2;
        return noconv;
    }

    virtual int do_length (
        _Statype &, const _Byte * _First1, const _Byte * _Last1, size_t _Count ) const {



        const auto _Dist = static_cast < size_t > ( ( :: std :: min ) ( _Last1 - _First1, ptrdiff_t { 2147483647 } ) );
        return static_cast < int > ( ( :: std :: min ) ( _Count, _Dist ) );
    }
};
#line 781
template< class _Elem, class _Byte, class _Statype> locale::id 
#line 782
codecvt< _Elem, _Byte, _Statype> ::id; 
#line 788
template < class _CvtTy, class _Byte, class _Statype >
[ [ nodiscard ] ] int _Codecvt_do_length (
    const _CvtTy & _Cvt, _Statype & _State, const _Byte * _First1, const _Byte * _Last1, size_t _Count ) {



    __pragma(warning(push))                            __pragma(warning(disable : 4996))
    using _Elem = typename _CvtTy :: intern_type;
    __pragma(warning(pop))

    _Adl_verify_range ( _First1, _Last1 );
    const auto _Old_first1 = _First1;

    while ( _Count > 0 && _First1 != _Last1 ) {
        const _Byte * _Mid1;
        _Elem * _Mid2;
        _Elem _Ch;



        __pragma(warning(push))                                __pragma(warning(disable : 4996))
        const auto _Result = _Cvt . _CvtTy :: do_in ( _State, _First1, _Last1, _Mid1, & _Ch, & _Ch + 1, _Mid2 );
        __pragma(warning(pop))

        if ( _Result != codecvt_base :: ok ) {
            if ( _Result == codecvt_base :: noconv ) {
                _First1 += ( :: std :: min ) ( static_cast < size_t > ( _Last1 - _First1 ), _Count );
            }

            break;
        }

        if ( _Mid2 == & _Ch + 1 ) {
            -- _Count;
        }

        _First1 = _Mid1;
    }

    return static_cast < int > ( ( :: std :: min ) ( _First1 - _Old_first1, ptrdiff_t { 2147483647 } ) );
}
#line 830
enum _Codecvt_mode { _Consume_header = 4, _Generate_header = 2}; 
#line 834
template<> class codecvt< char16_t, char, _Mbstatet>  : public codecvt_base { 
#line 837
public: using intern_type = char16_t; 
#line 838
using extern_type = char; 
#line 839
using state_type = mbstate_t; 
#line 841
result in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&_Mid1, char16_t *
#line 842
_First2, char16_t *_Last2, char16_t *&_Mid2) const { 
#line 844
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 845
} 
#line 847
result out(mbstate_t &_State, const char16_t *_First1, const char16_t *_Last1, const char16_t *&
#line 848
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 850
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 851
} 
#line 853
result unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 855
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 856
} 
#line 858
int length(mbstate_t &_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 861
return this->do_length(_State, _First1, _Last1, _Count); 
#line 862
} 
#line 864
static locale::id id; 
#line 866
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((1114111)), _Mode(_Consume_header) 
#line 867
{ 
#line 868
{ _Locinfo _Lobj; 
#line 869
this->_Init(_Lobj); 
#line 870
} 
#line 871
} 
#line 873
explicit codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((1114111)), _Mode(_Consume_header) 
#line 874
{ 
#line 875
this->_Init(_Lobj); 
#line 876
} 
#line 878
codecvt(const _Locinfo &
#line 879
_Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) 
#line 880
{ 
#line 881
this->_Init(_Lobj); 
#line 882
} 
#line 884
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 886
if (_Ppf && (!(*_Ppf))) { 
#line 887
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 888
(*_Ppf) = (new std::codecvt< char16_t, char, _Mbstatet> (((_Locinfo)(_Ploc->c_str())))); 
#line 889
__pragma( warning(pop)) 
#line 890
}  
#line 892
return 2; 
#line 893
} 
#line 896
protected: virtual ~codecvt() noexcept { } 
#line 898
void _Init(const _Locinfo &) { } 
#line 900
virtual result do_in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&
#line 901
_Mid1, char16_t *_First2, char16_t *_Last2, char16_t *&_Mid2) const { 
#line 903
unsigned short *_Pstate = reinterpret_cast< unsigned short *>(&_State); 
#line 904
_Mid1 = _First1; 
#line 905
_Mid2 = _First2; 
#line 907
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 908
unsigned char _By = static_cast< unsigned char>(*_Mid1); 
#line 909
unsigned long _Ch; 
#line 910
int _Nextra; 
#line 911
int _Nskip; 
#line 913
if ((*_Pstate) > 1) { 
#line 914
if ((_By < 128) || (192 <= _By)) { 
#line 915
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 916
}  
#line 919
++_Mid1; 
#line 920
(*(_Mid2++)) = (static_cast< char16_t>((*_Pstate) | (_By & 63))); 
#line 921
(*_Pstate) = (1); 
#line 922
continue; 
#line 923
}  
#line 925
if (_By < 128U) { 
#line 926
_Ch = _By; 
#line 927
_Nextra = 0; 
#line 928
} else { if (_By < 192U) { 
#line 929
++_Mid1; 
#line 930
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 931
} else { if (_By < 224U) { 
#line 932
_Ch = (static_cast< unsigned long>(_By & 31)); 
#line 933
_Nextra = 1; 
#line 934
} else { if (_By < 240U) { 
#line 935
_Ch = (static_cast< unsigned long>(_By & 15)); 
#line 936
_Nextra = 2; 
#line 937
} else { if (_By < 248U) { 
#line 938
_Ch = (static_cast< unsigned long>(_By & 7)); 
#line 939
_Nextra = 3; 
#line 940
} else { 
#line 941
_Ch = (static_cast< unsigned long>(_By & 3)); 
#line 942
_Nextra = ((_By < 252) ? 4 : 5); 
#line 943
}  }  }  }  }  
#line 945
_Nskip = ((_Nextra < 3) ? 0 : 1); 
#line 946
_First1 = _Mid1; 
#line 948
if (_Nextra == 0) { 
#line 949
++_Mid1; 
#line 950
} else { if ((_Last1 - _Mid1) < ((_Nextra + 1) - _Nskip)) { 
#line 951
break; 
#line 952
} else { 
#line 953
for (++_Mid1; _Nskip < _Nextra; (--_Nextra), (++_Mid1)) { 
#line 954
if (((_By = (static_cast< unsigned char>(*_Mid1))) < 128U) || (192U <= _By)) { 
#line 955
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 956
} else { 
#line 957
_Ch = ((_Ch << 6) | (_By & 63)); 
#line 958
}  
#line 959
}  
#line 960
}  }  
#line 962
if (0 < _Nskip) { 
#line 963
_Ch <<= 6; 
#line 964
}  
#line 966
if ((((_Maxcode) < (1114111U)) ? _Maxcode : (1114111U)) < _Ch) { 
#line 967
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 968
}  
#line 970
if ((65535U) < _Ch) { 
#line 971
unsigned short _Ch0 = static_cast< unsigned short>((55296) | ((_Ch >> 10) - (64))); 
#line 973
(*(_Mid2++)) = (static_cast< char16_t>(_Ch0)); 
#line 974
(*_Pstate) = (static_cast< unsigned short>((56320) | (_Ch & (1023)))); 
#line 975
continue; 
#line 976
}  
#line 978
if (_Nskip != 0) { 
#line 979
if (_Mid1 == _Last1) { 
#line 980
_Mid1 = _First1; 
#line 981
break; 
#line 982
}  
#line 984
if (((_By = (static_cast< unsigned char>(*(_Mid1++)))) < 128U) || (192U <= _By)) { 
#line 985
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 986
}  
#line 988
_Ch |= (_By & 63); 
#line 989
}  
#line 991
if ((*_Pstate) == 0U) { 
#line 992
(*_Pstate) = (1); 
#line 994
if ((((_Mode) & (_Consume_header)) != 0) && (_Ch == (65279U))) { 
#line 995
const result _Ans = this->do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 997
if (_Ans == (codecvt< char16_t, char, _Mbstatet> ::partial)) { 
#line 998
(*_Pstate) = (0); 
#line 999
_Mid1 = _First1; 
#line 1000
}  
#line 1002
return _Ans; 
#line 1003
}  
#line 1004
}  
#line 1006
(*(_Mid2++)) = (static_cast< char16_t>(_Ch)); 
#line 1007
}   
#line 1009
return (_First1 == _Mid1) ? codecvt< char16_t, char, _Mbstatet> ::partial : codecvt< char16_t, char, _Mbstatet> ::ok; 
#line 1010
} 
#line 1012
virtual result do_out(mbstate_t &_State, const char16_t *_First1, const char16_t *_Last1, const char16_t *&
#line 1013
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1015
unsigned short *_Pstate = reinterpret_cast< unsigned short *>(&_State); 
#line 1016
_Mid1 = _First1; 
#line 1017
_Mid2 = _First2; 
#line 1019
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1020
unsigned long _Ch; 
#line 1021
const unsigned short _Ch1 = static_cast< unsigned short>(*_Mid1); 
#line 1022
bool _Save = false; 
#line 1024
if (1 < (*_Pstate)) { 
#line 1025
if ((_Ch1 < 56320U) || (57344U <= _Ch1)) { 
#line 1026
return codecvt< char16_t, char, _Mbstatet> ::error; 
#line 1027
}  
#line 1029
_Ch = (static_cast< unsigned long>(((*_Pstate) << 10) | (_Ch1 - 56320))); 
#line 1030
} else { if ((55296U <= _Ch1) && (_Ch1 < 56320U)) { 
#line 1031
_Ch = (static_cast< unsigned long>(((_Ch1 - 55296) + 64) << 10)); 
#line 1032
_Save = true; 
#line 1033
} else { 
#line 1034
_Ch = _Ch1; 
#line 1035
}  }  
#line 1037
char _By; 
#line 1038
int _Nextra; 
#line 1040
if (_Ch < (128U)) { 
#line 1041
_By = (static_cast< char>(_Ch)); 
#line 1042
_Nextra = 0; 
#line 1043
} else { if (_Ch < (2048U)) { 
#line 1044
_By = (static_cast< char>((192) | (_Ch >> 6))); 
#line 1045
_Nextra = 1; 
#line 1046
} else { if (_Ch < (65536U)) { 
#line 1047
_By = (static_cast< char>((224) | (_Ch >> 12))); 
#line 1048
_Nextra = 2; 
#line 1049
} else { 
#line 1050
_By = (static_cast< char>((240) | (_Ch >> 18))); 
#line 1051
_Nextra = 3; 
#line 1052
}  }  }  
#line 1054
int _Nput = (_Nextra < 3) ? _Nextra + 1 : (_Save ? 1 : 3); 
#line 1056
if ((_Last2 - _Mid2) < _Nput) { 
#line 1057
break; 
#line 1058
}  
#line 1060
if (((*_Pstate) == 0U) && (((_Mode) & (_Generate_header)) != 0)) { 
#line 1061
if ((_Last2 - _Mid2) < (3 + _Nput)) { 
#line 1062
break; 
#line 1063
}  
#line 1066
(*(_Mid2++)) = '\357'; 
#line 1067
(*(_Mid2++)) = '\273'; 
#line 1068
(*(_Mid2++)) = '\277'; 
#line 1069
}  
#line 1071
++_Mid1; 
#line 1072
if (_Save || (_Nextra < 3)) { 
#line 1073
(*(_Mid2++)) = _By; 
#line 1074
--_Nput; 
#line 1075
}  
#line 1077
for (; 0 < _Nput; --_Nput) { 
#line 1078
(*(_Mid2++)) = (static_cast< char>(((_Ch >> (6 * (--_Nextra))) & (63)) | (128))); 
#line 1079
}  
#line 1081
(*_Pstate) = (static_cast< unsigned short>(_Save ? _Ch >> 10 : (1))); 
#line 1082
}  
#line 1084
return (_First1 == _Mid1) ? codecvt< char16_t, char, _Mbstatet> ::partial : codecvt< char16_t, char, _Mbstatet> ::ok; 
#line 1085
} 
#line 1087
virtual result do_unshift(mbstate_t &_State, char *_First2, char *, char *&_Mid2) const { 
#line 1089
unsigned short *_Pstate = reinterpret_cast< unsigned short *>(&_State); 
#line 1090
_Mid2 = _First2; 
#line 1092
return (1U < (*_Pstate)) ? codecvt< char16_t, char, _Mbstatet> ::error : codecvt< char16_t, char, _Mbstatet> ::ok; 
#line 1093
} 
#line 1095
friend int _Codecvt_do_length<> (const std::codecvt< char16_t, char, _Mbstatet>  &, mbstate_t &, const char *, const char *, size_t); 
#line 1097
virtual int do_length(mbstate_t &
#line 1098
_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 1099
return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count); 
#line 1100
} 
#line 1102
virtual bool do_always_noconv() const noexcept override { 
#line 1104
return false; 
#line 1105
} 
#line 1107
virtual int do_max_length() const noexcept override { 
#line 1110
if (((_Mode) & (_Consume_header)) != 0) { 
#line 1111
return 9; 
#line 1112
}  
#line 1114
if (((_Mode) & (_Generate_header)) != 0) { 
#line 1115
return 7; 
#line 1116
}  
#line 1118
return 6; 
#line 1119
} 
#line 1121
virtual int do_encoding() const noexcept override { 
#line 1122
return 0; 
#line 1123
} 
#line 1126
private: unsigned long _Maxcode; 
#line 1127
_Codecvt_mode _Mode; 
#line 1128
}; 
#line 1132
template<> class codecvt< char32_t, char, _Mbstatet>  : public codecvt_base { 
#line 1135
public: using intern_type = char32_t; 
#line 1136
using extern_type = char; 
#line 1137
using state_type = mbstate_t; 
#line 1139
result in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&_Mid1, char32_t *
#line 1140
_First2, char32_t *_Last2, char32_t *&_Mid2) const { 
#line 1142
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1143
} 
#line 1145
result out(mbstate_t &_State, const char32_t *_First1, const char32_t *_Last1, const char32_t *&
#line 1146
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1148
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1149
} 
#line 1151
result unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1153
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1154
} 
#line 1156
int length(mbstate_t &_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 1159
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1160
} 
#line 1162
static locale::id id; 
#line 1164
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((4294967295U)), _Mode(_Consume_header) 
#line 1165
{ 
#line 1166
{ _Locinfo _Lobj; 
#line 1167
this->_Init(_Lobj); 
#line 1168
} 
#line 1169
} 
#line 1171
explicit codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((4294967295U)), _Mode(_Consume_header) 
#line 1172
{ 
#line 1173
this->_Init(_Lobj); 
#line 1174
} 
#line 1176
codecvt(const _Locinfo &
#line 1177
_Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) 
#line 1178
{ 
#line 1179
this->_Init(_Lobj); 
#line 1180
} 
#line 1182
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 1184
if (_Ppf && (!(*_Ppf))) { 
#line 1185
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1186
(*_Ppf) = (new std::codecvt< char32_t, char, _Mbstatet> (((_Locinfo)(_Ploc->c_str())))); 
#line 1187
__pragma( warning(pop)) 
#line 1188
}  
#line 1190
return 2; 
#line 1191
} 
#line 1194
protected: virtual ~codecvt() noexcept { } 
#line 1196
void _Init(const _Locinfo &) { } 
#line 1198
virtual result do_in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&
#line 1199
_Mid1, char32_t *_First2, char32_t *_Last2, char32_t *&_Mid2) const { 
#line 1201
char *_Pstate = reinterpret_cast< char *>(&_State); 
#line 1202
_Mid1 = _First1; 
#line 1203
_Mid2 = _First2; 
#line 1205
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1206
unsigned char _By = static_cast< unsigned char>(*_Mid1); 
#line 1207
unsigned long _Ch; 
#line 1208
int _Nextra; 
#line 1210
if (_By < 128U) { 
#line 1211
_Ch = _By; 
#line 1212
_Nextra = 0; 
#line 1213
} else { if (_By < 192U) { 
#line 1214
++_Mid1; 
#line 1215
return codecvt< char32_t, char, _Mbstatet> ::error; 
#line 1216
} else { if (_By < 224U) { 
#line 1217
_Ch = (static_cast< unsigned long>(_By & 31)); 
#line 1218
_Nextra = 1; 
#line 1219
} else { if (_By < 240U) { 
#line 1220
_Ch = (static_cast< unsigned long>(_By & 15)); 
#line 1221
_Nextra = 2; 
#line 1222
} else { if (_By < 248U) { 
#line 1223
_Ch = (static_cast< unsigned long>(_By & 7)); 
#line 1224
_Nextra = 3; 
#line 1225
} else { 
#line 1226
_Ch = (static_cast< unsigned long>(_By & 3)); 
#line 1227
_Nextra = ((_By < 252) ? 4 : 5); 
#line 1228
}  }  }  }  }  
#line 1230
if (_Nextra == 0) { 
#line 1231
++_Mid1; 
#line 1232
} else { if ((_Last1 - _Mid1) < (_Nextra + 1)) { 
#line 1233
break; 
#line 1234
} else { 
#line 1235
for (++_Mid1; 0 < _Nextra; (--_Nextra), (++_Mid1)) { 
#line 1236
if (((_By = (static_cast< unsigned char>(*_Mid1))) < 128U) || (192U <= _By)) { 
#line 1237
return codecvt< char32_t, char, _Mbstatet> ::error; 
#line 1238
} else { 
#line 1239
_Ch = ((_Ch << 6) | (_By & 63)); 
#line 1240
}  
#line 1241
}  
#line 1242
}  }  
#line 1244
if ((*_Pstate) == 0) { 
#line 1245
(*_Pstate) = (1); 
#line 1247
if ((((_Mode) & (_Consume_header)) != 0) && (_Ch == (65279U))) { 
#line 1248
const result _Ans = this->do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1250
if (_Ans == (codecvt< char32_t, char, _Mbstatet> ::partial)) { 
#line 1251
(*_Pstate) = (0); 
#line 1252
_Mid1 = _First1; 
#line 1253
}  
#line 1254
return _Ans; 
#line 1255
}  
#line 1256
}  
#line 1258
if ((_Maxcode) < _Ch) { 
#line 1259
return codecvt< char32_t, char, _Mbstatet> ::error; 
#line 1260
}  
#line 1262
(*(_Mid2++)) = (static_cast< char32_t>(_Ch)); 
#line 1263
}  
#line 1265
return (_First1 == _Mid1) ? codecvt< char32_t, char, _Mbstatet> ::partial : codecvt< char32_t, char, _Mbstatet> ::ok; 
#line 1266
} 
#line 1268
virtual result do_out(mbstate_t &_State, const char32_t *_First1, const char32_t *_Last1, const char32_t *&
#line 1269
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1271
char *_Pstate = reinterpret_cast< char *>(&_State); 
#line 1272
_Mid1 = _First1; 
#line 1273
_Mid2 = _First2; 
#line 1275
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1276
char _By; 
#line 1277
int _Nextra; 
#line 1278
unsigned long _Ch = static_cast< unsigned long>(*_Mid1); 
#line 1280
if ((_Maxcode) < _Ch) { 
#line 1281
return codecvt< char32_t, char, _Mbstatet> ::error; 
#line 1282
}  
#line 1284
if (_Ch < (128U)) { 
#line 1285
_By = (static_cast< char>(_Ch)); 
#line 1286
_Nextra = 0; 
#line 1287
} else { if (_Ch < (2048U)) { 
#line 1288
_By = (static_cast< char>((192) | (_Ch >> 6))); 
#line 1289
_Nextra = 1; 
#line 1290
} else { if (_Ch < (65536U)) { 
#line 1291
_By = (static_cast< char>((224) | (_Ch >> 12))); 
#line 1292
_Nextra = 2; 
#line 1293
} else { if (_Ch < (2097152U)) { 
#line 1294
_By = (static_cast< char>((240) | (_Ch >> 18))); 
#line 1295
_Nextra = 3; 
#line 1296
} else { if (_Ch < (67108864U)) { 
#line 1297
_By = (static_cast< char>((248) | (_Ch >> 24))); 
#line 1298
_Nextra = 4; 
#line 1299
} else { 
#line 1300
_By = (static_cast< char>((252) | ((_Ch >> 30) & (3)))); 
#line 1301
_Nextra = 5; 
#line 1302
}  }  }  }  }  
#line 1304
if ((*_Pstate) == 0) { 
#line 1305
(*_Pstate) = (1); 
#line 1306
if (((_Mode) & (_Generate_header)) != 0) { 
#line 1307
if ((_Last2 - _Mid2) < ((3 + 1) + _Nextra)) { 
#line 1308
return codecvt< char32_t, char, _Mbstatet> ::partial; 
#line 1309
}  
#line 1312
(*(_Mid2++)) = '\357'; 
#line 1313
(*(_Mid2++)) = '\273'; 
#line 1314
(*(_Mid2++)) = '\277'; 
#line 1315
}  
#line 1316
}  
#line 1318
if ((_Last2 - _Mid2) < (1 + _Nextra)) { 
#line 1319
break; 
#line 1320
}  
#line 1322
++_Mid1; 
#line 1323
for ((*(_Mid2++)) = _By; 0 < _Nextra;) { 
#line 1324
(*(_Mid2++)) = (static_cast< char>(((_Ch >> (6 * (--_Nextra))) & (63)) | (128))); 
#line 1325
}  
#line 1326
}  
#line 1327
return (_First1 == _Mid1) ? codecvt< char32_t, char, _Mbstatet> ::partial : codecvt< char32_t, char, _Mbstatet> ::ok; 
#line 1328
} 
#line 1330
virtual result do_unshift(mbstate_t &, char *_First2, char *, char *&_Mid2) const { 
#line 1332
_Mid2 = _First2; 
#line 1333
return codecvt< char32_t, char, _Mbstatet> ::noconv; 
#line 1334
} 
#line 1336
friend int _Codecvt_do_length<> (const std::codecvt< char32_t, char, _Mbstatet>  &, mbstate_t &, const char *, const char *, size_t); 
#line 1338
virtual int do_length(mbstate_t &
#line 1339
_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 1340
return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count); 
#line 1341
} 
#line 1343
virtual bool do_always_noconv() const noexcept override { 
#line 1345
return false; 
#line 1346
} 
#line 1348
virtual int do_max_length() const noexcept override { 
#line 1350
return (((_Mode) & ((_Consume_header) | (_Generate_header))) != 0) ? 9 : 6; 
#line 1351
} 
#line 1353
virtual int do_encoding() const noexcept override { 
#line 1355
return (((_Mode) & ((_Consume_header) | (_Generate_header))) != 0) ? -1 : 0; 
#line 1357
} 
#line 1360
private: unsigned long _Maxcode; 
#line 1361
_Codecvt_mode _Mode; 
#line 1362
}; 
#line 1909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
template<> class codecvt< __wchar_t, char, _Mbstatet>  : public codecvt_base { 
#line 1912
public: using intern_type = __wchar_t; 
#line 1913
using extern_type = char; 
#line 1914
using state_type = mbstate_t; 
#line 1916
result in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&_Mid1, __wchar_t *
#line 1917
_First2, __wchar_t *_Last2, __wchar_t *&_Mid2) const { 
#line 1919
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1920
} 
#line 1922
result out(mbstate_t &_State, const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *&
#line 1923
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1925
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1926
} 
#line 1928
result unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 1930
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1931
} 
#line 1933
int length(mbstate_t &_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 1936
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1937
} 
#line 1939
static locale::id id; 
#line 1941
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { 
#line 1942
{ _Locinfo _Lobj; 
#line 1943
this->_Init(_Lobj); 
#line 1944
} 
#line 1945
} 
#line 1947
explicit codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) { 
#line 1948
this->_Init(_Lobj); 
#line 1949
} 
#line 1951
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 1953
if (_Ppf && (!(*_Ppf))) { 
#line 1954
(*_Ppf) = (new std::codecvt< __wchar_t, char, _Mbstatet> (((_Locinfo)(_Ploc->c_str())))); 
#line 1955
}  
#line 1957
return 2; 
#line 1958
} 
#line 1961
protected: virtual ~codecvt() noexcept { } 
#line 1963
void _Init(const _Locinfo &_Lobj) { 
#line 1964
(_Cvt) = _Lobj._Getcvt(); 
#line 1965
} 
#line 1967
virtual result do_in(mbstate_t &, const char *_First1, const char *_Last1, const char *&_Mid1, __wchar_t *
#line 1968
_First2, __wchar_t *_Last2, __wchar_t *&_Mid2) const { 
#line 1970
mbstate_t _Mystate{}; 
#line 1971
_Adl_verify_range(_First1, _Last1); 
#line 1972
_Adl_verify_range(_First2, _Last2); 
#line 1973
_Mid1 = _First1; 
#line 1974
_Mid2 = _First2; 
#line 1975
for (; ;) { 
#line 1976
if (_Mid1 == _Last1) { 
#line 1977
return ok; 
#line 1978
}  
#line 1980
if (_Mid2 == _Last2) { 
#line 1981
return partial; 
#line 1982
}  
#line 1984
int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast< size_t>(_Last1 - _Mid1), &_Mystate, &(_Cvt)); 
#line 1985
switch (_Bytes) { 
#line 1986
case -2:  
#line 1987
return partial; 
#line 1989
case -1:  
#line 1990
return error; 
#line 1992
case 0:  
#line 1993
_Bytes = 1; 
#line 1996
default:  
#line 1997
_Mid1 += _Bytes; 
#line 1998
++_Mid2; 
#line 1999
break; 
#line 2000
}  
#line 2001
}  
#line 2002
} 
#line 2004
virtual result do_out(mbstate_t &_State, const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *&
#line 2005
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2007
_Adl_verify_range(_First1, _Last1); 
#line 2008
_Adl_verify_range(_First2, _Last2); 
#line 2009
_Mid1 = _First1; 
#line 2010
_Mid2 = _First2; 
#line 2011
int _Bytes; 
#line 2013
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 2014
if ((5) <= (_Last2 - _Mid2)) { 
#line 2015
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 2016
return error; 
#line 2017
} else { 
#line 2018
++_Mid1; 
#line 2019
_Mid2 += _Bytes; 
#line 2020
}  
#line 2021
} else { 
#line 2022
char _Buf[5]; 
#line 2023
mbstate_t _Stsave = _State; 
#line 2025
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 2026
return error; 
#line 2027
} else { if ((_Last2 - _Mid2) < _Bytes) { 
#line 2028
_State = _Stsave; 
#line 2029
break; 
#line 2030
} else { 
#line 2031
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2032
++_Mid1; 
#line 2033
_Mid2 += _Bytes; 
#line 2034
}  }  
#line 2035
}  
#line 2036
}  
#line 2038
return (_Mid1 == _Last1) ? ok : partial; 
#line 2039
} 
#line 2041
virtual result do_unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2043
_Adl_verify_range(_First2, _Last2); 
#line 2044
_Mid2 = _First2; 
#line 2045
result _Ans = (ok); 
#line 2046
int _Bytes; 
#line 2047
char _Buf[5]; 
#line 2048
mbstate_t _Stsave = _State; 
#line 2050
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 2051
_Ans = (error); 
#line 2052
} else { if ((_Last2 - _Mid2) < (--_Bytes)) { 
#line 2053
_State = _Stsave; 
#line 2054
_Ans = (partial); 
#line 2055
} else { if (0 < _Bytes) { 
#line 2056
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2057
_Mid2 += _Bytes; 
#line 2058
}  }  }  
#line 2059
return _Ans; 
#line 2060
} 
#line 2062
virtual int do_length(mbstate_t &
#line 2063
_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 2066
_Adl_verify_range(_First1, _Last1); 
#line 2067
const auto _Old_first1 = _First1; 
#line 2069
for (; (_Count > (0U)) && (_First1 != _Last1); --_Count) { 
#line 2070
__wchar_t _Ch; 
#line 2071
int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast< size_t>(_Last1 - _First1), &_State, &(_Cvt)); 
#line 2072
if (_Bytes < 0) { 
#line 2073
break; 
#line 2074
}  
#line 2076
if (_Bytes == 0) { 
#line 2077
_Bytes = 1; 
#line 2078
}  
#line 2081
_First1 += _Bytes; 
#line 2082
}  
#line 2084
return static_cast< int>((::std::min)(_First1 - _Old_first1, (ptrdiff_t)2147483647)); 
#line 2085
} 
#line 2087
virtual bool do_always_noconv() const noexcept override { 
#line 2089
return false; 
#line 2090
} 
#line 2092
virtual int do_max_length() const noexcept override { 
#line 2094
return static_cast< int>((_Cvt)._Mbcurmax); 
#line 2095
} 
#line 2097
virtual int do_encoding() const noexcept override { 
#line 2099
return ((_Cvt)._Mbcurmax) == (1); 
#line 2100
} 
#line 2103
private: _Locinfo::_Cvtvec _Cvt; 
#line 2104
}; 
#line 2108
template<> class codecvt< unsigned short, char, _Mbstatet>  : public codecvt_base { 
#line 2111
public: using intern_type = unsigned short; 
#line 2112
using extern_type = char; 
#line 2113
using state_type = mbstate_t; 
#line 2115
result in(mbstate_t &_State, const char *_First1, const char *_Last1, const char *&_Mid1, unsigned short *
#line 2116
_First2, unsigned short *_Last2, unsigned short *&_Mid2) const { 
#line 2118
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 2119
} 
#line 2121
result out(mbstate_t &_State, const unsigned short *_First1, const unsigned short *_Last1, const unsigned short *&
#line 2122
_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2124
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 2125
} 
#line 2127
result unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2129
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 2130
} 
#line 2132
int length(mbstate_t &_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 2135
return this->do_length(_State, _First1, _Last1, _Count); 
#line 2136
} 
#line 2138
static locale::id id; 
#line 2140
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { 
#line 2141
{ _Locinfo _Lobj; 
#line 2142
this->_Init(_Lobj); 
#line 2143
} 
#line 2144
} 
#line 2146
explicit codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) { 
#line 2147
this->_Init(_Lobj); 
#line 2148
} 
#line 2150
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 2152
if (_Ppf && (!(*_Ppf))) { 
#line 2153
(*_Ppf) = (new std::codecvt< unsigned short, char, _Mbstatet> (((_Locinfo)(_Ploc->c_str())))); 
#line 2154
}  
#line 2156
return 2; 
#line 2157
} 
#line 2160
protected: virtual ~codecvt() noexcept { } 
#line 2162
void _Init(const _Locinfo &_Lobj) { 
#line 2163
(_Cvt) = _Lobj._Getcvt(); 
#line 2164
} 
#line 2166
virtual result do_in(mbstate_t &, const char *_First1, const char *_Last1, const char *&_Mid1, unsigned short *
#line 2167
_First2, unsigned short *_Last2, unsigned short *&_Mid2) const { 
#line 2169
mbstate_t _Mystate{}; 
#line 2170
_Adl_verify_range(_First1, _Last1); 
#line 2171
_Adl_verify_range(_First2, _Last2); 
#line 2172
_Mid1 = _First1; 
#line 2173
_Mid2 = _First2; 
#line 2174
for (; ;) { 
#line 2175
if (_Mid1 == _Last1) { 
#line 2176
return ok; 
#line 2177
}  
#line 2179
if (_Mid2 == _Last2) { 
#line 2180
return partial; 
#line 2181
}  
#line 2183
int _Bytes = _Mbrtowc(reinterpret_cast< __wchar_t *>(_Mid2), _Mid1, static_cast< size_t>(_Last1 - _Mid1), &_Mystate, &(_Cvt)); 
#line 2185
switch (_Bytes) { 
#line 2186
case -2:  
#line 2187
return partial; 
#line 2189
case -1:  
#line 2190
return error; 
#line 2192
case 0:  
#line 2193
_Bytes = 1; 
#line 2196
default:  
#line 2197
_Mid1 += _Bytes; 
#line 2198
++_Mid2; 
#line 2199
break; 
#line 2200
}  
#line 2201
}  
#line 2202
} 
#line 2204
virtual result do_out(mbstate_t &_State, const unsigned short *_First1, const unsigned short *
#line 2205
_Last1, const unsigned short *&_Mid1, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2207
_Adl_verify_range(_First1, _Last1); 
#line 2208
_Adl_verify_range(_First2, _Last2); 
#line 2209
_Mid1 = _First1; 
#line 2210
_Mid2 = _First2; 
#line 2211
int _Bytes; 
#line 2213
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 2214
if ((5) <= (_Last2 - _Mid2)) { 
#line 2215
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 2216
return error; 
#line 2217
} else { 
#line 2218
++_Mid1; 
#line 2219
_Mid2 += _Bytes; 
#line 2220
}  
#line 2221
} else { 
#line 2222
char _Buf[5]; 
#line 2223
mbstate_t _Stsave = _State; 
#line 2225
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 2226
return error; 
#line 2227
} else { if ((_Last2 - _Mid2) < _Bytes) { 
#line 2228
_State = _Stsave; 
#line 2229
break; 
#line 2230
} else { 
#line 2231
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2232
++_Mid1; 
#line 2233
_Mid2 += _Bytes; 
#line 2234
}  }  
#line 2235
}  
#line 2236
}  
#line 2238
return (_Mid1 == _Last1) ? ok : partial; 
#line 2239
} 
#line 2241
virtual result do_unshift(mbstate_t &_State, char *_First2, char *_Last2, char *&_Mid2) const { 
#line 2243
_Adl_verify_range(_First2, _Last2); 
#line 2244
_Mid2 = _First2; 
#line 2245
result _Ans = (ok); 
#line 2246
int _Bytes; 
#line 2247
char _Buf[5]; 
#line 2248
mbstate_t _Stsave = _State; 
#line 2250
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 2251
_Ans = (error); 
#line 2252
} else { if ((_Last2 - _Mid2) < (--_Bytes)) { 
#line 2253
_State = _Stsave; 
#line 2254
_Ans = (partial); 
#line 2255
} else { if (0 < _Bytes) { 
#line 2256
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2257
_Mid2 += _Bytes; 
#line 2258
}  }  }  
#line 2260
return _Ans; 
#line 2261
} 
#line 2263
virtual int do_length(mbstate_t &
#line 2264
_State, const char *_First1, const char *_Last1, size_t _Count) const { 
#line 2267
_Adl_verify_range(_First1, _Last1); 
#line 2268
const auto _Old_first1 = _First1; 
#line 2270
for (; (_Count > (0U)) && (_First1 != _Last1); --_Count) { 
#line 2271
__wchar_t _Ch; 
#line 2272
int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast< size_t>(_Last1 - _First1), &_State, &(_Cvt)); 
#line 2273
if (_Bytes < 0) { 
#line 2274
break; 
#line 2275
}  
#line 2277
if (_Bytes == 0) { 
#line 2278
_Bytes = 1; 
#line 2279
}  
#line 2282
_First1 += _Bytes; 
#line 2283
}  
#line 2285
return static_cast< int>((::std::min)(_First1 - _Old_first1, (ptrdiff_t)2147483647)); 
#line 2286
} 
#line 2288
virtual bool do_always_noconv() const noexcept override { 
#line 2290
return false; 
#line 2291
} 
#line 2293
virtual int do_max_length() const noexcept override { 
#line 2295
return static_cast< int>((_Cvt)._Mbcurmax); 
#line 2296
} 
#line 2298
virtual int do_encoding() const noexcept override { 
#line 2300
return ((_Cvt)._Mbcurmax) == 1U; 
#line 2301
} 
#line 2304
private: _Locinfo::_Cvtvec _Cvt; 
#line 2305
}; 
#line 2308 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
template < class _Elem, class _Byte, class _Statype >
class codecvt_byname : public codecvt < _Elem, _Byte, _Statype > {
public :
    static_assert ( ! 0
                      || _Is_any_of_v < codecvt_byname,



                          codecvt_byname < char, char, mbstate_t >, codecvt_byname < wchar_t, char, mbstate_t >>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORC" "E_FACET_SPECIALIZATIONS=0 to suppress this diagnostic." );

    explicit codecvt_byname ( const char * _Locname, size_t _Refs = 0 )
        : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Locname ), _Refs ) { }

    explicit codecvt_byname ( const string & _Str, size_t _Refs = 0 )
        : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Str . c_str ( ) ), _Refs ) { }

protected :
    virtual ~ codecvt_byname ( ) noexcept { }
};
#line 2339
struct ctype_base : public locale::facet { 
#line 2340
enum { 
#line 2341
alnum = (((4 | 2) | 1) | 256), 
#line 2342
alpha = ((2 | 1) | 256), 
#line 2343
cntrl = 32, 
#line 2344
digit = 4, 
#line 2345
graph = ((((4 | 2) | 16) | 1) | 256), 
#line 2346
lower = 2, 
#line 2347
print = ((((((4 | 2) | 16) | 64) | 1) | 256) | 128), 
#line 2348
punct = 16, 
#line 2349
space = (8 | 64), 
#line 2350
upper = 1, 
#line 2351
xdigit = 128, 
#line 2352
blank = (8 | 64)
#line 2353
}; 
#line 2354
using mask = short; 
#line 2356
ctype_base(size_t _Refs = 0) : locale::facet(_Refs) { } 
#line 2358
virtual ~ctype_base() noexcept { } 
#line 2359
}; 
#line 2371
template < class _Elem >
class ctype : public ctype_base {
public :

    static_assert ( ! 0 || _Always_false < _Elem >, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORC" "E_FACET_SPECIALIZATIONS=0 to suppress this diagnostic." );

    using char_type = _Elem;

    bool is ( mask _Maskval, _Elem _Ch ) const {
        return do_is ( _Maskval, _Ch );
    }

    const _Elem * is ( const _Elem * _First, const _Elem * _Last,
        mask * _Dest ) const {
        return do_is ( _First, _Last, _Dest );
    }

    const _Elem * scan_is ( mask _Maskval, const _Elem * _First,
        const _Elem * _Last ) const {
        return do_scan_is ( _Maskval, _First, _Last );
    }

    const _Elem * scan_not ( mask _Maskval, const _Elem * _First,
        const _Elem * _Last ) const {
        return do_scan_not ( _Maskval, _First, _Last );
    }

    _Elem tolower ( _Elem _Ch ) const {
        return do_tolower ( _Ch );
    }

    const _Elem * tolower (
        _Elem * _First, const _Elem * _Last ) const {
        return do_tolower ( _First, _Last );
    }

    _Elem toupper ( _Elem _Ch ) const {
        return do_toupper ( _Ch );
    }

    const _Elem * toupper (
        _Elem * _First, const _Elem * _Last ) const {
        return do_toupper ( _First, _Last );
    }

    _Elem widen ( char _Byte ) const {
        return do_widen ( _Byte );
    }

    const char * widen ( const char * _First, const char * _Last,
        _Elem * _Dest ) const {
        return do_widen ( _First, _Last, _Dest );
    }

    char narrow ( _Elem _Ch, char _Dflt = '\000' ) const {
        return do_narrow ( _Ch, _Dflt );
    }

    const _Elem * narrow ( const _Elem * _First, const _Elem * _Last, char _Dflt,
        char * _Dest ) const {
        return do_narrow ( _First, _Last, _Dflt, _Dest );
    }

     static locale :: id id;

    explicit ctype ( size_t _Refs = 0 ) : ctype_base ( _Refs ) {
        { _Locinfo _Lobj;
        _Init ( _Lobj );
        }
    }

     ctype ( const _Locinfo & _Lobj, size_t _Refs = 0 ) : ctype_base ( _Refs ) {
        _Init ( _Lobj );
    }

    static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {
        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new ctype < _Elem > ( _Locinfo ( _Ploc -> c_str ( ) ) );
        }

        return 2;
    }

protected :
    virtual ~ ctype ( ) noexcept {
        if ( _Ctype . _Delfl ) {
            :: free ( const_cast < short * > ( _Ctype . _Table ) );
        }

        :: free ( _Ctype . _LocaleName );
    }

    void _Init ( const _Locinfo & _Lobj ) {
        _Ctype = _Lobj . _Getctype ( );
        _Cvt = _Lobj . _Getcvt ( );
    }

    virtual bool do_is (
        mask _Maskval, _Elem _Ch ) const {
        return ( _Ctype . _Table [ static_cast < unsigned char > ( narrow ( _Ch ) ) ] & _Maskval ) != 0;
    }

    virtual const _Elem * do_is ( const _Elem * _First, const _Elem * _Last,
        mask * _Dest ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First, ++ _Dest ) {
            * _Dest = _Ctype . _Table [ static_cast < unsigned char > ( narrow ( * _First ) ) ];
        }

        return _First;
    }

    virtual const _Elem * do_scan_is ( mask _Maskval, const _Elem * _First,
        const _Elem * _Last ) const {
        _Adl_verify_range ( _First, _Last );
        while ( _First != _Last && ! is ( _Maskval, * _First ) ) {
            ++ _First;
        }

        return _First;
    }

    virtual const _Elem * do_scan_not ( mask _Maskval, const _Elem * _First,
        const _Elem * _Last ) const {
        _Adl_verify_range ( _First, _Last );
        while ( _First != _Last && is ( _Maskval, * _First ) ) {
            ++ _First;
        }

        return _First;
    }

    virtual _Elem do_tolower ( _Elem _Ch ) const {
        unsigned char _Byte = static_cast < unsigned char > ( narrow ( _Ch, '\000' ) );
        if ( _Byte == '\000' ) {
            return _Ch;
        }

        return widen ( static_cast < char > ( _Tolower ( _Byte, & _Ctype ) ) );
    }

    virtual const _Elem * do_tolower ( _Elem * _First,
        const _Elem * _Last ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First ) {
            unsigned char _Byte = static_cast < unsigned char > ( narrow ( * _First, '\000' ) );
            if ( _Byte != '\000' ) {
                * _First = ( widen ( static_cast < char > ( _Tolower ( _Byte, & _Ctype ) ) ) );
            }
        }
        return _First;
    }

    virtual _Elem do_toupper ( _Elem _Ch ) const {
        unsigned char _Byte = static_cast < unsigned char > ( narrow ( _Ch, '\000' ) );
        if ( _Byte == '\000' ) {
            return _Ch;
        }

        return widen ( static_cast < char > ( _Toupper ( _Byte, & _Ctype ) ) );
    }

    virtual const _Elem * do_toupper ( _Elem * _First,
        const _Elem * _Last ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First ) {
            unsigned char _Byte = static_cast < unsigned char > ( narrow ( * _First, '\000' ) );
            if ( _Byte != '\000' ) {
                * _First = ( widen ( static_cast < char > ( _Toupper ( _Byte, & _Ctype ) ) ) );
            }
        }

        return _First;
    }

    virtual _Elem do_widen ( char _Byte ) const {
        return _Maklocchr ( _Byte, static_cast < _Elem * > ( nullptr ), _Cvt );
    }

    virtual const char * do_widen (
        const char * _First, const char * _Last, _Elem * _Dest ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First, ++ _Dest ) {
            * _Dest = _Maklocchr ( * _First, static_cast < _Elem * > ( nullptr ), _Cvt );
        }

        return _First;
    }

    char _Donarrow ( _Elem _Ch, char _Dflt ) const {
        char _Byte;
        if ( _Ch == _Elem { } ) {
            return '\000';
        }

        if ( ( _Byte = _Maklocbyte ( _Ch, _Cvt ) ) == '\000' ) {
            return _Dflt;
        }

        return _Byte;
    }

    virtual char do_narrow ( _Elem _Ch, char _Dflt ) const {
        return _Donarrow ( _Ch, _Dflt );
    }

    virtual const _Elem * do_narrow ( const _Elem * _First, const _Elem * _Last, char _Dflt,
        char * _Dest ) const {
        _Adl_verify_range ( _First, _Last );
        for (; _First != _Last; ++ _First, ++ _Dest ) {
            * _Dest = _Donarrow ( * _First, _Dflt );
        }

        return _First;
    }

private :
    _Locinfo :: _Ctypevec _Ctype;
    _Locinfo :: _Cvtvec _Cvt;
};
#line 2597
template< class _Elem> locale::id 
#line 2598
ctype< _Elem> ::id; 
#line 2605
template<> class ctype< char>  : public ctype_base { 
#line 2607
public: using _Elem = char; 
#line 2608
using char_type = _Elem; 
#line 2610
bool is(mask _Maskval, _Elem _Ch) const { 
#line 2611
return ((((_Ctype)._Table)[static_cast< unsigned char>(_Ch)]) & _Maskval) != 0; 
#line 2612
} 
#line 2614
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2615
_Dest) const { 
#line 2616
_Adl_verify_range(_First, _Last); 
#line 2617
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2618
(*_Dest) = (((_Ctype)._Table)[static_cast< unsigned char>(*_First)]); 
#line 2619
}  
#line 2621
return _First; 
#line 2622
} 
#line 2624
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2625
_Last) const { 
#line 2626
_Adl_verify_range(_First, _Last); 
#line 2627
while ((_First != _Last) && (!this->is(_Maskval, *_First))) { 
#line 2628
++_First; 
#line 2629
}  
#line 2631
return _First; 
#line 2632
} 
#line 2634
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2635
_Last) const { 
#line 2636
_Adl_verify_range(_First, _Last); 
#line 2637
while ((_First != _Last) && this->is(_Maskval, *_First)) { 
#line 2638
++_First; 
#line 2639
}  
#line 2641
return _First; 
#line 2642
} 
#line 2644
_Elem tolower(_Elem _Ch) const { 
#line 2645
return this->do_tolower(_Ch); 
#line 2646
} 
#line 2648
const _Elem *tolower(_Elem *
#line 2649
_First, const _Elem *_Last) const { 
#line 2650
return this->do_tolower(_First, _Last); 
#line 2651
} 
#line 2653
_Elem toupper(_Elem _Ch) const { 
#line 2654
return this->do_toupper(_Ch); 
#line 2655
} 
#line 2657
const _Elem *toupper(_Elem *
#line 2658
_First, const _Elem *_Last) const { 
#line 2659
return this->do_toupper(_First, _Last); 
#line 2660
} 
#line 2662
_Elem widen(char _Byte) const { 
#line 2663
return this->do_widen(_Byte); 
#line 2664
} 
#line 2666
const _Elem *widen(const char *_First, const char *_Last, _Elem *
#line 2667
_Dest) const { 
#line 2668
return this->do_widen(_First, _Last, _Dest); 
#line 2669
} 
#line 2671
_Elem narrow(_Elem _Ch, char _Dflt = '\000') const { 
#line 2672
return this->do_narrow(_Ch, _Dflt); 
#line 2673
} 
#line 2675
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 2676
_Dest) const { 
#line 2677
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2678
} 
#line 2680
static locale::id id; 
#line 2682
explicit ctype(const mask *_Table = 0, bool _Deletetable = false, size_t 
#line 2683
_Refs = 0) : ctype_base(_Refs) 
#line 2684
{ 
#line 2685
{ _Locinfo _Lobj; 
#line 2686
this->_Init(_Lobj); 
#line 2687
} 
#line 2689
this->_Tidy(); 
#line 2690
if (_Table) { 
#line 2691
((_Ctype)._Table) = _Table; 
#line 2692
((_Ctype)._Delfl) = (_Deletetable ? -1 : 0); 
#line 2693
} else { 
#line 2694
((_Ctype)._Table) = classic_table(); 
#line 2695
((_Ctype)._Delfl) = 0; 
#line 2696
}  
#line 2697
} 
#line 2699
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) { 
#line 2700
this->_Init(_Lobj); 
#line 2701
} 
#line 2703
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 2704
if (_Ppf && (!(*_Ppf))) { 
#line 2705
(*_Ppf) = (new std::ctype< char> (((_Locinfo)(_Ploc->c_str())))); 
#line 2706
}  
#line 2708
return 2; 
#line 2709
} 
#line 2711
const mask *table() const noexcept { 
#line 2712
return (_Ctype)._Table; 
#line 2713
} 
#line 2715
static const mask *__cdecl classic_table() noexcept { 
#line 2716
return ::std::use_facet< std::ctype< char> > (locale::classic()).table(); 
#line 2717
} 
#line 2719
static const size_t table_size = (1 << 8); 
#line 2722
protected: virtual ~ctype() noexcept { 
#line 2723
this->_Tidy(); 
#line 2724
} 
#line 2726
void _Init(const _Locinfo &_Lobj) { 
#line 2727
(_Ctype) = _Lobj._Getctype(); 
#line 2728
} 
#line 2730
void _Tidy() noexcept { 
#line 2731
if (0 < ((_Ctype)._Delfl)) { 
#line 2732
::free(const_cast< short *>((_Ctype)._Table)); 
#line 2733
} else { if (((_Ctype)._Delfl) < 0) { 
#line 2734
delete [] ((_Ctype)._Table); 
#line 2735
}  }  
#line 2737
::free((_Ctype)._LocaleName); 
#line 2738
} 
#line 2740
virtual _Elem do_tolower(_Elem _Ch) const { 
#line 2741
return static_cast< _Elem>(_Tolower(static_cast< unsigned char>(_Ch), &(_Ctype))); 
#line 2742
} 
#line 2744
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2745
_Last) const { 
#line 2746
_Adl_verify_range(_First, _Last); 
#line 2747
for (; _First != _Last; ++_First) { 
#line 2748
(*_First) = (static_cast< _Elem>(_Tolower(static_cast< unsigned char>(*_First), &(_Ctype)))); 
#line 2749
}  
#line 2751
return _First; 
#line 2752
} 
#line 2754
virtual _Elem do_toupper(_Elem _Ch) const { 
#line 2755
return static_cast< _Elem>(_Toupper(static_cast< unsigned char>(_Ch), &(_Ctype))); 
#line 2756
} 
#line 2758
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2759
_Last) const { 
#line 2760
_Adl_verify_range(_First, _Last); 
#line 2761
for (; _First != _Last; ++_First) { 
#line 2762
(*_First) = (static_cast< _Elem>(_Toupper(static_cast< unsigned char>(*_First), &(_Ctype)))); 
#line 2763
}  
#line 2765
return _First; 
#line 2766
} 
#line 2768
virtual _Elem do_widen(char _Byte) const { 
#line 2769
return _Byte; 
#line 2770
} 
#line 2772
virtual const _Elem *do_widen(const char *
#line 2773
_First, const char *_Last, _Elem *_Dest) const { 
#line 2774
_Adl_verify_range(_First, _Last); 
#line 2775
::memcpy(_Dest, _First, static_cast< size_t>(_Last - _First)); 
#line 2776
return _Last; 
#line 2777
} 
#line 2779
virtual _Elem do_narrow(_Elem _Ch, char) const { 
#line 2780
return _Ch; 
#line 2781
} 
#line 2783
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last, char, char *
#line 2784
_Dest) const { 
#line 2785
_Adl_verify_range(_First, _Last); 
#line 2786
::memcpy(_Dest, _First, static_cast< size_t>(_Last - _First)); 
#line 2787
return _Last; 
#line 2788
} 
#line 2791
private: _Locinfo::_Ctypevec _Ctype; 
#line 2792
}; 
#line 2795
template<> class ctype< __wchar_t>  : public ctype_base { 
#line 2798
public: using _Elem = __wchar_t; 
#line 2799
using char_type = _Elem; 
#line 2801
bool is(mask _Maskval, _Elem _Ch) const { 
#line 2802
return this->do_is(_Maskval, _Ch); 
#line 2803
} 
#line 2805
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2806
_Dest) const { 
#line 2807
return this->do_is(_First, _Last, _Dest); 
#line 2808
} 
#line 2810
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2811
_Last) const { 
#line 2812
return this->do_scan_is(_Maskval, _First, _Last); 
#line 2813
} 
#line 2815
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2816
_Last) const { 
#line 2817
return this->do_scan_not(_Maskval, _First, _Last); 
#line 2818
} 
#line 2820
_Elem tolower(_Elem _Ch) const { 
#line 2821
return this->do_tolower(_Ch); 
#line 2822
} 
#line 2824
const _Elem *tolower(_Elem *
#line 2825
_First, const _Elem *_Last) const { 
#line 2826
return this->do_tolower(_First, _Last); 
#line 2827
} 
#line 2829
_Elem toupper(_Elem _Ch) const { 
#line 2830
return this->do_toupper(_Ch); 
#line 2831
} 
#line 2833
const _Elem *toupper(_Elem *
#line 2834
_First, const _Elem *_Last) const { 
#line 2835
return this->do_toupper(_First, _Last); 
#line 2836
} 
#line 2838
_Elem widen(char _Byte) const { 
#line 2839
return this->do_widen(_Byte); 
#line 2840
} 
#line 2842
const char *widen(const char *_First, const char *_Last, _Elem *
#line 2843
_Dest) const { 
#line 2844
return this->do_widen(_First, _Last, _Dest); 
#line 2845
} 
#line 2847
char narrow(_Elem _Ch, char _Dflt = '\000') const { 
#line 2848
return this->do_narrow(_Ch, _Dflt); 
#line 2849
} 
#line 2851
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 2852
_Dest) const { 
#line 2853
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2854
} 
#line 2856
static locale::id id; 
#line 2858
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) { 
#line 2859
{ _Locinfo _Lobj; 
#line 2860
this->_Init(_Lobj); 
#line 2861
} 
#line 2862
} 
#line 2864
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) { 
#line 2865
this->_Init(_Lobj); 
#line 2866
} 
#line 2868
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 2869
if (_Ppf && (!(*_Ppf))) { 
#line 2870
(*_Ppf) = (new std::ctype< __wchar_t> (((_Locinfo)(_Ploc->c_str())))); 
#line 2871
}  
#line 2873
return 2; 
#line 2874
} 
#line 2877
protected: virtual ~ctype() noexcept { 
#line 2878
if ((_Ctype)._Delfl) { 
#line 2879
::free(const_cast< short *>((_Ctype)._Table)); 
#line 2880
}  
#line 2882
::free((_Ctype)._LocaleName); 
#line 2883
} 
#line 2885
void _Init(const _Locinfo &_Lobj) { 
#line 2886
(_Ctype) = _Lobj._Getctype(); 
#line 2887
(_Cvt) = _Lobj._Getcvt(); 
#line 2888
} 
#line 2890
virtual bool do_is(mask 
#line 2891
_Maskval, _Elem _Ch) const { 
#line 2892
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 2893
} 
#line 2895
virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last, mask *
#line 2896
_Dest) const { 
#line 2897
_Adl_verify_range(_First, _Last); 
#line 2898
return ::_Getwctypes(_First, _Last, _Dest, &(_Ctype)); 
#line 2899
} 
#line 2901
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2902
_Last) const { 
#line 2903
_Adl_verify_range(_First, _Last); 
#line 2904
while ((_First != _Last) && (!this->is(_Maskval, *_First))) { 
#line 2905
++_First; 
#line 2906
}  
#line 2908
return _First; 
#line 2909
} 
#line 2911
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2912
_Last) const { 
#line 2913
_Adl_verify_range(_First, _Last); 
#line 2914
while ((_First != _Last) && this->is(_Maskval, *_First)) { 
#line 2915
++_First; 
#line 2916
}  
#line 2918
return _First; 
#line 2919
} 
#line 2921
virtual _Elem do_tolower(_Elem _Ch) const { 
#line 2922
return _Towlower(_Ch, &(_Ctype)); 
#line 2923
} 
#line 2925
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2926
_Last) const { 
#line 2927
_Adl_verify_range(_First, _Last); 
#line 2928
for (; _First != _Last; ++_First) { 
#line 2929
(*_First) = _Towlower(*_First, &(_Ctype)); 
#line 2930
}  
#line 2932
return _First; 
#line 2933
} 
#line 2935
virtual _Elem do_toupper(_Elem _Ch) const { 
#line 2936
return _Towupper(_Ch, &(_Ctype)); 
#line 2937
} 
#line 2939
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2940
_Last) const { 
#line 2941
_Adl_verify_range(_First, _Last); 
#line 2942
for (; _First != _Last; ++_First) { 
#line 2943
(*_First) = _Towupper(*_First, &(_Ctype)); 
#line 2944
}  
#line 2946
return _First; 
#line 2947
} 
#line 2949
_Elem _Dowiden(char _Byte) const { 
#line 2950
mbstate_t _Mbst = {}; 
#line 2951
__wchar_t _Wc; 
#line 2952
return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? static_cast< __wchar_t>((wint_t)65535) : _Wc; 
#line 2953
} 
#line 2955
virtual _Elem do_widen(char _Byte) const { 
#line 2956
return this->_Dowiden(_Byte); 
#line 2957
} 
#line 2959
virtual const char *do_widen(const char *
#line 2960
_First, const char *_Last, _Elem *_Dest) const { 
#line 2961
_Adl_verify_range(_First, _Last); 
#line 2962
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2963
(*_Dest) = this->_Dowiden(*_First); 
#line 2964
}  
#line 2966
return _First; 
#line 2967
} 
#line 2969
char _Donarrow(_Elem _Ch, char _Dflt) const { 
#line 2970
char _Buf[5]; 
#line 2971
mbstate_t _Mbst = {}; 
#line 2972
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : (_Buf[0]); 
#line 2973
} 
#line 2975
virtual char do_narrow(_Elem _Ch, char _Dflt) const { 
#line 2976
return this->_Donarrow(_Ch, _Dflt); 
#line 2977
} 
#line 2979
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 2980
_Dest) const { 
#line 2981
_Adl_verify_range(_First, _Last); 
#line 2982
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2983
(*_Dest) = this->_Donarrow(*_First, _Dflt); 
#line 2984
}  
#line 2986
return _First; 
#line 2987
} 
#line 2990
private: _Locinfo::_Ctypevec _Ctype; 
#line 2991
_Locinfo::_Cvtvec _Cvt; 
#line 2992
}; 
#line 2996
template<> class ctype< unsigned short>  : public ctype_base { 
#line 2999
public: using _Elem = unsigned short; 
#line 3000
using char_type = _Elem; 
#line 3002
bool is(mask _Maskval, _Elem _Ch) const { 
#line 3003
return this->do_is(_Maskval, _Ch); 
#line 3004
} 
#line 3006
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 3007
_Dest) const { 
#line 3008
return this->do_is(_First, _Last, _Dest); 
#line 3009
} 
#line 3011
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 3012
_Last) const { 
#line 3013
return this->do_scan_is(_Maskval, _First, _Last); 
#line 3014
} 
#line 3016
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 3017
_Last) const { 
#line 3018
return this->do_scan_not(_Maskval, _First, _Last); 
#line 3019
} 
#line 3021
_Elem tolower(_Elem _Ch) const { 
#line 3022
return this->do_tolower(_Ch); 
#line 3023
} 
#line 3025
const _Elem *tolower(_Elem *
#line 3026
_First, const _Elem *_Last) const { 
#line 3027
return this->do_tolower(_First, _Last); 
#line 3028
} 
#line 3030
_Elem toupper(_Elem _Ch) const { 
#line 3031
return this->do_toupper(_Ch); 
#line 3032
} 
#line 3034
const _Elem *toupper(_Elem *
#line 3035
_First, const _Elem *_Last) const { 
#line 3036
return this->do_toupper(_First, _Last); 
#line 3037
} 
#line 3039
_Elem widen(char _Byte) const { 
#line 3040
return this->do_widen(_Byte); 
#line 3041
} 
#line 3043
const char *widen(const char *_First, const char *_Last, _Elem *
#line 3044
_Dest) const { 
#line 3045
return this->do_widen(_First, _Last, _Dest); 
#line 3046
} 
#line 3048
char narrow(_Elem _Ch, char _Dflt = '\000') const { 
#line 3049
return this->do_narrow(_Ch, _Dflt); 
#line 3050
} 
#line 3052
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 3053
_Dest) const { 
#line 3054
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 3055
} 
#line 3057
static locale::id id; 
#line 3059
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) { 
#line 3060
{ _Locinfo _Lobj; 
#line 3061
this->_Init(_Lobj); 
#line 3062
} 
#line 3063
} 
#line 3065
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) { 
#line 3066
this->_Init(_Lobj); 
#line 3067
} 
#line 3069
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *_Ploc = 0) { 
#line 3070
if (_Ppf && (!(*_Ppf))) { 
#line 3071
(*_Ppf) = (new std::ctype< unsigned short> (((_Locinfo)(_Ploc->c_str())))); 
#line 3072
}  
#line 3074
return 2; 
#line 3075
} 
#line 3078
protected: virtual ~ctype() noexcept { 
#line 3079
if ((_Ctype)._Delfl) { 
#line 3080
::free(const_cast< short *>((_Ctype)._Table)); 
#line 3081
}  
#line 3083
::free((_Ctype)._LocaleName); 
#line 3084
} 
#line 3086
void _Init(const _Locinfo &_Lobj) { 
#line 3087
(_Ctype) = _Lobj._Getctype(); 
#line 3088
(_Cvt) = _Lobj._Getcvt(); 
#line 3089
} 
#line 3091
virtual bool do_is(mask 
#line 3092
_Maskval, _Elem _Ch) const { 
#line 3093
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 3094
} 
#line 3096
virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last, mask *
#line 3097
_Dest) const { 
#line 3098
_Adl_verify_range(_First, _Last); 
#line 3099
return reinterpret_cast< const _Elem *>(::_Getwctypes(reinterpret_cast< const __wchar_t *>(_First), reinterpret_cast< const __wchar_t *>(_Last), _Dest, &(_Ctype))); 
#line 3101
} 
#line 3103
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 3104
_Last) const { 
#line 3105
_Adl_verify_range(_First, _Last); 
#line 3106
while ((_First != _Last) && (!this->is(_Maskval, *_First))) { 
#line 3107
++_First; 
#line 3108
}  
#line 3110
return _First; 
#line 3111
} 
#line 3113
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 3114
_Last) const { 
#line 3115
_Adl_verify_range(_First, _Last); 
#line 3116
while ((_First != _Last) && this->is(_Maskval, *_First)) { 
#line 3117
++_First; 
#line 3118
}  
#line 3120
return _First; 
#line 3121
} 
#line 3123
virtual _Elem do_tolower(_Elem _Ch) const { 
#line 3124
return _Towlower(_Ch, &(_Ctype)); 
#line 3125
} 
#line 3127
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 3128
_Last) const { 
#line 3129
_Adl_verify_range(_First, _Last); 
#line 3130
for (; _First != _Last; ++_First) { 
#line 3131
(*_First) = (_Towlower(*_First, &(_Ctype))); 
#line 3132
}  
#line 3134
return _First; 
#line 3135
} 
#line 3137
virtual _Elem do_toupper(_Elem _Ch) const { 
#line 3138
return _Towupper(_Ch, &(_Ctype)); 
#line 3139
} 
#line 3141
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 3142
_Last) const { 
#line 3143
_Adl_verify_range(_First, _Last); 
#line 3144
for (; _First != _Last; ++_First) { 
#line 3145
(*_First) = (_Towupper(*_First, &(_Ctype))); 
#line 3146
}  
#line 3148
return _First; 
#line 3149
} 
#line 3151
_Elem _Dowiden(char _Byte) const { 
#line 3152
mbstate_t _Mbst = {}; 
#line 3153
unsigned short _Wc; 
#line 3155
if (_Mbrtowc(reinterpret_cast< __wchar_t *>(&_Wc), &_Byte, 1, &_Mbst, &(_Cvt)) < 0) { 
#line 3156
return static_cast< unsigned short>((wint_t)65535); 
#line 3157
}  
#line 3159
return _Wc; 
#line 3160
} 
#line 3162
virtual _Elem do_widen(char _Byte) const { 
#line 3163
return this->_Dowiden(_Byte); 
#line 3164
} 
#line 3166
virtual const char *do_widen(const char *
#line 3167
_First, const char *_Last, _Elem *_Dest) const { 
#line 3168
_Adl_verify_range(_First, _Last); 
#line 3169
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 3170
(*_Dest) = this->_Dowiden(*_First); 
#line 3171
}  
#line 3173
return _First; 
#line 3174
} 
#line 3176
char _Donarrow(_Elem _Ch, char _Dflt) const { 
#line 3177
char _Buf[5]; 
#line 3178
mbstate_t _Mbst = {}; 
#line 3179
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : (_Buf[0]); 
#line 3180
} 
#line 3182
virtual char do_narrow(_Elem _Ch, char _Dflt) const { 
#line 3183
return this->_Donarrow(_Ch, _Dflt); 
#line 3184
} 
#line 3186
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last, char _Dflt, char *
#line 3187
_Dest) const { 
#line 3188
_Adl_verify_range(_First, _Last); 
#line 3189
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 3190
(*_Dest) = this->_Donarrow(*_First, _Dflt); 
#line 3191
}  
#line 3193
return _First; 
#line 3194
} 
#line 3197
private: _Locinfo::_Ctypevec _Ctype; 
#line 3198
_Locinfo::_Cvtvec _Cvt; 
#line 3199
}; 
#line 3202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
template < class _Elem >
class ctype_byname : public ctype < _Elem > {
public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t >, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORC" "E_FACET_SPECIALIZATIONS=0 to suppress this diagnostic." );

    explicit ctype_byname ( const char * _Locname, size_t _Refs = 0 )
        : ctype < _Elem > ( _Locinfo ( _Locname ), _Refs ) { }

    explicit ctype_byname ( const string & _Str, size_t _Refs = 0 )
        : ctype < _Elem > ( _Locinfo ( _Str . c_str ( ) ), _Refs ) { }

protected :
    virtual ~ ctype_byname ( ) noexcept { }
};
#line 3217
enum class _Case_sensitive: bool { _Nope, _Yes}; 
#line 3219
template < class _InIt, class _Elem >
int __cdecl _Getloctxt (
    _InIt & _First, _InIt & _Last, size_t _Numfields, const _Elem * _Ptr, const _Case_sensitive _Matching ) {

    for ( size_t _Off = 0; _Ptr [ _Off ] != _Elem { }; ++ _Off ) {
        if ( _Ptr [ _Off ] == _Ptr [ 0 ] ) {
            ++ _Numfields;
        }
    }

    string _Str ( _Numfields, '\000' );
    const ctype < _Elem > & _CType = :: std :: use_facet < ctype < _Elem >> ( locale { } );

    int _Ans = - 2;
    for ( size_t _Column = 1;; ++ _Column, ( void ) ++ _First, _Ans = - 1 ) {
        bool _Prefix = false;
        size_t _Off = 0;
        size_t _Field = 0;

        for (; _Field < _Numfields; ++ _Field ) {
            while ( _Ptr [ _Off ] != _Elem { } && _Ptr [ _Off ] != _Ptr [ 0 ] ) {
                ++ _Off;
            }

            if ( _Str [ _Field ] != '\000' ) {
                _Off += _Str [ _Field ];
            } else if ( _Ptr [ _Off += _Column ] == _Ptr [ 0 ]
                       || _Ptr [ _Off ] == _Elem { } ) {
                _Str [ _Field ] = static_cast < char > ( _Column < 127 ? _Column : 127 );
                _Ans = static_cast < int > ( _Field );
            } else if ( _First == _Last
                       || ( _Matching == _Case_sensitive :: _Yes
                               ? _Ptr [ _Off ] != * _First
                               : _CType . tolower ( _Ptr [ _Off ] ) != _CType . tolower ( static_cast < _Elem > ( * _First ) ) ) ) {
                _Str [ _Field ] = static_cast < char > ( _Column < 127 ? _Column : 127 );
            } else {
                _Prefix = true;
            }
        }

        if ( ! _Prefix || _First == _Last ) {
            break;
        }
    }
    return _Ans;
}
#line 3271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
}
#line 3274
#pragma warning(pop)
#pragma pack ( pop )
#line 3278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 22
namespace std { 
#line 23
template< class _Dummy> 
#line 24
class _Iosb { 
#line 26
public: enum _Dummy_enum { _Dummy_enum_val = 1}; 
#line 27
enum _Fmtflags { 
#line 28
_Fmtmask = 65535, 
#line 29
_Fmtzero = 0
#line 30
}; 
#line 32
static constexpr _Fmtflags skipws = (static_cast< _Fmtflags>(1)); 
#line 33
static constexpr _Fmtflags unitbuf = (static_cast< _Fmtflags>(2)); 
#line 34
static constexpr _Fmtflags uppercase = (static_cast< _Fmtflags>(4)); 
#line 35
static constexpr _Fmtflags showbase = (static_cast< _Fmtflags>(8)); 
#line 36
static constexpr _Fmtflags showpoint = (static_cast< _Fmtflags>(16)); 
#line 37
static constexpr _Fmtflags showpos = (static_cast< _Fmtflags>(32)); 
#line 38
static constexpr _Fmtflags left = (static_cast< _Fmtflags>(64)); 
#line 39
static constexpr _Fmtflags right = (static_cast< _Fmtflags>(128)); 
#line 40
static constexpr _Fmtflags internal = (static_cast< _Fmtflags>(256)); 
#line 41
static constexpr _Fmtflags dec = (static_cast< _Fmtflags>(512)); 
#line 42
static constexpr _Fmtflags oct = (static_cast< _Fmtflags>(1024)); 
#line 43
static constexpr _Fmtflags hex = (static_cast< _Fmtflags>(2048)); 
#line 44
static constexpr _Fmtflags scientific = (static_cast< _Fmtflags>(4096)); 
#line 45
static constexpr _Fmtflags fixed = (static_cast< _Fmtflags>(8192)); 
#line 47
static constexpr _Fmtflags hexfloat = (static_cast< _Fmtflags>(12288)); 
#line 49
static constexpr _Fmtflags boolalpha = (static_cast< _Fmtflags>(16384)); 
#line 50
static constexpr _Fmtflags _Stdio = (static_cast< _Fmtflags>(32768)); 
#line 51
static constexpr _Fmtflags adjustfield = (static_cast< _Fmtflags>(448)); 
#line 52
static constexpr _Fmtflags basefield = (static_cast< _Fmtflags>(3584)); 
#line 53
static constexpr _Fmtflags floatfield = (static_cast< _Fmtflags>(12288)); 
#line 55
enum _Iostate { 
#line 56
_Statmask = 23
#line 57
}; 
#line 59
static constexpr _Iostate goodbit = (static_cast< _Iostate>(0)); 
#line 60
static constexpr _Iostate eofbit = (static_cast< _Iostate>(1)); 
#line 61
static constexpr _Iostate failbit = (static_cast< _Iostate>(2)); 
#line 62
static constexpr _Iostate badbit = (static_cast< _Iostate>(4)); 
#line 64
enum _Openmode { 
#line 65
_Openmask = 255
#line 66
}; 
#line 68
static constexpr _Openmode in = (static_cast< _Openmode>(1)); 
#line 69
static constexpr _Openmode out = (static_cast< _Openmode>(2)); 
#line 70
static constexpr _Openmode ate = (static_cast< _Openmode>(4)); 
#line 71
static constexpr _Openmode app = (static_cast< _Openmode>(8)); 
#line 72
static constexpr _Openmode trunc = (static_cast< _Openmode>(16)); 
#line 73
static constexpr _Openmode _Nocreate = (static_cast< _Openmode>(64)); 
#line 74
static constexpr _Openmode _Noreplace = (static_cast< _Openmode>(128)); 
#line 75
static constexpr _Openmode binary = (static_cast< _Openmode>(32)); 
#line 77
enum _Seekdir { 
#line 78
_Seekbeg, 
#line 79
_Seekcur, 
#line 80
_Seekend
#line 81
}; 
#line 83
static constexpr _Seekdir beg = (_Seekbeg); 
#line 84
static constexpr _Seekdir cur = (_Seekcur); 
#line 85
static constexpr _Seekdir end = (_Seekend); 
#line 87
enum { 
#line 88
_Openprot = 64
#line 89
}; 
#line 91
static constexpr int _Default_open_prot = 64; 
#line 92
}; 
#line 94
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::skipws; 
#line 96
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::unitbuf; 
#line 98
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::uppercase; 
#line 100
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::showbase; 
#line 102
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::showpoint; 
#line 104
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::showpos; 
#line 106
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::left; 
#line 108
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::right; 
#line 110
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::internal; 
#line 112
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::dec; 
#line 114
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::oct; 
#line 116
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::hex; 
#line 118
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::scientific; 
#line 120
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::fixed; 
#line 123
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::hexfloat; 
#line 126
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::boolalpha; 
#line 128
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::_Stdio; 
#line 130
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::adjustfield; 
#line 132
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::basefield; 
#line 134
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::floatfield; 
#line 137
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Iostate _Iosb< _Dummy> ::goodbit; 
#line 139
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Iostate _Iosb< _Dummy> ::eofbit; 
#line 141
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Iostate _Iosb< _Dummy> ::failbit; 
#line 143
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Iostate _Iosb< _Dummy> ::badbit; 
#line 146
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::in; 
#line 148
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::out; 
#line 150
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::ate; 
#line 152
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::app; 
#line 154
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::trunc; 
#line 156
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::_Nocreate; 
#line 158
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::_Noreplace; 
#line 160
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::binary; 
#line 163
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Seekdir _Iosb< _Dummy> ::beg; 
#line 165
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Seekdir _Iosb< _Dummy> ::cur; 
#line 167
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Seekdir _Iosb< _Dummy> ::end; 
#line 170
class ios_base : public _Iosb< int>  { 
#line 172
public: using fmtflags = int; 
#line 173
using iostate = int; 
#line 174
using openmode = int; 
#line 175
using seekdir = int; 
#line 178
using streamoff = std::streamoff; 
#line 179
using streampos = std::streampos; 
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
enum event { 
#line 183
erase_event, 
#line 184
imbue_event, 
#line 185
copyfmt_event
#line 186
}; 
#line 188
using event_callback = void (__cdecl *)(event, ios_base &, int); 
#line 191
using io_state = unsigned; 
#line 192
using open_mode = unsigned; 
#line 193
using seek_dir = unsigned; 
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
class failure : public system_error { 
#line 198
public: explicit failure(const string &_Message, const error_code &_Errcode = make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 199
{ } 
#line 201
explicit failure(const char *_Message, const error_code &_Errcode = make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 202
{ } 
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
}; 
#line 212
class Init { 
#line 214
public: Init() { 
#line 215
_Init_ctor(this); 
#line 216
} 
#line 218
~Init() noexcept { 
#line 219
_Init_dtor(this); 
#line 220
} 
#line 223
private: static void __cdecl _Init_ctor(Init *); 
#line 224
static void __cdecl _Init_dtor(Init *); 
#line 226
static int _Init_cnt; 
#line 228
static int &__cdecl _Init_cnt_func(); 
#line 229
}; 
#line 231
explicit operator bool() const { 
#line 232
return !this->fail(); 
#line 233
} 
#line 235
[[nodiscard]] bool operator!() const { 
#line 236
return this->fail(); 
#line 237
} 
#line 239
void clear(iostate _State, bool _Reraise) { 
#line 240
_State &= (_Statmask); 
#line 241
(_Mystate) = _State; 
#line 242
const auto _Filtered = _State & (_Except); 
#line 243
if (_Filtered) { 
#line 244
if (_Reraise) { 
#line 245
throw; 
#line 246
}  
#line 248
const char *_Msg; 
#line 249
if (_Filtered & badbit) { 
#line 250
_Msg = ("ios_base::badbit set"); 
#line 251
} else { if (_Filtered & failbit) { 
#line 252
_Msg = ("ios_base::failbit set"); 
#line 253
} else { 
#line 254
_Msg = ("ios_base::eofbit set"); 
#line 255
}  }  
#line 257
throw ((failure)(_Msg)); 
#line 258
}  
#line 259
} 
#line 261
void clear(iostate _State = goodbit) { 
#line 262
this->clear(_State, false); 
#line 263
} 
#line 266
void clear(io_state _State) { 
#line 267
this->clear(static_cast< iostate>(_State)); 
#line 268
} 
#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
[[nodiscard]] iostate rdstate() const { 
#line 272
return _Mystate; 
#line 273
} 
#line 275
void setstate(iostate 
#line 276
_State, bool _Exreraise) { 
#line 277
this->clear(this->rdstate() | _State, _Exreraise); 
#line 278
} 
#line 280
void setstate(iostate _State) { 
#line 281
this->clear(this->rdstate() | _State, false); 
#line 282
} 
#line 285
void setstate(io_state _State) { 
#line 286
this->setstate(static_cast< iostate>(_State)); 
#line 287
} 
#line 290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
[[nodiscard]] bool good() const { 
#line 291
return this->rdstate() == goodbit; 
#line 292
} 
#line 294
[[nodiscard]] bool eof() const { 
#line 295
return this->rdstate() & eofbit; 
#line 296
} 
#line 298
[[nodiscard]] bool fail() const { 
#line 299
return this->rdstate() & (badbit | failbit); 
#line 300
} 
#line 302
[[nodiscard]] bool bad() const { 
#line 303
return this->rdstate() & badbit; 
#line 304
} 
#line 306
[[nodiscard]] iostate exceptions() const { 
#line 307
return _Except; 
#line 308
} 
#line 310
void exceptions(iostate _Newexcept) { 
#line 311
(_Except) = (_Newexcept & (_Statmask)); 
#line 312
this->clear(this->rdstate()); 
#line 313
} 
#line 316
void exceptions(io_state _State) { 
#line 317
this->exceptions(static_cast< iostate>(_State)); 
#line 318
} 
#line 321 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
[[nodiscard]] fmtflags flags() const { 
#line 322
return _Fmtfl; 
#line 323
} 
#line 325
fmtflags flags(fmtflags _Newfmtflags) { 
#line 326
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 327
(_Fmtfl) = (_Newfmtflags & (_Fmtmask)); 
#line 328
return _Oldfmtflags; 
#line 329
} 
#line 331
fmtflags setf(fmtflags _Newfmtflags) { 
#line 332
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 333
(_Fmtfl) |= (_Newfmtflags & (_Fmtmask)); 
#line 334
return _Oldfmtflags; 
#line 335
} 
#line 337
fmtflags setf(fmtflags 
#line 338
_Newfmtflags, fmtflags _Mask) { 
#line 339
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 340
(_Fmtfl) = ((_Oldfmtflags & (~_Mask)) | ((_Newfmtflags & _Mask) & (_Fmtmask))); 
#line 341
return _Oldfmtflags; 
#line 342
} 
#line 344
void unsetf(fmtflags _Mask) { 
#line 345
(_Fmtfl) &= (~_Mask); 
#line 346
} 
#line 348
[[nodiscard]] streamsize precision() const { 
#line 349
return _Prec; 
#line 350
} 
#line 352
streamsize precision(streamsize _Newprecision) { 
#line 353
const streamsize _Oldprecision = _Prec; 
#line 354
(_Prec) = _Newprecision; 
#line 355
return _Oldprecision; 
#line 356
} 
#line 358
[[nodiscard]] streamsize width() const { 
#line 359
return _Wide; 
#line 360
} 
#line 362
streamsize width(streamsize _Newwidth) { 
#line 363
const streamsize _Oldwidth = _Wide; 
#line 364
(_Wide) = _Newwidth; 
#line 365
return _Oldwidth; 
#line 366
} 
#line 368
[[nodiscard]] locale getloc() const { 
#line 369
return *(_Ploc); 
#line 370
} 
#line 372
locale imbue(const locale &_Loc) { 
#line 373
locale _Oldlocale = *(_Ploc); 
#line 374
((*(_Ploc)) = _Loc); 
#line 375
this->_Callfns(imbue_event); 
#line 376
return _Oldlocale; 
#line 377
} 
#line 379
[[nodiscard]] static int __cdecl xalloc() { 
#line 380
{ _Lockit _Lock(2); 
#line 381
return _Index++; 
#line 382
} 
#line 383
} 
#line 385
[[nodiscard]] long &iword(int _Idx) { 
#line 386
return this->_Findarr(_Idx)._Lo; 
#line 387
} 
#line 389
[[nodiscard]] void *&pword(int _Idx) { 
#line 390
return this->_Findarr(_Idx)._Vp; 
#line 391
} 
#line 393
void register_callback(event_callback _Pfn, int 
#line 394
_Idx) { 
#line 395
(_Calls) = (new _Fnarray(_Idx, _Pfn, _Calls)); 
#line 396
} 
#line 398
ios_base &copyfmt(const ios_base &_Other) { 
#line 399
if (this != ::std::addressof(_Other)) { 
#line 400
this->_Tidy(); 
#line 401
((*(_Ploc)) = (*(_Other._Ploc))); 
#line 402
(_Fmtfl) = (_Other._Fmtfl); 
#line 403
(_Prec) = (_Other._Prec); 
#line 404
(_Wide) = (_Other._Wide); 
#line 405
_Iosarray *_Ptr = _Other._Arr; 
#line 407
for ((_Arr) = (nullptr); _Ptr; _Ptr = (_Ptr->_Next)) { 
#line 408
if (((_Ptr->_Lo) != (0)) || (_Ptr->_Vp)) { 
#line 409
this->iword(_Ptr->_Index) = (_Ptr->_Lo); 
#line 410
this->pword(_Ptr->_Index) = (_Ptr->_Vp); 
#line 411
}  
#line 412
}  
#line 414
for (_Fnarray *_Pfa = _Other._Calls; _Pfa; _Pfa = (_Pfa->_Next)) { 
#line 415
this->register_callback(_Pfa->_Pfn, _Pfa->_Index); 
#line 416
}  
#line 418
this->_Callfns(copyfmt_event); 
#line 419
this->exceptions(_Other._Except); 
#line 420
}  
#line 421
return *this; 
#line 422
} 
#line 424
static bool __cdecl sync_with_stdio(bool 
#line 425
_Newsync = true) { 
#line 426
{ _Lockit _Lock(2); 
#line 427
const bool _Oldsync = _Sync; 
#line 428
_Sync = _Newsync; 
#line 429
return _Oldsync; 
#line 430
} 
#line 431
} 
#line 433
void swap(ios_base &_Right) { 
#line 434
if (this != ::std::addressof(_Right)) { 
#line 435
::std::swap(_Mystate, _Right._Mystate); 
#line 436
::std::swap(_Except, _Right._Except); 
#line 437
::std::swap(_Fmtfl, _Right._Fmtfl); 
#line 438
::std::swap(_Prec, _Right._Prec); 
#line 439
::std::swap(_Wide, _Right._Wide); 
#line 441
::std::swap(_Arr, _Right._Arr); 
#line 442
::std::swap(_Calls, _Right._Calls); 
#line 443
::std::swap(_Ploc, _Right._Ploc); 
#line 444
}  
#line 445
} 
#line 447
virtual ~ios_base() noexcept { 
#line 448
_Ios_base_dtor(this); 
#line 449
} 
#line 451
static void __cdecl _Addstd(ios_base *); 
#line 453
size_t _Stdstr{(0)}; 
#line 456
protected: ios_base() { } 
#line 458
void _Init() { 
#line 459
(_Ploc) = (nullptr); 
#line 460
(_Stdstr) = (0); 
#line 461
(_Except) = goodbit; 
#line 462
(_Fmtfl) = (skipws | dec); 
#line 463
(_Prec) = (6); 
#line 464
(_Wide) = (0); 
#line 465
(_Arr) = (nullptr); 
#line 466
(_Calls) = (nullptr); 
#line 467
this->clear(goodbit); 
#line 468
(_Ploc) = (new locale); 
#line 469
} 
#line 472
private: struct _Iosarray : public _Crt_new_delete { 
#line 474
_Iosarray(int _Idx, _Iosarray *_Link) : _Next(_Link), _Index(_Idx), _Lo((0)), _Vp((nullptr)) 
#line 475
{ } 
#line 477
_Iosarray *_Next; 
#line 478
int _Index; 
#line 479
long _Lo; 
#line 480
void *_Vp; 
#line 481
}; 
#line 483
struct _Fnarray : public _Crt_new_delete { 
#line 484
_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) 
#line 485
{ } 
#line 487
_Fnarray *_Next; 
#line 488
int _Index; 
#line 489
event_callback _Pfn; 
#line 490
}; 
#line 492
void _Callfns(event _Ev) { 
#line 493
for (_Fnarray *_Pfa = _Calls; _Pfa; _Pfa = (_Pfa->_Next)) { 
#line 494
(*(_Pfa->_Pfn))(_Ev, *this, _Pfa->_Index); 
#line 495
}  
#line 496
} 
#line 498
_Iosarray &_Findarr(int _Idx) { 
#line 499
_Iosarray *_Ptr1; 
#line 500
_Iosarray *_Ptr2; 
#line 502
for ((_Ptr1 = (_Arr)), (_Ptr2 = (nullptr)); _Ptr1; _Ptr1 = (_Ptr1->_Next)) { 
#line 503
if ((_Ptr1->_Index) == _Idx) { 
#line 504
return *_Ptr1; 
#line 505
} else { if (((!_Ptr2) && ((_Ptr1->_Lo) == (0))) && (!(_Ptr1->_Vp))) { 
#line 506
_Ptr2 = _Ptr1; 
#line 507
}  }  
#line 508
}  
#line 510
if (_Ptr2) { 
#line 511
(_Ptr2->_Index) = _Idx; 
#line 512
return *_Ptr2; 
#line 513
}  
#line 515
(_Arr) = (new _Iosarray(_Idx, _Arr)); 
#line 516
return *(_Arr); 
#line 517
} 
#line 519
void _Tidy() noexcept { 
#line 520
this->_Callfns(erase_event); 
#line 521
_Iosarray *_Ptr1; 
#line 522
_Iosarray *_Ptr2; 
#line 524
for (_Ptr1 = (_Arr); _Ptr1; _Ptr1 = _Ptr2) { 
#line 525
_Ptr2 = (_Ptr1->_Next); 
#line 526
delete _Ptr1; 
#line 527
}  
#line 528
(_Arr) = (nullptr); 
#line 530
_Fnarray *_Pfa1; 
#line 531
_Fnarray *_Pfa2; 
#line 532
for (_Pfa1 = (_Calls); _Pfa1; _Pfa1 = _Pfa2) { 
#line 533
_Pfa2 = (_Pfa1->_Next); 
#line 534
delete _Pfa1; 
#line 535
}  
#line 536
(_Calls) = (nullptr); 
#line 537
} 
#line 539
iostate _Mystate; 
#line 540
iostate _Except; 
#line 541
fmtflags _Fmtfl; 
#line 542
streamsize _Prec; 
#line 543
streamsize _Wide; 
#line 544
_Iosarray *_Arr{(nullptr)}; 
#line 545
_Fnarray *_Calls{(nullptr)}; 
#line 546
locale *_Ploc{(nullptr)}; 
#line 548
static int _Index; 
#line 549
static bool _Sync; 
#line 551
static void __cdecl _Ios_base_dtor(ios_base *); 
#line 554
public: ios_base(const ios_base &) = delete;
#line 555
ios_base &operator=(const ios_base &) = delete;
#line 556
}; 
#line 557
}
#line 560
#pragma warning(pop)
#pragma pack ( pop )
#line 564 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 20
namespace std { 
#line 21
template < class _Elem, class _Traits >
class basic_streambuf {
protected :
     basic_streambuf ( ) : _Plocale ( new locale ) {
        _Init ( );
    }

     basic_streambuf ( _Uninitialized ) { }

     basic_streambuf ( const basic_streambuf & _Right ) : _Plocale ( new locale ( _Right . getloc ( ) ) ) {
        _Init ( );
        setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
        setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
    }

    basic_streambuf & operator = ( const basic_streambuf & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
            setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
            pubimbue ( _Right . getloc ( ) );
        }
        return * this;
    }

    void swap ( basic_streambuf & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Elem * _Pfirst0 = pbase ( );
            _Elem * _Pnext0 = pptr ( );
            _Elem * _Pend = epptr ( );
            _Elem * _Gfirst0 = eback ( );
            _Elem * _Gnext0 = gptr ( );
            _Elem * _Gend = egptr ( );

            setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
            _Right . setp ( _Pfirst0, _Pnext0, _Pend );

            setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
            _Right . setg ( _Gfirst0, _Gnext0, _Gend );

            :: std :: swap ( _Plocale, _Right . _Plocale );
        }
    }

public :
    using char_type = _Elem;
    using traits_type = _Traits;

    virtual ~ basic_streambuf ( ) noexcept {
        delete _Plocale;
    }

    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    pos_type pubseekoff ( off_type _Off, ios_base :: seekdir _Way,
        ios_base :: openmode _Mode = ios_base :: in | ios_base :: out ) {
        return seekoff ( _Off, _Way, _Mode );
    }


    pos_type pubseekoff ( off_type _Off, ios_base :: seek_dir _Way,
        ios_base :: open_mode _Mode ) {
        return pubseekoff ( _Off, static_cast < ios_base :: seekdir > ( _Way ), static_cast < ios_base :: openmode > ( _Mode ) );
    }


    pos_type pubseekpos ( pos_type _Pos,
        ios_base :: openmode _Mode = ios_base :: in | ios_base :: out ) {
        return seekpos ( _Pos, _Mode );
    }


    pos_type pubseekpos ( pos_type _Pos,
        ios_base :: open_mode _Mode ) {
        return seekpos ( _Pos, static_cast < ios_base :: openmode > ( _Mode ) );
    }


    basic_streambuf * pubsetbuf ( _Elem * _Buffer,
        streamsize _Count ) {
        return setbuf ( _Buffer, _Count );
    }

    locale pubimbue ( const locale & _Newlocale ) {
        locale _Oldlocale = * _Plocale;
        imbue ( _Newlocale );
        * _Plocale = _Newlocale;
        return _Oldlocale;
    }

    locale getloc ( ) const {
        return * _Plocale;
    }

    streamsize in_avail ( ) {
        streamsize _Res = _Gnavail ( );
        return 0 < _Res ? _Res : showmanyc ( );
    }

    int pubsync ( ) {
        return sync ( );
    }

    int_type sbumpc ( ) {
        return 0 < _Gnavail ( ) ? _Traits :: to_int_type ( * _Gninc ( ) ) : uflow ( );
    }

    int_type sgetc ( ) {
        return 0 < _Gnavail ( ) ? _Traits :: to_int_type ( * gptr ( ) ) : underflow ( );
    }

    streamsize sgetn ( _Elem * _Ptr,
        streamsize _Count ) {
        return xsgetn ( _Ptr, _Count );
    }

    int_type snextc ( ) {
        return 1 < _Gnavail ( ) ? _Traits :: to_int_type ( * _Gnpreinc ( ) )
             : _Traits :: eq_int_type ( _Traits :: eof ( ), sbumpc ( ) ) ? _Traits :: eof ( )
                                                              : sgetc ( );
    }

    int_type sputbackc ( _Elem _Ch ) {
        if ( gptr ( ) && eback ( ) < gptr ( ) && _Traits :: eq ( _Ch, gptr ( ) [ - 1 ] ) ) {
            return _Traits :: to_int_type ( * _Gndec ( ) );
        }

        return pbackfail ( _Traits :: to_int_type ( _Ch ) );
    }


    void stossc ( ) {
        if ( 0 < _Gnavail ( ) ) {
            _Gninc ( );
        } else {
            uflow ( );
        }
    }


    int_type sungetc ( ) {
        return gptr ( ) && eback ( ) < gptr ( ) ? _Traits :: to_int_type ( * _Gndec ( ) ) : pbackfail ( );
    }

    int_type sputc ( _Elem _Ch ) {
        return 0 < _Pnavail ( ) ? _Traits :: to_int_type ( * _Pninc ( ) = _Ch ) : overflow ( _Traits :: to_int_type ( _Ch ) );
    }

    streamsize sputn ( const _Elem * _Ptr,
        streamsize _Count ) {
        return xsputn ( _Ptr, _Count );
    }

    virtual void _Lock ( ) { }

    virtual void _Unlock ( ) { }

protected :
    _Elem * eback ( ) const {
        return * _IGfirst;
    }

    _Elem * gptr ( ) const {
        return * _IGnext;
    }

    _Elem * pbase ( ) const {
        return * _IPfirst;
    }

    _Elem * pptr ( ) const {
        return * _IPnext;
    }

    _Elem * egptr ( ) const {
        return * _IGnext + * _IGcount;
    }

    void gbump ( int _Off ) {
        * _IGcount -= _Off;
        * _IGnext += _Off;
    }

    void setg ( _Elem * _First, _Elem * _Next, _Elem * _Last ) {
        * _IGfirst = _First;
        * _IGnext = _Next;
        * _IGcount = static_cast < int > ( _Last - _Next );
    }

    _Elem * epptr ( ) const {
        return * _IPnext + * _IPcount;
    }

    _Elem * _Gndec ( ) {
        ++ * _IGcount;
        return -- * _IGnext;
    }

    _Elem * _Gninc ( ) {
        -- * _IGcount;
        return ( * _IGnext ) ++;
    }

    _Elem * _Gnpreinc ( ) {
        -- * _IGcount;
        return ++ ( * _IGnext );
    }

    streamsize _Gnavail ( ) const {
        return * _IGnext ? * _IGcount : 0;
    }

    void pbump ( int _Off ) {
        * _IPcount -= _Off;
        * _IPnext += _Off;
    }

    void setp ( _Elem * _First, _Elem * _Last ) {
        * _IPfirst = _First;
        * _IPnext = _First;
        * _IPcount = static_cast < int > ( _Last - _First );
    }

    void setp (
        _Elem * _First, _Elem * _Next, _Elem * _Last ) {
        * _IPfirst = _First;
        * _IPnext = _Next;
        * _IPcount = static_cast < int > ( _Last - _Next );
    }

    _Elem * _Pninc ( ) {
        -- * _IPcount;
        return ( * _IPnext ) ++;
    }

    streamsize _Pnavail ( ) const {
        return * _IPnext ? * _IPcount : 0;
    }

    void _Init ( ) {
        _IGfirst = & _Gfirst;
        _IPfirst = & _Pfirst;
        _IGnext = & _Gnext;
        _IPnext = & _Pnext;
        _IGcount = & _Gcount;
        _IPcount = & _Pcount;
        setp ( nullptr, nullptr );
        setg ( nullptr, nullptr, nullptr );
    }

    void _Init ( _Elem * * _Gf, _Elem * * _Gn, int * _Gc, _Elem * * _Pf, _Elem * * _Pn, int * _Pc ) {

        _IGfirst = _Gf;
        _IPfirst = _Pf;
        _IGnext = _Gn;
        _IPnext = _Pn;
        _IGcount = _Gc;
        _IPcount = _Pc;
    }

    virtual int_type overflow ( int_type = _Traits :: eof ( ) ) {
        return _Traits :: eof ( );
    }

    virtual int_type pbackfail ( int_type = _Traits :: eof ( ) ) {

        return _Traits :: eof ( );
    }

    virtual streamsize showmanyc ( ) {
        return 0;
    }

    virtual int_type underflow ( ) {
        return _Traits :: eof ( );
    }

    virtual int_type uflow ( ) {
        return _Traits :: eq_int_type ( _Traits :: eof ( ), underflow ( ) ) ? _Traits :: eof ( ) : _Traits :: to_int_type ( * _Gninc ( ) );
    }

    virtual streamsize xsgetn ( _Elem * _Ptr, streamsize _Count ) {
        const streamsize _Start_count = _Count;

        while ( 0 < _Count ) {
            streamsize _Size = _Gnavail ( );
            if ( 0 < _Size ) {
                if ( _Count < _Size ) {
                    _Size = _Count;
                }

                _Traits :: copy ( _Ptr, gptr ( ), static_cast < size_t > ( _Size ) );
                _Ptr += _Size;
                _Count -= _Size;
                gbump ( static_cast < int > ( _Size ) );
            } else {
                const int_type _Meta = uflow ( );
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    break;
                }


                * _Ptr ++ = _Traits :: to_char_type ( _Meta );
                -- _Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual streamsize xsputn ( const _Elem * _Ptr, streamsize _Count ) {

        const streamsize _Start_count = _Count;
        while ( 0 < _Count ) {
            streamsize _Size = _Pnavail ( );
            if ( 0 < _Size ) {
                if ( _Count < _Size ) {
                    _Size = _Count;
                }

                _Traits :: copy ( pptr ( ), _Ptr, static_cast < size_t > ( _Size ) );
                _Ptr += _Size;
                _Count -= _Size;
                pbump ( static_cast < int > ( _Size ) );
            } else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), overflow ( _Traits :: to_int_type ( * _Ptr ) ) ) ) {
                break;
            } else {
                ++ _Ptr;
                -- _Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual pos_type seekoff (
        off_type, ios_base :: seekdir, ios_base :: openmode = ios_base :: in | ios_base :: out ) {

        return streampos ( - 1 );
    }

    virtual pos_type seekpos ( pos_type, ios_base :: openmode = ios_base :: in | ios_base :: out ) {

        return streampos ( - 1 );
    }

    virtual basic_streambuf * setbuf ( _Elem *, streamsize ) {

        return this;
    }

    virtual int sync ( ) {
        return 0;
    }

    virtual void imbue ( const locale & ) { }

private :
    _Elem * _Gfirst;
    _Elem * _Pfirst;
    _Elem * * _IGfirst;
    _Elem * * _IPfirst;
    _Elem * _Gnext;
    _Elem * _Pnext;
    _Elem * * _IGnext;
    _Elem * * _IPnext;

    int _Gcount;
    int _Pcount;
    int * _IGcount;
    int * _IPcount;

protected :
    locale * _Plocale;
};
#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"
}
#line 413
#pragma warning(pop)
#pragma pack ( pop )
#line 417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 25
extern "C" {
#line 27
extern float __cdecl _Stofx(const char *, char **, long, int *); 
#line 29
extern double __cdecl _Stodx(const char *, char **, long, int *); 
#line 31
extern long double __cdecl _Stoldx(const char *, char **, long, int *); 
#line 33
extern long __cdecl _Stolx(const char *, char **, int, int *); 
#line 35
extern unsigned long __cdecl _Stoulx(const char *, char **, int, int *); 
#line 37
extern __int64 __cdecl _Stollx(const char *, char **, int, int *); 
#line 39
extern unsigned __int64 __cdecl _Stoullx(const char *, char **, int, int *); 
#line 42
}
#line 44
namespace std { 
#line 46
inline double _Stodx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr) { 
#line 47
int &_Errno_ref = *_errno(); 
#line 48
const int _Orig = _Errno_ref; 
#line 50
_Errno_ref = 0; 
#line 51
double _Val = ::strtod(_Str, _Endptr); 
#line 52
(*_Perr) = _Errno_ref; 
#line 53
_Errno_ref = _Orig; 
#line 55
if (_Pten != 0) { 
#line 56
_Val *= ::pow((10.0), static_cast< double>(_Pten)); 
#line 57
}  
#line 59
return _Val; 
#line 60
} 
#line 62
inline float _Stofx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr) { 
#line 63
int &_Errno_ref = *_errno(); 
#line 64
const int _Orig = _Errno_ref; 
#line 66
_Errno_ref = 0; 
#line 67
float _Val = ::strtof(_Str, _Endptr); 
#line 68
(*_Perr) = _Errno_ref; 
#line 69
_Errno_ref = _Orig; 
#line 71
if (_Pten != 0) { 
#line 72
_Val *= ::powf((10.0F), static_cast< float>(_Pten)); 
#line 73
}  
#line 75
return _Val; 
#line 76
} 
#line 78
template < class _Elem, size_t _Base_size >
size_t _Find_elem ( const _Elem ( & _Base ) [ _Base_size ],
    const _Elem _Ch ) {

    return static_cast < size_t > ( _Find_unchecked ( _Base, _Base + ( _Base_size - 1 ), _Ch ) - _Base );
}
#line 85
inline __wchar_t *_Maklocwcs(const __wchar_t *_Ptr) { 
#line 86
const size_t _Count = ::wcslen(_Ptr) + (1); 
#line 88
__wchar_t *_Ptrdest = static_cast< __wchar_t *>(calloc(_Count, sizeof(__wchar_t))); 
#line 90
if (!_Ptrdest) { 
#line 91
_Xbad_alloc(); 
#line 92
}  
#line 94
::wmemcpy(_Ptrdest, _Ptr, _Count); 
#line 95
return _Ptrdest; 
#line 96
} 
#line 98
template < class _Elem >
class numpunct : public locale :: facet {
private :
    friend _Tidy_guard < numpunct >;

public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t, unsigned short >,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORC" "E_FACET_SPECIALIZATIONS=0 to suppress this diagnostic." );

    using string_type = basic_string < _Elem, char_traits < _Elem >, allocator < _Elem >>;
    using char_type = _Elem;

      static locale :: id id;

    _Elem decimal_point ( ) const {
        return do_decimal_point ( );
    }

    _Elem thousands_sep ( ) const {
        return do_thousands_sep ( );
    }

    string grouping ( ) const {
        return do_grouping ( );
    }

    string_type falsename ( ) const {
        return do_falsename ( );
    }

    string_type truename ( ) const {
        return do_truename ( );
    }

    explicit numpunct ( size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        { _Locinfo _Lobj;
        _Init ( _Lobj );
        if ( _Kseparator == 0 ) {
            _Kseparator =
                _Maklocchr ( ',', static_cast < _Elem * > ( nullptr ), _Lobj . _Getcvt ( ) );
        }
        }
    }

    numpunct ( const _Locinfo & _Lobj, size_t _Refs = 0, bool _Isdef = false ) : locale :: facet ( _Refs ) {
        _Init ( _Lobj, _Isdef );
    }

    static size_t _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {

        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new numpunct < _Elem > ( _Locinfo ( _Ploc -> c_str ( ) ), 0, true );
        }
        return 4;
    }

protected :
    virtual ~ numpunct ( ) noexcept {
        _Tidy ( );
    }

    numpunct ( const char * _Locname, size_t _Refs = 0, bool _Isdef = false ) : locale :: facet ( _Refs ) {
        { _Locinfo _Lobj ( _Locname );
        _Init ( _Lobj, _Isdef );
        }
    }

    template < class _Elem2 >
    void _Getvals ( _Elem2, const lconv * _Ptr, _Locinfo :: _Cvtvec _Cvt ) {
        _Dp = _Maklocchr ( _Ptr -> decimal_point [ 0 ], static_cast < _Elem2 * > ( nullptr ), _Cvt );
        _Kseparator = _Maklocchr ( _Ptr -> thousands_sep [ 0 ], static_cast < _Elem2 * > ( nullptr ), _Cvt );
    }

    void _Getvals ( wchar_t, const lconv * _Ptr, _Locinfo :: _Cvtvec ) {
        _Dp = static_cast < _Elem > ( _Ptr -> _W_decimal_point [ 0 ] );
        _Kseparator = static_cast < _Elem > ( _Ptr -> _W_thousands_sep [ 0 ] );
    }

    void _Init ( const _Locinfo & _Lobj, bool _Isdef = false ) {
        const lconv * _Ptr = _Lobj . _Getlconv ( );
        _Locinfo :: _Cvtvec _Cvt = _Lobj . _Getcvt ( );

        _Grouping = nullptr;
        _Falsename = nullptr;
        _Truename = nullptr;

        _Tidy_guard < numpunct > _Guard { this };
        _Grouping = _Maklocstr ( _Isdef ? "" : _Ptr -> grouping, static_cast < char * > ( nullptr ), _Lobj . _Getcvt ( ) );
        _Falsename = _Maklocstr ( _Lobj . _Getfalse ( ), static_cast < _Elem * > ( nullptr ), _Cvt );
        _Truename = _Maklocstr ( _Lobj . _Gettrue ( ), static_cast < _Elem * > ( nullptr ), _Cvt );
        _Guard . _Target = nullptr;

        if ( _Isdef ) {

            _Dp = _Maklocchr ( '.', static_cast < _Elem * > ( nullptr ), _Cvt );
            _Kseparator = _Maklocchr ( ',', static_cast < _Elem * > ( nullptr ), _Cvt );
        } else {
            _Getvals ( _Elem { }, _Ptr, _Cvt );
        }
    }

    virtual _Elem do_decimal_point ( ) const {
        return _Dp;
    }

    virtual _Elem do_thousands_sep ( ) const {
        return _Kseparator;
    }

    virtual string do_grouping ( ) const {
        return string ( _Grouping );
    }

    virtual string_type do_falsename ( ) const {
        return string_type ( _Falsename );
    }

    virtual string_type do_truename ( ) const {
        return string_type ( _Truename );
    }

private :
    void _Tidy ( ) noexcept {
        :: free ( const_cast < char * > ( _Grouping ) );
        :: free ( const_cast < _Elem * > ( _Falsename ) );
        :: free ( const_cast < _Elem * > ( _Truename ) );
    }

    const char * _Grouping;
    _Elem _Dp;
    _Elem _Kseparator;
    const _Elem * _Falsename;
    const _Elem * _Truename;
};
#line 233
template < class _Elem >
class numpunct_byname : public numpunct < _Elem > {
public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t >, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORC" "E_FACET_SPECIALIZATIONS=0 to suppress this diagnostic." );

    explicit numpunct_byname ( const char * _Locname, size_t _Refs = 0 )
        : numpunct < _Elem > ( _Locname, _Refs ) { }

    explicit numpunct_byname ( const string & _Str, size_t _Refs = 0 )
        : numpunct < _Elem > ( _Str . c_str ( ), _Refs ) { }

protected :
    virtual ~ numpunct_byname ( ) noexcept { }
};
#line 254
template< class _Elem> locale::id 
#line 255
numpunct< _Elem> ::id; 
#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
template < class _Elem, class _InIt = istreambuf_iterator < _Elem, char_traits < _Elem > > >
class num_get : public locale :: facet {
public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t, unsigned short >,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORC" "E_FACET_SPECIALIZATIONS=0 to suppress this diagnostic." );

    static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {

        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new num_get < _Elem, _InIt > ( _Locinfo ( _Ploc -> c_str ( ) ) );
        }

        return 4;
    }

     static locale :: id id;

protected :
    virtual ~ num_get ( ) noexcept { }

    void _Init ( const _Locinfo & ) { }

public :
    explicit num_get ( size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        { _Locinfo _Lobj;
        _Init ( _Lobj );
        }
    }

     num_get ( const _Locinfo & _Lobj, size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        _Init ( _Lobj );
    }

    using char_type = _Elem;
    using iter_type = _InIt;

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        bool & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned short & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned int & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned long & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long long & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned long long & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        float & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        double & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long double & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

    _InIt get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        void * & _Val ) const {
        return do_get ( _First, _Last, _Iosbase, _State, _Val );
    }

protected :
    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        bool & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        if ( _Iosbase . flags ( ) & ios_base :: boolalpha ) {
            const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
            basic_string < _Elem > _Str ( static_cast < size_t > ( 1 ), _Elem { } );
            _Str += _Punct_fac . falsename ( );
            _Str . push_back ( _Elem { } );
            _Str += _Punct_fac . truename ( );
            switch ( _Getloctxt ( _First, _Last, 2, _Str . c_str ( ), _Case_sensitive :: _Yes ) ) {
            case 0 :
                _Val = false;
                break;
            case 1 :
                _Val = true;
                break;
            default :
                _Val = false;
                _State = ios_base :: failbit;
                break;
            }
        } else {
            char _Ac [ 32 ];
            const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
            if ( _Ac [ 0 ] == '\000' ) {





                _Val = false;
                _State = ios_base :: failbit;
            } else {
                char * _Ep;
                int _Errno;
                const long _Ans = :: _Stolx ( _Ac, & _Ep, _Base, & _Errno );
                if ( _Ep == _Ac || _Errno != 0 ) {
                    _Val = true;
                    _State = ios_base :: failbit;
                } else {
                    _Val = _Ans != 0;
                    if ( _Ans != 0 && _Ans != 1 ) {
                        _State = ios_base :: failbit;
                    }
                }
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned short & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ 32 ];
        const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Ac [ 0 ] == '\000' ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            const bool _Minus = _Ac [ 0 ] == '-';
            const char * _Digits = _Ac;


            if ( _Minus ) {
                ++ _Digits;
            }

            char * _Ep;
            int _Errno;
            const unsigned long _Tmp = :: _Stoulx ( _Digits, & _Ep, _Base, & _Errno );
            _Val = static_cast < unsigned short > ( _Tmp );
            if ( _Ep == _Digits || _Errno != 0 || _Tmp > 65535 ) {
                _State = ios_base :: failbit;
                _Val = 65535;
            } else if ( _Minus ) {

                _Val = static_cast < unsigned short > ( 0 - _Val );
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned int & _Val ) const {
        static_assert ( sizeof ( unsigned int ) == sizeof ( unsigned long ),
            "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)" );
        unsigned long _Tmp;
        _First = num_get :: do_get ( _First, _Last, _Iosbase, _State, _Tmp );
        _Val = _Tmp;
        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ 32 ];
        const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Ac [ 0 ] == '\000' ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            char * _Ep;
            int _Errno;
            _Val = :: _Stolx ( _Ac, & _Ep, _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0 ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned long & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ 32 ];
        const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Ac [ 0 ] == '\000' ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            char * _Ep;
            int _Errno;
            _Val = :: _Stoulx ( _Ac, & _Ep, _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0 ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long long & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ 32 ];
        const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Ac [ 0 ] == '\000' ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            char * _Ep;
            int _Errno;
            _Val = :: _Stollx ( _Ac, & _Ep, _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0 ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        unsigned long long & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ 32 ];
        const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
        if ( _Ac [ 0 ] == '\000' ) {
            _State = ios_base :: failbit;
            _Val = 0;
        } else {
            int _Errno;
            char * _Ep;
            _Val = :: _Stoullx ( _Ac, & _Ep, _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0 ) {
                _State = ios_base :: failbit;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }








    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        float & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ ( 8 + 768 + 16 ) ];
        int _Hexexp = 1000000000;
        const int _Base = _Getffld ( _Ac, _First, _Last, _Iosbase, & _Hexexp );
        if ( _Ac [ 0 ] == '\000' ) {
            _State = ios_base :: failbit;
            _Val = (0.0F);
        } else {
            int _Errno;
            char * _Ep;
            _Val = _Stofx_v2 ( _Ac, & _Ep, _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0 ) {
                _State = ios_base :: failbit;
                _Val = (0.0F);
            } else if ( _Hexexp != 1000000000 && _Hexexp != 0 ) {
                _Val = :: ldexpf ( _Val, 4 * _Hexexp );
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        double & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ ( 8 + 768 + 16 ) ];
        int _Hexexp = 1000000000;
        const int _Base = _Getffld ( _Ac, _First, _Last, _Iosbase, & _Hexexp );
        if ( _Ac [ 0 ] == '\000' ) {
            _State = ios_base :: failbit;
            _Val = (0.0);
        } else {
            int _Errno;
            char * _Ep;
            _Val = _Stodx_v2 ( _Ac, & _Ep, _Base, & _Errno );
            if ( _Ep == _Ac || _Errno != 0 ) {
                _State = ios_base :: failbit;
                _Val = (0.0);
            } else if ( _Hexexp != 1000000000 && _Hexexp != 0 ) {
                _Val = :: ldexp ( _Val, 4 * _Hexexp );
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }


    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        long double & _Val ) const {
        static_assert ( sizeof ( double ) == sizeof ( long double ), "Bad assumption: sizeof(double) == sizeof(long double)." );
        double _Result;
        _First = num_get :: do_get ( _First, _Last, _Iosbase, _State, _Result );
        _Val = _Result;
        return _First;
    }

    virtual _InIt do_get ( _InIt _First, _InIt _Last, ios_base & _Iosbase, ios_base :: iostate & _State,
        void * & _Val ) const {
        _Adl_verify_range ( _First, _Last );
        char _Ac [ 32 ];
        const int _Base = _Getifld ( _Ac, _First, _Last, ios_base :: hex, _Iosbase . getloc ( ) );
        if ( _Ac [ 0 ] == '\000' ) {
            _State = ios_base :: failbit;
            _Val = nullptr;
        } else {
            int _Errno;
            char * _Ep;

            _Val = reinterpret_cast < void * > ( :: _Stoullx ( _Ac, & _Ep, _Base, & _Errno ) );



            if ( _Ep == _Ac || _Errno != 0 ) {
                _State = ios_base :: failbit;
                _Val = nullptr;
            }
        }

        if ( _First == _Last ) {
            _State |= ios_base :: eofbit;
        }

        return _First;
    }

private :
    int __cdecl _Getifld ( char * _Ac, _InIt & _First, _InIt & _Last, ios_base :: fmtflags _Basefield,
        const locale & _Loc ) const {
        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Loc );
        const string _Grouping = _Punct_fac . grouping ( );
        const _Elem _Kseparator = _Grouping . size ( ) == 0 ? _Elem { } : _Punct_fac . thousands_sep ( );

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff = 24;
        static constexpr char _Src [ ] = "0123456789ABCDEFabcdef-+Xx";
        _Elem _Atoms [ sizeof ( _Src ) ];
        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Loc );
        _Ctype_fac . widen ( :: std :: begin ( _Src ), :: std :: end ( _Src ), _Atoms );

        char * _Ptr = _Ac;

        if ( _First != _Last ) {
            if ( * _First == _Atoms [ _Numget_signoff + 1 ] ) {
                * _Ptr ++ = '+';
                ++ _First;
            } else if ( * _First == _Atoms [ _Numget_signoff ] ) {
                * _Ptr ++ = '-';
                ++ _First;
            }
        }

        _Basefield &= ios_base :: basefield;

        int _Base;
        if ( _Basefield == ios_base :: oct ) {
            _Base = 8;
        } else if ( _Basefield == ios_base :: hex ) {
            _Base = 16;
        } else if ( _Basefield == ios_base :: _Fmtzero ) {
            _Base = 0;
        } else {
            _Base = 10;
        }

        bool _Seendigit = false;
        bool _Nonzero = false;

        if ( _First != _Last && * _First == _Atoms [ 0 ] ) {
            _Seendigit = true;
            ++ _First;
            if ( _First != _Last && ( * _First == _Atoms [ _Numget_xoff + 1 ] || * _First == _Atoms [ _Numget_xoff ] )
                && ( _Base == 0 || _Base == 16 ) ) {
                _Base = 16;
                _Seendigit = false;
                ++ _First;
            } else if ( _Base == 0 ) {
                _Base = 8;
            }
        }

        const auto _Dlen = static_cast < size_t > ( _Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6 );
        string _Groups ( 1, static_cast < char > ( _Seendigit ) );
        size_t _Group = 0;

        for ( char * const _Pe = & _Ac [ 32 - 1 ]; _First != _Last; ++ _First ) {
            size_t _Idx = _Find_elem ( _Atoms, * _First );
            if ( _Idx < _Dlen ) {
                * _Ptr = _Src [ _Idx ];
                if ( ( _Nonzero || * _Ptr != '0' ) && _Ptr < _Pe ) {
                    ++ _Ptr;
                    _Nonzero = true;
                }

                _Seendigit = true;
                if ( _Groups [ _Group ] != 127 ) {
                    ++ _Groups [ _Group ];
                }
            } else if ( _Groups [ _Group ] == '\000' || _Kseparator == _Elem { } || * _First != _Kseparator ) {
                break;
            } else {
                _Groups . push_back ( '\000' );
                ++ _Group;
            }
        }

        if ( _Group != 0 ) {
            if ( '\000' < _Groups [ _Group ] ) {
                ++ _Group;
            } else {
                _Seendigit = false;
            }
        }

        for ( const char * _Pg = & _Grouping [ 0 ]; _Seendigit && 0 < _Group; ) {
            if ( * _Pg == 127 ) {
                break;
            } else if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] ) || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) ) {
                _Seendigit = false;
            } else if ( '\000' < _Pg [ 1 ] ) {
                ++ _Pg;
            }
        }

        if ( _Seendigit && ! _Nonzero ) {
            * _Ptr ++ = '0';
        } else if ( ! _Seendigit ) {
            _Ptr = _Ac;
        }

        * _Ptr = '\000';
        return _Base;
    }

    int __cdecl _Getffld ( char * _Ac, _InIt & _First, _InIt & _Last, ios_base & _Iosbase,
        int * _Phexexp ) const {
        if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: hexfloat ) {
            return _Getffldx ( _Ac, _First, _Last, _Iosbase, _Phexexp );
        }

        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
        const string _Grouping = _Punct_fac . grouping ( );
        char * _Ptr = _Ac;
        bool _Bad = false;
        bool _Sticky = false;

        constexpr int _Numget_signoff = 10;
        constexpr int _Numget_eoff = 12;
        static constexpr char _Src [ ] = "0123456789-+Ee";
        _Elem _Atoms [ sizeof ( _Src ) ];
        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
        _Ctype_fac . widen ( :: std :: begin ( _Src ), :: std :: end ( _Src ), _Atoms );

        if ( _First != _Last ) {
            if ( * _First == _Atoms [ _Numget_signoff + 1 ] ) {
                * _Ptr ++ = '+';
                ++ _First;
            } else if ( * _First == _Atoms [ _Numget_signoff ] ) {
                * _Ptr ++ = '-';
                ++ _First;
            }
        }

        char * _Leading = _Ptr;
        * _Ptr ++ = '0';

        bool _Seendigit = false;
        int _Significant = 0;
        int _Pten = 0;
        size_t _Idx;

        const int _Max_sig_dig = ( * _Phexexp == 1000000000 ? 768 : 36 );

        const char * _Pg = & _Grouping [ 0 ];
        if ( * _Pg == 127 || * _Pg <= '\000' ) {
            for (; _First != _Last && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10; _Seendigit = true, ( void ) ++ _First ) {
                if ( _Max_sig_dig <= _Significant ) {
                    ++ _Pten;
                    if ( 0 < _Idx ) {
                        _Sticky = true;
                    }
                } else if ( _Idx != 0 || _Significant != 0 ) {
                    * _Ptr ++ = _Src [ _Idx ];
                    ++ _Significant;
                }
            }
        } else {
            const _Elem _Kseparator = _Grouping . size ( ) == 0 ? _Elem { } : _Punct_fac . thousands_sep ( );
            string _Groups ( 1, '\000' );
            size_t _Group = 0;

            for (; _First != _Last; ++ _First ) {
                if ( ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10 ) {
                    _Seendigit = true;
                    if ( _Max_sig_dig <= _Significant ) {
                        ++ _Pten;
                        if ( 0 < _Idx ) {
                            _Sticky = true;
                        }
                    } else if ( _Idx != 0 || _Significant != 0 ) {
                        * _Ptr ++ = _Src [ _Idx ];
                        ++ _Significant;
                    }

                    if ( _Groups [ _Group ] != 127 ) {
                        ++ _Groups [ _Group ];
                    }
                } else if ( _Groups [ _Group ] == '\000' || _Kseparator == _Elem { } || * _First != _Kseparator ) {
                    break;
                } else {
                    _Groups . push_back ( '\000' );
                    ++ _Group;
                }
            }

            if ( _Group != 0 ) {
                if ( '\000' < _Groups [ _Group ] ) {
                    ++ _Group;
                } else {
                    _Bad = true;
                }
            }

            while ( ! _Bad && 0 < _Group ) {
                if ( * _Pg == 127 ) {
                    break;
                }

                if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] ) || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) ) {
                    _Bad = true;
                } else if ( '\000' < _Pg [ 1 ] ) {
                    ++ _Pg;
                }
            }
        }

        if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) ) {
            * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ];
            ++ _First;
        }

        if ( * _Phexexp != 1000000000 && _Significant == 0 ) {
            for (; _First != _Last && * _First == _Atoms [ 0 ]; _Seendigit = true, ( void ) ++ _First ) {
                -- _Pten;
            }

            if ( _Pten < 0 ) {
                * _Ptr ++ = '0';
                ++ _Pten;
            }
        }

        for (; _First != _Last && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10; _Seendigit = true, ( void ) ++ _First ) {
            if ( _Significant < _Max_sig_dig ) {
                * _Ptr ++ = _Src [ _Idx ];
                ++ _Significant;
            } else if ( 0 < _Idx ) {
                _Sticky = true;
            }
        }

        if ( _Sticky ) {
            char * _Px = _Ptr;
            while ( -- _Px != _Leading ) {
                if ( * _Px != localeconv ( ) -> decimal_point [ 0 ] ) {
                    if ( * _Px != '9' ) {
                        ++ * _Px;
                        break;
                    }

                    * _Px = '0';
                }
            }

            if ( _Px == _Leading ) {
                * _Px = '1';
                ++ _Pten;
            }
        }

        if ( _Seendigit && _First != _Last
            && ( * _First == _Atoms [ _Numget_eoff + 1 ]
                || * _First == _Atoms [ _Numget_eoff ] ) ) {
            * _Ptr ++ = 'e';
            ++ _First;
            _Seendigit = false;
            _Significant = 0;

            if ( _First != _Last ) {
                if ( * _First == _Atoms [ _Numget_signoff + 1 ] ) {
                    * _Ptr ++ = '+';
                    ++ _First;
                } else if ( * _First == _Atoms [ _Numget_signoff ] ) {
                    * _Ptr ++ = '-';
                    ++ _First;
                }
            }

            for (; _First != _Last && * _First == _Atoms [ 0 ]; ++ _First ) {
                _Seendigit = true;
            }

            if ( _Seendigit ) {
                * _Ptr ++ = '0';
            }

            for (; _First != _Last && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10; _Seendigit = true, ( void ) ++ _First ) {
                if ( _Significant < 8 ) {
                    * _Ptr ++ = _Src [ _Idx ];
                    ++ _Significant;
                }
            }
        }

        if ( _Bad || ! _Seendigit ) {
            _Ptr = _Ac;
        }

        * _Ptr = '\000';
        return _Pten;
    }

    int __cdecl _Getffldx ( char * _Ac, _InIt & _First, _InIt & _Last, ios_base & _Iosbase,
        int * _Phexexp ) const {
        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
        const string _Grouping = _Punct_fac . grouping ( );

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff = 24;
        constexpr int _Numget_poff = 26;
        static constexpr char _Src [ ] = "0123456789ABCDEFabcdef-+XxPp";
        _Elem _Atoms [ sizeof ( _Src ) ];
        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
        _Ctype_fac . widen ( :: std :: begin ( _Src ), :: std :: end ( _Src ), _Atoms );

        char * _Ptr = _Ac;
        bool _Bad = false;
        size_t _Idx;

        if ( _First != _Last ) {
            if ( * _First == _Atoms [ _Numget_signoff + 1 ] ) {
                * _Ptr ++ = '+';
                ++ _First;
            } else if ( * _First == _Atoms [ _Numget_signoff ] ) {
                * _Ptr ++ = '-';
                ++ _First;
            }
        }

        * _Ptr ++ = '0';
        * _Ptr ++ = 'x';

        bool _Seendigit = false;
        int _Significant = 0;
        int _Phex = 0;

        if ( _First != _Last && * _First == _Atoms [ 0 ] ) {
            if ( ++ _First != _Last && ( * _First == _Atoms [ _Numget_xoff + 1 ] || * _First == _Atoms [ _Numget_xoff ] ) ) {
                ++ _First;
            } else {
                _Seendigit = true;
            }
        }

        const int _Max_sig_dig = ( * _Phexexp == 1000000000 ? 768 : 36 );

        const char * _Pg = & _Grouping [ 0 ];
        if ( * _Pg == 127 || * _Pg <= '\000' ) {
            for (; _First != _Last && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _Numget_signoff;
                 _Seendigit = true, ( void ) ++ _First ) {
                if ( _Max_sig_dig <= _Significant ) {
                    ++ _Phex;
                } else if ( _Idx != 0 || _Significant != 0 ) {
                    * _Ptr ++ = _Src [ _Idx ];
                    ++ _Significant;
                }
            }
        } else {
            const _Elem _Kseparator = _Grouping . size ( ) == 0 ? _Elem { } : _Punct_fac . thousands_sep ( );
            string _Groups ( 1, '\000' );
            size_t _Group = 0;

            for (; _First != _Last; ++ _First ) {
                if ( ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _Numget_signoff ) {
                    _Seendigit = true;
                    if ( _Max_sig_dig <= _Significant ) {
                        ++ _Phex;
                    } else if ( _Idx != 0 || _Significant != 0 ) {
                        * _Ptr ++ = _Src [ _Idx ];
                        ++ _Significant;
                    }

                    if ( _Groups [ _Group ] != 127 ) {
                        ++ _Groups [ _Group ];
                    }
                } else if ( _Groups [ _Group ] == '\000' || _Kseparator == _Elem { } || * _First != _Kseparator ) {
                    break;
                } else {
                    _Groups . push_back ( '\000' );
                    ++ _Group;
                }
            }

            if ( _Group != 0 ) {
                if ( '\000' < _Groups [ _Group ] ) {
                    ++ _Group;
                } else {
                    _Bad = true;
                }
            }

            while ( ! _Bad && 0 < _Group ) {
                if ( * _Pg == 127 ) {
                    break;
                }

                if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] ) || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) ) {
                    _Bad = true;
                } else if ( '\000' < _Pg [ 1 ] ) {
                    ++ _Pg;
                }
            }
        }

        if ( _Seendigit && _Significant == 0 ) {
            * _Ptr ++ = '0';
        }

        if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) ) {
            * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ];
            ++ _First;
        }

        if ( _Significant == 0 ) {
            for (; _First != _Last && * _First == _Atoms [ 0 ]; _Seendigit = true, ( void ) ++ _First ) {
                -- _Phex;
            }

            if ( _Phex < 0 ) {
                * _Ptr ++ = '0';
                ++ _Phex;
            }
        }

        for (; _First != _Last && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _Numget_signoff;
             _Seendigit = true, ( void ) ++ _First ) {
            if ( _Significant < _Max_sig_dig ) {
                * _Ptr ++ = _Src [ _Idx ];
                ++ _Significant;
            }
        }

        if ( _Seendigit && _First != _Last
            && ( * _First == _Atoms [ _Numget_poff + 1 ]
                || * _First == _Atoms [ _Numget_poff ] ) ) {
            * _Ptr ++ = 'p';
            ++ _First;
            _Seendigit = false;
            _Significant = 0;

            if ( _First != _Last ) {
                if ( * _First == _Atoms [ _Numget_signoff + 1 ] ) {
                    * _Ptr ++ = '+';
                    ++ _First;
                } else if ( * _First == _Atoms [ _Numget_signoff ] ) {
                    * _Ptr ++ = '-';
                    ++ _First;
                }
            }

            for (; _First != _Last && * _First == _Atoms [ 0 ]; ++ _First ) {
                _Seendigit = true;
            }

            if ( _Seendigit ) {
                * _Ptr ++ = '0';
            }

            for (; _First != _Last && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _Numget_signoff;
                 _Seendigit = true, ( void ) ++ _First ) {
                if ( _Significant < 8 ) {
                    * _Ptr ++ = _Src [ _Idx ];
                    ++ _Significant;
                }
            }
        }

        if ( _Bad || ! _Seendigit ) {
            _Ptr = _Ac;
        }

        * _Ptr = '\000';
        * _Phexexp = _Phex;
        return 0;
    }


};
#line 1132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
template< class _Elem, class _InIt> locale::id 
#line 1133
num_get< _Elem, _InIt> ::id; 
#line 1139
template< class _Ty> struct _Hex_float_precision; 
#line 1143
template<> struct _Hex_float_precision< double>  { 
#line 1145
static constexpr int value = (((53 - 1) + 3) / 4); 
#line 1146
}; 
#line 1149
template<> struct _Hex_float_precision< long double>  { 
#line 1151
static constexpr int value = (((53 - 1) + 3) / 4); 
#line 1152
}; 
#line 1154
template < class _Ty >
int _Float_put_desired_precision ( const streamsize _Precision, const ios_base :: fmtflags _Float_flags ) {
    const bool _Is_hex = _Float_flags == ( ios_base :: fixed | ios_base :: scientific );
    if ( _Is_hex ) {
        return _Hex_float_precision < _Ty > :: value;
    }

    if ( _Precision > 0 ) {
        return static_cast < int > ( _Precision );
    } else if ( _Precision == 0 ) {
        const bool _Is_default_float = _Float_flags == 0;
        if ( _Is_default_float ) {
            return 1;
        } else {
            return 0;
        }
    } else {
        constexpr int _Default_precision = 6;
        return _Default_precision;
    }
}
#line 1176
template < class _Elem, class _OutIt = ostreambuf_iterator < _Elem, char_traits < _Elem > > >
class num_put : public locale :: facet {
public :
    static_assert ( ! 0 || _Is_any_of_v < _Elem, char, wchar_t, unsigned short >,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORC" "E_FACET_SPECIALIZATIONS=0 to suppress this diagnostic." );

    static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr, const locale * _Ploc = nullptr ) {

        if ( _Ppf && ! * _Ppf ) {
            * _Ppf = new num_put < _Elem, _OutIt > ( _Locinfo ( _Ploc -> c_str ( ) ) );
        }

        return 4;
    }

     static locale :: id id;

protected :
    virtual ~ num_put ( ) noexcept { }

    void _Init ( const _Locinfo & ) { }

public :
    explicit num_put ( size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        { _Locinfo _Lobj;
        _Init ( _Lobj );
        }
    }

     num_put ( const _Locinfo & _Lobj, size_t _Refs = 0 ) : locale :: facet ( _Refs ) {
        _Init ( _Lobj );
    }

    using char_type = _Elem;
    using iter_type = _OutIt;

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, bool _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill,
        unsigned long _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long long _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill,
        unsigned long long _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, double _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long double _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

    _OutIt put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const {
        return do_put ( _Dest, _Iosbase, _Fill, _Val );
    }

protected :
    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, bool _Val ) const {
        if ( ! ( _Iosbase . flags ( ) & ios_base :: boolalpha ) ) {
            return do_put ( _Dest, _Iosbase, _Fill, static_cast < long > ( _Val ) );
        } else {
            const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
            basic_string < _Elem > _Str;
            if ( _Val ) {
                _Str . assign ( _Punct_fac . truename ( ) );
            } else {
                _Str . assign ( _Punct_fac . falsename ( ) );
            }

            size_t _Fillcount;
            if ( _Iosbase . width ( ) <= 0 || static_cast < size_t > ( _Iosbase . width ( ) ) <= _Str . size ( ) ) {
                _Fillcount = 0;
            } else {
                _Fillcount = static_cast < size_t > ( _Iosbase . width ( ) ) - _Str . size ( );
            }

            if ( ( _Iosbase . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
                _Dest = _Rep ( _Dest, _Fill, _Fillcount );
                _Fillcount = 0;
            }
            _Dest = _Put ( _Dest, _Str . c_str ( ), _Str . size ( ) );
            _Iosbase . width ( 0 );
            return _Rep ( _Dest, _Fill, _Fillcount );
        }
    }

#pragma warning(push)
#pragma warning(disable : 4774)
    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long _Val ) const {
        char _Buf [ 2 * 32 ];
        char _Fmt [ 6 ];

        return _Iput ( _Dest, _Iosbase, _Fill, _Buf,
            static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "ld", _Iosbase . flags ( ) ), _Val ) ) );
    }

    virtual _OutIt do_put ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill,
        unsigned long _Val ) const {
        char _Buf [ 2 * 32 ];
        char _Fmt [ 6 ];

        return _Iput ( _Dest, _Iosbase, _Fill, _Buf,
            static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "lu", _Iosbase . flags ( ) ), _Val ) ) );
    }

    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long long _Val ) const {
        char _Buf [ 2 * 32 ];
        char _Fmt [ 8 ];

        return _Iput ( _Dest, _Iosbase, _Fill, _Buf,
            static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Ld", _Iosbase . flags ( ) ), _Val ) ) );
    }

    virtual _OutIt do_put ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill,
        unsigned long long _Val ) const {
        char _Buf [ 2 * 32 ];
        char _Fmt [ 8 ];

        return _Iput ( _Dest, _Iosbase, _Fill, _Buf,
            static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Lu", _Iosbase . flags ( ) ), _Val ) ) );
    }

    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, double _Val ) const {
        string _Buf;
        char _Fmt [ 8 ];
        const auto _Float_flags = _Iosbase . flags ( ) & ios_base :: floatfield;
        const bool _Is_fixed = _Float_flags == ios_base :: fixed;
        const bool _Is_hex = _Float_flags == ( ios_base :: fixed | ios_base :: scientific );
        const streamsize _Precision = _Is_hex ? - 1 : _Iosbase . precision ( );
        const int _Desired_precision =
            _Float_put_desired_precision < double > ( _Precision, _Float_flags );
        size_t _Bufsize = static_cast < size_t > ( _Desired_precision );
        if ( _Is_fixed && (10000000000.0) < :: fabs ( _Val ) ) {
            int _Ptwo;
            ( void ) :: frexp ( _Val, & _Ptwo );
            _Bufsize += :: abs ( _Ptwo ) * 30103L / 100000L;
        }

        _Buf . resize ( _Bufsize + 50 );
        const auto _Ngen = static_cast < size_t > ( :: sprintf_s (
            & _Buf [ 0 ], _Buf . size ( ), _Ffmt ( _Fmt, 0, _Iosbase . flags ( ) ), static_cast < int > ( _Precision ), _Val ) );

        return _Fput ( _Dest, _Iosbase, _Fill, _Buf . c_str ( ), _Ngen );
    }

    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, long double _Val ) const {
        string _Buf;
        char _Fmt [ 8 ];
        const auto _Float_flags = _Iosbase . flags ( ) & ios_base :: floatfield;
        const bool _Is_fixed = _Float_flags == ios_base :: fixed;
        const bool _Is_hex = _Float_flags == ( ios_base :: fixed | ios_base :: scientific );
        const streamsize _Precision = _Is_hex ? - 1 : _Iosbase . precision ( );
        const int _Desired_precision =
            _Float_put_desired_precision < long double > ( _Precision, _Float_flags );
        size_t _Bufsize = static_cast < size_t > ( _Desired_precision );
        if ( _Is_fixed && (10000000000.0) < :: fabsl ( _Val ) ) {
            int _Ptwo;
            ( void ) :: frexpl ( _Val, & _Ptwo );
            _Bufsize += :: abs ( _Ptwo ) * 30103L / 100000L;
        }

        _Buf . resize ( _Bufsize + 50 );
        const auto _Ngen = static_cast < size_t > ( :: sprintf_s (
            & _Buf [ 0 ], _Buf . size ( ), _Ffmt ( _Fmt, 'L', _Iosbase . flags ( ) ), static_cast < int > ( _Precision ), _Val ) );

        return _Fput ( _Dest, _Iosbase, _Fill, _Buf . c_str ( ), _Ngen );
    }
#pragma warning(pop)

    virtual _OutIt do_put (
        _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const {
        char _Buf [ 2 * 32 ];

        return _Iput (
            _Dest, _Iosbase, _Fill, _Buf, static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), "%p", _Val ) ) );
    }

private :
    char * __cdecl _Ffmt (
        char * _Fmt, char _Spec, ios_base :: fmtflags _Flags ) const {
        char * _Ptr = _Fmt;
        * _Ptr ++ = '%';

        if ( _Flags & ios_base :: showpos ) {
            * _Ptr ++ = '+';
        }

        if ( _Flags & ios_base :: showpoint ) {
            * _Ptr ++ = '#';
        }

        * _Ptr ++ = '.';
        * _Ptr ++ = '*';
        if ( _Spec != '\000' ) {
            * _Ptr ++ = _Spec;
        }

        char _Ch;
        ios_base :: fmtflags _Ffl = _Flags & ios_base :: floatfield;
        if ( _Flags & ios_base :: uppercase ) {
            if ( _Ffl == ios_base :: fixed ) {
                _Ch = 'f';
            } else if ( _Ffl == ios_base :: hexfloat ) {
                _Ch = 'A';
            } else if ( _Ffl == ios_base :: scientific ) {
                _Ch = 'E';
            } else {
                _Ch = 'G';
            }
        } else {
            if ( _Ffl == ios_base :: fixed ) {
                _Ch = 'f';
            } else if ( _Ffl == ios_base :: hexfloat ) {
                _Ch = 'a';
            } else if ( _Ffl == ios_base :: scientific ) {
                _Ch = 'e';
            } else {
                _Ch = 'g';
            }
        }
        * _Ptr ++ = _Ch;

        * _Ptr = '\000';
        return _Fmt;
    }

    _OutIt __cdecl _Fput ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, const char * _Buf,
        size_t _Count ) const {
        auto _Prefix = static_cast < size_t > ( 0 < _Count && ( * _Buf == '+' || * _Buf == '-' ) );
        const char * _Exps;
        if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) != ios_base :: hexfloat ) {
            _Exps = "eE";
        } else {
            _Exps = "pP";
            if ( _Prefix + 2 <= _Count && _Buf [ _Prefix ] == '0'
                && ( _Buf [ _Prefix + 1 ] == 'x' || _Buf [ _Prefix + 1 ] == 'X' ) ) {
                _Prefix += 2;
            }
        }
        const size_t _Eoff = :: strcspn ( & _Buf [ 0 ], _Exps );
        char _Dp [ 2 ] = { "." };
        _Dp [ 0 ] = :: localeconv ( ) -> decimal_point [ 0 ];
        const size_t _Poff = :: strcspn ( & _Buf [ 0 ], & _Dp [ 0 ] );

        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
        basic_string < _Elem > _Groupstring ( _Count, _Elem ( 0 ) );
        _Ctype_fac . widen ( _Buf, _Buf + _Count, & _Groupstring [ 0 ] );

        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
        const string _Grouping = _Punct_fac . grouping ( );
        const _Elem _Kseparator = _Punct_fac . thousands_sep ( );

        if ( _Poff != _Count ) {
            _Groupstring [ _Poff ] = _Punct_fac . decimal_point ( );
        }

        size_t _Off = _Poff == _Count ? _Eoff : _Poff;
        const char * _Pg = & _Grouping [ 0 ];
        while ( * _Pg != 127 && '\000' < * _Pg && static_cast < size_t > ( * _Pg ) < _Off - _Prefix ) {

            _Groupstring . insert ( _Off -= * _Pg, 1, _Kseparator );
            if ( '\000' < _Pg [ 1 ] ) {
                ++ _Pg;
            }
        }

        _Count = _Groupstring . size ( );

        size_t _Fillcount;
        if ( _Iosbase . width ( ) <= 0 || static_cast < size_t > ( _Iosbase . width ( ) ) <= _Count ) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast < size_t > ( _Iosbase . width ( ) ) - _Count;
        }

        ios_base :: fmtflags _Adjustfield = _Iosbase . flags ( ) & ios_base :: adjustfield;
        if ( _Adjustfield != ios_base :: left && _Adjustfield != ios_base :: internal ) {
            _Dest = _Rep ( _Dest, _Fill, _Fillcount );
            _Fillcount = 0;
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
        } else if ( _Adjustfield == ios_base :: internal ) {
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
            _Dest = _Rep ( _Dest, _Fill, _Fillcount );
            _Fillcount = 0;
        } else {
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
        }

        _Dest = _Put ( _Dest, & _Groupstring [ _Prefix ], _Count - _Prefix );
        _Iosbase . width ( 0 );
        return _Rep ( _Dest, _Fill, _Fillcount );
    }

    char * __cdecl _Ifmt (
        char * _Fmt, const char * _Spec, ios_base :: fmtflags _Flags ) const {
        char * _Ptr = _Fmt;
        * _Ptr ++ = '%';

        if ( _Flags & ios_base :: showpos ) {
            * _Ptr ++ = '+';
        }

        if ( _Flags & ios_base :: showbase ) {
            * _Ptr ++ = '#';
        }

        if ( _Spec [ 0 ] != 'L' ) {
            * _Ptr ++ = _Spec [ 0 ];
        } else {
            * _Ptr ++ = 'I';
            * _Ptr ++ = '6';
            * _Ptr ++ = '4';
        }

        ios_base :: fmtflags _Basefield = _Flags & ios_base :: basefield;
        * _Ptr ++ = _Basefield == ios_base :: oct ? 'o'
                                      : _Basefield != ios_base :: hex ? _Spec [ 1 ]
                                      : _Flags & ios_base :: uppercase ? 'X'
                                                                     : 'x';
        * _Ptr = '\000';
        return _Fmt;
    }

    _OutIt __cdecl _Iput ( _OutIt _Dest, ios_base & _Iosbase, _Elem _Fill, char * _Buf,
        size_t _Count ) const {
        auto _Prefix = static_cast < size_t > ( 0 < _Count && ( * _Buf == '+' || * _Buf == '-' ) );
        if ( ( _Iosbase . flags ( ) & ios_base :: basefield ) == ios_base :: hex && _Prefix + 2 <= _Count && _Buf [ _Prefix ] == '0'
            && ( _Buf [ _Prefix + 1 ] == 'x' || _Buf [ _Prefix + 1 ] == 'X' ) ) {
            _Prefix += 2;
        }

        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
        basic_string < _Elem > _Groupstring ( _Count, _Elem ( 0 ) );
        _Ctype_fac . widen ( _Buf, _Buf + _Count, & _Groupstring [ 0 ] );

        const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
        const string _Grouping = _Punct_fac . grouping ( );
        const char * _Pg = & _Grouping [ 0 ];
        if ( * _Pg != 127 && '\000' < * _Pg ) {
            const _Elem _Kseparator = _Punct_fac . thousands_sep ( );
            while ( * _Pg != 127 && '\000' < * _Pg && static_cast < size_t > ( * _Pg ) < _Count - _Prefix ) {

                _Count -= * _Pg;
                _Groupstring . insert ( _Count, 1, _Kseparator );
                if ( '\000' < _Pg [ 1 ] ) {
                    ++ _Pg;
                }
            }
        }

        _Count = _Groupstring . size ( );

        size_t _Fillcount;
        if ( _Iosbase . width ( ) <= 0 || static_cast < size_t > ( _Iosbase . width ( ) ) <= _Count ) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast < size_t > ( _Iosbase . width ( ) ) - _Count;
        }

        ios_base :: fmtflags _Adjustfield = _Iosbase . flags ( ) & ios_base :: adjustfield;
        if ( _Adjustfield != ios_base :: left && _Adjustfield != ios_base :: internal ) {
            _Dest = _Rep ( _Dest, _Fill, _Fillcount );
            _Fillcount = 0;
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
        } else if ( _Adjustfield == ios_base :: internal ) {
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
            _Dest = _Rep ( _Dest, _Fill, _Fillcount );
            _Fillcount = 0;
        } else {
            _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
        }

        _Dest = _Put ( _Dest, & _Groupstring [ _Prefix ], _Count - _Prefix );
        _Iosbase . width ( 0 );
        return _Rep ( _Dest, _Fill, _Fillcount );
    }

    _OutIt __cdecl _Put (
        _OutIt _Dest, const _Elem * _Ptr, size_t _Count ) const {
        for (; 0 < _Count; -- _Count, ( void ) ++ _Dest, ++ _Ptr ) {
            * _Dest = * _Ptr;
        }

        return _Dest;
    }

    _OutIt __cdecl _Rep ( _OutIt _Dest, _Elem _Ch, size_t _Count ) const {
        for (; 0 < _Count; -- _Count, ( void ) ++ _Dest ) {
            * _Dest = _Ch;
        }

        return _Dest;
    }
};
#line 1601
template< class _Elem, class _OutIt> locale::id 
#line 1602
num_put< _Elem, _OutIt> ::id; 
#line 1628 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
}
#line 1631
#pragma warning(pop)
#pragma pack ( pop )
#line 1635 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 20
namespace std { 
#line 21
template < class _Elem, class _Traits >
class basic_ios : public ios_base {
public :
    using _Myos = basic_ostream < _Elem, _Traits >;
    using _Mysb = basic_streambuf < _Elem, _Traits >;
    using _Ctype = ctype < _Elem >;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    explicit basic_ios ( _Mysb * _Strbuf ) {
        init ( _Strbuf );
    }

    virtual ~ basic_ios ( ) noexcept { }

    void clear ( iostate _State = goodbit, bool _Reraise = false ) {

        ios_base :: clear ( _State | ( _Mystrbuf ? ios_base :: _Iostate { } : ios_base :: badbit ), _Reraise );
    }


    void clear ( io_state _State ) {
        clear ( static_cast < iostate > ( _State ) );
    }


    void setstate (
        iostate _State, bool _Reraise = false ) {
        clear ( rdstate ( ) | _State, _Reraise );
    }


    void setstate ( io_state _State ) {
        setstate ( static_cast < iostate > ( _State ) );
    }


    basic_ios & copyfmt ( const basic_ios & _Right ) {
        _Tiestr = _Right . tie ( );
        _Fillch = _Right . fill ( );
        ios_base :: copyfmt ( _Right );
        return * this;
    }

    _Myos * tie ( ) const {
        return _Tiestr;
    }

    _Myos * tie ( _Myos * _Newtie ) {
        _Myos * _Oldtie = _Tiestr;
        _Tiestr = _Newtie;
        return _Oldtie;
    }

    [ [ nodiscard ] ] _Mysb * rdbuf ( ) const {
        return _Mystrbuf;
    }

    _Mysb * rdbuf ( _Mysb * _Strbuf ) {
        _Mysb * _Oldstrbuf = _Mystrbuf;
        _Mystrbuf = _Strbuf;
        clear ( );
        return _Oldstrbuf;
    }

    locale imbue ( const locale & _Loc ) {
        locale _Oldlocale = ios_base :: imbue ( _Loc );
        const auto _Rdbuf = rdbuf ( );
        if ( _Rdbuf ) {
            _Rdbuf -> pubimbue ( _Loc );
        }

        return _Oldlocale;
    }

    _Elem fill ( ) const {
        return _Fillch;
    }

    _Elem fill ( _Elem _Newfill ) {
        _Elem _Oldfill = _Fillch;
        _Fillch = _Newfill;
        return _Oldfill;
    }

    char narrow ( _Elem _Ch, char _Dflt = '\000' ) const {
        return :: std :: use_facet < _Ctype > ( getloc ( ) ) . narrow ( _Ch, _Dflt );
    }

    _Elem widen ( char _Byte ) const {
        return :: std :: use_facet < _Ctype > ( getloc ( ) ) . widen ( _Byte );
    }

    void move ( basic_ios & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Mystrbuf = nullptr;
            _Tiestr = nullptr;
            this -> swap ( _Right );
        }
    }

    void move ( basic_ios && _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Mystrbuf = nullptr;
            _Tiestr = nullptr;
            this -> swap ( _Right );
        }
    }

    void swap ( basic_ios & _Right ) noexcept {
        ios_base :: swap ( _Right );
        :: std :: swap ( _Fillch, _Right . _Fillch );
        :: std :: swap ( _Tiestr, _Right . _Tiestr );
    }

    void set_rdbuf ( _Mysb * _Strbuf ) {
        _Mystrbuf = _Strbuf;
    }

protected :
    void init ( _Mysb * _Strbuf = nullptr,
        bool _Isstd = false ) {
        _Init ( );
        _Mystrbuf = _Strbuf;
        _Tiestr = nullptr;
        _Fillch = widen ( ' ' );

        if ( ! _Mystrbuf ) {
            setstate ( badbit );
        }

        if ( _Isstd ) {
            _Addstd ( this );
        }
    }

     basic_ios ( ) { }

private :
    _Mysb * _Mystrbuf;
    _Myos * _Tiestr;
    _Elem _Fillch;

public :
     basic_ios ( const basic_ios & ) = delete;
    basic_ios & operator = ( const basic_ios & ) = delete;
};
#line 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"
inline ios_base &__cdecl boolalpha(ios_base &_Iosbase) { 
#line 185
_Iosbase.setf(_Iosb< int> ::boolalpha); 
#line 186
return _Iosbase; 
#line 187
} 
#line 189
inline ios_base &__cdecl dec(ios_base &_Iosbase) { 
#line 190
_Iosbase.setf(_Iosb< int> ::dec, _Iosb< int> ::basefield); 
#line 191
return _Iosbase; 
#line 192
} 
#line 194
inline ios_base &__cdecl defaultfloat(ios_base &_Iosbase) { 
#line 195
_Iosbase.unsetf(_Iosb< int> ::floatfield); 
#line 196
return _Iosbase; 
#line 197
} 
#line 199
inline ios_base &__cdecl fixed(ios_base &_Iosbase) { 
#line 200
_Iosbase.setf(_Iosb< int> ::fixed, _Iosb< int> ::floatfield); 
#line 201
return _Iosbase; 
#line 202
} 
#line 204
inline ios_base &__cdecl hex(ios_base &_Iosbase) { 
#line 205
_Iosbase.setf(_Iosb< int> ::hex, _Iosb< int> ::basefield); 
#line 206
return _Iosbase; 
#line 207
} 
#line 209
inline ios_base &__cdecl hexfloat(ios_base &_Iosbase) { 
#line 210
_Iosbase.setf(_Iosb< int> ::hexfloat, _Iosb< int> ::floatfield); 
#line 211
return _Iosbase; 
#line 212
} 
#line 214
inline ios_base &__cdecl internal(ios_base &_Iosbase) { 
#line 215
_Iosbase.setf(_Iosb< int> ::internal, _Iosb< int> ::adjustfield); 
#line 216
return _Iosbase; 
#line 217
} 
#line 219
inline ios_base &__cdecl left(ios_base &_Iosbase) { 
#line 220
_Iosbase.setf(_Iosb< int> ::left, _Iosb< int> ::adjustfield); 
#line 221
return _Iosbase; 
#line 222
} 
#line 224
inline ios_base &__cdecl noboolalpha(ios_base &_Iosbase) { 
#line 225
_Iosbase.unsetf(_Iosb< int> ::boolalpha); 
#line 226
return _Iosbase; 
#line 227
} 
#line 229
inline ios_base &__cdecl noshowbase(ios_base &_Iosbase) { 
#line 230
_Iosbase.unsetf(_Iosb< int> ::showbase); 
#line 231
return _Iosbase; 
#line 232
} 
#line 234
inline ios_base &__cdecl noshowpoint(ios_base &_Iosbase) { 
#line 235
_Iosbase.unsetf(_Iosb< int> ::showpoint); 
#line 236
return _Iosbase; 
#line 237
} 
#line 239
inline ios_base &__cdecl noshowpos(ios_base &_Iosbase) { 
#line 240
_Iosbase.unsetf(_Iosb< int> ::showpos); 
#line 241
return _Iosbase; 
#line 242
} 
#line 244
inline ios_base &__cdecl noskipws(ios_base &_Iosbase) { 
#line 245
_Iosbase.unsetf(_Iosb< int> ::skipws); 
#line 246
return _Iosbase; 
#line 247
} 
#line 249
inline ios_base &__cdecl nounitbuf(ios_base &_Iosbase) { 
#line 250
_Iosbase.unsetf(_Iosb< int> ::unitbuf); 
#line 251
return _Iosbase; 
#line 252
} 
#line 254
inline ios_base &__cdecl nouppercase(ios_base &_Iosbase) { 
#line 255
_Iosbase.unsetf(_Iosb< int> ::uppercase); 
#line 256
return _Iosbase; 
#line 257
} 
#line 259
inline ios_base &__cdecl oct(ios_base &_Iosbase) { 
#line 260
_Iosbase.setf(_Iosb< int> ::oct, _Iosb< int> ::basefield); 
#line 261
return _Iosbase; 
#line 262
} 
#line 264
inline ios_base &__cdecl right(ios_base &_Iosbase) { 
#line 265
_Iosbase.setf(_Iosb< int> ::right, _Iosb< int> ::adjustfield); 
#line 266
return _Iosbase; 
#line 267
} 
#line 269
inline ios_base &__cdecl scientific(ios_base &_Iosbase) { 
#line 270
_Iosbase.setf(_Iosb< int> ::scientific, _Iosb< int> ::floatfield); 
#line 271
return _Iosbase; 
#line 272
} 
#line 274
inline ios_base &__cdecl showbase(ios_base &_Iosbase) { 
#line 275
_Iosbase.setf(_Iosb< int> ::showbase); 
#line 276
return _Iosbase; 
#line 277
} 
#line 279
inline ios_base &__cdecl showpoint(ios_base &_Iosbase) { 
#line 280
_Iosbase.setf(_Iosb< int> ::showpoint); 
#line 281
return _Iosbase; 
#line 282
} 
#line 284
inline ios_base &__cdecl showpos(ios_base &_Iosbase) { 
#line 285
_Iosbase.setf(_Iosb< int> ::showpos); 
#line 286
return _Iosbase; 
#line 287
} 
#line 289
inline ios_base &__cdecl skipws(ios_base &_Iosbase) { 
#line 290
_Iosbase.setf(_Iosb< int> ::skipws); 
#line 291
return _Iosbase; 
#line 292
} 
#line 294
inline ios_base &__cdecl unitbuf(ios_base &_Iosbase) { 
#line 295
_Iosbase.setf(_Iosb< int> ::unitbuf); 
#line 296
return _Iosbase; 
#line 297
} 
#line 299
inline ios_base &__cdecl uppercase(ios_base &_Iosbase) { 
#line 300
_Iosbase.setf(_Iosb< int> ::uppercase); 
#line 301
return _Iosbase; 
#line 302
} 
#line 305
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 306
using std::hexfloat;
#line 307
}
#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"
}
#line 314
#pragma warning(pop)
#pragma pack ( pop )
#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 20
namespace std { 
#pragma vtordisp(push, 2)
#line 23
template < class _Elem, class _Traits >
class basic_ostream : virtual public basic_ios < _Elem, _Traits > {
public :
    using _Myios = basic_ios < _Elem, _Traits >;
    using _Mysb = basic_streambuf < _Elem, _Traits >;
    using _Iter = ostreambuf_iterator < _Elem, _Traits >;
    using _Nput = num_put < _Elem, _Iter >;

    explicit basic_ostream ( basic_streambuf < _Elem, _Traits > * _Strbuf, bool _Isstd = false ) {
        _Myios :: init ( _Strbuf, _Isstd );
    }

     basic_ostream ( _Uninitialized, bool _Addit = true ) {
        if ( _Addit ) {
            this -> _Addstd ( this );
        }
    }

protected :
     basic_ostream ( basic_ostream && _Right ) {
        _Myios :: init ( );
        _Myios :: move ( :: std :: move ( _Right ) );
    }

    basic_ostream & operator = ( basic_ostream && _Right ) {
        this -> swap ( _Right );
        return * this;
    }

    void swap ( basic_ostream & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Myios :: swap ( _Right );
        }
    }

public :
     basic_ostream ( const basic_ostream & ) = delete;
    basic_ostream & operator = ( const basic_ostream & ) = delete;

    virtual ~ basic_ostream ( ) noexcept { }

    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    class _Sentry_base {
    public :
         _Sentry_base ( basic_ostream & _Ostr ) : _Myostr ( _Ostr ) {
            const auto _Rdbuf = _Myostr . rdbuf ( );
            if ( _Rdbuf ) {
                _Rdbuf -> _Lock ( );
            }
        }

         ~ _Sentry_base ( ) noexcept {
            const auto _Rdbuf = _Myostr . rdbuf ( );
            if ( _Rdbuf ) {
                _Rdbuf -> _Unlock ( );
            }
        }

        basic_ostream & _Myostr;

        _Sentry_base & operator = ( const _Sentry_base & ) = delete;
    };

    class sentry : public _Sentry_base {
    public :
        explicit sentry ( basic_ostream & _Ostr ) : _Sentry_base ( _Ostr ) {
            if ( ! _Ostr . good ( ) ) {
                _Ok = false;
                return;
            }

            const auto _Tied = _Ostr . tie ( );
            if ( ! _Tied || _Tied == & _Ostr ) {
                _Ok = true;
                return;
            }

            _Tied -> flush ( );
            _Ok = _Ostr . good ( );
        }

        __pragma(warning(push))                                __pragma(warning(disable : 4996))
         ~ sentry ( ) noexcept {



            const bool _Zero_uncaught_exceptions = ! :: std :: uncaught_exception ( );




            if ( _Zero_uncaught_exceptions ) {
                this -> _Myostr . _Osfx ( );
            }
        }
        __pragma(warning(pop))

        explicit operator bool ( ) const {
            return _Ok;
        }

         sentry ( const sentry & ) = delete;
        sentry & operator = ( const sentry & ) = delete;

    private :
        bool _Ok;
    };


    bool opfx ( ) {
        if ( ! this -> good ( ) ) {
            return false;
        }

        const auto _Tied = _Myios :: tie ( );
        if ( ! _Tied || _Myios :: tie ( ) == this ) {
            return true;
        }

        _Tied -> flush ( );
        return this -> good ( );
    }


    void osfx ( ) {
        _Osfx ( );
    }

    void _Osfx ( ) {
        try {
        if ( this -> good ( ) && this -> flags ( ) & ios_base :: unitbuf ) {
            if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 ) {
                _Myios :: setstate ( ios_base :: badbit );
            }
        }
        } catch ( ... ) {
        }
    }


















    basic_ostream & operator << (
        basic_ostream & ( __cdecl * _Pfn ) ( basic_ostream & ) ) {
        return _Pfn ( * this );
    }

    basic_ostream & operator << ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) ) {
        _Pfn ( * this );
        return * this;
    }

    basic_ostream & operator << ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) ) {
        _Pfn ( * this );
        return * this;
    }

    basic_ostream & operator << ( bool _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( short _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );
            ios_base :: fmtflags _Bfl = this -> flags ( ) & ios_base :: basefield;

            long _Tmp;
            if ( _Bfl == ios_base :: oct || _Bfl == ios_base :: hex ) {
                _Tmp = static_cast < long > ( static_cast < unsigned short > ( _Val ) );
            } else {
                _Tmp = static_cast < long > ( _Val );
            }

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Tmp ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }









    basic_ostream & operator << ( unsigned short _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), static_cast < unsigned long > ( _Val ) )
                    . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( int _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );
            ios_base :: fmtflags _Bfl = this -> flags ( ) & ios_base :: basefield;

            long _Tmp;
            if ( _Bfl == ios_base :: oct || _Bfl == ios_base :: hex ) {
                _Tmp = static_cast < long > ( static_cast < unsigned int > ( _Val ) );
            } else {
                _Tmp = static_cast < long > ( _Val );
            }

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Tmp ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( unsigned int _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), static_cast < unsigned long > ( _Val ) )
                    . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( long _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( unsigned long _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( long long _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( unsigned long long _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( float _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), static_cast < double > ( _Val ) ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( double _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( long double _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & operator << ( const void * _Val ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

            try {
            if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this, _Myios :: fill ( ), _Val ) . failed ( ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }








    basic_ostream & operator << ( _Mysb * _Strbuf ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        bool _Copied = false;
        const sentry _Ok ( * this );

        if ( _Ok && _Strbuf ) {
            for ( int_type _Meta = _Traits :: eof ( );; _Copied = true ) {
                try {
                _Meta = _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ? _Strbuf -> sgetc ( ) : _Strbuf -> snextc ( );
                } catch ( ... ) {
                _Myios :: setstate ( ios_base :: failbit );
                throw;
                }

                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    break;
                }

                try {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Myios :: rdbuf ( ) -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
                } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
            }
        }

        this -> width ( 0 );
        int _Setstate_with;
        if ( _Strbuf ) {
            if ( _Copied ) {
                _Setstate_with = _State;
            } else {
                _Setstate_with = _State | ios_base :: failbit;
            }
        } else {
            _Setstate_with = ios_base :: badbit;
        }

        _Myios :: setstate ( _Setstate_with );
        return * this;
    }

    basic_ostream & put ( _Elem _Ch ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( ! _Ok ) {
            _State |= ios_base :: badbit;
        } else {
            try {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Myios :: rdbuf ( ) -> sputc ( _Ch ) ) ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & write ( const _Elem * _Str,
        streamsize _Count ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( ! _Ok ) {
            _State |= ios_base :: badbit;
        } else if ( 0 < _Count ) {
            try {
            if ( _Myios :: rdbuf ( ) -> sputn ( _Str, _Count ) != _Count ) {
                _State |= ios_base :: badbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_ostream & flush ( ) {
        const auto _Rdbuf = _Myios :: rdbuf ( );
        if ( _Rdbuf ) {
            const sentry _Ok ( * this );

            if ( _Ok && _Rdbuf -> pubsync ( ) == - 1 ) {
                _Myios :: setstate ( ios_base :: badbit );
            }
        }
        return * this;
    }

    basic_ostream & seekp ( pos_type _Pos ) {
        const sentry _Ok ( * this );

        if ( ! this -> fail ( ) && static_cast < off_type > ( _Myios :: rdbuf ( ) -> pubseekpos ( _Pos, ios_base :: out ) ) == - 1 ) {
            _Myios :: setstate ( ios_base :: failbit );
        }

        return * this;
    }

    basic_ostream & seekp (
        off_type _Off, ios_base :: seekdir _Way ) {
        const sentry _Ok ( * this );

        if ( ! this -> fail ( ) && static_cast < off_type > ( _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way, ios_base :: out ) ) == - 1 ) {
            _Myios :: setstate ( ios_base :: failbit );
        }

        return * this;
    }

    pos_type tellp ( ) {
        const sentry _Ok ( * this );

        if ( ! this -> fail ( ) ) {
            return _Myios :: rdbuf ( ) -> pubseekoff ( 0, ios_base :: cur, ios_base :: out );
        } else {
            return pos_type ( - 1 );
        }
    }
};
#line 588 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
#pragma vtordisp(pop)
#line 649 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, const char * _Val ) {
    ios_base :: iostate _State = ios_base :: goodbit;
    streamsize _Count = static_cast < streamsize > ( :: strlen ( _Val ) );
    streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count ? 0 : _Ostr . width ( ) - _Count;
    const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

    if ( ! _Ok ) {
        _State |= ios_base :: badbit;
    } else {
        try {
        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Ostr . getloc ( ) );
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        for (; _State == ios_base :: goodbit && 0 < _Count; -- _Count, ++ _Val ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( * _Val ) ) ) ) {
                _State |= ios_base :: badbit;
            }
        }

        if ( _State == ios_base :: goodbit ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        _Ostr . width ( 0 );
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 693
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, char _Ch ) {
    ios_base :: iostate _State = ios_base :: goodbit;
    const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

    if ( _Ok ) {
        const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Ostr . getloc ( ) );
        streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                }
            }
        }

        if ( _State == ios_base :: goodbit
            && _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( _Ch ) ) ) ) {
            _State |= ios_base :: badbit;
        }

        for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                _State |= ios_base :: badbit;
            }
        }
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . width ( 0 );
    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 729
template < class _Traits >
basic_ostream < char, _Traits > & operator << ( basic_ostream < char, _Traits > & _Ostr,
    const char * _Val ) {
    using _Elem = char;
    using _Myos = basic_ostream < _Elem, _Traits >;

    ios_base :: iostate _State = ios_base :: goodbit;
    streamsize _Count = static_cast < streamsize > ( _Traits :: length ( _Val ) );
    streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count ? 0 : _Ostr . width ( ) - _Count;
    const typename _Myos :: sentry _Ok ( _Ostr );

    if ( ! _Ok ) {
        _State |= ios_base :: badbit;
    } else {
        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        if ( _State == ios_base :: goodbit && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count ) {
            _State |= ios_base :: badbit;
        }

        if ( _State == ios_base :: goodbit ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        _Ostr . width ( 0 );
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 774
template < class _Traits >
basic_ostream < char, _Traits > & operator << (
    basic_ostream < char, _Traits > & _Ostr, char _Ch ) {
    using _Elem = char;
    using _Myos = basic_ostream < _Elem, _Traits >;

    ios_base :: iostate _State = ios_base :: goodbit;
    const typename _Myos :: sentry _Ok ( _Ostr );

    if ( _Ok ) {
        streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                }
            }
        }

        if ( _State == ios_base :: goodbit && _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) ) {
            _State |= ios_base :: badbit;
        }

        for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                _State |= ios_base :: badbit;
            }
        }
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . width ( 0 );
    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 812
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * _Val ) {
    using _Myos = basic_ostream < _Elem, _Traits >;

    ios_base :: iostate _State = ios_base :: goodbit;
    streamsize _Count = static_cast < streamsize > ( _Traits :: length ( _Val ) );
    streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count ? 0 : _Ostr . width ( ) - _Count;
    const typename _Myos :: sentry _Ok ( _Ostr );

    if ( ! _Ok ) {
        _State |= ios_base :: badbit;
    } else {
        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        if ( _State == ios_base :: goodbit && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count ) {
            _State |= ios_base :: badbit;
        }

        if ( _State == ios_base :: goodbit ) {
            for (; 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                    break;
                }
            }
        }

        _Ostr . width ( 0 );
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 855
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr, _Elem _Ch ) {
    using _Myos = basic_ostream < _Elem, _Traits >;

    ios_base :: iostate _State = ios_base :: goodbit;
    const typename _Myos :: sentry _Ok ( _Ostr );

    if ( _Ok ) {
        streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

        try {
        if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left ) {
            for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                    _State |= ios_base :: badbit;
                }
            }
        }

        if ( _State == ios_base :: goodbit && _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) ) {
            _State |= ios_base :: badbit;
        }

        for (; _State == ios_base :: goodbit && 0 < _Pad; -- _Pad ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) ) {
                _State |= ios_base :: badbit;
            }
        }
        } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Ostr . width ( 0 );
    _Ostr . setstate ( _State );
    return _Ostr;
}
#line 891
template < class _Traits >
basic_ostream < char, _Traits > & operator << (
    basic_ostream < char, _Traits > & _Ostr, const signed char * _Val ) {
    return _Ostr << reinterpret_cast < const char * > ( _Val );
}
#line 897
template < class _Traits >
basic_ostream < char, _Traits > & operator << ( basic_ostream < char, _Traits > & _Ostr, signed char _Ch ) {
    return _Ostr << static_cast < char > ( _Ch );
}
#line 902
template < class _Traits >
basic_ostream < char, _Traits > & operator << (
    basic_ostream < char, _Traits > & _Ostr, const unsigned char * _Val ) {
    return _Ostr << reinterpret_cast < const char * > ( _Val );
}
#line 908
template < class _Traits >
basic_ostream < char, _Traits > & operator << (
    basic_ostream < char, _Traits > & _Ostr, unsigned char _Ch ) {
    return _Ostr << static_cast < char > ( _Ch );
}
#line 958 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
template< class _Ostr, class _Ty, class  = void> 
#line 959
struct _Can_stream_out : public false_type { }; 
#line 961
template< class _Ostr, class _Ty> 
#line 962
struct _Can_stream_out< _Ostr, _Ty, void_t< decltype(std::declval< _Ostr &> () << std::declval< const _Ty &> ())> >  : public true_type { 
#line 963
}; 
#line 965
template < class _Ostr, class _Ty,
    enable_if_t < conjunction_v < is_convertible < _Ostr *, ios_base * >, _Can_stream_out < _Ostr, _Ty > >, int > = 0 >
_Ostr && operator << ( _Ostr && _Os, const _Ty & _Val ) {
    _Os << _Val;
    return :: std :: move ( _Os );
}
#line 972
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & __cdecl endl (
    basic_ostream < _Elem, _Traits > & _Ostr ) {
    _Ostr . put ( _Ostr . widen ( '\n' ) );
    _Ostr . flush ( );
    return _Ostr;
}
#line 980
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & __cdecl ends ( basic_ostream < _Elem, _Traits > & _Ostr ) {
    _Ostr . put ( _Elem ( ) );
    return _Ostr;
}
#line 986
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & __cdecl flush ( basic_ostream < _Elem, _Traits > & _Ostr ) {
    _Ostr . flush ( );
    return _Ostr;
}
#line 1031 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const error_code & _Errcode ) {
    return _Ostr << _Errcode . category ( ) . name ( ) << ':' << _Errcode . value ( );
}
#line 1036
}
#line 1040
#pragma warning(pop)
#pragma pack ( pop )
#line 1044 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 20
namespace std { 
#pragma vtordisp(push, 2)
#line 23
template < class _Elem, class _Traits >
class basic_istream : virtual public basic_ios < _Elem, _Traits > {
public :
    using _Myios = basic_ios < _Elem, _Traits >;
    using _Mysb = basic_streambuf < _Elem, _Traits >;
    using _Iter = istreambuf_iterator < _Elem, _Traits >;
    using _Ctype = ctype < _Elem >;
    using _Nget = num_get < _Elem, _Iter >;









    explicit basic_istream ( _Mysb * _Strbuf, bool _Isstd = false )

        : _Chcount ( 0 ) {
        _Myios :: init ( _Strbuf, _Isstd );
    }

     basic_istream ( _Uninitialized ) {
        this -> _Addstd ( this );
    }

protected :
     basic_istream ( basic_istream && _Right ) : _Chcount ( _Right . _Chcount ) {
        _Myios :: init ( );
        _Myios :: move ( :: std :: move ( _Right ) );
        _Right . _Chcount = 0;
    }

    basic_istream & operator = ( basic_istream && _Right ) {
        this -> swap ( _Right );
        return * this;
    }

    void swap ( basic_istream & _Right ) {
        _Myios :: swap ( _Right );
        :: std :: swap ( _Chcount, _Right . _Chcount );
    }

public :
     basic_istream ( const basic_istream & ) = delete;
    basic_istream & operator = ( const basic_istream & ) = delete;

    virtual ~ basic_istream ( ) noexcept { }

    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    class _Sentry_base {
    public :
         _Sentry_base ( basic_istream & _Istr ) : _Myistr ( _Istr ) {
            const auto _Rdbuf = _Myistr . rdbuf ( );
            if ( _Rdbuf ) {
                _Rdbuf -> _Lock ( );
            }
        }

         ~ _Sentry_base ( ) noexcept {
            const auto _Rdbuf = _Myistr . rdbuf ( );
            if ( _Rdbuf ) {
                _Rdbuf -> _Unlock ( );
            }
        }

        basic_istream & _Myistr;

        _Sentry_base & operator = ( const _Sentry_base & ) = delete;
    };

    class sentry : public _Sentry_base {
    public :
        explicit sentry ( basic_istream & _Istr, bool _Noskip = false )
            : _Sentry_base ( _Istr ), _Ok ( _Sentry_base :: _Myistr . _Ipfx ( _Noskip ) ) { }

        explicit operator bool ( ) const {
            return _Ok;
        }

         sentry ( const sentry & ) = delete;
        sentry & operator = ( const sentry & ) = delete;

    private :
        bool _Ok;
    };

    bool _Ipfx ( bool _Noskip = false ) {
        if ( ! this -> good ( ) ) {
            _Myios :: setstate ( ios_base :: failbit );
            return false;
        }


        const auto _Tied = _Myios :: tie ( );
        if ( _Tied ) {
            _Tied -> flush ( );
        }

        bool _Eof = false;
        if ( ! _Noskip && this -> flags ( ) & ios_base :: skipws ) {
            const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( this -> getloc ( ) );

            try {
            int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _Eof = true;
                    break;
                } else if ( ! _Ctype_fac . is ( _Ctype :: space, _Traits :: to_char_type ( _Meta ) ) ) {
                    break;
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        if ( _Eof ) {
            _Myios :: setstate ( ios_base :: eofbit | ios_base :: failbit );
        }

        return this -> good ( );
    }


    bool ipfx ( bool _Noskip = false ) {
        return _Ipfx ( _Noskip );
    }


    void isfx ( ) { }


















    basic_istream & operator >> ( basic_istream & ( __cdecl * _Pfn ) ( basic_istream & ) ) {

        return _Pfn ( * this );
    }

    basic_istream & operator >> ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) ) {
        _Pfn ( * this );
        return * this;
    }

    basic_istream & operator >> ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) ) {
        _Pfn ( * this );
        return * this;
    }

private :
    template < class _Ty >
    basic_istream & _Common_extract_with_num_get ( _Ty & _Val ) {
        ios_base :: iostate _Err = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            try {
            :: std :: use_facet < _Nget > ( this -> getloc ( ) ) . get ( * this, { }, * this, _Err, _Val );
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _Err );
        return * this;
    }

    template < class = void >
    void _Increment_gcount ( ) {
        if ( _Chcount != ( numeric_limits < streamsize > :: max ) ( ) ) {
            ++ _Chcount;
        }
    }

public :
    basic_istream & operator >> ( bool & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( short & _Val ) {
        ios_base :: iostate _Err = ios_base :: goodbit;
        const sentry _Ok ( * this );

        if ( _Ok ) {
            try {
            long _Lval;
            :: std :: use_facet < _Nget > ( this -> getloc ( ) ) . get ( * this, { }, * this, _Err, _Lval );
            if ( _Lval < ( - 32768 ) ) {
                _Err |= ios_base :: failbit;
                _Val = ( - 32768 );
            } else if ( _Lval > 32767 ) {
                _Err |= ios_base :: failbit;
                _Val = 32767;
            } else {
                _Val = static_cast < short > ( _Lval );
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _Err );
        return * this;
    }









    basic_istream & operator >> ( unsigned short & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( int & _Val ) {
        static_assert ( sizeof ( int ) == sizeof ( long ), "Bad overflow assumptions due to sizeof(int) != sizeof(long)" );
        long _Result = _Val;
        _Common_extract_with_num_get ( _Result );
        _Val = _Result;
        return * this;
    }

    basic_istream & operator >> ( unsigned int & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( long & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( unsigned long & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( long long & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( unsigned long long & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( float & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( double & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( long double & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( void * & _Val ) {
        return _Common_extract_with_num_get ( _Val );
    }

    basic_istream & operator >> ( _Mysb * _Strbuf ) {
        _Chcount = 0;
        const sentry _Ok ( * this, true );
        ios_base :: iostate _State = ios_base :: goodbit;
        if ( _Ok && _Strbuf ) {
            try {
            for ( int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                }

                try {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Strbuf -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) ) {
                    break;
                }

                } catch ( ... ) {
                break;
                }

                _Increment_gcount ( );
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        if ( _Chcount == 0 ) {
            _State |= ios_base :: failbit;
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    int_type get ( ) {
        int_type _Meta = 0;
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( ! _Ok ) {
            _Meta = _Traits :: eof ( );
        } else {
            try {
            _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                _State |= ios_base :: eofbit | ios_base :: failbit;
            } else {
                _Myios :: rdbuf ( ) -> sbumpc ( );
                _Chcount = 1;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return _Meta;
    }

    basic_istream & get ( _Elem * _Str, streamsize _Count ) {
        return get ( _Str, _Count, _Myios :: widen ( '\n' ) );
    }

    basic_istream & get (
        _Elem * _Str, streamsize _Count, _Elem _Delim ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( _Ok && 0 < _Count ) {
            try {
            int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            for (; 0 < -- _Count; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                } else if ( _Traits :: to_char_type ( _Meta ) == _Delim ) {
                    break;
                } else {
                    * _Str ++ = _Traits :: to_char_type ( _Meta );
                    _Increment_gcount ( );
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
        * _Str = _Elem ( );
        return * this;
    }

    basic_istream & get ( _Elem & _Ch ) {
        int_type _Meta = get ( );
        if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
            _Ch = _Traits :: to_char_type ( _Meta );
        }

        return * this;
    }

    basic_istream & get ( _Mysb & _Strbuf ) {
        return get ( _Strbuf, _Myios :: widen ( '\n' ) );
    }

    basic_istream & get (
        _Mysb & _Strbuf, _Elem _Delim ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( _Ok ) {
            try {
            int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                } else {
                    try {
                    _Elem _Ch = _Traits :: to_char_type ( _Meta );
                    if ( _Ch == _Delim || _Traits :: eq_int_type ( _Traits :: eof ( ), _Strbuf . sputc ( _Ch ) ) ) {
                        break;
                    }
                    } catch ( ... ) {
                    break;
                    }
                    _Increment_gcount ( );
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        if ( _Chcount == 0 ) {
            _State |= ios_base :: failbit;
        }
        _Myios :: setstate ( _State );
        return * this;
    }

    basic_istream & getline (
        _Elem * _Str, streamsize _Count ) {
        return getline ( _Str, _Count, _Myios :: widen ( '\n' ) );
    }

    basic_istream & getline (
        _Elem * _Str, streamsize _Count, _Elem _Delim ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( _Ok && 0 < _Count ) {
            int_type _Metadelim = _Traits :: to_int_type ( _Delim );

            try {
            int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

            for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) ) {
                if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                } else if ( _Meta == _Metadelim ) {
                    _Increment_gcount ( );
                    _Myios :: rdbuf ( ) -> sbumpc ( );
                    break;
                } else if ( -- _Count <= 0 ) {
                    _State |= ios_base :: failbit;
                    break;
                } else {
                    * _Str ++ = _Traits :: to_char_type ( _Meta );
                    _Increment_gcount ( );
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        * _Str = _Elem ( );
        _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
        return * this;
    }

    basic_istream & ignore ( streamsize _Count = 1,
        int_type _Metadelim = _Traits :: eof ( ) ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( _Ok && 0 < _Count ) {
            try {
            for (;; ) {
                int_type _Meta;
                if ( _Count != ( numeric_limits < streamsize > :: max ) ( ) && -- _Count < 0 ) {
                    break;
                } else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
                               _Meta = _Myios :: rdbuf ( ) -> sbumpc ( ) ) ) {
                    _State |= ios_base :: eofbit;
                    break;
                } else {
                    _Increment_gcount ( );
                    if ( _Meta == _Metadelim ) {
                        break;
                    }
                }
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_istream & read ( _Elem * _Str, streamsize _Count ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );

        if ( _Ok && 0 < _Count ) {
            try {
            const streamsize _Num = _Myios :: rdbuf ( ) -> sgetn ( _Str, _Count );
            _Chcount = _Num;

            if ( _Num != _Count ) {
                _State |= ios_base :: eofbit | ios_base :: failbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    streamsize readsome ( _Elem * _Str,
        streamsize _Count ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        const sentry _Ok ( * this, true );
        streamsize _Num;

        if ( ! _Ok ) {
            _State |= ios_base :: failbit;
        } else if ( ( _Num = _Myios :: rdbuf ( ) -> in_avail ( ) ) < 0 ) {
            _State |= ios_base :: eofbit;
        } else if ( 0 < _Count && 0 < _Num ) {
            read ( _Str, _Num < _Count ? _Num : _Count );
        }

        _Myios :: setstate ( _State );
        return gcount ( );
    }

    int_type peek ( ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        _Chcount = 0;
        int_type _Meta = 0;
        const sentry _Ok ( * this, true );

        if ( ! _Ok ) {
            _Meta = _Traits :: eof ( );
        } else {
            try {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta = _Myios :: rdbuf ( ) -> sgetc ( ) ) ) {
                _State |= ios_base :: eofbit;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return _Meta;
    }

    basic_istream & putback ( _Elem _Ch ) {
        _Chcount = 0;
        ios_base :: iostate _State = ios_base :: goodbit;
        ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
        _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
        const sentry _Ok ( * this, true );

        if ( _Ok ) {
            try {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Myios :: rdbuf ( ) -> sputbackc ( _Ch ) ) ) {
                _State |= ios_base :: badbit | _Oldstate;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    basic_istream & unget ( ) {
        _Chcount = 0;
        ios_base :: iostate _State = ios_base :: goodbit;
        ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
        _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
        const sentry _Ok ( * this, true );

        if ( _Ok ) {
            try {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Myios :: rdbuf ( ) -> sungetc ( ) ) ) {
                _State |= ios_base :: badbit | _Oldstate;
            }
            } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        }

        _Myios :: setstate ( _State );
        return * this;
    }

    [ [ nodiscard ] ] streamsize gcount ( ) const {
        return _Chcount;
    }

    int sync ( ) {
        const sentry _Ok ( * this, true );

        const auto _Rdbuf = _Myios :: rdbuf ( );
        if ( ! _Rdbuf ) {
            return - 1;
        }

        bool _Sync_failed = true;
        try {
        _Sync_failed = _Rdbuf -> pubsync ( ) == - 1;
        } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
        if ( _Sync_failed ) {
            _Myios :: setstate ( ios_base :: badbit );
            return - 1;
        }

        return 0;
    }

    basic_istream & seekg ( pos_type _Pos ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
        _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
        const sentry _Ok ( * this, true );

        if ( ! this -> fail ( ) && static_cast < off_type > ( _Myios :: rdbuf ( ) -> pubseekpos ( _Pos, ios_base :: in ) ) == - 1 ) {
            _Myios :: setstate ( _State | ios_base :: failbit );
        }

        return * this;
    }

    basic_istream & seekg (
        off_type _Off, ios_base :: seekdir _Way ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
        _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
        const sentry _Ok ( * this, true );

        if ( ! this -> fail ( ) && static_cast < off_type > ( _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way, ios_base :: in ) ) == - 1 ) {
            _Myios :: setstate ( _State | ios_base :: failbit );
        }

        return * this;
    }

    pos_type tellg ( ) {
        const sentry _Ok ( * this, true );

        if ( ! this -> fail ( ) ) {
            return _Myios :: rdbuf ( ) -> pubseekoff ( 0, ios_base :: cur, ios_base :: in );
        } else {
            return pos_type ( - 1 );
        }
    }

private :
    streamsize _Chcount;
};
#line 673 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
#pragma vtordisp(pop)
#line 706 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
template < class _Elem, class _Traits >
class basic_iostream : public basic_istream < _Elem, _Traits >,
                       public basic_ostream < _Elem, _Traits > {
public :
    using _Myis = basic_istream < _Elem, _Traits >;
    using _Myos = basic_ostream < _Elem, _Traits >;
    using _Myios = basic_ios < _Elem, _Traits >;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename _Traits :: int_type;
    using pos_type = typename _Traits :: pos_type;
    using off_type = typename _Traits :: off_type;

    explicit basic_iostream ( basic_streambuf < _Elem, _Traits > * _Strbuf )
        : _Myis ( _Strbuf, false ), _Myos ( _Noinit, false ) { }

protected :
     basic_iostream ( basic_iostream && _Right ) : _Myis ( _Right . rdbuf ( ), false ), _Myos ( _Noinit, false ) {
        _Myios :: init ( );
        _Myios :: move ( :: std :: move ( _Right ) );
    }

    basic_iostream & operator = ( basic_iostream && _Right ) {
        this -> swap ( _Right );
        return * this;
    }

    void swap ( basic_iostream & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Myios :: swap ( _Right );
        }
    }

public :
     basic_iostream ( const basic_iostream & ) = delete;
    basic_iostream & operator = ( const basic_iostream & ) = delete;

    virtual ~ basic_iostream ( ) noexcept { }
};
#line 758 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & _Istream_extract_into_buffer (
    basic_istream < _Elem, _Traits > & _Istr, size_t _Size, _Elem * _Str ) {
    using _Myis = basic_istream < _Elem, _Traits >;
    using _Ctype = ctype < _Elem >;
    ios_base :: iostate _State = ios_base :: goodbit;
    size_t _Current = 0;
    const typename _Myis :: sentry _Ok ( _Istr );

    if ( _Ok ) {
        const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( _Istr . getloc ( ) );

        try {
        size_t _Count = _Size;
        const size_t _Width = static_cast < size_t > ( _Istr . width ( ) );
        if ( _Width > 0 && _Width < _Size ) {
            _Count = _Width;
        }

        typename _Myis :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );
        _Elem _Ch;

        for (; _Current < _Count - 1; _Meta = _Istr . rdbuf ( ) -> snextc ( ), ( void ) ++ _Current ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                _State |= ios_base :: eofbit;
                break;
            } else if ( _Ctype_fac . is ( _Ctype :: space, _Ch = _Traits :: to_char_type ( _Meta ) ) || _Ch == _Elem ( ) ) {
                break;
            } else {
                _Str [ _Current ] = _Traits :: to_char_type ( _Meta );
            }
        }
        } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
    }
    ;
    _Str [ _Current ] = _Elem ( );
    _Istr . width ( 0 );
    if ( _Current == 0 ) {
        _State |= ios_base :: failbit;
    }
    _Istr . setstate ( _State );
    return _Istr;
}
#line 824 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr, _Elem * _Str ) {
    return _Istream_extract_into_buffer ( _Istr, 18446744073709551615Ui64, _Str );
}
#line 829
template < class _Traits >
basic_istream < char, _Traits > & operator >> ( basic_istream < char, _Traits > & _Istr, signed char * _Str ) {
    return _Istream_extract_into_buffer ( _Istr, 18446744073709551615Ui64, reinterpret_cast < char * > ( _Str ) );
}
#line 834
template < class _Traits >
basic_istream < char, _Traits > & operator >> ( basic_istream < char, _Traits > & _Istr, unsigned char * _Str ) {
    return _Istream_extract_into_buffer ( _Istr, 18446744073709551615Ui64, reinterpret_cast < char * > ( _Str ) );
}
#line 840 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr, _Elem & _Ch ) {
    using _Myis = basic_istream < _Elem, _Traits >;

    typename _Myis :: int_type _Meta;
    ios_base :: iostate _State = ios_base :: goodbit;
    const typename _Myis :: sentry _Ok ( _Istr );

    if ( _Ok ) {
        try {
        _Meta = _Istr . rdbuf ( ) -> sbumpc ( );
        if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
            _State |= ios_base :: eofbit | ios_base :: failbit;
        } else {
            _Ch = _Traits :: to_char_type ( _Meta );
        }
        } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
    }

    _Istr . setstate ( _State );
    return _Istr;
}
#line 863
template < class _Traits >
basic_istream < char, _Traits > & operator >> (
    basic_istream < char, _Traits > & _Istr, signed char & _Ch ) {
    return _Istr >> reinterpret_cast < char & > ( _Ch );
}
#line 869
template < class _Traits >
basic_istream < char, _Traits > & operator >> (
    basic_istream < char, _Traits > & _Istr, unsigned char & _Ch ) {
    return _Istr >> reinterpret_cast < char & > ( _Ch );
}
#line 875
template< class _Istr, class _Ty, class  = void> 
#line 876
struct _Can_stream_in : public false_type { }; 
#line 878
template< class _Istr, class _Ty> 
#line 879
struct _Can_stream_in< _Istr, _Ty, void_t< decltype(std::declval< _Istr &> () >> std::declval< _Ty> ())> >  : public true_type { }; 
#line 881
template < class _Istr, class _Ty,
    enable_if_t < conjunction_v < is_convertible < _Istr *, ios_base * >, _Can_stream_in < _Istr, _Ty > >, int > = 0 >
_Istr && operator >> ( _Istr && _Is, _Ty && _Val ) {
    _Is >> :: std :: forward < _Ty > ( _Val );
    return :: std :: move ( _Is );
}
#line 888
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & __cdecl ws ( basic_istream < _Elem, _Traits > & _Istr ) {
    const typename basic_istream < _Elem, _Traits > :: sentry _Ok ( _Istr, true );

    if ( _Ok ) {
        ios_base :: iostate _State = ios_base :: goodbit;
        const auto & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Istr . getloc ( ) );

        try {
        for ( typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );; _Meta = _Istr . rdbuf ( ) -> snextc ( ) ) {
            if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) ) {
                _State |= ios_base :: eofbit;
                break;
            } else if ( ! _Ctype_fac . is ( ctype < _Elem > :: space, _Traits :: to_char_type ( _Meta ) ) ) {
                break;
            }
        }
        } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
        _Istr . setstate ( _State );
    }

    return _Istr;
}
#line 911
}
#line 915
#pragma warning(pop)
#pragma pack ( pop )
#line 919 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 19
namespace std { 
#line 39
extern istream cin; 
#line 40
extern ostream cout; 
#line 41
extern ostream cerr; 
#line 42
extern ostream clog; 
#line 43
extern istream *_Ptr_cin; 
#line 44
extern ostream *_Ptr_cout; 
#line 45
extern ostream *_Ptr_cerr; 
#line 46
extern ostream *_Ptr_clog; 
#line 48
extern wistream wcin; 
#line 49
extern wostream wcout; 
#line 50
extern wostream wcerr; 
#line 51
extern wostream wclog; 
#line 52
extern wistream *_Ptr_wcin; 
#line 53
extern wostream *_Ptr_wcout; 
#line 54
extern wostream *_Ptr_wcerr; 
#line 55
extern wostream *_Ptr_wclog; 
#line 57
class _Winit { 
#line 59
public: __thiscall _Winit(); 
#line 60
__thiscall ~_Winit() noexcept; 
#line 63
private: static int _Init_cnt; 
#line 64
}; 
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"
}
#line 69
#pragma warning(pop)
#pragma pack ( pop )
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"
#pragma external_header(pop)
#line 16 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 24
namespace std { 
#line 25
template < class _Myvec >
class _Vector_const_iterator : public _Iterator_base {
public :



    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Myvec :: value_type;
    using difference_type = typename _Myvec :: difference_type;
    using pointer = typename _Myvec :: const_pointer;
    using reference = const value_type &;

    using _Tptr = typename _Myvec :: pointer;

    inline _Vector_const_iterator ( ) noexcept : _Ptr ( ) { }

    inline _Vector_const_iterator ( _Tptr _Parg, const _Container_base * _Pvector ) noexcept : _Ptr ( _Parg ) {
        this -> _Adopt ( _Pvector );
    }

    [ [ nodiscard ] ] inline reference operator * ( ) const noexcept {







        return * _Ptr;
    }

    [ [ nodiscard ] ] inline pointer operator -> ( ) const noexcept {







        return _Ptr;
    }

    inline _Vector_const_iterator & operator ++ ( ) noexcept {






        ++ _Ptr;
        return * this;
    }

    inline _Vector_const_iterator operator ++ ( int ) noexcept {
        _Vector_const_iterator _Tmp = * this;
        ++ * this;
        return _Tmp;
    }

    inline _Vector_const_iterator & operator -- ( ) noexcept {






        -- _Ptr;
        return * this;
    }

    inline _Vector_const_iterator operator -- ( int ) noexcept {
        _Vector_const_iterator _Tmp = * this;
        -- * this;
        return _Tmp;
    }

    inline void _Verify_offset ( const difference_type _Off ) const noexcept {

        ( void ) _Off;











    }

    inline _Vector_const_iterator & operator += ( const difference_type _Off ) noexcept {
        _Verify_offset ( _Off );
        _Ptr += _Off;
        return * this;
    }

    [ [ nodiscard ] ] inline _Vector_const_iterator operator + ( const difference_type _Off ) const noexcept {
        _Vector_const_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _Vector_const_iterator & operator -= ( const difference_type _Off ) noexcept {
        return * this += - _Off;
    }

    [ [ nodiscard ] ] inline _Vector_const_iterator operator - ( const difference_type _Off ) const noexcept {
        _Vector_const_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline difference_type operator - ( const _Vector_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return _Ptr - _Right . _Ptr;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] inline bool operator == ( const _Vector_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return _Ptr == _Right . _Ptr;
    }







    [ [ nodiscard ] ] bool operator != ( const _Vector_const_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] bool operator < ( const _Vector_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return _Ptr < _Right . _Ptr;
    }

    [ [ nodiscard ] ] bool operator > ( const _Vector_const_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] bool operator <= ( const _Vector_const_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] bool operator >= ( const _Vector_const_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }


    inline void _Compat ( const _Vector_const_iterator & _Right ) const noexcept {


        ( void ) _Right;



    }









    using _Prevent_inheriting_unwrap = _Vector_const_iterator;

    [ [ nodiscard ] ] inline const value_type * _Unwrapped ( ) const noexcept {
        return _Unfancy ( _Ptr );
    }

    inline void _Seek_to ( const value_type * _It ) noexcept {
        _Ptr = _Refancy < _Tptr > ( const_cast < value_type * > ( _It ) );
    }

    _Tptr _Ptr;
};
#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Myvec >
[ [ nodiscard ] ] inline _Vector_const_iterator < _Myvec > operator + (
    typename _Vector_const_iterator < _Myvec > :: difference_type _Off, _Vector_const_iterator < _Myvec > _Next ) noexcept {
    return _Next += _Off;
}
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Myvec >
class _Vector_iterator : public _Vector_const_iterator < _Myvec > {
public :
    using _Mybase = _Vector_const_iterator < _Myvec >;




    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Myvec :: value_type;
    using difference_type = typename _Myvec :: difference_type;
    using pointer = typename _Myvec :: pointer;
    using reference = value_type &;

    using _Mybase :: _Mybase;

    [ [ nodiscard ] ] inline reference operator * ( ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator * ( ) );
    }

    [ [ nodiscard ] ] inline pointer operator -> ( ) const noexcept {







        return this -> _Ptr;
    }

    inline _Vector_iterator & operator ++ ( ) noexcept {
        _Mybase :: operator ++ ( );
        return * this;
    }

    inline _Vector_iterator operator ++ ( int ) noexcept {
        _Vector_iterator _Tmp = * this;
        _Mybase :: operator ++ ( );
        return _Tmp;
    }

    inline _Vector_iterator & operator -- ( ) noexcept {
        _Mybase :: operator -- ( );
        return * this;
    }

    inline _Vector_iterator operator -- ( int ) noexcept {
        _Vector_iterator _Tmp = * this;
        _Mybase :: operator -- ( );
        return _Tmp;
    }

    inline _Vector_iterator & operator += ( const difference_type _Off ) noexcept {
        _Mybase :: operator += ( _Off );
        return * this;
    }

    [ [ nodiscard ] ] inline _Vector_iterator operator + ( const difference_type _Off ) const noexcept {
        _Vector_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _Vector_iterator & operator -= ( const difference_type _Off ) noexcept {
        _Mybase :: operator -= ( _Off );
        return * this;
    }

    using _Mybase :: operator -;

    [ [ nodiscard ] ] inline _Vector_iterator operator - ( const difference_type _Off ) const noexcept {
        _Vector_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator [ ] ( _Off ) );
    }

    using _Prevent_inheriting_unwrap = _Vector_iterator;

    [ [ nodiscard ] ] inline value_type * _Unwrapped ( ) const noexcept {
        return _Unfancy ( this -> _Ptr );
    }
};
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Myvec >
[ [ nodiscard ] ] inline _Vector_iterator < _Myvec > operator + (
    typename _Vector_iterator < _Myvec > :: difference_type _Off, _Vector_iterator < _Myvec > _Next ) noexcept {
    return _Next += _Off;
}
#line 365 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template< class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class 
#line 366
_Reference, class _Const_reference> 
#line 367
struct _Vec_iter_types { 
#line 368
using value_type = _Value_type; 
#line 369
using size_type = _Size_type; 
#line 370
using difference_type = _Difference_type; 
#line 371
using pointer = _Pointer; 
#line 372
using const_pointer = _Const_pointer; 
#line 373
}; 
#line 375
struct _Value_init_tag { 
#line 376
explicit _Value_init_tag() = default;
#line 377
}; 
#line 379
template < class _Val_types >
class _Vector_val : public _Container_base {
public :
    using value_type = typename _Val_types :: value_type;
    using size_type = typename _Val_types :: size_type;
    using difference_type = typename _Val_types :: difference_type;
    using pointer = typename _Val_types :: pointer;
    using const_pointer = typename _Val_types :: const_pointer;
    using reference = value_type &;
    using const_reference = const value_type &;

    inline _Vector_val ( ) noexcept : _Myfirst ( ), _Mylast ( ), _Myend ( ) { }

    inline _Vector_val ( pointer _First, pointer _Last, pointer _End ) noexcept
        : _Myfirst ( _First ), _Mylast ( _Last ), _Myend ( _End ) { }

    inline void _Swap_val ( _Vector_val & _Right ) noexcept {
        this -> _Swap_proxy_and_iterators ( _Right );
        _Swap_adl ( _Myfirst, _Right . _Myfirst );
        _Swap_adl ( _Mylast, _Right . _Mylast );
        _Swap_adl ( _Myend, _Right . _Myend );
    }

    inline void _Take_contents ( _Vector_val & _Right ) noexcept {
        this -> _Swap_proxy_and_iterators ( _Right );
        _Myfirst = _Right . _Myfirst;
        _Mylast = _Right . _Mylast;
        _Myend = _Right . _Myend;

        _Right . _Myfirst = nullptr;
        _Right . _Mylast = nullptr;
        _Right . _Myend = nullptr;
    }

    pointer _Myfirst;
    pointer _Mylast;
    pointer _Myend;
};
#line 418
template < class _Ptrty >
constexpr auto _Unfancy_maybe_null ( _Ptrty _Ptr ) noexcept {

    return _Ptr ? :: std :: addressof ( * _Ptr ) : nullptr;
}
#line 424
template < class _Ty >
constexpr _Ty * _Unfancy_maybe_null ( _Ty * _Ptr ) noexcept {
    return _Ptr;
}
#line 429
template < class _Ty, class _Alloc = allocator < _Ty > >
class vector {
private :
    template < class >
    friend class _Vb_val;
    friend _Tidy_guard < vector >;

    using _Alty = _Rebind_alloc_t < _Alloc, _Ty >;
    using _Alty_traits = allocator_traits < _Alty >;

public :
    static_assert ( ! 0 || is_same_v < _Ty, typename _Alloc :: value_type >,
        "vector<T, Allocator> requires that Allocator\'s value_type match T (See N4659 26.2.1 [container.requirements.general]/16 allocat" "or_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic." );

    using value_type = _Ty;
    using allocator_type = _Alloc;
    using pointer = typename _Alty_traits :: pointer;
    using const_pointer = typename _Alty_traits :: const_pointer;
    using reference = _Ty &;
    using const_reference = const _Ty &;
    using size_type = typename _Alty_traits :: size_type;
    using difference_type = typename _Alty_traits :: difference_type;

private :
    using _Scary_val = _Vector_val < conditional_t < _Is_simple_alloc_v < _Alty >, _Simple_types < _Ty >,
        _Vec_iter_types < _Ty, size_type, difference_type, pointer, const_pointer, _Ty &, const _Ty & >> >;

public :
    using iterator = _Vector_iterator < _Scary_val >;
    using const_iterator = _Vector_const_iterator < _Scary_val >;
    using reverse_iterator = :: std :: reverse_iterator < iterator >;
    using const_reverse_iterator = :: std :: reverse_iterator < const_iterator >;

    inline vector ( ) noexcept ( is_nothrow_default_constructible_v < _Alty > )
        : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Mypair . _Myval2 . _Alloc_proxy ( _Fake_alloc );
    }

    inline explicit vector ( const _Alloc & _Al ) noexcept : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Mypair . _Myval2 . _Alloc_proxy ( _Fake_alloc );
    }

private :
    template < class _Ty2 >
    inline void _Construct_n_copies_of_ty ( const size_type _Count, const _Ty2 & _Val ) {
        auto && _Alproxy = _Fake_alloc;
        auto & _My_data = _Mypair . _Myval2;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );
        if ( _Count != 0 ) {
            _Buy_nonzero ( _Count );
            _Tidy_guard < vector > _Guard { this };
            _My_data . _Mylast = _Ufill ( _My_data . _Myfirst, _Count, _Val );
            _Guard . _Target = nullptr;
        }

        _Proxy . _Release ( );
    }

public :
    inline explicit vector ( const size_type _Count, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Construct_n_copies_of_ty ( _Count, _Value_init_tag { } );
    }

    inline vector (
         const size_type _Count, const _Ty & _Val, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Construct_n_copies_of_ty ( _Count, _Val );
    }

private :
    template < class _Iter >
    inline void _Range_construct_or_tidy ( _Iter _First, _Iter _Last, input_iterator_tag ) {
        _Tidy_guard < vector > _Guard { this };
        for (; _First != _Last; ++ _First ) {
            emplace_back ( * _First );
        }

        _Guard . _Target = nullptr;
    }

    template < class _Iter >
    inline void _Range_construct_or_tidy ( _Iter _First, _Iter _Last, forward_iterator_tag ) {
        const auto _Count = _Convert_size < size_type > ( static_cast < size_t > ( :: std :: distance ( _First, _Last ) ) );
        if ( _Count != 0 ) {
            _Buy_nonzero ( _Count );
            _Tidy_guard < vector > _Guard { this };
            auto & _My_data = _Mypair . _Myval2;
            _My_data . _Mylast = _Ucopy ( _First, _Last, _My_data . _Myfirst );
            _Guard . _Target = nullptr;
        }
    }

public :
    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline vector ( _Iter _First, _Iter _Last, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Adl_verify_range ( _First, _Last );
        _Range_construct_or_tidy ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Iter_cat_t < _Iter > { } );
        _Proxy . _Release ( );
    }

    inline vector ( initializer_list < _Ty > _Ilist, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Range_construct_or_tidy ( _Ilist . begin ( ), _Ilist . end ( ), random_access_iterator_tag { } );
        _Proxy . _Release ( );
    }

    inline vector ( const vector & _Right )
        : _Mypair ( _One_then_variadic_args_t { }, _Alty_traits :: select_on_container_copy_construction ( _Right . _Getal ( ) ) ) {
        auto && _Alproxy = _Fake_alloc;
        auto & _My_data = _Mypair . _Myval2;
        const auto & _Right_data = _Right . _Mypair . _Myval2;
        const pointer _Rightfirst = _Right_data . _Myfirst;
        const pointer _Rightlast = _Right_data . _Mylast;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );
        if ( _Rightfirst != _Rightlast ) {
            _Buy_raw ( static_cast < size_type > ( _Rightlast - _Rightfirst ) );
            _Tidy_guard < vector > _Guard { this };
            _My_data . _Mylast = _Ucopy ( _Rightfirst, _Rightlast, _My_data . _Myfirst );
            _Guard . _Target = nullptr;
        }

        _Proxy . _Release ( );
    }

    inline vector ( const vector & _Right, const _Alloc & _Al ) : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        auto & _My_data = _Mypair . _Myval2;
        const auto & _Right_data = _Right . _Mypair . _Myval2;
        const pointer _Rightfirst = _Right_data . _Myfirst;
        const pointer _Rightlast = _Right_data . _Mylast;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _My_data );
        if ( _Rightfirst != _Rightlast ) {
            _Buy_raw ( static_cast < size_type > ( _Rightlast - _Rightfirst ) );
            _Tidy_guard < vector > _Guard { this };
            _My_data . _Mylast = _Ucopy ( _Rightfirst, _Rightlast, _My_data . _Myfirst );
            _Guard . _Target = nullptr;
        }

        _Proxy . _Release ( );
    }

private :
    inline void _Move_construct ( vector & _Right, true_type ) noexcept {

        _Mypair . _Myval2 . _Take_contents ( _Right . _Mypair . _Myval2 );
    }

    inline void _Move_construct ( vector & _Right, false_type ) {

        if constexpr ( ! _Alty_traits :: is_always_equal :: value ) {
            if ( _Getal ( ) != _Right . _Getal ( ) ) {
                const auto & _Right_data = _Right . _Mypair . _Myval2;
                const pointer _Rightfirst = _Right_data . _Myfirst;
                const pointer _Rightlast = _Right_data . _Mylast;
                if ( _Rightfirst != _Rightlast ) {
                    _Buy_raw ( static_cast < size_type > ( _Rightlast - _Rightfirst ) );
                    _Tidy_guard < vector > _Guard { this };
                    auto & _My_data = _Mypair . _Myval2;
                    _My_data . _Mylast = _Umove ( _Rightfirst, _Rightlast, _My_data . _Myfirst );
                    _Guard . _Target = nullptr;
                }
                return;
            }
        }

        _Move_construct ( _Right, true_type { } );
    }

public :
    inline vector ( vector && _Right ) noexcept
        : _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Right . _Getal ( ) ),
            :: std :: exchange ( _Right . _Mypair . _Myval2 . _Myfirst, nullptr ),
            :: std :: exchange ( _Right . _Mypair . _Myval2 . _Mylast, nullptr ),
            :: std :: exchange ( _Right . _Mypair . _Myval2 . _Myend, nullptr ) ) {
        _Mypair . _Myval2 . _Alloc_proxy ( _Fake_alloc );
        _Mypair . _Myval2 . _Swap_proxy_and_iterators ( _Right . _Mypair . _Myval2 );
    }

    inline vector ( vector && _Right, const _Alloc & _Al ) noexcept (
        _Alty_traits :: is_always_equal :: value )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        auto && _Alproxy = _Fake_alloc;
        _Container_proxy_ptr < _Alty > _Proxy ( _Alproxy, _Mypair . _Myval2 );
        _Move_construct ( _Right, typename _Alty_traits :: is_always_equal :: type { } );
        _Proxy . _Release ( );
    }

private :
    inline void _Move_assign ( vector & _Right, _Equal_allocators ) noexcept {
        _Tidy ( );
        _Pocma ( _Getal ( ), _Right . _Getal ( ) );
        _Mypair . _Myval2 . _Take_contents ( _Right . _Mypair . _Myval2 );
    }

    inline void _Move_assign ( vector & _Right, _Propagate_allocators ) noexcept {
        _Tidy ( );








        _Pocma ( _Getal ( ), _Right . _Getal ( ) );
        _Mypair . _Myval2 . _Take_contents ( _Right . _Mypair . _Myval2 );
    }

    inline void _Move_assign ( vector & _Right, _No_propagate_allocators ) {
        if ( _Getal ( ) == _Right . _Getal ( ) ) {
            _Move_assign ( _Right, _Equal_allocators { } );
        } else {
            auto & _Right_data = _Right . _Mypair . _Myval2;
            const pointer _First = _Right_data . _Myfirst;
            const pointer _Last = _Right_data . _Mylast;
            const auto _Newsize = static_cast < size_type > ( _Last - _First );

            auto & _My_data = _Mypair . _Myval2;
            pointer & _Myfirst = _My_data . _Myfirst;
            pointer & _Mylast = _My_data . _Mylast;

            _My_data . _Orphan_all ( );

            const auto _Oldcapacity = static_cast < size_type > ( _My_data . _Myend - _Myfirst );
            if constexpr ( conjunction_v < bool_constant < _Ptr_copy_cat < _Ty *, _Ty * > :: _Trivially_copyable >,
                              _Uses_default_construct < _Alty, _Ty *, _Ty >, _Uses_default_destroy < _Alty, _Ty * >> ) {
                if ( _Newsize > _Oldcapacity ) {
                    _Clear_and_reserve_geometric ( _Newsize );
                }

                _Mylast = _Refancy < pointer > ( _Copy_memmove ( _Unfancy ( _First ), _Unfancy ( _Last ), _Unfancy ( _Myfirst ) ) );
            } else {
                auto _Oldsize = static_cast < size_type > ( _Mylast - _Myfirst );

                if ( _Newsize > _Oldsize ) {
                    if ( _Newsize > _Oldcapacity ) {
                        _Clear_and_reserve_geometric ( _Newsize );
                        _Oldsize = 0;
                    }

                    const pointer _Mid = _First + _Oldsize;
                    _Move_unchecked ( _First, _Mid, _Myfirst );
                    _Mylast = _Umove ( _Mid, _Last, _Mylast );
                } else {
                    const pointer _Newlast = _Myfirst + _Newsize;
                    _Move_unchecked ( _First, _Last, _Myfirst );
                    _Destroy ( _Newlast, _Mylast );
                    _Mylast = _Newlast;
                }
            }
        }
    }

public :
    inline vector & operator = ( vector && _Right ) noexcept (
        noexcept ( _Move_assign ( _Right, _Choose_pocma < _Alty > { } ) ) ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Move_assign ( _Right, _Choose_pocma < _Alty > { } );
        }

        return * this;
    }

    inline ~ vector ( ) noexcept {
        _Tidy ( );




    }

private :
    template < class ... _Valty >
    inline decltype ( auto ) _Emplace_back_with_unused_capacity ( _Valty && ... _Val ) {

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Mylast = _My_data . _Mylast;
        ;
        _Alty_traits :: construct ( _Getal ( ), _Unfancy ( _Mylast ), :: std :: forward < _Valty > ( _Val ) ... );
        _Orphan_range ( _Mylast, _Mylast );
        _Ty & _Result = * _Mylast;
        ++ _Mylast;



        ( void ) _Result;

    }

public :
    template < class ... _Valty >
    inline decltype ( auto ) emplace_back ( _Valty && ... _Val ) {

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Mylast = _My_data . _Mylast;
        if ( _Mylast != _My_data . _Myend ) {
            return _Emplace_back_with_unused_capacity ( :: std :: forward < _Valty > ( _Val ) ... );
        }

        _Ty & _Result = * _Emplace_reallocate ( _Mylast, :: std :: forward < _Valty > ( _Val ) ... );



        ( void ) _Result;

    }

    inline void push_back ( const _Ty & _Val ) {
        emplace_back ( _Val );
    }

    inline void push_back ( _Ty && _Val ) {

        emplace_back ( :: std :: move ( _Val ) );
    }

    template < class ... _Valty >
    inline pointer _Emplace_reallocate ( const pointer _Whereptr, _Valty && ... _Val ) {

        _Alty & _Al = _Getal ( );
        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;

        ;

        const auto _Whereoff = static_cast < size_type > ( _Whereptr - _Myfirst );
        const auto _Oldsize = static_cast < size_type > ( _Mylast - _Myfirst );

        if ( _Oldsize == max_size ( ) ) {
            _Xlength ( );
        }

        const size_type _Newsize = _Oldsize + 1;
        const size_type _Newcapacity = _Calculate_growth ( _Newsize );

        const pointer _Newvec = _Al . allocate ( _Newcapacity );
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;
        pointer _Constructed_first = _Constructed_last;

        try {
        _Alty_traits :: construct ( _Al, _Unfancy ( _Newvec + _Whereoff ), :: std :: forward < _Valty > ( _Val ) ... );
        _Constructed_first = _Newvec + _Whereoff;

        if ( _Whereptr == _Mylast ) {
            _Umove_if_noexcept ( _Myfirst, _Mylast, _Newvec );
        } else {
            _Umove ( _Myfirst, _Whereptr, _Newvec );
            _Constructed_first = _Newvec;
            _Umove ( _Whereptr, _Mylast, _Newvec + _Whereoff + 1 );
        }
        } catch ( ... ) {
        _Destroy ( _Constructed_first, _Constructed_last );
        _Al . deallocate ( _Newvec, _Newcapacity );
        throw;
        }

        _Change_array ( _Newvec, _Newsize, _Newcapacity );
        return _Newvec + _Whereoff;
    }

    template < class ... _Valty >
    inline iterator emplace ( const_iterator _Where, _Valty && ... _Val ) {

        const pointer _Whereptr = _Where . _Ptr;
        auto & _My_data = _Mypair . _Myval2;
        const pointer _Oldlast = _My_data . _Mylast;






        if ( _Oldlast != _My_data . _Myend ) {
            if ( _Whereptr == _Oldlast ) {
                _Emplace_back_with_unused_capacity ( :: std :: forward < _Valty > ( _Val ) ... );
            } else {
                auto & _Al = _Getal ( );
                _Alloc_temporary2 < _Alty > _Obj ( _Al, :: std :: forward < _Valty > ( _Val ) ... );

                _Orphan_range ( _Whereptr, _Oldlast );
                _Alty_traits :: construct ( _Al, _Unfancy ( _Oldlast ), :: std :: move ( _Oldlast [ - 1 ] ) );
                ++ _My_data . _Mylast;
                _Move_backward_unchecked ( _Whereptr, _Oldlast - 1, _Oldlast );
                * _Whereptr = :: std :: move ( _Obj . _Get_value ( ) );
            }

            return _Make_iterator ( _Whereptr );
        }

        return _Make_iterator ( _Emplace_reallocate ( _Whereptr, :: std :: forward < _Valty > ( _Val ) ... ) );
    }

    inline iterator insert ( const_iterator _Where, const _Ty & _Val ) {
        return emplace ( _Where, _Val );
    }

    inline iterator insert ( const_iterator _Where, _Ty && _Val ) {
        return emplace ( _Where, :: std :: move ( _Val ) );
    }

    inline iterator insert (
        const_iterator _Where, const size_type _Count, const _Ty & _Val ) {

        const pointer _Whereptr = _Where . _Ptr;

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Mylast = _My_data . _Mylast;

        const pointer _Oldfirst = _My_data . _Myfirst;
        const pointer _Oldlast = _Mylast;





        const auto _Whereoff = static_cast < size_type > ( _Whereptr - _Oldfirst );
        const auto _Unused_capacity = static_cast < size_type > ( _My_data . _Myend - _Oldlast );
        const bool _One_at_back = _Count == 1 && _Whereptr == _Oldlast;
        if ( _Count == 0 ) {
        } else if ( _Count > _Unused_capacity ) {
            const auto _Oldsize = static_cast < size_type > ( _Oldlast - _Oldfirst );

            if ( _Count > max_size ( ) - _Oldsize ) {
                _Xlength ( );
            }

            const size_type _Newsize = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth ( _Newsize );

            const pointer _Newvec = _Getal ( ) . allocate ( _Newcapacity );
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first = _Constructed_last;

            try {
            _Ufill ( _Newvec + _Whereoff, _Count, _Val );
            _Constructed_first = _Newvec + _Whereoff;

            if ( _One_at_back ) {
                _Umove_if_noexcept ( _Oldfirst, _Oldlast, _Newvec );
            } else {
                _Umove ( _Oldfirst, _Whereptr, _Newvec );
                _Constructed_first = _Newvec;
                _Umove ( _Whereptr, _Oldlast, _Newvec + _Whereoff + _Count );
            }
            } catch ( ... ) {
            _Destroy ( _Constructed_first, _Constructed_last );
            _Getal ( ) . deallocate ( _Newvec, _Newcapacity );
            throw;
            }

            _Change_array ( _Newvec, _Newsize, _Newcapacity );
        } else if ( _One_at_back ) {
            _Emplace_back_with_unused_capacity ( _Val );
        } else {
            const _Alloc_temporary2 < _Alty > _Tmp_storage ( _Getal ( ), _Val );
            const auto & _Tmp = _Tmp_storage . _Get_value ( );
            const auto _Affected_elements = static_cast < size_type > ( _Oldlast - _Whereptr );
            _Orphan_range ( _Whereptr, _Oldlast );

            if ( _Count > _Affected_elements ) {
                _Mylast = _Ufill ( _Oldlast, _Count - _Affected_elements, _Tmp );
                _Mylast = _Umove ( _Whereptr, _Oldlast, _Mylast );
                :: std :: fill ( _Whereptr, _Oldlast, _Tmp );
            } else {
                _Mylast = _Umove ( _Oldlast - _Count, _Oldlast, _Oldlast );
                _Move_backward_unchecked ( _Whereptr, _Oldlast - _Count, _Oldlast );
                :: std :: fill ( _Whereptr, _Whereptr + _Count, _Tmp );
            }
        }

        return _Make_iterator_offset ( _Whereoff );
    }

private :
    template < class _Iter >
    inline void _Insert_range ( const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag ) {

        if ( _First == _Last ) {
            return;
        }

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;
        const auto _Whereoff = static_cast < size_type > ( _Where . _Ptr - _Myfirst );
        const auto _Oldsize = static_cast < size_type > ( _Mylast - _Myfirst );





        for (; _First != _Last; ++ _First ) {
            emplace_back ( * _First );
        }

        _Orphan_range ( _Myfirst + _Whereoff, _Myfirst + _Oldsize );

        :: std :: rotate ( _Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast );
    }

    template < class _Iter >
    inline void _Insert_range ( const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag ) {

        const pointer _Whereptr = _Where . _Ptr;
        const auto _Count = _Convert_size < size_type > ( static_cast < size_t > ( :: std :: distance ( _First, _Last ) ) );

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Mylast = _My_data . _Mylast;

        const pointer _Oldfirst = _My_data . _Myfirst;
        const pointer _Oldlast = _Mylast;
        const auto _Unused_capacity = static_cast < size_type > ( _My_data . _Myend - _Oldlast );

        if ( _Count == 0 ) {
        } else if ( _Count > _Unused_capacity ) {
            const auto _Oldsize = static_cast < size_type > ( _Oldlast - _Oldfirst );

            if ( _Count > max_size ( ) - _Oldsize ) {
                _Xlength ( );
            }

            const size_type _Newsize = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth ( _Newsize );

            const pointer _Newvec = _Getal ( ) . allocate ( _Newcapacity );
            const auto _Whereoff = static_cast < size_type > ( _Whereptr - _Oldfirst );
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first = _Constructed_last;

            try {
            _Ucopy ( _First, _Last, _Newvec + _Whereoff );
            _Constructed_first = _Newvec + _Whereoff;

            if ( _Count == 1 && _Whereptr == _Oldlast ) {
                _Umove_if_noexcept ( _Oldfirst, _Oldlast, _Newvec );
            } else {
                _Umove ( _Oldfirst, _Whereptr, _Newvec );
                _Constructed_first = _Newvec;
                _Umove ( _Whereptr, _Oldlast, _Newvec + _Whereoff + _Count );
            }
            } catch ( ... ) {
            _Destroy ( _Constructed_first, _Constructed_last );
            _Getal ( ) . deallocate ( _Newvec, _Newcapacity );
            throw;
            }

            _Change_array ( _Newvec, _Newsize, _Newcapacity );
        } else {



            const auto _Affected_elements = static_cast < size_type > ( _Oldlast - _Whereptr );

            if ( _Count < _Affected_elements ) {
                _Mylast = _Umove ( _Oldlast - _Count, _Oldlast, _Oldlast );
                _Move_backward_unchecked ( _Whereptr, _Oldlast - _Count, _Oldlast );
                _Destroy ( _Whereptr, _Whereptr + _Count );

                try {
                _Ucopy ( _First, _Last, _Whereptr );
                } catch ( ... ) {


                try {
                _Umove ( _Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr );
                } catch ( ... ) {

                _Orphan_range ( _Whereptr, _Oldlast );
                _Destroy ( _Whereptr + _Count, _Mylast );
                _Mylast = _Whereptr;
                throw;
                }

                _Move_unchecked ( _Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count );
                _Destroy ( _Oldlast, _Mylast );
                _Mylast = _Oldlast;
                throw;
                }
            } else {
                const pointer _Relocated = _Whereptr + _Count;
                _Mylast = _Umove ( _Whereptr, _Oldlast, _Relocated );
                _Destroy ( _Whereptr, _Oldlast );

                try {
                _Ucopy ( _First, _Last, _Whereptr );
                } catch ( ... ) {


                try {
                _Umove ( _Relocated, _Mylast, _Whereptr );
                } catch ( ... ) {

                _Orphan_range ( _Whereptr, _Oldlast );
                _Destroy ( _Relocated, _Mylast );
                _Mylast = _Whereptr;
                throw;
                }

                _Destroy ( _Relocated, _Mylast );
                _Mylast = _Oldlast;
                throw;
                }
            }

            _Orphan_range ( _Whereptr, _Oldlast );
        }
    }

public :
    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline iterator insert ( const_iterator _Where, _Iter _First, _Iter _Last ) {
        const pointer _Whereptr = _Where . _Ptr;
        auto & _My_data = _Mypair . _Myval2;
        const pointer _Oldfirst = _My_data . _Myfirst;






        _Adl_verify_range ( _First, _Last );
        const auto _Whereoff = static_cast < size_type > ( _Whereptr - _Oldfirst );
        _Insert_range ( _Where, _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Iter_cat_t < _Iter > { } );
        return _Make_iterator_offset ( _Whereoff );
    }

    inline iterator insert ( const_iterator _Where, initializer_list < _Ty > _Ilist ) {
        return insert ( _Where, _Ilist . begin ( ), _Ilist . end ( ) );
    }

    inline void assign ( const size_type _Newsize, const _Ty & _Val ) {

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;

        _My_data . _Orphan_all ( );

        auto _Oldsize = static_cast < size_type > ( _Mylast - _Myfirst );
        if ( _Newsize > _Oldsize ) {
            const auto _Oldcapacity = static_cast < size_type > ( _My_data . _Myend - _Myfirst );
            if ( _Newsize > _Oldcapacity ) {
                _Clear_and_reserve_geometric ( _Newsize );
                _Oldsize = 0;
            } else {
                :: std :: fill ( _Myfirst, _Mylast, _Val );
            }

            _Mylast = _Ufill ( _Mylast, _Newsize - _Oldsize, _Val );
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            :: std :: fill ( _Myfirst, _Newlast, _Val );
            _Destroy ( _Newlast, _Mylast );
            _Mylast = _Newlast;
        }
    }

private :
    template < class _Iter >
    inline void _Assign_range ( _Iter _First, _Iter _Last, input_iterator_tag ) {

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;

        _My_data . _Orphan_all ( );

        pointer _Next = _Myfirst;

        for (; _First != _Last && _Next != _Mylast; ++ _First, ( void ) ++ _Next ) {
            * _Next = * _First;
        }







        _Destroy ( _Next, _Mylast );
        _Mylast = _Next;


        for (; _First != _Last; ++ _First ) {
            emplace_back ( * _First );
        }
    }

    template < class _Iter >
    inline void _Assign_range ( _Iter _First, _Iter _Last, forward_iterator_tag ) {

        const auto _Newsize = _Convert_size < size_type > ( static_cast < size_t > ( :: std :: distance ( _First, _Last ) ) );
        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;
        pointer & _Myend = _My_data . _Myend;

        _My_data . _Orphan_all ( );

        if constexpr ( conjunction_v < bool_constant < _Ptr_copy_cat < _Iter, _Ty * > :: _Trivially_copyable >,
                          _Uses_default_construct < _Alty, _Ty *, decltype ( * _First ) >,
                          _Uses_default_destroy < _Alty, _Ty * >> ) {



            {
                const auto _Oldcapacity = static_cast < size_type > ( _Myend - _Myfirst );
                if ( _Newsize > _Oldcapacity ) {
                    _Clear_and_reserve_geometric ( _Newsize );
                }

                _Mylast = _Refancy < pointer > ( _Copy_memmove ( _First, _Last, _Unfancy ( _Myfirst ) ) );
                return;
            }
        }
        auto _Oldsize = static_cast < size_type > ( _Mylast - _Myfirst );

        if ( _Newsize > _Oldsize ) {
            const auto _Oldcapacity = static_cast < size_type > ( _Myend - _Myfirst );
            if ( _Newsize > _Oldcapacity ) {
                _Clear_and_reserve_geometric ( _Newsize );
                _Oldsize = 0;
            }


            const _Iter _Mid = :: std :: next ( _First, static_cast < difference_type > ( _Oldsize ) );
            _Copy_unchecked ( _First, _Mid, _Myfirst );
            _Mylast = _Ucopy ( _Mid, _Last, _Mylast );
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _Copy_unchecked ( _First, _Last, _Myfirst );
            _Destroy ( _Newlast, _Mylast );
            _Mylast = _Newlast;
        }
    }

public :
    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline void assign ( _Iter _First, _Iter _Last ) {
        _Adl_verify_range ( _First, _Last );
        _Assign_range ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Iter_cat_t < _Iter > { } );
    }

    inline void assign ( initializer_list < _Ty > _Ilist ) {
        _Assign_range ( _Ilist . begin ( ), _Ilist . end ( ), random_access_iterator_tag { } );
    }

private :
    inline void _Copy_assign ( const vector & _Right, false_type ) {
        _Pocca ( _Getal ( ), _Right . _Getal ( ) );
        auto & _Right_data = _Right . _Mypair . _Myval2;
        assign ( _Right_data . _Myfirst, _Right_data . _Mylast );
    }

    inline void _Copy_assign ( const vector & _Right, true_type ) {
        if ( _Getal ( ) != _Right . _Getal ( ) ) {
            _Tidy ( );
            _Mypair . _Myval2 . _Reload_proxy (
                _Fake_alloc, _Fake_alloc );
        }

        _Copy_assign ( _Right, false_type { } );
    }

public :
    inline vector & operator = ( const vector & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Copy_assign ( _Right, _Choose_pocca < _Alty > { } );
        }

        return * this;
    }

    inline vector & operator = ( initializer_list < _Ty > _Ilist ) {
        _Assign_range ( _Ilist . begin ( ), _Ilist . end ( ), random_access_iterator_tag { } );
        return * this;
    }

private :
    template < class _Ty2 >
    inline void _Resize_reallocate ( const size_type _Newsize, const _Ty2 & _Val ) {
        if ( _Newsize > max_size ( ) ) {
            _Xlength ( );
        }

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;

        const auto _Oldsize = static_cast < size_type > ( _Mylast - _Myfirst );
        const size_type _Newcapacity = _Calculate_growth ( _Newsize );

        const pointer _Newvec = _Getal ( ) . allocate ( _Newcapacity );
        const pointer _Appended_first = _Newvec + _Oldsize;
        pointer _Appended_last = _Appended_first;

        try {
        _Appended_last = _Ufill ( _Appended_first, _Newsize - _Oldsize, _Val );
        _Umove_if_noexcept ( _Myfirst, _Mylast, _Newvec );
        } catch ( ... ) {
        _Destroy ( _Appended_first, _Appended_last );
        _Getal ( ) . deallocate ( _Newvec, _Newcapacity );
        throw;
        }

        _Change_array ( _Newvec, _Newsize, _Newcapacity );
    }

    template < class _Ty2 >
    inline void _Resize ( const size_type _Newsize, const _Ty2 & _Val ) {

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;
        const auto _Oldsize = static_cast < size_type > ( _Mylast - _Myfirst );
        if ( _Newsize < _Oldsize ) {
            const pointer _Newlast = _Myfirst + _Newsize;
            _Orphan_range ( _Newlast, _Mylast );
            _Destroy ( _Newlast, _Mylast );
            _Mylast = _Newlast;
            return;
        }

        if ( _Newsize > _Oldsize ) {
            const auto _Oldcapacity = static_cast < size_type > ( _My_data . _Myend - _Myfirst );
            if ( _Newsize > _Oldcapacity ) {
                _Resize_reallocate ( _Newsize, _Val );
                return;
            }

            const pointer _Oldlast = _Mylast;
            _Mylast = _Ufill ( _Oldlast, _Newsize - _Oldsize, _Val );
            _Orphan_range ( _Oldlast, _Oldlast );
        }


    }

public :
    inline void resize ( const size_type _Newsize ) {

        _Resize ( _Newsize, _Value_init_tag { } );
    }

    inline void resize ( const size_type _Newsize, const _Ty & _Val ) {

        _Resize ( _Newsize, _Val );
    }

private :
    inline void _Reallocate_exactly ( const size_type _Newcapacity ) {

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;

        const auto _Size = static_cast < size_type > ( _Mylast - _Myfirst );

        const pointer _Newvec = _Getal ( ) . allocate ( _Newcapacity );

        try {
        _Umove_if_noexcept ( _Myfirst, _Mylast, _Newvec );
        } catch ( ... ) {
        _Getal ( ) . deallocate ( _Newvec, _Newcapacity );
        throw;
        }

        _Change_array ( _Newvec, _Size, _Newcapacity );
    }





















    inline void _Clear_and_reserve_geometric ( const size_type _Newsize ) {
        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;
        pointer & _Myend = _My_data . _Myend;






        if ( _Newsize > max_size ( ) ) {
            _Xlength ( );
        }

        const size_type _Newcapacity = _Calculate_growth ( _Newsize );

        if ( _Myfirst ) {
            _Destroy ( _Myfirst, _Mylast );
            _Getal ( ) . deallocate ( _Myfirst, static_cast < size_type > ( _Myend - _Myfirst ) );

            _Myfirst = nullptr;
            _Mylast = nullptr;
            _Myend = nullptr;
        }

        _Buy_raw ( _Newcapacity );
    }

public :
    inline void reserve ( const size_type _Newcapacity ) {

        if ( _Newcapacity > capacity ( ) ) {
            if ( _Newcapacity > max_size ( ) ) {
                _Xlength ( );
            }

            _Reallocate_exactly ( _Newcapacity );
        }
    }

    inline void shrink_to_fit ( ) {
        auto & _My_data = _Mypair . _Myval2;
        const pointer _Oldlast = _My_data . _Mylast;
        if ( _Oldlast != _My_data . _Myend ) {
            const pointer _Oldfirst = _My_data . _Myfirst;
            if ( _Oldfirst == _Oldlast ) {
                _Tidy ( );
            } else {
                _Reallocate_exactly ( static_cast < size_type > ( _Oldlast - _Oldfirst ) );
            }
        }
    }

    inline void pop_back ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;
        pointer & _Mylast = _My_data . _Mylast;





        _Orphan_range ( _Mylast - 1, _Mylast );
        _Alty_traits :: destroy ( _Getal ( ), _Unfancy ( _Mylast - 1 ) );
        -- _Mylast;
    }

    inline iterator erase ( const_iterator _Where ) noexcept (
        is_nothrow_move_assignable_v < value_type > ) {
        const pointer _Whereptr = _Where . _Ptr;
        auto & _My_data = _Mypair . _Myval2;
        pointer & _Mylast = _My_data . _Mylast;







        _Orphan_range ( _Whereptr, _Mylast );
        _Move_unchecked ( _Whereptr + 1, _Mylast, _Whereptr );
        _Alty_traits :: destroy ( _Getal ( ), _Unfancy ( _Mylast - 1 ) );
        -- _Mylast;
        return iterator ( _Whereptr, :: std :: addressof ( _My_data ) );
    }

    inline iterator erase ( const_iterator _First, const_iterator _Last ) noexcept (
        is_nothrow_move_assignable_v < value_type > ) {
        const pointer _Firstptr = _First . _Ptr;
        const pointer _Lastptr = _Last . _Ptr;
        auto & _My_data = _Mypair . _Myval2;
        pointer & _Mylast = _My_data . _Mylast;







        if ( _Firstptr != _Lastptr ) {
            _Orphan_range ( _Firstptr, _Mylast );

            const pointer _Newlast = _Move_unchecked ( _Lastptr, _Mylast, _Firstptr );
            _Destroy ( _Newlast, _Mylast );
            _Mylast = _Newlast;
        }

        return iterator ( _Firstptr, :: std :: addressof ( _My_data ) );
    }

    inline void clear ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;

        _My_data . _Orphan_all ( );
        _Destroy ( _Myfirst, _Mylast );
        _Mylast = _Myfirst;
    }

    inline void swap ( vector & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Pocs ( _Getal ( ), _Right . _Getal ( ) );
            _Mypair . _Myval2 . _Swap_val ( _Right . _Mypair . _Myval2 );
        }
    }

    [ [ nodiscard ] ] inline _Ty * data ( ) noexcept {
        return _Unfancy_maybe_null ( _Mypair . _Myval2 . _Myfirst );
    }

    [ [ nodiscard ] ] inline const _Ty * data ( ) const noexcept {
        return _Unfancy_maybe_null ( _Mypair . _Myval2 . _Myfirst );
    }

    [ [ nodiscard ] ] inline iterator begin ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;
        return iterator ( _My_data . _Myfirst, :: std :: addressof ( _My_data ) );
    }

    [ [ nodiscard ] ] inline const_iterator begin ( ) const noexcept {
        auto & _My_data = _Mypair . _Myval2;
        return const_iterator ( _My_data . _Myfirst, :: std :: addressof ( _My_data ) );
    }

    [ [ nodiscard ] ] inline iterator end ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;
        return iterator ( _My_data . _Mylast, :: std :: addressof ( _My_data ) );
    }

    [ [ nodiscard ] ] inline const_iterator end ( ) const noexcept {
        auto & _My_data = _Mypair . _Myval2;
        return const_iterator ( _My_data . _Mylast, :: std :: addressof ( _My_data ) );
    }

    [ [ nodiscard ] ] inline reverse_iterator rbegin ( ) noexcept {
        return reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator rbegin ( ) const noexcept {
        return const_reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] inline reverse_iterator rend ( ) noexcept {
        return reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator rend ( ) const noexcept {
        return const_reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] inline const_iterator cbegin ( ) const noexcept {
        return begin ( );
    }

    [ [ nodiscard ] ] inline const_iterator cend ( ) const noexcept {
        return end ( );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator crbegin ( ) const noexcept {
        return rbegin ( );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator crend ( ) const noexcept {
        return rend ( );
    }

    [ [ nodiscard ] ] inline pointer _Unchecked_begin ( ) noexcept {
        return _Mypair . _Myval2 . _Myfirst;
    }

    [ [ nodiscard ] ] inline const_pointer _Unchecked_begin ( ) const noexcept {
        return _Mypair . _Myval2 . _Myfirst;
    }

    [ [ nodiscard ] ] inline pointer _Unchecked_end ( ) noexcept {
        return _Mypair . _Myval2 . _Mylast;
    }

    [ [ nodiscard ] ] inline const_pointer _Unchecked_end ( ) const noexcept {
        return _Mypair . _Myval2 . _Mylast;
    }

    [ [ nodiscard ] ] inline bool empty ( ) const noexcept {
        auto & _My_data = _Mypair . _Myval2;
        return _My_data . _Myfirst == _My_data . _Mylast;
    }

    [ [ nodiscard ] ] inline size_type size ( ) const noexcept {
        auto & _My_data = _Mypair . _Myval2;
        return static_cast < size_type > ( _My_data . _Mylast - _My_data . _Myfirst );
    }

    [ [ nodiscard ] ] inline size_type max_size ( ) const noexcept {
        return ( :: std :: min ) (
            static_cast < size_type > ( ( numeric_limits < difference_type > :: max ) ( ) ), _Alty_traits :: max_size ( _Getal ( ) ) );
    }

    [ [ nodiscard ] ] inline size_type capacity ( ) const noexcept {
        auto & _My_data = _Mypair . _Myval2;
        return static_cast < size_type > ( _My_data . _Myend - _My_data . _Myfirst );
    }

    [ [ nodiscard ] ] inline _Ty & operator [ ] ( const size_type _Pos ) noexcept {
        auto & _My_data = _Mypair . _Myval2;





        return _My_data . _Myfirst [ _Pos ];
    }

    [ [ nodiscard ] ] inline const _Ty & operator [ ] ( const size_type _Pos ) const noexcept {
        auto & _My_data = _Mypair . _Myval2;





        return _My_data . _Myfirst [ _Pos ];
    }

    [ [ nodiscard ] ] inline _Ty & at ( const size_type _Pos ) {
        auto & _My_data = _Mypair . _Myval2;
        if ( static_cast < size_type > ( _My_data . _Mylast - _My_data . _Myfirst ) <= _Pos ) {
            _Xrange ( );
        }

        return _My_data . _Myfirst [ _Pos ];
    }

    [ [ nodiscard ] ] inline const _Ty & at ( const size_type _Pos ) const {
        auto & _My_data = _Mypair . _Myval2;
        if ( static_cast < size_type > ( _My_data . _Mylast - _My_data . _Myfirst ) <= _Pos ) {
            _Xrange ( );
        }

        return _My_data . _Myfirst [ _Pos ];
    }

    [ [ nodiscard ] ] inline _Ty & front ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;




        return * _My_data . _Myfirst;
    }

    [ [ nodiscard ] ] inline const _Ty & front ( ) const noexcept {
        auto & _My_data = _Mypair . _Myval2;




        return * _My_data . _Myfirst;
    }

    [ [ nodiscard ] ] inline _Ty & back ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;




        return _My_data . _Mylast [ - 1 ];
    }

    [ [ nodiscard ] ] inline const _Ty & back ( ) const noexcept {
        auto & _My_data = _Mypair . _Myval2;




        return _My_data . _Mylast [ - 1 ];
    }

    [ [ nodiscard ] ] inline allocator_type get_allocator ( ) const noexcept {
        return static_cast < allocator_type > ( _Getal ( ) );
    }

private :
    inline pointer _Ufill ( pointer _Dest, const size_type _Count, const _Ty & _Val ) {

        return _Uninitialized_fill_n ( _Dest, _Count, _Val, _Getal ( ) );
    }

    inline pointer _Ufill ( pointer _Dest, const size_type _Count, _Value_init_tag ) {

        return _Uninitialized_value_construct_n ( _Dest, _Count, _Getal ( ) );
    }

    template < class _Iter >
    inline pointer _Ucopy ( _Iter _First, _Iter _Last, pointer _Dest ) {

        return _Uninitialized_copy ( _First, _Last, _Dest, _Getal ( ) );
    }

    inline pointer _Umove ( pointer _First, pointer _Last, pointer _Dest ) {

        return _Uninitialized_move ( _First, _Last, _Dest, _Getal ( ) );
    }

    inline void _Umove_if_noexcept1 ( pointer _First, pointer _Last, pointer _Dest, true_type ) {

        _Uninitialized_move ( _First, _Last, _Dest, _Getal ( ) );
    }

    inline void _Umove_if_noexcept1 ( pointer _First, pointer _Last, pointer _Dest, false_type ) {

        _Uninitialized_copy ( _First, _Last, _Dest, _Getal ( ) );
    }

    inline void _Umove_if_noexcept ( pointer _First, pointer _Last, pointer _Dest ) {

        _Umove_if_noexcept1 ( _First, _Last, _Dest,
            bool_constant < disjunction_v < is_nothrow_move_constructible < _Ty >, negation < is_copy_constructible < _Ty >> >> { } );
    }

    inline void _Destroy ( pointer _First, pointer _Last ) {

        _Destroy_range ( _First, _Last, _Getal ( ) );
    }

    inline size_type _Calculate_growth ( const size_type _Newsize ) const {

        const size_type _Oldcapacity = capacity ( );
        const auto _Max = max_size ( );

        if ( _Oldcapacity > _Max - _Oldcapacity / 2 ) {
            return _Max;
        }

        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

        if ( _Geometric < _Newsize ) {
            return _Newsize;
        }

        return _Geometric;
    }

    inline void _Buy_raw ( const size_type _Newcapacity ) {

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;
        pointer & _Myend = _My_data . _Myend;

        ;
        ;

        const auto _Newvec = _Getal ( ) . allocate ( _Newcapacity );
        _Myfirst = _Newvec;
        _Mylast = _Newvec;
        _Myend = _Newvec + _Newcapacity;
    }

    inline void _Buy_nonzero ( const size_type _Newcapacity ) {










        if ( _Newcapacity > max_size ( ) ) {
            _Xlength ( );
        }

        _Buy_raw ( _Newcapacity );
    }

    inline void _Change_array (
        const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity ) {

        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;
        pointer & _Myend = _My_data . _Myend;

        _My_data . _Orphan_all ( );

        if ( _Myfirst ) {
            _Destroy ( _Myfirst, _Mylast );
            _Getal ( ) . deallocate ( _Myfirst, static_cast < size_type > ( _Myend - _Myfirst ) );
        }

        _Myfirst = _Newvec;
        _Mylast = _Newvec + _Newsize;
        _Myend = _Newvec + _Newcapacity;
    }

    inline void _Tidy ( ) noexcept {
        auto & _My_data = _Mypair . _Myval2;
        pointer & _Myfirst = _My_data . _Myfirst;
        pointer & _Mylast = _My_data . _Mylast;
        pointer & _Myend = _My_data . _Myend;

        _My_data . _Orphan_all ( );

        if ( _Myfirst ) {
            _Destroy ( _Myfirst, _Mylast );
            _Getal ( ) . deallocate ( _Myfirst, static_cast < size_type > ( _Myend - _Myfirst ) );

            _Myfirst = nullptr;
            _Mylast = nullptr;
            _Myend = nullptr;
        }
    }

    [ [ noreturn ] ] static void _Xlength ( ) {
        _Xlength_error ( "vector too long" );
    }

    [ [ noreturn ] ] static void _Xrange ( ) {
        _Xout_of_range ( "invalid vector subscript" );
    }


































    inline void _Orphan_range ( pointer, pointer ) const { }


    [ [ nodiscard ] ] inline _Alty & _Getal ( ) noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] inline const _Alty & _Getal ( ) const noexcept {
        return _Mypair . _Get_first ( );
    }

    [ [ nodiscard ] ] inline iterator _Make_iterator ( const pointer _Ptr ) noexcept {
        return iterator ( _Ptr, :: std :: addressof ( _Mypair . _Myval2 ) );
    }

    [ [ nodiscard ] ] inline iterator _Make_iterator_offset ( const size_type _Offset ) noexcept {

        auto & _My_data = _Mypair . _Myval2;
        return iterator ( _My_data . _Myfirst + _Offset, :: std :: addressof ( _My_data ) );
    }

    _Compressed_pair < _Alty, _Scary_val > _Mypair;
};
#line 1831 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Alloc >
class vector < bool, _Alloc >;
#line 1834
using _Vbase = unsigned; 
#line 1835
constexpr int _VBITS = ((8) * sizeof(_Vbase)); 
#line 1837
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] inline bool operator == ( const vector < _Ty, _Alloc > & _Left, const vector < _Ty, _Alloc > & _Right ) {
    if ( _Left . size ( ) != _Right . size ( ) ) {
        return false;
    }

    if constexpr ( is_same_v < _Ty, bool > ) {
        return :: std :: equal (
            _Left . _Myvec . _Unchecked_begin ( ), _Left . _Myvec . _Unchecked_end ( ), _Right . _Myvec . _Unchecked_begin ( ) );
    } else {
        return :: std :: equal ( _Left . _Unchecked_begin ( ), _Left . _Unchecked_end ( ), _Right . _Unchecked_begin ( ) );
    }
}
#line 1852
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] bool operator != ( const vector < _Ty, _Alloc > & _Left, const vector < _Ty, _Alloc > & _Right ) {
    return ! ( _Left == _Right );
}
#line 1873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Ret >
struct _Vbase_compare_three_way {
    [ [ nodiscard ] ] constexpr _Ret operator ( ) ( const _Vbase _Left, const _Vbase _Right ) const noexcept {
        const _Vbase _Differing_bits = _Left ^ _Right;

        if ( _Differing_bits == 0 ) {



            return 0;

        }

        const int _Bit_index = _Countr_zero ( _Differing_bits );
        ;

        const _Vbase _Mask = _Vbase { 1 } << _Bit_index;





        return ( _Left & _Mask ) == 0 ? - 1 : 1;

    }
};
#line 1926 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] inline bool operator < ( const vector < _Ty, _Alloc > & _Left, const vector < _Ty, _Alloc > & _Right ) {
    if constexpr ( is_same_v < _Ty, bool > ) {

        auto _First = _Left . _Myvec . _Unchecked_begin ( );
        auto _Other = _Right . _Myvec . _Unchecked_begin ( );

        const auto _Last = _First + ( :: std :: min ) ( _Left . _Myvec . size ( ), _Right . _Myvec . size ( ) );

        for (; _First != _Last; ++ _First, ( void ) ++ _Other ) {
            using _Comp = _Vbase_compare_three_way < signed char >;
            const auto _Result = _Comp { } ( * _First, * _Other );

            if ( _Result < 0 ) {
                return true;
            } else if ( _Result > 0 ) {
                return false;
            }
        }

        return _Left . size ( ) < _Right . size ( );
    } else {
        return :: std :: lexicographical_compare (
            _Left . _Unchecked_begin ( ), _Left . _Unchecked_end ( ), _Right . _Unchecked_begin ( ), _Right . _Unchecked_end ( ) );
    }
}
#line 1953
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] inline bool operator > ( const vector < _Ty, _Alloc > & _Left, const vector < _Ty, _Alloc > & _Right ) {
    return _Right < _Left;
}
#line 1958
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] inline bool operator <= ( const vector < _Ty, _Alloc > & _Left, const vector < _Ty, _Alloc > & _Right ) {
    return ! ( _Right < _Left );
}
#line 1963
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] inline bool operator >= ( const vector < _Ty, _Alloc > & _Left, const vector < _Ty, _Alloc > & _Right ) {
    return ! ( _Left < _Right );
}
#line 1969 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Ty, class _Alloc >
inline void swap ( vector < _Ty, _Alloc > & _Left, vector < _Ty, _Alloc > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 1986 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template< class _Alloc0> 
#line 1987
struct _Wrap_alloc { 
#line 1988
using _Alloc = _Alloc0; 
#line 1989
}; 
#line 1991
template < class _Alvbase_wrapped >
class _Vb_iter_base : public _Iterator_base {

public :
    using _Alvbase = typename _Alvbase_wrapped :: _Alloc;
    using _Size_type = typename allocator_traits < _Alvbase > :: size_type;
    using _Difference_type = typename allocator_traits < _Alvbase > :: difference_type;
    using _Mycont = vector < bool, _Rebind_alloc_t < _Alvbase, bool >>;

    inline _Vb_iter_base ( ) = default;

    inline _Vb_iter_base ( const _Vbase * _Ptr, _Size_type _Off, const _Container_base * _Mypvbool ) noexcept
        : _Myptr ( _Ptr ), _Myoff ( _Off ) {
        this -> _Adopt ( _Mypvbool );
    }

    inline void _Advance ( _Size_type _Off ) noexcept {
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }







    const _Vbase * _Myptr = nullptr;
    _Size_type _Myoff = 0;
};
#line 2023 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Alvbase_wrapped >
class _Vb_reference : public _Vb_iter_base < _Alvbase_wrapped > {

    using _Mybase = _Vb_iter_base < _Alvbase_wrapped >;
    using _Mycont = typename _Mybase :: _Mycont;
    using _Difference_type = typename _Mybase :: _Difference_type;


    inline _Vb_reference ( ) = default;

public :
    inline _Vb_reference ( const _Vb_reference & ) = default;

    inline _Vb_reference ( const _Mybase & _Right ) noexcept
        : _Mybase ( _Right . _Myptr, _Right . _Myoff, _Right . _Getcont ( ) ) { }

    inline _Vb_reference & operator = ( const _Vb_reference & _Right ) noexcept {
        return * this = static_cast < bool > ( _Right );
    }

    inline _Vb_reference & operator = ( bool _Val ) noexcept {
        if ( _Val ) {
            * const_cast < _Vbase * > ( _Getptr ( ) ) |= _Mask ( );
        } else {
            * const_cast < _Vbase * > ( _Getptr ( ) ) &= ~ _Mask ( );
        }

        return * this;
    }

    inline void flip ( ) noexcept {
        * const_cast < _Vbase * > ( _Getptr ( ) ) ^= _Mask ( );
    }

    inline operator bool ( ) const noexcept {
        return ( * _Getptr ( ) & _Mask ( ) ) != 0;
    }

    inline const _Vbase * _Getptr ( ) const noexcept {







        return this -> _Myptr;
    }

    friend inline void swap ( _Vb_reference _Left, _Vb_reference _Right ) noexcept {
        bool _Val = _Left;
        _Left = _Right;
        _Right = _Val;
    }

protected :
    inline _Vbase _Mask ( ) const noexcept {
        return static_cast < _Vbase > ( 1 ) << this -> _Myoff;
    }
};
#line 2084 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Alvbase_wrapped >
class _Vb_const_iterator : public _Vb_iter_base < _Alvbase_wrapped > {
private :
    using _Mybase = _Vb_iter_base < _Alvbase_wrapped >;

public :
    using _Mycont = typename _Mybase :: _Mycont;
    using _Difference_type = typename _Mybase :: _Difference_type;
    using _Size_type = typename _Mybase :: _Size_type;
    using _Reft = _Vb_reference < _Alvbase_wrapped >;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type = bool;
    using difference_type = typename _Mybase :: _Difference_type;
    using pointer = const_reference *;
    using reference = const_reference;

    inline _Vb_const_iterator ( ) = default;

    inline _Vb_const_iterator ( const _Vbase * _Ptr, const _Container_base * _Mypvbool ) noexcept
        : _Mybase ( _Ptr, 0, _Mypvbool ) { }

    [ [ nodiscard ] ] inline const_reference operator * ( ) const noexcept {







        return _Reft ( * this );
    }

    inline _Vb_const_iterator & operator ++ ( ) noexcept {
        _Inc ( );
        return * this;
    }

    inline _Vb_const_iterator operator ++ ( int ) noexcept {
        _Vb_const_iterator _Tmp = * this;
        _Inc ( );
        return _Tmp;
    }

    inline _Vb_const_iterator & operator -- ( ) noexcept {
        _Dec ( );
        return * this;
    }

    inline _Vb_const_iterator operator -- ( int ) noexcept {
        _Vb_const_iterator _Tmp = * this;
        _Dec ( );
        return _Tmp;
    }

    inline _Vb_const_iterator & operator += ( const difference_type _Off ) noexcept {














        if ( _Off < 0 && this -> _Myoff < 0 - static_cast < _Size_type > ( _Off ) ) {
            this -> _Myoff += static_cast < _Size_type > ( _Off );
            this -> _Myptr -= 1 + ( static_cast < _Size_type > ( - 1 ) - this -> _Myoff ) / _VBITS;
            this -> _Myoff %= _VBITS;
        } else {
            this -> _Myoff += static_cast < _Size_type > ( _Off );
            this -> _Myptr += this -> _Myoff / _VBITS;
            this -> _Myoff %= _VBITS;
        }
        return * this;
    }

    [ [ nodiscard ] ] inline _Vb_const_iterator operator + ( const difference_type _Off ) const noexcept {
        _Vb_const_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _Vb_const_iterator & operator -= ( const difference_type _Off ) noexcept {
        return * this += - _Off;
    }

    [ [ nodiscard ] ] inline _Vb_const_iterator operator - ( const difference_type _Off ) const noexcept {
        _Vb_const_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline difference_type operator - ( const _Vb_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return static_cast < difference_type > ( _VBITS * ( this -> _Myptr - _Right . _Myptr ) )
             + static_cast < difference_type > ( this -> _Myoff ) - static_cast < difference_type > ( _Right . _Myoff );
    }

    [ [ nodiscard ] ] inline const_reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] inline bool operator == ( const _Vb_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return this -> _Myptr == _Right . _Myptr && this -> _Myoff == _Right . _Myoff;
    }










    [ [ nodiscard ] ] bool operator != ( const _Vb_const_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] bool operator < ( const _Vb_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return this -> _Myptr < _Right . _Myptr || ( this -> _Myptr == _Right . _Myptr && this -> _Myoff < _Right . _Myoff );
    }

    [ [ nodiscard ] ] bool operator > ( const _Vb_const_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] bool operator <= ( const _Vb_const_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] bool operator >= ( const _Vb_const_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }


    inline void _Compat ( const _Vb_const_iterator & _Right ) const noexcept {


        ( void ) _Right;



    }











    inline void _Dec ( ) noexcept {






        if ( this -> _Myoff != 0 ) {
            -- this -> _Myoff;
        } else {
            this -> _Myoff = _VBITS - 1;
            -- this -> _Myptr;
        }
    }

    inline void _Inc ( ) noexcept {







        if ( this -> _Myoff < _VBITS - 1 ) {
            ++ this -> _Myoff;
        } else {
            this -> _Myoff = 0;
            ++ this -> _Myptr;
        }
    }
};
#line 2280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Alvbase_wrapped >
[ [ nodiscard ] ] inline _Vb_const_iterator < _Alvbase_wrapped > operator + (
    typename _Vb_const_iterator < _Alvbase_wrapped > :: difference_type _Off,
    _Vb_const_iterator < _Alvbase_wrapped > _Right ) noexcept {
    return _Right += _Off;
}
#line 2287
template < class _Alvbase_wrapped >
class _Vb_iterator : public _Vb_const_iterator < _Alvbase_wrapped > {
public :
    using _Mybase = _Vb_const_iterator < _Alvbase_wrapped >;
    using _Mycont = typename _Mybase :: _Mycont;
    using _Difference_type = typename _Mybase :: _Difference_type;

    using _Reft = _Vb_reference < _Alvbase_wrapped >;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type = bool;
    using difference_type = typename _Mybase :: difference_type;
    using pointer = _Reft *;
    using reference = _Reft;

    using _Mybase :: _Mybase;

    [ [ nodiscard ] ] inline reference operator * ( ) const noexcept {







        return _Reft ( * this );
    }

    inline _Vb_iterator & operator ++ ( ) noexcept {
        _Mybase :: operator ++ ( );
        return * this;
    }

    inline _Vb_iterator operator ++ ( int ) noexcept {
        _Vb_iterator _Tmp = * this;
        _Mybase :: operator ++ ( );
        return _Tmp;
    }

    inline _Vb_iterator & operator -- ( ) noexcept {
        _Mybase :: operator -- ( );
        return * this;
    }

    inline _Vb_iterator operator -- ( int ) noexcept {
        _Vb_iterator _Tmp = * this;
        _Mybase :: operator -- ( );
        return _Tmp;
    }

    inline _Vb_iterator & operator += ( const difference_type _Off ) noexcept {
        _Mybase :: operator += ( _Off );
        return * this;
    }

    [ [ nodiscard ] ] inline _Vb_iterator operator + ( const difference_type _Off ) const noexcept {
        _Vb_iterator _Tmp = * this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _Vb_iterator & operator -= ( const difference_type _Off ) noexcept {
        _Mybase :: operator -= ( _Off );
        return * this;
    }

    using _Mybase :: operator -;

    [ [ nodiscard ] ] inline _Vb_iterator operator - ( const difference_type _Off ) const noexcept {
        _Vb_iterator _Tmp = * this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    using _Prevent_inheriting_unwrap = _Vb_iterator;
};
#line 2369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Alvbase_wrapped >
[ [ nodiscard ] ] inline _Vb_iterator < _Alvbase_wrapped > operator + (
    typename _Vb_iterator < _Alvbase_wrapped > :: difference_type _Off, _Vb_iterator < _Alvbase_wrapped > _Right ) noexcept {
    return _Right += _Off;
}
#line 2375
template < class _Alloc >
class _Vb_val : public _Container_base {
public :
    using _Alvbase = _Rebind_alloc_t < _Alloc, _Vbase >;
    using _Alvbase_traits = allocator_traits < _Alvbase >;
    using _Vectype = vector < _Vbase, _Alvbase >;
    using _Alvbase_wrapped = _Wrap_alloc < _Alvbase >;
    using size_type = typename _Alvbase_traits :: size_type;

    inline _Vb_val ( ) noexcept ( is_nothrow_default_constructible_v < _Vectype > ) : _Myvec ( ), _Mysize ( 0 ) {
        this -> _Alloc_proxy ( _Fake_alloc );
    }

    inline _Vb_val ( const _Alloc & _Al ) noexcept ( is_nothrow_constructible_v < _Vectype, _Alvbase > )
        : _Myvec ( static_cast < _Alvbase > ( _Al ) ), _Mysize ( 0 ) {
        this -> _Alloc_proxy ( _Fake_alloc );
    }

    inline _Vb_val ( size_type _Count, const bool & _Val )
        : _Myvec ( _Nw ( _Count ), static_cast < _Vbase > ( _Val ? - 1 : 0 ) ), _Mysize ( 0 ) {
        this -> _Alloc_proxy ( _Fake_alloc );
    }

    inline _Vb_val ( size_type _Count, const bool & _Val, const _Alloc & _Al )
        : _Myvec ( _Nw ( _Count ), static_cast < _Vbase > ( _Val ? - 1 : 0 ), static_cast < _Alvbase > ( _Al ) ), _Mysize ( 0 ) {
        this -> _Alloc_proxy ( _Fake_alloc );
    }

    inline _Vb_val ( const _Vb_val & _Right ) : _Myvec ( _Right . _Myvec ), _Mysize ( _Right . _Mysize ) {
        this -> _Alloc_proxy ( _Fake_alloc );
    }

    inline _Vb_val ( const _Vb_val & _Right, const _Alloc & _Al )
        : _Myvec ( _Right . _Myvec, static_cast < _Alvbase > ( _Al ) ), _Mysize ( _Right . _Mysize ) {
        this -> _Alloc_proxy ( _Fake_alloc );
    }

    inline _Vb_val ( _Vb_val && _Right ) noexcept ( is_nothrow_move_constructible_v < _Vectype > )
        : _Myvec ( :: std :: move ( _Right . _Myvec ) ), _Mysize ( :: std :: exchange ( _Right . _Mysize, size_type { 0 } ) ) {
        this -> _Alloc_proxy ( _Fake_alloc );
    }

    inline _Vb_val ( _Vb_val && _Right, const _Alloc & _Al ) noexcept (
        is_nothrow_constructible_v < _Vectype, _Vectype, _Alvbase > )
        : _Myvec ( :: std :: move ( _Right . _Myvec ), static_cast < _Alvbase > ( _Al ) ), _Mysize ( _Right . _Mysize ) {
        if ( _Right . _Myvec . empty ( ) ) {

            _Right . _Mysize = 0;
        }

        this -> _Alloc_proxy ( _Fake_alloc );
    }

    inline ~ _Vb_val ( ) noexcept {





    }

    inline _Alvbase & _Getal ( ) noexcept {
        return _Myvec . _Getal ( );
    }

    inline const _Alvbase & _Getal ( ) const noexcept {
        return _Myvec . _Getal ( );
    }

    static inline size_type _Nw ( size_type _Count ) noexcept {
        return ( _Count + _VBITS - 1 ) / _VBITS;
    }

    _Vectype _Myvec;
    size_type _Mysize;
};
#line 2452 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Alloc >
class vector < bool, _Alloc > : public _Vb_val < _Alloc > {
public :
    static_assert ( ! 0 || is_same_v < bool, typename _Alloc :: value_type >,
        "vector<bool, Allocator> requires that Allocator\'s value_type match bool (See N4659 26.2.1 [container.requirements.general]/16 a" "llocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic." );

    using _Mybase = _Vb_val < _Alloc >;
    using _Alvbase_wrapped = typename _Mybase :: _Alvbase_wrapped;
    using _Alvbase = typename _Mybase :: _Alvbase;
    using _Alvbase_traits = typename _Mybase :: _Alvbase_traits;

    using size_type = typename _Alvbase_traits :: size_type;
    using difference_type = typename _Alvbase_traits :: difference_type;
    using allocator_type = _Alloc;

    using reference = _Vb_reference < _Alvbase_wrapped >;
    using const_reference = bool;
    using value_type = bool;

    using _Reft = reference;
    using iterator = _Vb_iterator < _Alvbase_wrapped >;
    using const_iterator = _Vb_const_iterator < _Alvbase_wrapped >;

    using pointer = iterator;
    using const_pointer = const_iterator;
    using reverse_iterator = :: std :: reverse_iterator < iterator >;
    using const_reverse_iterator = :: std :: reverse_iterator < const_iterator >;

    static const int _VBITS = :: std :: _VBITS;
    enum { _EEN_VBITS = _VBITS };

    inline vector ( ) noexcept ( is_nothrow_default_constructible_v < _Mybase > )
        : _Mybase ( ) { }

    inline explicit vector ( const _Alloc & _Al ) noexcept (
        is_nothrow_constructible_v < _Mybase, const _Alloc & > )
        : _Mybase ( _Al ) { }

    inline explicit vector ( size_type _Count, const _Alloc & _Al = _Alloc ( ) )
        : _Mybase ( _Count, false, _Al ) {
        _Trim ( _Count );
    }

    inline vector ( size_type _Count, const bool & _Val, const _Alloc & _Al = _Alloc ( ) )
        : _Mybase ( _Count, _Val, _Al ) {
        _Trim ( _Count );
    }

    inline vector ( const vector & _Right ) : _Mybase ( _Right ) { }

    inline vector ( const vector & _Right, const _Alloc & _Al ) : _Mybase ( _Right, _Al ) { }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline vector ( _Iter _First, _Iter _Last, const _Alloc & _Al = _Alloc ( ) ) : _Mybase ( _Al ) {
        _BConstruct ( _First, _Last );
    }

    template < class _Iter >
    inline void _BConstruct ( _Iter _First, _Iter _Last ) {
        insert ( begin ( ), _First, _Last );
    }

    inline vector ( vector && _Right ) noexcept ( is_nothrow_move_constructible_v < _Mybase > )
        : _Mybase ( :: std :: move ( _Right ) ) {
        this -> _Swap_proxy_and_iterators ( _Right );
    }

    inline vector ( vector && _Right, const _Alloc & _Al ) noexcept (
        is_nothrow_constructible_v < _Mybase, _Mybase, const _Alloc & > )
        : _Mybase ( :: std :: move ( _Right ), _Al ) {
        if constexpr ( ! _Alvbase_traits :: is_always_equal :: value ) {
            if ( this -> _Getal ( ) != _Right . _Getal ( ) ) {
                return;
            }
        }

        this -> _Swap_proxy_and_iterators ( _Right );
    }

private :








































public :
    inline vector & operator = ( vector && _Right ) noexcept ( is_nothrow_move_assignable_v < _Mybase > ) {
        if ( this != :: std :: addressof ( _Right ) ) {

            this -> _Myvec = :: std :: move ( _Right . _Myvec );
            this -> _Mysize = :: std :: exchange ( _Right . _Mysize, size_type { 0 } );




        }
        return * this;
    }

    template < class ... _Valty >
    inline decltype ( auto ) emplace_back ( _Valty && ... _Val ) {
        bool _Tmp ( :: std :: forward < _Valty > ( _Val ) ... );
        push_back ( _Tmp );




    }

    template < class ... _Valty >
    inline iterator emplace ( const_iterator _Where, _Valty && ... _Val ) {
        bool _Tmp ( :: std :: forward < _Valty > ( _Val ) ... );
        return insert ( _Where, _Tmp );
    }

    inline vector ( initializer_list < bool > _Ilist, const _Alloc & _Al = allocator_type ( ) )
        : _Mybase ( 0, false, _Al ) {
        insert ( begin ( ), _Ilist . begin ( ), _Ilist . end ( ) );
    }

    inline vector & operator = ( initializer_list < bool > _Ilist ) {
        assign ( _Ilist . begin ( ), _Ilist . end ( ) );
        return * this;
    }

    inline void assign ( initializer_list < bool > _Ilist ) {
        assign ( _Ilist . begin ( ), _Ilist . end ( ) );
    }

    inline iterator insert ( const_iterator _Where, initializer_list < bool > _Ilist ) {
        return insert ( _Where, _Ilist . begin ( ), _Ilist . end ( ) );
    }

    inline ~ vector ( ) noexcept { }

private :






















public :
    inline vector & operator = ( const vector & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {

            this -> _Myvec = _Right . _Myvec;
            this -> _Mysize = _Right . _Mysize;




        }

        return * this;
    }

    inline void reserve ( size_type _Count ) {
        this -> _Myvec . reserve ( this -> _Nw ( _Count ) );
    }

    [ [ nodiscard ] ] inline size_type capacity ( ) const noexcept {
        return this -> _Myvec . capacity ( ) * _VBITS;
    }

    [ [ nodiscard ] ] inline iterator begin ( ) noexcept {
        return iterator ( this -> _Myvec . data ( ), this );
    }

    [ [ nodiscard ] ] inline const_iterator begin ( ) const noexcept {
        return const_iterator ( this -> _Myvec . data ( ), this );
    }

    [ [ nodiscard ] ] inline iterator end ( ) noexcept {
        return begin ( ) + static_cast < difference_type > ( this -> _Mysize );
    }

    [ [ nodiscard ] ] inline const_iterator end ( ) const noexcept {
        return begin ( ) + static_cast < difference_type > ( this -> _Mysize );
    }

    [ [ nodiscard ] ] inline const_iterator cbegin ( ) const noexcept {
        return begin ( );
    }

    [ [ nodiscard ] ] inline const_iterator cend ( ) const noexcept {
        return end ( );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator crbegin ( ) const noexcept {
        return rbegin ( );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator crend ( ) const noexcept {
        return rend ( );
    }

    [ [ nodiscard ] ] inline iterator _Unchecked_begin ( ) noexcept {
        return iterator ( this -> _Myvec . data ( ), this );
    }

    [ [ nodiscard ] ] inline const_iterator _Unchecked_begin ( ) const noexcept {
        return const_iterator ( this -> _Myvec . data ( ), this );
    }

    [ [ nodiscard ] ] inline iterator _Unchecked_end ( ) noexcept {
        return _Unchecked_begin ( ) + static_cast < difference_type > ( this -> _Mysize );
    }

    [ [ nodiscard ] ] inline const_iterator _Unchecked_end ( ) const noexcept {
        return _Unchecked_begin ( ) + static_cast < difference_type > ( this -> _Mysize );
    }

    inline void shrink_to_fit ( ) {
        if ( this -> _Myvec . capacity ( ) != this -> _Myvec . size ( ) ) {
            this -> _Orphan_all ( );
            this -> _Myvec . shrink_to_fit ( );
        }
    }

    inline iterator _Make_iter ( const_iterator _Where ) noexcept {
        iterator _Tmp = begin ( );
        if ( 0 < this -> _Mysize ) {
            _Tmp += _Where - begin ( );
        }

        return _Tmp;
    }

    [ [ nodiscard ] ] inline reverse_iterator rbegin ( ) noexcept {
        return reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator rbegin ( ) const noexcept {
        return const_reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] inline reverse_iterator rend ( ) noexcept {
        return reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] inline const_reverse_iterator rend ( ) const noexcept {
        return const_reverse_iterator ( begin ( ) );
    }

    inline void resize ( size_type _Newsize, bool _Val = false ) {
        if ( size ( ) < _Newsize ) {
            _Insert_n ( end ( ), _Newsize - size ( ), _Val );
        } else if ( _Newsize < size ( ) ) {
            erase ( begin ( ) + static_cast < difference_type > ( _Newsize ), end ( ) );
        }
    }

    [ [ nodiscard ] ] inline size_type size ( ) const noexcept {
        return this -> _Mysize;
    }

    [ [ nodiscard ] ] inline size_type max_size ( ) const noexcept {
        constexpr auto _Diff_max = static_cast < size_type > ( ( numeric_limits < difference_type > :: max ) ( ) );
        const size_type _Ints_max = this -> _Myvec . max_size ( );
        if ( _Ints_max > _Diff_max / _VBITS ) {
            return _Diff_max;
        }


        return _Ints_max * _VBITS;
    }

    [ [ nodiscard ] ] inline bool empty ( ) const noexcept {
        return size ( ) == 0;
    }

    [ [ nodiscard ] ] inline allocator_type get_allocator ( ) const noexcept {
        return static_cast < allocator_type > ( this -> _Myvec . get_allocator ( ) );
    }

    [ [ nodiscard ] ] inline const_reference at ( size_type _Off ) const {
        if ( size ( ) <= _Off ) {
            _Xran ( );
        }

        return ( * this ) [ _Off ];
    }

    [ [ nodiscard ] ] inline reference at ( size_type _Off ) {
        if ( size ( ) <= _Off ) {
            _Xran ( );
        }

        return ( * this ) [ _Off ];
    }

    [ [ nodiscard ] ] inline const_reference operator [ ] ( size_type _Off ) const noexcept {




        const_iterator _It = begin ( );
        _It . _Advance ( _Off );
        return * _It;
    }

    [ [ nodiscard ] ] inline reference operator [ ] ( size_type _Off ) noexcept {




        iterator _It = begin ( );
        _It . _Advance ( _Off );
        return * _It;
    }

    [ [ nodiscard ] ] inline reference front ( ) noexcept {




        return * begin ( );
    }

    [ [ nodiscard ] ] inline const_reference front ( ) const noexcept {




        return * begin ( );
    }

    [ [ nodiscard ] ] inline reference back ( ) noexcept {




        return * ( end ( ) - 1 );
    }

    [ [ nodiscard ] ] inline const_reference back ( ) const noexcept {




        return * ( end ( ) - 1 );
    }

    inline void push_back ( const bool & _Val ) {
        insert ( end ( ), _Val );
    }

    inline void pop_back ( ) noexcept {
        erase ( end ( ) - 1 );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline void assign ( _Iter _First, _Iter _Last ) {
        clear ( );
        insert ( begin ( ), _First, _Last );
    }

    inline void assign ( size_type _Count, const bool & _Val ) {
        clear ( );
        _Insert_n ( begin ( ), _Count, _Val );
    }

    inline iterator insert ( const_iterator _Where, const bool & _Val ) {
        return _Insert_n ( _Where, static_cast < size_type > ( 1 ), _Val );
    }

    inline iterator insert (
        const_iterator _Where, size_type _Count, const bool & _Val ) {
        return _Insert_n ( _Where, _Count, _Val );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    inline iterator insert ( const_iterator _Where, _Iter _First, _Iter _Last ) {
        difference_type _Off = _Where - begin ( );
        _Insert ( _Where, _First, _Last, _Iter_cat_t < _Iter > { } );
        return begin ( ) + _Off;
    }

    template < class _Iter >
    inline void _Insert ( const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag ) {
        difference_type _Off = _Where - begin ( );

        for (; _First != _Last; ++ _First, ( void ) ++ _Off ) {
            insert ( begin ( ) + _Off, * _First );
        }
    }

    template < class _Iter >
    inline void _Insert ( const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag ) {
        _Adl_verify_range ( _First, _Last );
        auto _Count = _Convert_size < size_type > ( static_cast < size_t > ( :: std :: distance ( _First, _Last ) ) );
        size_type _Off = _Insert_x ( _Where, _Count );
        _Copy_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), begin ( ) + static_cast < difference_type > ( _Off ) );
    }

    inline iterator erase ( const_iterator _Where_arg ) noexcept {
        iterator _Where = _Make_iter ( _Where_arg );
        difference_type _Off = _Where - begin ( );







        :: std :: copy ( _Next_iter ( _Where ), end ( ), _Where );


        _Trim ( this -> _Mysize - 1 );
        return begin ( ) + _Off;
    }

    inline iterator erase ( const_iterator _First_arg, const_iterator _Last_arg ) noexcept
     {
        iterator _First = _Make_iter ( _First_arg );
        iterator _Last = _Make_iter ( _Last_arg );
        difference_type _Off = _First - begin ( );

        if ( _First != _Last ) {








            iterator _Next = :: std :: copy ( _Last, end ( ), _First );
            _Trim ( static_cast < size_type > ( _Next - begin ( ) ) );

        }
        return begin ( ) + _Off;
    }

    inline void clear ( ) noexcept {
        this -> _Orphan_all ( );
        this -> _Myvec . clear ( );
        this -> _Mysize = 0;
    }

    inline void flip ( ) noexcept {
        for ( auto & _Elem : this -> _Myvec ) {
            _Elem = ~ _Elem;
        }

        _Trim ( this -> _Mysize );
    }

    inline void swap ( vector & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            this -> _Swap_proxy_and_iterators ( _Right );
            this -> _Myvec . swap ( _Right . _Myvec );
            :: std :: swap ( this -> _Mysize, _Right . _Mysize );
        }
    }

    static inline void swap ( reference _Left, reference _Right ) noexcept {
        bool _Val = _Left;
        _Left = _Right;
        _Right = _Val;
    }

    friend hash < vector < bool, _Alloc >>;

    inline iterator _Insert_n ( const_iterator _Where, size_type _Count, const bool & _Val ) {
        size_type _Off = _Insert_x ( _Where, _Count );
        const auto _Result = begin ( ) + static_cast < difference_type > ( _Off );
        :: std :: fill ( _Result, _Result + static_cast < difference_type > ( _Count ), _Val );
        return _Result;
    }

    inline size_type _Insert_x ( const_iterator _Where, size_type _Count ) {
        difference_type _Off = _Where - begin ( );






        if ( _Count != 0 ) {
            if ( max_size ( ) - size ( ) < _Count ) {
                _Xlen ( );
            }


            this -> _Myvec . resize ( this -> _Nw ( size ( ) + _Count ), 0 );
            if ( empty ( ) ) {
                this -> _Mysize += _Count;
            } else {
                iterator _Oldend = end ( );
                this -> _Mysize += _Count;
                :: std :: copy_backward ( begin ( ) + _Off, _Oldend, end ( ) );
            }




        }

        return static_cast < size_type > ( _Off );
    }









































    inline void _Trim ( size_type _Size ) {
        if ( max_size ( ) < _Size ) {
            _Xlen ( );
        }

        const size_type _Words = this -> _Nw ( _Size );
        if ( _Words < this -> _Myvec . size ( ) ) {
            this -> _Myvec . erase ( this -> _Myvec . begin ( ) + static_cast < difference_type > ( _Words ), this -> _Myvec . end ( ) );
        }

        this -> _Mysize = _Size;
        _Size %= _VBITS;
        if ( 0 < _Size ) {
            this -> _Myvec [ _Words - 1 ] &= ( static_cast < _Vbase > ( 1 ) << _Size ) - 1;
        }
    }

    [ [ noreturn ] ] void _Xlen ( ) const {
        _Xlength_error ( "vector<bool> too long" );
    }

    [ [ noreturn ] ] void _Xran ( ) const {
        _Xout_of_range ( "invalid vector<bool> subscript" );
    }
};
#line 3072 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template < class _Alloc >
struct hash < vector < bool, _Alloc > > {
     typedef vector < bool, _Alloc > argument_type;
     typedef size_t result_type;

    [ [ nodiscard ] ] size_t operator ( ) ( const vector < bool, _Alloc > & _Keyval ) const noexcept {
        return _Hash_array_representation ( _Keyval . _Myvec . data ( ), _Keyval . _Myvec . size ( ) );
    }
};
#line 3089 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
template< class _Alloc, bool _RequiresMutable> constexpr bool 
#line 3090
_Is_vb_iterator< _Vb_iterator< _Alloc> , _RequiresMutable>  = true; 
#line 3092
template< class _Alloc> constexpr bool 
#line 3093
_Is_vb_iterator< _Vb_const_iterator< _Alloc> , false>  = true; 
#line 3095
template < class _FwdIt, class _Ty >
inline void _Fill_vbool ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val ) {

    if ( _First == _Last ) {
        return;
    }

    _Vbase * _VbFirst = const_cast < _Vbase * > ( _First . _Myptr );
    _Vbase * const _VbLast = const_cast < _Vbase * > ( _Last . _Myptr );

    const auto _FirstSourceMask = static_cast < _Vbase > ( - 1 ) << _First . _Myoff;
    const auto _FirstDestMask = ~ _FirstSourceMask;
    const auto _FillVal = static_cast < _Vbase > ( _Val ? - 1 : 0 );

    if ( _VbFirst == _VbLast ) {

        const auto _LastSourceMask = static_cast < _Vbase > ( - 1 ) >> ( _VBITS - _Last . _Myoff );
        const auto _LastDestMask = ~ _LastSourceMask;
        const auto _SourceMask = _FirstSourceMask & _LastSourceMask;
        const auto _DestMask = _FirstDestMask | _LastDestMask;
        * _VbFirst = ( * _VbFirst & _DestMask ) | ( _FillVal & _SourceMask );
        return;
    }

    * _VbFirst = ( * _VbFirst & _FirstDestMask ) | ( _FillVal & _FirstSourceMask );
    ++ _VbFirst;








    {
        const auto _VbFirst_ch = reinterpret_cast < const char * > ( _VbFirst );
        const auto _VbLast_ch = reinterpret_cast < const char * > ( _VbLast );
        const auto _Count_ch = static_cast < size_t > ( _VbLast_ch - _VbFirst_ch );
        const auto _ValChar = static_cast < unsigned char > ( _Val ? - 1 : 0 );
        :: memset ( _VbFirst, _ValChar, _Count_ch );
        _VbFirst = _VbLast;
    }

    if ( _Last . _Myoff != 0 ) {
        const auto _LastSourceMask = static_cast < _Vbase > ( - 1 ) >> ( _VBITS - _Last . _Myoff );
        const auto _LastDestMask = ~ _LastSourceMask;
        * _VbFirst = ( * _VbFirst & _LastDestMask ) | ( _FillVal & _LastSourceMask );
    }
}
#line 3144
}
#line 3148
#pragma warning(pop)
#pragma pack ( pop )
#line 3152 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
#pragma external_header(pop)
#line 17 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cassert"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 18
__pragma( pack ( push, 8 )) extern "C" {
#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"
}__pragma( pack ( pop )) 
#line 47
#pragma warning(pop)
#pragma external_header(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cassert"
#pragma external_header(pop)
#line 18 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
extern "C" {
#line 29
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_1(const void * _First, const void * _Last, void * _Dest) noexcept; 
#line 31
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_2(const void * _First, const void * _Last, void * _Dest) noexcept; 
#line 33
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_4(const void * _First, const void * _Last, void * _Dest) noexcept; 
#line 35
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_8(const void * _First, const void * _Last, void * _Dest) noexcept; 
#line 37
}
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
namespace std { 
#line 41
constexpr int _ISORT_MAX = 32; 
#line 43
template< class _It> constexpr auto 
#line 44
_Isort_max = _Iter_diff_t< _It> {_ISORT_MAX}; 
#line 46
template < class _Diff >
constexpr ptrdiff_t _Temporary_buffer_size ( const _Diff _Value ) noexcept {

    using _CT = common_type_t < ptrdiff_t, _Diff >;
    return static_cast < ptrdiff_t > ( ( :: std :: min ) ( static_cast < _CT > ( 9223372036854775807i64 ), static_cast < _CT > ( _Value ) ) );
}
#line 53
template < class _Ty >
struct _Optimistic_temporary_buffer {
    static constexpr size_t _Optimistic_size = 4096;
    static constexpr size_t _Optimistic_count = ( :: std :: max ) ( static_cast < size_t > ( 1 ), _Optimistic_size / sizeof ( _Ty ) );

    template < class _Diff >
    explicit _Optimistic_temporary_buffer ( const _Diff _Requested_size ) noexcept {
        const auto _Attempt = _Temporary_buffer_size ( _Requested_size );


        if ( static_cast < size_t > ( _Requested_size ) <= _Optimistic_count ) {
            _Data = reinterpret_cast < _Ty * > ( & _Stack_space [ 0 ] );
            _Capacity = static_cast < ptrdiff_t > ( _Requested_size );
            return;
        }

        const pair < _Ty *, ptrdiff_t > _Raw = _Get_temporary_buffer < _Ty > ( _Attempt );
        if ( static_cast < size_t > ( _Raw . second ) > _Optimistic_count ) {
            _Data = _Raw . first;
            _Capacity = _Raw . second;
            return;
        }


        _Return_temporary_buffer ( _Raw . first );
        _Data = reinterpret_cast < _Ty * > ( & _Stack_space [ 0 ] );
        _Capacity = _Optimistic_count;
    }

    _Optimistic_temporary_buffer ( const _Optimistic_temporary_buffer & ) = delete;
    _Optimistic_temporary_buffer & operator = ( const _Optimistic_temporary_buffer & ) = delete;

    ~ _Optimistic_temporary_buffer ( ) noexcept {
        if ( static_cast < size_t > ( _Capacity ) > _Optimistic_count ) {
            _Return_temporary_buffer ( _Data );
        }
    }

    _Ty * _Data;
    ptrdiff_t _Capacity;
    aligned_union_t < 0, _Ty > _Stack_space [ _Optimistic_count ];
};
#line 227
template < class _InIt, class _Fn >
inline _Fn for_each ( _InIt _First, _InIt _Last, _Fn _Func ) {
    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        _Func ( * _UFirst );
    }

    return _Func;
}
#line 351 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _Pr >
[ [ nodiscard ] ] inline _InIt find_if_not ( _InIt _First, const _InIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( ! _Pred ( * _UFirst ) ) {
            break;
        }
    }

    _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 372 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] inline _FwdIt adjacent_find ( const _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    auto _ULast = _Get_unwrapped ( _Last );
    if ( _UFirst != _ULast ) {
        for ( auto _UNext = _UFirst; ++ _UNext != _ULast; _UFirst = _UNext ) {
            if ( _Pred ( * _UFirst, * _UNext ) ) {
                _ULast = _UFirst;
                break;
            }
        }
    }

    _Seek_wrapped ( _Last, _ULast );
    return _Last;
}
#line 391
template < class _FwdIt >
[ [ nodiscard ] ] inline _FwdIt adjacent_find ( const _FwdIt _First, const _FwdIt _Last ) {
    return :: std :: adjacent_find ( _First, _Last, equal_to < > { } );
}
#line 503 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _Pr >
[ [ nodiscard ] ] inline _Iter_diff_t < _InIt > count_if ( _InIt _First, _InIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    _Iter_diff_t < _InIt > _Count = 0;
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( _Pred ( * _UFirst ) ) {
            ++ _Count;
        }
    }

    return _Count;
}
#line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline pair < _InIt1, _InIt2 > mismatch ( _InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped_n ( _First2, _Idl_distance < _InIt1 > ( _UFirst1, _ULast1 ) );
    while ( _UFirst1 != _ULast1 && _Pred ( * _UFirst1, * _UFirst2 ) ) {
        ++ _UFirst1;
        ++ _UFirst2;
    }

    _Seek_wrapped ( _First2, _UFirst2 );
    _Seek_wrapped ( _First1, _UFirst1 );
    return { _First1, _First2 };
}
#line 591 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline pair < _InIt1, _InIt2 > mismatch ( const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2 ) {

    return :: std :: mismatch ( _First1, _Last1, _First2, equal_to < > { } );
}
#line 608 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline pair < _InIt1, _InIt2 > mismatch (
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    if constexpr ( _Is_random_iter_v < _InIt1 > && _Is_random_iter_v < _InIt2 > ) {
        using _CT = _Common_diff_t < _InIt1, _InIt2 >;
        const _CT _Count1 = _ULast1 - _UFirst1;
        const _CT _Count2 = _ULast2 - _UFirst2;
        const auto _Count = static_cast < _Iter_diff_t < _InIt1 >> ( ( :: std :: min ) ( _Count1, _Count2 ) );
        _ULast1 = _UFirst1 + _Count;
        while ( _UFirst1 != _ULast1 && _Pred ( * _UFirst1, * _UFirst2 ) ) {
            ++ _UFirst1;
            ++ _UFirst2;
        }
    } else {
        while ( _UFirst1 != _ULast1 && _UFirst2 != _ULast2 && _Pred ( * _UFirst1, * _UFirst2 ) ) {
            ++ _UFirst1;
            ++ _UFirst2;
        }
    }

    _Seek_wrapped ( _First2, _UFirst2 );
    _Seek_wrapped ( _First1, _UFirst1 );
    return { _First1, _First2 };
}
#line 646 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline pair < _InIt1, _InIt2 > mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2 ) {

    return :: std :: mismatch ( _First1, _Last1, _First2, _Last2, equal_to < > { } );
}
#line 761 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt1, class _FwdIt2, class _Pr >
[ [ nodiscard ] ] inline bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped_n ( _First2, _Idl_distance < _FwdIt1 > ( _UFirst1, _ULast1 ) );

    for (;; ++ _UFirst1, ( void ) ++ _UFirst2 ) {
        if ( _UFirst1 == _ULast1 ) {
            return true;
        }

        if ( ! _Pred ( * _UFirst1, * _UFirst2 ) ) {
            break;
        }
    }



    const auto _Dist2 = static_cast < _Iter_diff_t < _FwdIt2 >> ( :: std :: distance ( _UFirst1, _ULast1 ) );
    return _Check_match_counts ( _UFirst1, _ULast1, _UFirst2, :: std :: next ( _UFirst2, _Dist2 ), _Pass_fn ( _Pred ) );
}
#line 785
template < class _FwdIt1, class _FwdIt2 >
[ [ nodiscard ] ] inline bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2 ) {

    return :: std :: is_permutation ( _First1, _Last1, _First2, equal_to < > { } );
}
#line 791
template < class _FwdIt1, class _FwdIt2, class _Pr >
inline bool _Is_permutation_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    forward_iterator_tag, forward_iterator_tag ) {

    for (;; ++ _First1, ( void ) ++ _First2 ) {
        if ( _First1 == _Last1 ) {
            return _First2 == _Last2;
        }

        if ( _First2 == _Last2 ) {
            return false;
        }

        if ( ! _Pred ( * _First1, * _First2 ) ) {
            break;
        }
    }

    auto _Next1 = _First1;
    auto _Next2 = _First2;
    for (;; ++ _Next1, ( void ) ++ _Next2 ) {
        if ( _Next1 == _Last1 ) {
            if ( _Next2 == _Last2 ) {
                return _Check_match_counts ( _First1, _Last1, _First2, _Last2, _Pred );
            }

            return false;
        }

        if ( _Next2 == _Last2 ) {
            return false;
        }
    }
}
#line 826
template < class _FwdIt1, class _FwdIt2, class _Pr >
inline bool _Is_permutation_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    random_access_iterator_tag, random_access_iterator_tag ) {

    if ( _Last1 - _First1 != _Last2 - _First2 ) {
        return false;
    }

    for (; _First1 != _Last1; ++ _First1, ( void ) ++ _First2 ) {
        if ( ! _Pred ( * _First1, * _First2 ) ) {

            return _Check_match_counts ( _First1, _Last1, _First2, _Last2, _Pred );
        }
    }

    return true;
}
#line 844
template < class _FwdIt1, class _FwdIt2, class _Pr >
[ [ nodiscard ] ] inline bool is_permutation (
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    return _Is_permutation_unchecked ( _Get_unwrapped ( _First1 ), _Get_unwrapped ( _Last1 ), _Get_unwrapped ( _First2 ),
        _Get_unwrapped ( _Last2 ), _Pass_fn ( _Pred ), _Iter_cat_t < _FwdIt1 > { }, _Iter_cat_t < _FwdIt2 > { } );
}
#line 854
template < class _FwdIt1, class _FwdIt2 >
[ [ nodiscard ] ] inline bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2 ) {

    return :: std :: is_permutation ( _First1, _Last1, _First2, _Last2, equal_to < > { } );
}
#line 1093
template < class _InIt, class _Pr >
[ [ nodiscard ] ] inline bool all_of ( _InIt _First, _InIt _Last, _Pr _Pred ) {
    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( ! _Pred ( * _UFirst ) ) {
            return false;
        }
    }

    return true;
}
#line 1154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _Pr >
[ [ nodiscard ] ] inline bool any_of ( const _InIt _First, const _InIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( _Pred ( * _UFirst ) ) {
            return true;
        }
    }

    return false;
}
#line 1216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _Pr >
[ [ nodiscard ] ] inline bool none_of ( const _InIt _First, const _InIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( _Pred ( * _UFirst ) ) {
            return false;
        }
    }

    return true;
}
#line 1342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _OutIt, class _Pr >
inline _OutIt copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred ) {
    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_unverified ( _Dest );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( _Pred ( * _UFirst ) ) {
            * _UDest = * _UFirst;
            ++ _UDest;
        }
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 1535 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _OutIt1, class _OutIt2, class _Pr >
inline pair < _OutIt1, _OutIt2 > partition_copy (
    _InIt _First, _InIt _Last, _OutIt1 _Dest_true, _OutIt2 _Dest_false, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest_true = _Get_unwrapped_unverified ( _Dest_true );
    auto _UDest_false = _Get_unwrapped_unverified ( _Dest_false );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( _Pred ( * _UFirst ) ) {
            * _UDest_true = * _UFirst;
            ++ _UDest_true;
        } else {
            * _UDest_false = * _UFirst;
            ++ _UDest_false;
        }
    }

    _Seek_wrapped ( _Dest_false, _UDest_false );
    _Seek_wrapped ( _Dest_true, _UDest_true );
    return { _Dest_true, _Dest_false };
}
#line 1641 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _Pr >
[ [ nodiscard ] ] inline bool is_partitioned ( const _InIt _First, const _InIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );

    for (;; ++ _UFirst ) {
        if ( _UFirst == _ULast ) {
            return true;
        }

        if ( ! _Pred ( * _UFirst ) ) {
            break;
        }
    }

    while ( ++ _UFirst != _ULast ) {
        if ( _Pred ( * _UFirst ) ) {
            return false;
        }
    }

    return true;
}
#line 1724 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] inline _FwdIt partition_point ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _Count = :: std :: distance ( _UFirst, _ULast );
    while ( 0 < _Count ) {
        const auto _Count2 = static_cast < _Iter_diff_t < _FwdIt >> ( _Count / 2 );
        const auto _UMid = :: std :: next ( _UFirst, _Count2 );

        if ( _Pred ( * _UMid ) ) {
            _UFirst = _Next_iter ( _UMid );
            _Count -= _Count2;
            -- _Count;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 1846
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline bool _Equal_rev_pred_unchecked ( _InIt1 _First1, _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred ) {

    if constexpr ( _Equal_memcmp_is_safe < _InIt1, _InIt2, _Pr > ) {



        {
            return _Memcmp_ranges ( _First2, _Last2, _First1 ) == 0;
        }
    }

    for (; _First2 != _Last2; ++ _First1, ( void ) ++ _First2 ) {
        if ( ! _Pred ( * _First1, * _First2 ) ) {
            return false;
        }
    }

    return true;
}
#line 1867
template < class _FwdItHaystack, class _FwdItPat, class _Pr >
[ [ nodiscard ] ] inline _FwdItHaystack search ( _FwdItHaystack _First1, _FwdItHaystack _Last1, const _FwdItPat _First2,
    const _FwdItPat _Last2, _Pr _Pred ) {
    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    const auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    if constexpr ( _Is_random_iter_v < _FwdItHaystack > && _Is_random_iter_v < _FwdItPat > ) {
        const _Iter_diff_t < _FwdItPat > _Count2 = _ULast2 - _UFirst2;
        if ( _ULast1 - _UFirst1 >= _Count2 ) {
            const auto _Last_possible = _ULast1 - static_cast < _Iter_diff_t < _FwdItHaystack >> ( _Count2 );
            for (;; ++ _UFirst1 ) {
                if ( _Equal_rev_pred_unchecked ( _UFirst1, _UFirst2, _ULast2, _Pass_fn ( _Pred ) ) ) {
                    _Seek_wrapped ( _Last1, _UFirst1 );
                    break;
                }

                if ( _UFirst1 == _Last_possible ) {
                    break;
                }
            }
        }
    } else {
        for (;; ++ _UFirst1 ) {
            auto _UMid1 = _UFirst1;
            for ( auto _UMid2 = _UFirst2;; ++ _UMid1, ( void ) ++ _UMid2 ) {
                if ( _UMid2 == _ULast2 ) {
                    _Seek_wrapped ( _Last1, _UFirst1 );
                    return _Last1;
                } else if ( _UMid1 == _ULast1 ) {
                    return _Last1;
                } else if ( ! _Pred ( * _UMid1, * _UMid2 ) ) {
                    break;
                }
            }
        }
    }

    return _Last1;
}
#line 1916 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdItHaystack, class _FwdItPat >
[ [ nodiscard ] ] inline _FwdItHaystack search (
    const _FwdItHaystack _First1, const _FwdItHaystack _Last1, const _FwdItPat _First2, const _FwdItPat _Last2 ) {

    return :: std :: search ( _First1, _Last1, _First2, _Last2, equal_to < > { } );
}
#line 1932 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdItHaystack, class _Searcher >
[ [ nodiscard ] ] inline _FwdItHaystack search (
    const _FwdItHaystack _First, const _FwdItHaystack _Last, const _Searcher & _Search ) {

    return _Search ( _First, _Last ) . first;
}
#line 1939
template < class _FwdIt, class _Diff, class _Ty, class _Pr >
[ [ nodiscard ] ] inline _FwdIt search_n (
    const _FwdIt _First, _FwdIt _Last, const _Diff _Count_raw, const _Ty & _Val, _Pr _Pred ) {

    const _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( _Count <= 0 ) {
        return _First;
    }

    if ( static_cast < uintmax_t > ( _Count ) > static_cast < uintmax_t > ( ( numeric_limits < _Iter_diff_t < _FwdIt >> :: max ) ( ) ) ) {

        return _Last;
    }

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    if constexpr ( _Is_random_iter_v < _FwdIt > ) {
        const auto _Count_diff = static_cast < _Iter_diff_t < _FwdIt >> ( _Count );
        auto _UOld_first = _UFirst;
        for ( _Iter_diff_t < _FwdIt > _Inc = 0; _Count_diff <= _ULast - _UOld_first; ) {
            _UFirst = _UOld_first + _Inc;
            if ( _Pred ( * _UFirst, _Val ) ) {
                _Iter_diff_t < _FwdIt > _Count1 = _Count_diff;
                auto _UMid = _UFirst;

                while ( _UOld_first != _UFirst && _Pred ( * _Prev_iter ( _UFirst ), _Val ) ) {
                    -- _Count1;
                    -- _UFirst;
                }

                if ( _Count1 <= _ULast - _UMid ) {
                    for (;; ) {
                        if ( -- _Count1 == 0 ) {
                            _Seek_wrapped ( _Last, _UFirst );
                            return _Last;
                        } else if ( ! _Pred ( * ++ _UMid, _Val ) ) {
                            break;
                        }
                    }
                }
                _UOld_first = ++ _UMid;
                _Inc = 0;
            } else {
                _UOld_first = _Next_iter ( _UFirst );
                _Inc = _Count_diff - 1;
            }
        }
    } else {
        for (; _UFirst != _ULast; ++ _UFirst ) {
            if ( _Pred ( * _UFirst, _Val ) ) {
                auto _UMid = _UFirst;

                for ( _Algorithm_int_t < _Diff > _Count1 = _Count;; ) {
                    if ( -- _Count1 == 0 ) {
                        _Seek_wrapped ( _Last, _UFirst );
                        return _Last;
                    } else if ( ++ _UMid == _ULast ) {
                        return _Last;
                    } else if ( ! _Pred ( * _UMid, _Val ) ) {
                        break;
                    }
                }

                _UFirst = _UMid;
            }
        }
    }

    return _Last;
}
#line 2017 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Diff, class _Ty >
[ [ nodiscard ] ] inline _FwdIt search_n ( const _FwdIt _First, const _FwdIt _Last, const _Diff _Count, const _Ty & _Val ) {

    return :: std :: search_n ( _First, _Last, _Count, _Val, equal_to < > { } );
}
#line 2194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt1, class _FwdIt2, class _Pr >
[ [ nodiscard ] ] inline _FwdIt1 find_end (
    _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    const auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    if constexpr ( _Is_random_iter_v < _FwdIt1 > && _Is_random_iter_v < _FwdIt2 > ) {
        const _Iter_diff_t < _FwdIt2 > _Count2 = _ULast2 - _UFirst2;
        if ( _Count2 > 0 && _Count2 <= _ULast1 - _UFirst1 ) {
            for ( auto _UCandidate = _ULast1 - static_cast < _Iter_diff_t < _FwdIt1 >> ( _Count2 );; -- _UCandidate ) {
                if ( _Equal_rev_pred_unchecked ( _UCandidate, _UFirst2, _ULast2, _Pass_fn ( _Pred ) ) ) {
                    _Seek_wrapped ( _First1, _UCandidate );
                    return _First1;
                }

                if ( _UCandidate == _UFirst1 ) {
                    break;
                }
            }
        }

        return _Last1;
    } else if constexpr ( _Is_bidi_iter_v < _FwdIt1 > && _Is_bidi_iter_v < _FwdIt2 > ) {
        for ( auto _UCandidate = _ULast1;; -- _UCandidate ) {
            auto _UNext1 = _UCandidate;
            auto _UNext2 = _ULast2;
            for (;; ) {
                if ( _UFirst2 == _UNext2 ) {
                    _Seek_wrapped ( _First1, _UNext1 );
                    return _First1;
                }

                if ( _UFirst1 == _UNext1 ) {

                    return _Last1;
                }

                -- _UNext1;
                -- _UNext2;
                if ( ! _Pred ( * _UNext1, * _UNext2 ) ) {
                    break;
                }
            }
        }
    } else {
        auto _UResult = _ULast1;
        for (;; ) {
            auto _UNext1 = _UFirst1;
            auto _UNext2 = _UFirst2;
            for (;; ) {
                const bool _End_of_needle = static_cast < bool > ( _UNext2 == _ULast2 );
                if ( _End_of_needle ) {
                    _UResult = _UFirst1;
                }

                if ( _UNext1 == _ULast1 ) {

                    _Seek_wrapped ( _First1, _UResult );
                    return _First1;
                }

                if ( _End_of_needle || ! _Pred ( * _UNext1, * _UNext2 ) ) {
                    break;
                }

                ++ _UNext1;
                ++ _UNext2;
            }

            ++ _UFirst1;
        }

        _Seek_wrapped ( _First1, _UResult );
        return _First1;
    }
}
#line 2275
template < class _FwdIt1, class _FwdIt2 >
[ [ nodiscard ] ] inline _FwdIt1 find_end (
    _FwdIt1 const _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2 ) {

    return :: std :: find_end ( _First1, _Last1, _First2, _Last2, equal_to < > { } );
}
#line 2459 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt1, class _FwdIt2, class _Pr >
[ [ nodiscard ] ] inline _FwdIt1 find_first_of (
    _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    const auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    for (; _UFirst1 != _ULast1; ++ _UFirst1 ) {
        for ( auto _UMid2 = _UFirst2; _UMid2 != _ULast2; ++ _UMid2 ) {
            if ( _Pred ( * _UFirst1, * _UMid2 ) ) {
                _Seek_wrapped ( _First1, _UFirst1 );
                return _First1;
            }
        }
    }

    _Seek_wrapped ( _First1, _UFirst1 );
    return _First1;
}
#line 2482
template < class _FwdIt1, class _FwdIt2 >
[ [ nodiscard ] ] inline _FwdIt1 find_first_of ( const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2 ) {
    return :: std :: find_first_of ( _First1, _Last1, _First2, _Last2, equal_to < > { } );
}
#line 2622 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt1, class _FwdIt2 >
inline _FwdIt2 swap_ranges ( const _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2 ) {

    _Adl_verify_range ( _First1, _Last1 );
    const auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    const auto _UFirst2 = _Get_unwrapped_n ( _First2, _Idl_distance < _FwdIt1 > ( _UFirst1, _ULast1 ) );
    _Seek_wrapped ( _First2, _Swap_ranges_unchecked ( _UFirst1, _ULast1, _UFirst2 ) );
    return _First2;
}
#line 2642 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _OutIt, class _Fn >
inline _OutIt transform ( const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    for (; _UFirst != _ULast; ++ _UFirst, ( void ) ++ _UDest ) {
        * _UDest = _Func ( * _UFirst );
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 2663 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2, class _OutIt, class _Fn >
inline _OutIt transform (
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest, _Fn _Func ) {

    _Adl_verify_range ( _First1, _Last1 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    const auto _Count = _Idl_distance < _InIt1 > ( _UFirst1, _ULast1 );
    auto _UFirst2 = _Get_unwrapped_n ( _First2, _Count );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Count );
    for (; _UFirst1 != _ULast1; ++ _UFirst1, ( void ) ++ _UFirst2, ++ _UDest ) {
        * _UDest = _Func ( * _UFirst1, * _UFirst2 );
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 2798 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Ty >
inline void replace ( const _FwdIt _First, const _FwdIt _Last, const _Ty & _Oldval, const _Ty & _Newval ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( * _UFirst == _Oldval ) {
            * _UFirst = _Newval;
        }
    }
}
#line 2874 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Pr, class _Ty >
inline void replace_if ( const _FwdIt _First, const _FwdIt _Last, _Pr _Pred, const _Ty & _Val ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( _Pred ( * _UFirst ) ) {
            * _UFirst = _Val;
        }
    }
}
#line 2948 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _OutIt, class _Ty >
inline _OutIt replace_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, const _Ty & _Oldval, const _Ty & _Newval ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    for (; _UFirst != _ULast; ++ _UFirst, ( void ) ++ _UDest ) {
        if ( * _UFirst == _Oldval ) {
            * _UDest = _Newval;
        } else {
            * _UDest = * _UFirst;
        }
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 3043 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _OutIt, class _Pr, class _Ty >
inline _OutIt replace_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty & _Val ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
    for (; _UFirst != _ULast; ++ _UFirst, ( void ) ++ _UDest ) {
        if ( _Pred ( * _UFirst ) ) {
            * _UDest = _Val;
        } else {
            * _UDest = * _UFirst;
        }
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 3248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Fn >
inline void generate ( _FwdIt _First, _FwdIt _Last, _Fn _Func ) {
    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        * _UFirst = _Func ( );
    }
}
#line 3267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _OutIt, class _Diff, class _Fn >
inline _OutIt generate_n ( _OutIt _Dest, const _Diff _Count_raw, _Fn _Func ) {

    _Algorithm_int_t < _Diff > _Count = _Count_raw;
    if ( 0 < _Count ) {
        auto _UDest = _Get_unwrapped_n ( _Dest, _Count );
        do {
            * _UDest = _Func ( );
            -- _Count;
            ++ _UDest;
        } while ( 0 < _Count );

        _Seek_wrapped ( _Dest, _UDest );
    }

    return _Dest;
}
#line 3295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _OutIt, class _Ty >
inline _OutIt remove_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, const _Ty & _Val ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_unverified ( _Dest );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( ! ( * _UFirst == _Val ) ) {
            * _UDest = * _UFirst;
            ++ _UDest;
        }
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 3324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _OutIt, class _Pr >
inline _OutIt remove_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_unverified ( _Dest );
    for (; _UFirst != _ULast; ++ _UFirst ) {
        if ( ! _Pred ( * _UFirst ) ) {
            * _UDest = * _UFirst;
            ++ _UDest;
        }
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 3592 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] inline _FwdIt unique ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    if ( _UFirst != _ULast ) {
        for ( auto _UFirstb = _UFirst; ++ _UFirst != _ULast; _UFirstb = _UFirst ) {
            if ( _Pred ( * _UFirstb, * _UFirst ) ) {
                while ( ++ _UFirst != _ULast ) {
                    if ( ! _Pred ( * _UFirstb, * _UFirst ) ) {
                        * ++ _UFirstb = :: std :: move ( * _UFirst );
                    }
                }

                _Seek_wrapped ( _Last, ++ _UFirstb );
                return _Last;
            }
        }
    }

    _Seek_wrapped ( _Last, _ULast );
    return _Last;
}
#line 3617
template < class _FwdIt >
[ [ nodiscard ] ] inline _FwdIt unique ( _FwdIt _First, _FwdIt _Last ) {
    return :: std :: unique ( _First, _Last, equal_to < > { } );
}
#line 3709 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template< class _InIt, class _OutIt> constexpr bool 
#line 3710
_Can_reread_dest = _Is_fwd_iter_v< _OutIt>  && is_same_v< _Iter_value_t< _InIt> , _Iter_value_t< _OutIt> > ; 
#line 3715 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _OutIt, class _Pr >
inline _OutIt unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );

    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );

    if ( _UFirst == _ULast ) {
        return _Dest;
    }

    auto _UDest = _Get_unwrapped_unverified ( _Dest );

    if constexpr ( _Is_fwd_iter_v < _InIt > ) {
        auto _Firstb = _UFirst;

        * _UDest = * _Firstb;
        ++ _UDest;

        while ( ++ _UFirst != _ULast ) {
            if ( ! static_cast < bool > ( _Pred ( * _Firstb, * _UFirst ) ) ) {
                _Firstb = _UFirst;
                * _UDest = * _Firstb;
                ++ _UDest;
            }
        }
    } else if constexpr ( _Can_reread_dest < _InIt, _OutIt > ) {
        * _UDest = * _UFirst;

        while ( ++ _UFirst != _ULast ) {
            if ( ! static_cast < bool > ( _Pred ( * _UDest, * _UFirst ) ) ) {
                * ++ _UDest = * _UFirst;
            }
        }

        ++ _UDest;
    } else {
        _Iter_value_t < _InIt > _Val = * _UFirst;

        * _UDest = _Val;
        ++ _UDest;

        while ( ++ _UFirst != _ULast ) {
            if ( ! static_cast < bool > ( _Pred ( _Val, * _UFirst ) ) ) {
                _Val = * _UFirst;
                * _UDest = _Val;
                ++ _UDest;
            }
        }
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 3771
template < class _InIt, class _OutIt >
inline _OutIt unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest ) {
    return :: std :: unique_copy ( _First, _Last, _Dest, equal_to < > { } );
}
#line 3972 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _BidIt, class _OutIt >
inline _OutIt reverse_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest ) {

    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _BidIt > ( _UFirst, _ULast ) );


    using _Elem = remove_reference_t < _Iter_ref_t < remove_const_t < decltype ( _UFirst ) >> >;
    using _DestElem = remove_reference_t < _Iter_ref_t < decltype ( _UDest ) >>;
    constexpr bool _Allow_vectorization = conjunction_v < is_same < remove_const_t < _Elem >, _DestElem >,
        bool_constant < _Iterators_are_contiguous < decltype ( _UFirst ), decltype ( _UDest ) >>, is_trivially_copyable < _Elem >,
        negation < is_volatile < _Elem >> >;
    constexpr size_t _Nx = sizeof ( _Elem );

#pragma warning(suppress : 6326)
    if constexpr ( _Allow_vectorization && _Nx <= 8 && ( _Nx & ( _Nx - 1 ) ) == 0 ) {



        {
            if constexpr ( _Nx == 1 ) {
                __std_reverse_copy_trivially_copyable_1 ( _To_address ( _UFirst ), _To_address ( _ULast ), _To_address ( _UDest ) );
            } else if constexpr ( _Nx == 2 ) {
                __std_reverse_copy_trivially_copyable_2 ( _To_address ( _UFirst ), _To_address ( _ULast ), _To_address ( _UDest ) );
            } else if constexpr ( _Nx == 4 ) {
                __std_reverse_copy_trivially_copyable_4 ( _To_address ( _UFirst ), _To_address ( _ULast ), _To_address ( _UDest ) );
            } else {
                __std_reverse_copy_trivially_copyable_8 ( _To_address ( _UFirst ), _To_address ( _ULast ), _To_address ( _UDest ) );
            }

            _UDest += _ULast - _UFirst;
            _Seek_wrapped ( _Dest, _UDest );
            return _Dest;
        }
    }


    for (; _UFirst != _ULast; ++ _UDest ) {
        * _UDest = * -- _ULast;
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 4226 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _OutIt >
inline _OutIt rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest ) {

    _Adl_verify_range ( _First, _Mid );
    _Adl_verify_range ( _Mid, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _UMid = _Get_unwrapped ( _Mid );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _FwdIt > ( _UFirst, _ULast ) );
    _UDest = _Copy_unchecked ( _UMid, _ULast, _UDest );
    _Seek_wrapped ( _Dest, _Copy_unchecked ( _UFirst, _UMid, _UDest ) );
    return _Dest;
}
#line 4507 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _RanIt, class _RngFn >
void _Random_shuffle1 ( _RanIt _First, _RanIt _Last, _RngFn & _RngFunc ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    if ( _UFirst == _ULast ) {
        return;
    }

    using _Diff = _Iter_diff_t < _RanIt >;
    auto _UTarget = _UFirst;
    _Diff _Target_index = 1;
    for (; ++ _UTarget != _ULast; ++ _Target_index ) {
        _Diff _Off = _RngFunc ( static_cast < _Diff > ( _Target_index + 1 ) );
        ;
        if ( _Off != _Target_index ) {
            :: std :: iter_swap ( _UTarget, _UFirst + _Off );
        }
    }
}
#line 4529
template < class _RanIt, class _Urng >
void shuffle ( _RanIt _First, _RanIt _Last, _Urng && _Func ) {
    using _Urng0 = remove_reference_t < _Urng >;
    _Rng_from_urng < _Iter_diff_t < _RanIt >, _Urng0 > _RngFunc ( _Func );
    _Random_shuffle1 ( _First, _Last, _RngFunc );
}
#line 4596
template < class _RanIt, class _RngFn >
void random_shuffle ( _RanIt _First, _RanIt _Last, _RngFn && _RngFunc ) {

    _Random_shuffle1 ( _First, _Last, _RngFunc );
}
#line 4602
struct _Rand_urng_from_func { 
#line 4603
using result_type = unsigned; 
#line 4605
static result_type min() { 
#line 4606
return 0; 
#line 4607
} 
#line 4609
static result_type max() { 
#line 4610
return 32767; 
#line 4611
} 
#line 4613
result_type operator()() { 
#line 4614
return static_cast< result_type>(::rand()); 
#line 4615
} 
#line 4616
}; 
#line 4618
template < class _RanIt >
void random_shuffle ( _RanIt _First, _RanIt _Last ) {
    _Rand_urng_from_func _Func;
    :: std :: shuffle ( _First, _Last, _Func );
}
#line 4745 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Pr >
inline _FwdIt partition ( _FwdIt _First, const _FwdIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    auto _ULast = _Get_unwrapped ( _Last );
    if constexpr ( _Is_bidi_iter_v < _FwdIt > ) {
        for (;; ) {
            for (;; ) {
                if ( _UFirst == _ULast ) {
                    _Seek_wrapped ( _First, _UFirst );
                    return _First;
                }

                if ( ! _Pred ( * _UFirst ) ) {
                    break;
                }

                ++ _UFirst;
            }

            do {
                -- _ULast;
                if ( _UFirst == _ULast ) {
                    _Seek_wrapped ( _First, _UFirst );
                    return _First;
                }
            } while ( ! _Pred ( * _ULast ) );

            :: std :: iter_swap ( _UFirst, _ULast );
            ++ _UFirst;
        }
    } else {
        for (;; ) {
            if ( _UFirst == _ULast ) {
                _Seek_wrapped ( _First, _UFirst );
                return _First;
            }

            if ( ! _Pred ( * _UFirst ) ) {
                break;
            }

            ++ _UFirst;
        }

        for ( auto _UNext = _UFirst; ++ _UNext != _ULast; ) {
            if ( _Pred ( * _UNext ) ) {
                :: std :: iter_swap ( _UFirst, _UNext );
                ++ _UFirst;
            }
        }
    }

    _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 4891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _BidIt >
_BidIt _Buffered_rotate_unchecked ( const _BidIt _First, const _BidIt _Mid, const _BidIt _Last,
    const _Iter_diff_t < _BidIt > _Count1, const _Iter_diff_t < _BidIt > _Count2, _Iter_value_t < _BidIt > * const _Temp_ptr,
    const ptrdiff_t _Capacity ) {


    if ( _Count1 == 0 ) {
        return _Last;
    }

    if ( _Count2 == 0 ) {
        return _First;
    }

    if ( _Count1 <= _Count2 && _Count1 <= _Capacity ) {
        _Uninitialized_backout < _Iter_value_t < _BidIt > * > _Backout {
            _Temp_ptr, _Uninitialized_move_unchecked ( _First, _Mid, _Temp_ptr ) };
        const _BidIt _New_mid = _Move_unchecked ( _Mid, _Last, _First );
        _Move_unchecked ( _Backout . _First, _Backout . _Last, _New_mid );
        return _New_mid;
    }

    if ( _Count2 <= _Capacity ) {
        _Uninitialized_backout < _Iter_value_t < _BidIt > * > _Backout {
            _Temp_ptr, _Uninitialized_move_unchecked ( _Mid, _Last, _Temp_ptr ) };
        _Move_backward_unchecked ( _First, _Mid, _Last );
        return _Move_unchecked ( _Backout . _First, _Backout . _Last, _First );
    }


    return :: std :: rotate ( _First, _Mid, _Last );
}
#line 4924
template < class _BidIt, class _Pr >
pair < _BidIt, _Iter_diff_t < _BidIt > > _Stable_partition_unchecked1 ( _BidIt _First, _BidIt _Last, _Pr _Pred,
    const _Iter_diff_t < _BidIt > _Count, _Iter_value_t < _BidIt > * const _Temp_ptr, const ptrdiff_t _Capacity ) {






    using _Diff = _Iter_diff_t < _BidIt >;
    if ( _Count - static_cast < _Diff > ( 1 ) <= _Capacity ) {
        _Uninitialized_backout < _Iter_value_t < _BidIt > * > _Backout { _Temp_ptr };
        _BidIt _Next = _First;
        _Backout . _Emplace_back ( :: std :: move ( * _First ) );
        while ( ++ _First != _Last ) {

            if ( _Pred ( * _First ) ) {
                * _Next = :: std :: move ( * _First );
                ++ _Next;
            } else {
                _Backout . _Emplace_back ( :: std :: move ( * _First ) );
            }
        }


        * _Next = :: std :: move ( * _Last );
        ++ _Next;
        _Move_unchecked ( _Backout . _First, _Backout . _Last, _Next );
        _Diff _True_distance = static_cast < _Diff > ( _Count - static_cast < _Diff > ( _Backout . _Last - _Backout . _First ) );
        return pair < _BidIt, _Diff > ( _Next, _True_distance );
    }

    const _Diff _Mid_offset = _Count / static_cast < _Diff > ( 2 );
    const _BidIt _Mid = :: std :: next ( _First, _Mid_offset );


    _BidIt _Left = _Mid;
    _Diff _Left_true_count = _Mid_offset;
    for (;; ) {
        -- _Left;
        if ( _First == _Left ) {
            -- _Left_true_count;
            break;
        }

        if ( _Pred ( * _Left ) ) {
            const pair < _BidIt, _Diff > _Low =
                _Stable_partition_unchecked1 ( _First, _Left, _Pred, _Left_true_count, _Temp_ptr, _Capacity );
            _Left = _Low . first;
            _Left_true_count = _Low . second;
            break;
        }

        -- _Left_true_count;
    }


    _BidIt _Right = _Mid;
    _Diff _Right_true_count = 0;
    for (;; ) {
        if ( _Right == _Last ) {
            ++ _Right;
            ++ _Right_true_count;
            break;
        }

        if ( ! _Pred ( * _Right ) ) {
            const _Diff _Right_count = _Count - _Mid_offset;
            const _Diff _Remaining = _Right_count - _Right_true_count;
            const pair < _BidIt, _Diff > _High =
                _Stable_partition_unchecked1 ( _Right, _Last, _Pred, _Remaining, _Temp_ptr, _Capacity );
            _Right = _High . first;
            _Right_true_count += _High . second;
            break;
        }

        ++ _Right;
        ++ _Right_true_count;
    }


    const _BidIt _Partition_point = _Buffered_rotate_unchecked ( _Left, _Mid, _Right,
        static_cast < _Diff > ( _Mid_offset - _Left_true_count ), _Right_true_count, _Temp_ptr, _Capacity );
    return pair < _BidIt, _Diff > ( _Partition_point, static_cast < _Diff > ( _Left_true_count + _Right_true_count ) );
}
#line 5010
template < class _BidIt, class _Pr >
_BidIt _Stable_partition_unchecked ( _BidIt _First, _BidIt _Last, _Pr _Pred ) {

    for (;; ) {
        if ( _First == _Last ) {
            return _First;
        }

        if ( ! _Pred ( * _First ) ) {
            break;
        }

        ++ _First;
    }

    for (;; ) {
        -- _Last;
        if ( _First == _Last ) {
            return _First;
        }

        if ( _Pred ( * _Last ) ) {
            break;
        }
    }

    using _Diff = _Iter_diff_t < _BidIt >;
    const _Diff _Temp_count = :: std :: distance ( _First, _Last );
    const _Diff _Total_count = _Temp_count + static_cast < _Diff > ( 1 );
    _Optimistic_temporary_buffer < _Iter_value_t < _BidIt >> _Temp_buf { _Temp_count };
    return _Stable_partition_unchecked1 ( _First, _Last, _Pred, _Total_count, _Temp_buf . _Data, _Temp_buf . _Capacity ) . first;
}
#line 5043
template < class _BidIt, class _Pr >
_BidIt stable_partition ( _BidIt _First, _BidIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    _Seek_wrapped ( _First, _Stable_partition_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Pass_fn ( _Pred ) ) );
    return _First;
}
#line 5262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _RanIt, class _Ty, class _Pr >
inline void _Push_heap_by_index (
    _RanIt _First, _Iter_diff_t < _RanIt > _Hole, _Iter_diff_t < _RanIt > _Top, _Ty && _Val, _Pr _Pred ) {

    using _Diff = _Iter_diff_t < _RanIt >;
    for ( _Diff _Idx = ( _Hole - 1 ) >> 1;
         _Top < _Hole && static_cast < bool > ( _Pred ( * ( _First + _Idx ), _Val ) );
         _Idx = ( _Hole - 1 ) >> 1 ) {

        * ( _First + _Hole ) = :: std :: move ( * ( _First + _Idx ) );
        _Hole = _Idx;
    }

    * ( _First + _Hole ) = :: std :: forward < _Ty > ( _Val );
}
#line 5278
template < class _RanIt, class _Pr >
inline void push_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    auto _ULast = _Get_unwrapped ( _Last );
    using _Diff = _Iter_diff_t < _RanIt >;
    _Diff _Count = _ULast - _UFirst;
    if ( 2 <= _Count ) {
        _Iter_value_t < _RanIt > _Val = :: std :: move ( * -- _ULast );
        _Push_heap_by_index ( _UFirst, -- _Count, _Diff ( 0 ), :: std :: move ( _Val ), _Pass_fn ( _Pred ) );
    }
}
#line 5292
template < class _RanIt >
inline void push_heap ( _RanIt _First, _RanIt _Last ) {

    :: std :: push_heap ( _First, _Last, less < > { } );
}
#line 5373
template < class _RanIt, class _Ty, class _Pr >
inline void _Pop_heap_hole_by_index (
    _RanIt _First, _Iter_diff_t < _RanIt > _Hole, _Iter_diff_t < _RanIt > _Bottom, _Ty && _Val, _Pr _Pred ) {

    ;

    using _Diff = _Iter_diff_t < _RanIt >;
    const _Diff _Top = _Hole;
    _Diff _Idx = _Hole;



    const _Diff _Max_sequence_non_leaf = ( _Bottom - 1 ) >> 1;
    while ( _Idx < _Max_sequence_non_leaf ) {
        _Idx = 2 * _Idx + 2;
        if ( static_cast < bool > ( _Pred ( * ( _First + _Idx ), * ( _First + ( _Idx - 1 ) ) ) ) ) {
            -- _Idx;
        }
        * ( _First + _Hole ) = :: std :: move ( * ( _First + _Idx ) );
        _Hole = _Idx;
    }

    if ( _Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0 ) {
        * ( _First + _Hole ) = :: std :: move ( * ( _First + ( _Bottom - 1 ) ) );
        _Hole = _Bottom - 1;
    }

    _Push_heap_by_index ( _First, _Hole, _Top, :: std :: forward < _Ty > ( _Val ), _Pred );
}
#line 5403
template < class _RanIt, class _Ty, class _Pr >
inline void _Pop_heap_hole_unchecked ( _RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty && _Val, _Pr _Pred ) {



    * _Dest = :: std :: move ( * _First );
    using _Diff = _Iter_diff_t < _RanIt >;
    _Pop_heap_hole_by_index (
        _First, static_cast < _Diff > ( 0 ), static_cast < _Diff > ( _Last - _First ), :: std :: forward < _Ty > ( _Val ), _Pred );
}
#line 5414
template < class _RanIt, class _Pr >
inline void _Pop_heap_unchecked ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    if ( 2 <= _Last - _First ) {
        -- _Last;
        _Iter_value_t < _RanIt > _Val = :: std :: move ( * _Last );
        _Pop_heap_hole_unchecked ( _First, _Last, _Last, :: std :: move ( _Val ), _Pred );
    }
}
#line 5424
template < class _RanIt, class _Pr >
inline void pop_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    _Pop_heap_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Pass_fn ( _Pred ) );
}
#line 5431
template < class _RanIt >
inline void pop_heap ( _RanIt _First, _RanIt _Last ) {

    :: std :: pop_heap ( _First, _Last, less < > { } );
}
#line 5543
template < class _RanIt, class _Pr >
inline void _Make_heap_unchecked ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    using _Diff = _Iter_diff_t < _RanIt >;
    _Diff _Bottom = _Last - _First;
    for ( _Diff _Hole = _Bottom >> 1; _Hole > 0; ) {

        -- _Hole;
        _Iter_value_t < _RanIt > _Val = :: std :: move ( * ( _First + _Hole ) );
        _Pop_heap_hole_by_index ( _First, _Hole, _Bottom, :: std :: move ( _Val ), _Pred );
    }
}
#line 5556
template < class _RanIt, class _Pr >
inline void make_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {
    _Adl_verify_range ( _First, _Last );
    _Make_heap_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Pass_fn ( _Pred ) );
}
#line 5562
template < class _RanIt >
inline void make_heap ( _RanIt _First, _RanIt _Last ) {
    :: std :: make_heap ( _First, _Last, less < > { } );
}
#line 5623
template < class _RanIt, class _Pr >
inline _RanIt _Is_heap_until_unchecked ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    using _Diff = _Iter_diff_t < _RanIt >;
    const _Diff _Size = _Last - _First;
    for ( _Diff _Off = 1; _Off < _Size; ++ _Off ) {
        if ( static_cast < bool > ( _Pred ( * ( _First + ( ( _Off - 1 ) >> 1 ) ), * ( _First + _Off ) ) ) ) {
            return _First + _Off;
        }
    }

    return _Last;
}
#line 5637
template < class _RanIt, class _Pr >
[ [ nodiscard ] ] inline _RanIt is_heap_until ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    _Seek_wrapped ( _First, _Is_heap_until_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Pass_fn ( _Pred ) ) );
    return _First;
}
#line 5645
template < class _RanIt, class _Pr >
[ [ nodiscard ] ] inline bool is_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    return _Is_heap_until_unchecked ( _UFirst, _ULast, _Pass_fn ( _Pred ) ) == _ULast;
}
#line 5654
template < class _RanIt >
[ [ nodiscard ] ] inline _RanIt is_heap_until ( _RanIt _First, _RanIt _Last ) {

    return :: std :: is_heap_until ( _First, _Last, less < > { } );
}
#line 5660
template < class _RanIt >
[ [ nodiscard ] ] inline bool is_heap ( _RanIt _First, _RanIt _Last ) {
    return :: std :: is_heap ( _First, _Last, less < > { } );
}
#line 5771 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _RanIt, class _Pr >
inline void _Sort_heap_unchecked ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    for (; _Last - _First >= 2; -- _Last ) {
        _Pop_heap_unchecked ( _First, _Last, _Pred );
    }
}
#line 5779
template < class _RanIt, class _Pr >
inline void sort_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {
    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );






    _Sort_heap_unchecked ( _UFirst, _ULast, _Pass_fn ( _Pred ) );
}
#line 5793 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _RanIt >
inline void sort_heap ( _RanIt _First, _RanIt _Last ) {
    :: std :: sort_heap ( _First, _Last, less < > { } );
}
#line 5903
template < class _FwdIt, class _Ty, class _Pr >
[ [ nodiscard ] ] inline _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _UFirst, _Get_unwrapped ( _Last ) );

    while ( 0 < _Count ) {
        _Iter_diff_t < _FwdIt > _Count2 = _Count / 2;
        const auto _UMid = :: std :: next ( _UFirst, _Count2 );
        if ( _Pred ( _Val, * _UMid ) ) {
            _Count = _Count2;
        } else {
            _UFirst = _Next_iter ( _UMid );
            _Count -= _Count2 + 1;
        }
    }

    _Seek_wrapped ( _First, _UFirst );
    return _First;
}
#line 5925
template < class _FwdIt, class _Ty >
[ [ nodiscard ] ] inline _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val ) {

    return :: std :: upper_bound ( _First, _Last, _Val, less < > { } );
}
#line 5988
template < class _FwdIt, class _Ty, class _Pr >
[ [ nodiscard ] ] inline pair < _FwdIt, _FwdIt > equal_range ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );

    using _Diff = _Iter_diff_t < _FwdIt >;
    _Diff _Count = :: std :: distance ( _UFirst, _ULast );

    for (;; ) {
        if ( _Count <= 0 ) {
            _Seek_wrapped ( _Last, _UFirst );
            _Seek_wrapped ( _First, _UFirst );
            break;
        }

        _Diff _Count2 = _Count / 2;
        const auto _UMid = :: std :: next ( _UFirst, _Count2 );
        if ( static_cast < bool > ( _Pred ( * _UMid, _Val ) ) ) {
            _UFirst = _Next_iter ( _UMid );
            _Count -= _Count2 + 1;
        } else if ( _Pred ( _Val, * _UMid ) ) {
            _Count = _Count2;
        } else {
            auto _UFirst2 = :: std :: lower_bound ( _UFirst, _UMid, _Val, _Pass_fn ( _Pred ) );
            :: std :: advance ( _UFirst, _Count );
            auto _ULast2 = :: std :: upper_bound ( _Next_iter ( _UMid ), _UFirst, _Val, _Pass_fn ( _Pred ) );
            _Seek_wrapped ( _Last, _ULast2 );
            _Seek_wrapped ( _First, _UFirst2 );
            break;
        }
    }

    return { _First, _Last };
}
#line 6025
template < class _FwdIt, class _Ty >
[ [ nodiscard ] ] inline pair < _FwdIt, _FwdIt > equal_range ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val ) {

    return :: std :: equal_range ( _First, _Last, _Val, less < > { } );
}
#line 6094
template < class _FwdIt, class _Ty, class _Pr >
[ [ nodiscard ] ] inline bool binary_search ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    _UFirst = :: std :: lower_bound ( _UFirst, _ULast, _Val, _Pass_fn ( _Pred ) );
    return _UFirst != _ULast && ! _Pred ( _Val, * _UFirst );
}
#line 6104
template < class _FwdIt, class _Ty >
[ [ nodiscard ] ] inline bool binary_search ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val ) {

    return :: std :: binary_search ( _First, _Last, _Val, less < > { } );
}
#line 6143
[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Distance_unknown, _Distance_unknown) { 
#line 6144
return {}; 
#line 6145
} 
#line 6147
template < class _Diff1 >
[ [ nodiscard ] ] constexpr _Distance_unknown _Idl_dist_add ( _Diff1, _Distance_unknown ) {
    return { };
}
#line 6152
template < class _Diff2 >
[ [ nodiscard ] ] constexpr _Distance_unknown _Idl_dist_add ( _Distance_unknown, _Diff2 ) {
    return { };
}
#line 6157
template < class _Diff1, class _Diff2 >
[ [ nodiscard ] ] constexpr auto _Idl_dist_add ( _Diff1 _Lhs, _Diff2 _Rhs ) {
    return _Lhs + _Rhs;
}
#line 6162
template < class _InIt1, class _InIt2, class _OutIt, class _Pr >
inline _OutIt merge ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    ;
    ;
    const auto _Count1 = _Idl_distance < _InIt1 > ( _UFirst1, _ULast1 );
    const auto _Count2 = _Idl_distance < _InIt2 > ( _UFirst2, _ULast2 );
    auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_dist_add ( _Count1, _Count2 ) );
    if ( _UFirst1 != _ULast1 && _UFirst2 != _ULast2 ) {
        for (;; ) {
            if ( static_cast < bool > ( _Pred ( * _UFirst2, * _UFirst1 ) ) ) {
                * _UDest = * _UFirst2;
                ++ _UDest;
                ++ _UFirst2;

                if ( _UFirst2 == _ULast2 ) {
                    break;
                }
            } else {
                * _UDest = * _UFirst1;
                ++ _UDest;
                ++ _UFirst1;

                if ( _UFirst1 == _ULast1 ) {
                    break;
                }
            }
        }
    }

    _UDest = _Copy_unchecked ( _UFirst1, _ULast1, _UDest );
    _Seek_wrapped ( _Dest, _Copy_unchecked ( _UFirst2, _ULast2, _UDest ) );
    return _Dest;
}
#line 6203
template < class _InIt1, class _InIt2, class _OutIt >
inline _OutIt merge ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest ) {

    return :: std :: merge ( _First1, _Last1, _First2, _Last2, _Dest, less < > { } );
}
#line 6323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _BidIt >
void _Rotate_one_right ( _BidIt _First, _BidIt _Mid, _BidIt _Last ) {


    _Iter_value_t < _BidIt > _Temp ( :: std :: move ( * _Mid ) );
    _Move_backward_unchecked ( _First, _Mid, _Last );
    * _First = :: std :: move ( _Temp );
}
#line 6332
template < class _BidIt >
void _Rotate_one_left ( _BidIt _First, _BidIt _Mid, _BidIt _Last ) {


    _Iter_value_t < _BidIt > _Temp ( :: std :: move ( * _First ) );
    * _Move_unchecked ( _Mid, _Last, _First ) = :: std :: move ( _Temp );
}
#line 6340
template < class _BidIt, class _Pr >
void _Inplace_merge_buffer_left (
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t < _BidIt > * const _Temp_ptr, _Pr _Pred ) {


    using _Ptr_ty = _Iter_value_t < _BidIt > *;
    _Uninitialized_backout < _Ptr_ty > _Backout { _Temp_ptr, _Uninitialized_move_unchecked ( _First, _Mid, _Temp_ptr ) };
    _Ptr_ty _Left_first = _Temp_ptr;
    const _Ptr_ty _Left_last = _Backout . _Last - 1;
    * _First = :: std :: move ( * _Mid );
    ++ _First;
    ++ _Mid;
    for (;; ) {
        if ( _Pred ( * _Mid, * _Left_first ) ) {
            * _First = :: std :: move ( * _Mid );
            ++ _First;
            ++ _Mid;
            if ( _Mid == _Last ) {
                _Move_unchecked ( _Left_first, _Backout . _Last, _First );
                return;
            }
        } else {
            * _First = :: std :: move ( * _Left_first );
            ++ _First;
            ++ _Left_first;
            if ( _Left_first == _Left_last ) {

                * _Move_unchecked ( _Mid, _Last, _First ) = :: std :: move ( * _Left_last );
                return;
            }
        }
    }
}
#line 6374
template < class _BidIt, class _Pr >
void _Inplace_merge_buffer_right (
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t < _BidIt > * const _Temp_ptr, _Pr _Pred ) {


    using _Ptr_ty = _Iter_value_t < _BidIt > *;
    _Uninitialized_backout < _Ptr_ty > _Backout { _Temp_ptr, _Uninitialized_move_unchecked ( _Mid, _Last, _Temp_ptr ) };
    * -- _Last = :: std :: move ( * -- _Mid );
    const _Ptr_ty _Right_first = _Temp_ptr;
    _Ptr_ty _Right_last = _Backout . _Last - 1;
    -- _Mid;
    for (;; ) {
        if ( _Pred ( * _Right_last, * _Mid ) ) {
            * -- _Last = :: std :: move ( * _Mid );
            if ( _First == _Mid ) {
                * -- _Last = :: std :: move ( * _Right_last );
                _Move_backward_unchecked ( _Right_first, _Right_last, _Last );
                return;
            }

            -- _Mid;
        } else {
            * -- _Last = :: std :: move ( * _Right_last );
            -- _Right_last;
            if ( _Right_first == _Right_last ) {
                * -- _Last = :: std :: move ( * _Mid );
                _Move_backward_unchecked ( _First, _Mid, _Last );
                * _First = :: std :: move ( * _Right_first );
                return;
            }
        }
    }
}
#line 6408
template < class _BidIt, class _Pr >
void _Buffered_inplace_merge_unchecked ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t < _BidIt > _Count1,
    _Iter_diff_t < _BidIt > _Count2, _Iter_value_t < _BidIt > * const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred );
#line 6412
template < class _BidIt, class _Pr >
void _Buffered_inplace_merge_divide_and_conquer2 ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t < _BidIt > _Count1,
    _Iter_diff_t < _BidIt > _Count2, _Iter_value_t < _BidIt > * const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred,
    _BidIt _Firstn, _BidIt _Lastn, _Iter_diff_t < _BidIt > _Count1n, _Iter_diff_t < _BidIt > _Count2n ) {

    using _Diff = _Iter_diff_t < _BidIt >;
    _BidIt _Midn = _Buffered_rotate_unchecked ( _Firstn, _Mid, _Lastn, static_cast < _Diff > ( _Count1 - _Count1n ), _Count2n,
        _Temp_ptr, _Capacity );
    _Buffered_inplace_merge_unchecked (
        _First, _Firstn, _Midn, _Count1n, _Count2n, _Temp_ptr, _Capacity, _Pred );
    _Buffered_inplace_merge_unchecked ( _Midn, _Lastn, _Last, static_cast < _Diff > ( _Count1 - _Count1n ),
        static_cast < _Diff > ( _Count2 - _Count2n ), _Temp_ptr, _Capacity, _Pred );
}
#line 6426
template < class _BidIt, class _Pr >
void _Buffered_inplace_merge_divide_and_conquer ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t < _BidIt > _Count1,
    _Iter_diff_t < _BidIt > _Count2, _Iter_value_t < _BidIt > * const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred ) {


    using _Diff = _Iter_diff_t < _BidIt >;
    if ( _Count1 <= _Count2 ) {
        const _Diff _Count1n = _Count1 >> 1;
        const _BidIt _Firstn = :: std :: next ( _First, _Count1n );
        const _BidIt _Lastn = :: std :: lower_bound ( _Mid, _Last, * _Firstn, _Pred );
        _Buffered_inplace_merge_divide_and_conquer2 ( _First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred,
            _Firstn, _Lastn, _Count1n, :: std :: distance ( _Mid, _Lastn ) );
    } else {
        const _Diff _Count2n = _Count2 >> 1;
        const _BidIt _Lastn = :: std :: next ( _Mid, _Count2n );
        const _BidIt _Firstn = :: std :: upper_bound ( _First, _Mid, * _Lastn, _Pred );
        _Buffered_inplace_merge_divide_and_conquer2 ( _First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred,
            _Firstn, _Lastn, :: std :: distance ( _First, _Firstn ), _Count2n );
    }
}
#line 6447
template < class _BidIt, class _Pr >
void _Buffered_inplace_merge_unchecked_impl ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t < _BidIt > _Count1,
    _Iter_diff_t < _BidIt > _Count2, _Iter_value_t < _BidIt > * const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred ) {


    if ( _Count1 <= _Count2 && _Count1 <= _Capacity ) {
        _Inplace_merge_buffer_left ( _First, _Mid, _Last, _Temp_ptr, _Pred );
    } else if ( _Count2 <= _Capacity ) {
        _Inplace_merge_buffer_right ( _First, _Mid, _Last, _Temp_ptr, _Pred );
    } else {
        _Buffered_inplace_merge_divide_and_conquer ( _First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred );
    }
}
#line 6461
template < class _BidIt, class _Pr >
void _Buffered_inplace_merge_unchecked ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t < _BidIt > _Count1,
    _Iter_diff_t < _BidIt > _Count2, _Iter_value_t < _BidIt > * const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred ) {



    if ( _Mid == _Last ) {
        return;
    }

    for (;; ) {
        if ( _First == _Mid ) {
            return;
        }

        if ( _Pred ( * _Mid, * _First ) ) {
            break;
        }

        ++ _First;
        -- _Count1;
    }

    const auto _Highest = _Prev_iter ( _Mid );
    do {
        -- _Last;
        -- _Count2;
        if ( _Mid == _Last ) {
            _Rotate_one_right ( _First, _Mid, ++ _Last );
            return;
        }
    } while ( ! _Pred ( * _Last, * _Highest ) );

    ++ _Last;
    ++ _Count2;

    if ( _Count1 == 1 ) {
        _Rotate_one_left ( _First, _Mid, _Last );
        return;
    }

    _Buffered_inplace_merge_unchecked_impl ( _First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred );
}
#line 6505
template < class _BidIt, class _Pr >
void inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Mid );
    _Adl_verify_range ( _Mid, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    auto _UMid = _Get_unwrapped ( _Mid );
    auto _ULast = _Get_unwrapped ( _Last );
    ;


    if ( _UMid == _ULast ) {
        return;
    }

    for (;; ) {
        if ( _UFirst == _UMid ) {
            return;
        }

        if ( _Pred ( * _UMid, * _UFirst ) ) {
            break;
        }

        ++ _UFirst;
    }

    const auto _Highest = _Prev_iter ( _UMid );
    do {
        -- _ULast;
        if ( _UMid == _ULast ) {
            _Rotate_one_right ( _UFirst, _UMid, ++ _ULast );
            return;
        }
    } while ( ! _Pred ( * _ULast, * _Highest ) );

    ++ _ULast;

    using _Diff = _Iter_diff_t < _BidIt >;
    const _Diff _Count1 = :: std :: distance ( _UFirst, _UMid );
    if ( _Count1 == 1 ) {
        _Rotate_one_left ( _UFirst, _UMid, _ULast );
        return;
    }

    const _Diff _Count2 = :: std :: distance ( _UMid, _ULast );
    _Optimistic_temporary_buffer < _Iter_value_t < _BidIt >> _Temp_buf { ( :: std :: min ) ( _Count1, _Count2 ) };
    _Buffered_inplace_merge_unchecked_impl (
        _UFirst, _UMid, _ULast, _Count1, _Count2, _Temp_buf . _Data, _Temp_buf . _Capacity, _Pass_fn ( _Pred ) );
}
#line 6556
template < class _BidIt >
void inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last ) {

    :: std :: inplace_merge ( _First, _Mid, _Last, less < > { } );
}
#line 6918 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _BidIt, class _Pr >
inline _BidIt _Insertion_sort_unchecked ( const _BidIt _First, const _BidIt _Last, _Pr _Pred ) {

    if ( _First != _Last ) {
        for ( _BidIt _Mid = _First; ++ _Mid != _Last; ) {
            _BidIt _Hole = _Mid;
            _Iter_value_t < _BidIt > _Val = :: std :: move ( * _Mid );

            if ( static_cast < bool > ( _Pred ( _Val, * _First ) ) ) {
                _Move_backward_unchecked ( _First, _Mid, ++ _Hole );
                * _First = :: std :: move ( _Val );
            } else {
                for ( _BidIt _Prev = _Hole; static_cast < bool > ( _Pred ( _Val, * -- _Prev ) ); _Hole = _Prev ) {
                    * _Hole = :: std :: move ( * _Prev );
                }

                * _Hole = :: std :: move ( _Val );
            }
        }
    }

    return _Last;
}
#line 6942
template < class _RanIt, class _Pr >
inline void _Med3_unchecked ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred ) {

    if ( static_cast < bool > ( _Pred ( * _Mid, * _First ) ) ) {
        :: std :: iter_swap ( _Mid, _First );
    }

    if ( static_cast < bool > ( _Pred ( * _Last, * _Mid ) ) ) {
        :: std :: iter_swap ( _Last, _Mid );

        if ( static_cast < bool > ( _Pred ( * _Mid, * _First ) ) ) {
            :: std :: iter_swap ( _Mid, _First );
        }
    }
}
#line 6958
template < class _RanIt, class _Pr >
inline void _Guess_median_unchecked ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred ) {

    using _Diff = _Iter_diff_t < _RanIt >;
    const _Diff _Count = _Last - _First;
    if ( 40 < _Count ) {
        const _Diff _Step = ( _Count + 1 ) >> 3;
        const _Diff _Two_step = _Step << 1;
        _Med3_unchecked ( _First, _First + _Step, _First + _Two_step, _Pred );
        _Med3_unchecked ( _Mid - _Step, _Mid, _Mid + _Step, _Pred );
        _Med3_unchecked ( _Last - _Two_step, _Last - _Step, _Last, _Pred );
        _Med3_unchecked ( _First + _Step, _Mid, _Last - _Step, _Pred );
    } else {
        _Med3_unchecked ( _First, _Mid, _Last, _Pred );
    }
}
#line 6975
template < class _RanIt, class _Pr >
inline pair < _RanIt, _RanIt > _Partition_by_median_guess_unchecked ( _RanIt _First, _RanIt _Last, _Pr _Pred ) {

    _RanIt _Mid = _First + ( ( _Last - _First ) >> 1 );
    _Guess_median_unchecked ( _First, _Mid, _Prev_iter ( _Last ), _Pred );
    _RanIt _Pfirst = _Mid;
    _RanIt _Plast = _Next_iter ( _Pfirst );

    while ( _First < _Pfirst && ! static_cast < bool > ( _Pred ( * _Prev_iter ( _Pfirst ), * _Pfirst ) )
           && ! _Pred ( * _Pfirst, * _Prev_iter ( _Pfirst ) ) ) {
        -- _Pfirst;
    }

    while ( _Plast < _Last && ! static_cast < bool > ( _Pred ( * _Plast, * _Pfirst ) ) && ! _Pred ( * _Pfirst, * _Plast ) ) {
        ++ _Plast;
    }

    _RanIt _Gfirst = _Plast;
    _RanIt _Glast = _Pfirst;

    for (;; ) {
        for (; _Gfirst < _Last; ++ _Gfirst ) {
            if ( static_cast < bool > ( _Pred ( * _Pfirst, * _Gfirst ) ) ) {
                continue;
            } else if ( _Pred ( * _Gfirst, * _Pfirst ) ) {
                break;
            } else if ( _Plast != _Gfirst ) {
                :: std :: iter_swap ( _Plast, _Gfirst );
                ++ _Plast;
            } else {
                ++ _Plast;
            }
        }

        for (; _First < _Glast; -- _Glast ) {
            if ( static_cast < bool > ( _Pred ( * _Prev_iter ( _Glast ), * _Pfirst ) ) ) {
                continue;
            } else if ( _Pred ( * _Pfirst, * _Prev_iter ( _Glast ) ) ) {
                break;
            } else if ( -- _Pfirst != _Prev_iter ( _Glast ) ) {
                :: std :: iter_swap ( _Pfirst, _Prev_iter ( _Glast ) );
            }
        }

        if ( _Glast == _First && _Gfirst == _Last ) {
            return pair < _RanIt, _RanIt > ( _Pfirst, _Plast );
        }

        if ( _Glast == _First ) {
            if ( _Plast != _Gfirst ) {
                :: std :: iter_swap ( _Pfirst, _Plast );
            }

            ++ _Plast;
            :: std :: iter_swap ( _Pfirst, _Gfirst );
            ++ _Pfirst;
            ++ _Gfirst;
        } else if ( _Gfirst == _Last ) {
            if ( -- _Glast != -- _Pfirst ) {
                :: std :: iter_swap ( _Glast, _Pfirst );
            }

            :: std :: iter_swap ( _Pfirst, -- _Plast );
        } else {
            :: std :: iter_swap ( _Gfirst, -- _Glast );
            ++ _Gfirst;
        }
    }
}
#line 7045
template < class _RanIt, class _Pr >
inline void _Sort_unchecked ( _RanIt _First, _RanIt _Last, _Iter_diff_t < _RanIt > _Ideal, _Pr _Pred ) {

    for (;; ) {
        if ( _Last - _First <= _ISORT_MAX ) {
            _Insertion_sort_unchecked ( _First, _Last, _Pred );
            return;
        }

        if ( _Ideal <= 0 ) {
            _Make_heap_unchecked ( _First, _Last, _Pred );
            _Sort_heap_unchecked ( _First, _Last, _Pred );
            return;
        }


        auto _Mid = _Partition_by_median_guess_unchecked ( _First, _Last, _Pred );

        _Ideal = ( _Ideal >> 1 ) + ( _Ideal >> 2 );

        if ( _Mid . first - _First < _Last - _Mid . second ) {
            _Sort_unchecked ( _First, _Mid . first, _Ideal, _Pred );
            _First = _Mid . second;
        } else {
            _Sort_unchecked ( _Mid . second, _Last, _Ideal, _Pred );
            _Last = _Mid . first;
        }
    }
}
#line 7075
template < class _RanIt, class _Pr >
inline void sort ( const _RanIt _First, const _RanIt _Last, _Pr _Pred ) {
    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    _Sort_unchecked ( _UFirst, _ULast, _ULast - _UFirst, _Pass_fn ( _Pred ) );
}
#line 7083
template < class _RanIt >
inline void sort ( const _RanIt _First, const _RanIt _Last ) {
    :: std :: sort ( _First, _Last, less < > { } );
}
#line 7328 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Ty, class _Pr >
_Ty * _Uninitialized_merge_move ( _FwdIt _First, const _FwdIt _Mid, const _FwdIt _Last, _Ty * const _Dest, _Pr _Pred ) {


    _Uninitialized_backout < _Ty * > _Backout { _Dest };
    _FwdIt _Next = _Mid;
    for (;; ) {
        if ( static_cast < bool > ( _Pred ( * _Next, * _First ) ) ) {
            _Backout . _Emplace_back ( :: std :: move ( * _Next ) );
            ++ _Next;

            if ( _Next == _Last ) {
                _Backout . _Last = _Uninitialized_move_unchecked ( _First, _Mid, _Backout . _Last );
                return _Backout . _Release ( );
            }
        } else {
            _Backout . _Emplace_back ( :: std :: move ( * _First ) );
            ++ _First;

            if ( _First == _Mid ) {
                _Backout . _Last = _Uninitialized_move_unchecked ( _Next, _Last, _Backout . _Last );
                return _Backout . _Release ( );
            }
        }
    }
}
#line 7355
template < class _InIt, class _OutIt, class _Pr >
_OutIt _Merge_move ( _InIt _First, const _InIt _Mid, const _InIt _Last, _OutIt _Dest, _Pr _Pred ) {


    _InIt _Next = _Mid;
    for (;; ) {
        if ( static_cast < bool > ( _Pred ( * _Next, * _First ) ) ) {
            * _Dest = :: std :: move ( * _Next );
            ++ _Dest;
            ++ _Next;

            if ( _Next == _Last ) {
                return _Move_unchecked ( _First, _Mid, _Dest );
            }
        } else {
            * _Dest = :: std :: move ( * _First );
            ++ _Dest;
            ++ _First;

            if ( _First == _Mid ) {
                return _Move_unchecked ( _Next, _Last, _Dest );
            }
        }
    }
}
#line 7381
template < class _BidIt, class _Ty, class _Pr >
void _Uninitialized_chunked_merge_unchecked2 (
    _BidIt _First, const _BidIt _Last, _Ty * _Dest, _Iter_diff_t < _BidIt > _Count, _Pr _Pred ) {



    _Uninitialized_backout < _Ty * > _Backout { _Dest };
    while ( _Count > _Isort_max < _BidIt > ) {
        _Count -= _Isort_max < _BidIt >;
        const _BidIt _Mid1 = :: std :: next ( _First, _Isort_max < _BidIt > );
        const auto _Chunk2 = ( :: std :: min ) ( _Isort_max < _BidIt >, _Count );
        _Count -= _Chunk2;
        const _BidIt _Mid2 = :: std :: next ( _Mid1, _Chunk2 );
        _Backout . _Last = _Uninitialized_merge_move ( _First, _Mid1, _Mid2, _Backout . _Last, _Pred );
        _First = _Mid2;
    }

    _Uninitialized_move_unchecked ( _First, _Last, _Backout . _Last );
    _Backout . _Release ( );
}
#line 7402
template < class _BidIt, class _OutIt, class _Pr >
void _Chunked_merge_unchecked ( _BidIt _First, const _BidIt _Last, _OutIt _Dest, const _Iter_diff_t < _BidIt > _Chunk,
    _Iter_diff_t < _BidIt > _Count, _Pr _Pred ) {



    while ( _Chunk < _Count ) {
        _Count -= _Chunk;
        const _BidIt _Mid1 = :: std :: next ( _First, _Chunk );
        const auto _Chunk2 = ( :: std :: min ) ( _Chunk, _Count );
        _Count -= _Chunk2;
        const _BidIt _Mid2 = :: std :: next ( _Mid1, _Chunk2 );
        _Dest = _Merge_move ( _First, _Mid1, _Mid2, _Dest, _Pred );
        _First = _Mid2;
    }

    _Move_unchecked ( _First, _Last, _Dest );
}
#line 7421
template < class _BidIt, class _Pr >
void _Insertion_sort_isort_max_chunks ( _BidIt _First, const _BidIt _Last, _Iter_diff_t < _BidIt > _Count, _Pr _Pred ) {


    for (; _Isort_max < _BidIt > < _Count; _Count -= _Isort_max < _BidIt > ) {
        _First = _Insertion_sort_unchecked ( _First, :: std :: next ( _First, _Isort_max < _BidIt > ), _Pred );
    }

    _Insertion_sort_unchecked ( _First, _Last, _Pred );
}
#line 7432
template < class _BidIt, class _Pr >
void _Buffered_merge_sort_unchecked ( const _BidIt _First, const _BidIt _Last, const _Iter_diff_t < _BidIt > _Count,
    _Iter_value_t < _BidIt > * const _Temp_ptr, _Pr _Pred ) {



    _Insertion_sort_isort_max_chunks ( _First, _Last, _Count, _Pred );

    if ( _Count <= _Isort_max < _BidIt > ) {
        return;
    }


    _Uninitialized_chunked_merge_unchecked2 ( _First, _Last, _Temp_ptr, _Count, _Pred );
    _Uninitialized_backout < _Iter_value_t < _BidIt > * > _Backout { _Temp_ptr, _Temp_ptr + _Count };
    auto _Chunk = _Isort_max < _BidIt >;
    for (;; ) {

        _Chunk <<= 1;
        _Chunked_merge_unchecked ( _Temp_ptr, _Temp_ptr + _Count, _First, static_cast < ptrdiff_t > ( _Chunk ),
            static_cast < ptrdiff_t > ( _Count ), _Pred );
        _Chunk <<= 1;
        if ( _Count <= _Chunk ) {
            return;
        }


        _Chunked_merge_unchecked ( _First, _Last, _Temp_ptr, _Chunk, _Count, _Pred );
    }
}
#line 7463
template < class _BidIt, class _Pr >
void _Stable_sort_unchecked ( const _BidIt _First, const _BidIt _Last, const _Iter_diff_t < _BidIt > _Count,
    _Iter_value_t < _BidIt > * const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred ) {

    using _Diff = _Iter_diff_t < _BidIt >;
    if ( _Count <= _ISORT_MAX ) {
        _Insertion_sort_unchecked ( _First, _Last, _Pred );
    } else {
        const auto _Half_count = static_cast < _Diff > ( _Count >> 1 );
        const auto _Half_count_ceil = static_cast < _Diff > ( _Count - _Half_count );
        const _BidIt _Mid = :: std :: next ( _First, _Half_count_ceil );
        if ( _Half_count_ceil <= _Capacity ) {
            _Buffered_merge_sort_unchecked ( _First, _Mid, _Half_count_ceil, _Temp_ptr, _Pred );
            _Buffered_merge_sort_unchecked ( _Mid, _Last, _Half_count, _Temp_ptr, _Pred );
        } else {
            _Stable_sort_unchecked ( _First, _Mid, _Half_count_ceil, _Temp_ptr, _Capacity, _Pred );
            _Stable_sort_unchecked ( _Mid, _Last, _Half_count, _Temp_ptr, _Capacity, _Pred );
        }

        _Buffered_inplace_merge_unchecked (
            _First, _Mid, _Last, _Half_count_ceil, _Half_count, _Temp_ptr, _Capacity, _Pred );
    }
}
#line 7487
template < class _BidIt, class _Pr >
void stable_sort ( const _BidIt _First, const _BidIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    const auto _Count = :: std :: distance ( _UFirst, _ULast );
    if ( _Count <= _ISORT_MAX ) {
        _Insertion_sort_unchecked ( _UFirst, _ULast, _Pass_fn ( _Pred ) );
        return;
    }

    _Optimistic_temporary_buffer < _Iter_value_t < _BidIt >> _Temp_buf { _Count - _Count / 2 };
    _Stable_sort_unchecked ( _UFirst, _ULast, _Count, _Temp_buf . _Data, _Temp_buf . _Capacity, _Pass_fn ( _Pred ) );
}
#line 7508 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _BidIt >
void stable_sort ( const _BidIt _First, const _BidIt _Last ) {
    :: std :: stable_sort ( _First, _Last, less < > { } );
}
#line 7779 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _RanIt, class _Pr >
inline void partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Mid );
    _Adl_verify_range ( _Mid, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _UMid = _Get_unwrapped ( _Mid );
    const auto _ULast = _Get_unwrapped ( _Last );

    if ( _UFirst == _UMid ) {
        return;
    }

    _Make_heap_unchecked ( _UFirst, _UMid, _Pass_fn ( _Pred ) );
    for ( auto _UNext = _UMid; _UNext < _ULast; ++ _UNext ) {
        if ( static_cast < bool > ( _Pred ( * _UNext, * _UFirst ) ) ) {
            _Iter_value_t < _RanIt > _Val = :: std :: move ( * _UNext );
            _Pop_heap_hole_unchecked ( _UFirst, _UMid, _UNext, :: std :: move ( _Val ), _Pass_fn ( _Pred ) );
        }
    }

    _Sort_heap_unchecked ( _UFirst, _UMid, _Pass_fn ( _Pred ) );
}
#line 7803
template < class _RanIt >
inline void partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last ) {

    :: std :: partial_sort ( _First, _Mid, _Last, less < > { } );
}
#line 7903 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt, class _RanIt, class _Pr >
inline _RanIt partial_sort_copy ( _InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    auto _UMid2 = _UFirst2;
    if ( _UFirst1 != _ULast1 && _UFirst2 != _ULast2 ) {
        for (; _UFirst1 != _ULast1 && _UMid2 != _ULast2; ++ _UFirst1, ( void ) ++ _UMid2 ) {
            * _UMid2 = * _UFirst1;
        }

        _Make_heap_unchecked ( _UFirst2, _UMid2, _Pass_fn ( _Pred ) );
        for (; _UFirst1 != _ULast1; ++ _UFirst1 ) {
            if ( static_cast < bool > ( _Pred ( * _UFirst1, * _UFirst2 ) ) ) {

                using _Diff = _Iter_diff_t < _RanIt >;
                _Pop_heap_hole_by_index (
                    _UFirst2, static_cast < _Diff > ( 0 ), static_cast < _Diff > ( _UMid2 - _UFirst2 ), * _UFirst1, _Pass_fn ( _Pred ) );
            }
        }

        _Sort_heap_unchecked ( _UFirst2, _UMid2, _Pass_fn ( _Pred ) );
    }

    _Seek_wrapped ( _First2, _UMid2 );
    return _First2;
}
#line 7935
template < class _InIt, class _RanIt >
inline _RanIt partial_sort_copy ( _InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2 ) {

    return :: std :: partial_sort_copy ( _First1, _Last1, _First2, _Last2, less < > { } );
}
#line 8055 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _RanIt, class _Pr >
inline void nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Nth );
    _Adl_verify_range ( _Nth, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _UNth = _Get_unwrapped ( _Nth );
    auto _ULast = _Get_unwrapped ( _Last );
    if ( _UNth == _ULast ) {
        return;
    }

    while ( _ISORT_MAX < _ULast - _UFirst ) {
        auto _UMid = _Partition_by_median_guess_unchecked ( _UFirst, _ULast, _Pass_fn ( _Pred ) );

        if ( _UMid . second <= _UNth ) {
            _UFirst = _UMid . second;
        } else if ( _UMid . first <= _UNth ) {
            return;
        } else {
            _ULast = _UMid . first;
        }
    }

    _Insertion_sort_unchecked ( _UFirst, _ULast, _Pass_fn ( _Pred ) );
}
#line 8082
template < class _RanIt >
inline void nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last ) {
    :: std :: nth_element ( _First, _Nth, _Last, less < > { } );
}
#line 8178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2, class _Pr >
[ [ nodiscard ] ] inline bool includes ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    ;
    ;
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++ _UFirst1 ) {
        if ( static_cast < bool > ( _Pred ( * _UFirst2, * _UFirst1 ) ) ) {
            return false;
        }

        if ( ! _Pred ( * _UFirst1, * _UFirst2 ) ) {
            ++ _UFirst2;
        }
    }

    return _UFirst2 == _ULast2;
}
#line 8202
template < class _InIt1, class _InIt2 >
[ [ nodiscard ] ] inline bool includes ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2 ) {

    return :: std :: includes ( _First1, _Last1, _First2, _Last2, less < > { } );
}
#line 8302 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2, class _OutIt, class _Pr >
inline _OutIt set_union ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified ( _Dest );
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++ _UDest ) {
        if ( static_cast < bool > ( _Pred ( * _UFirst1, * _UFirst2 ) ) ) {
            * _UDest = * _UFirst1;
            ++ _UFirst1;
        } else if ( _Pred ( * _UFirst2, * _UFirst1 ) ) {
            * _UDest = * _UFirst2;
            ++ _UFirst2;
        } else {
            * _UDest = * _UFirst1;
            ++ _UFirst1;
            ++ _UFirst2;
        }
    }

    _UDest = _Copy_unchecked ( _UFirst1, _ULast1, _UDest );
    _Seek_wrapped ( _Dest, _Copy_unchecked ( _UFirst2, _ULast2, _UDest ) );
    return _Dest;
}
#line 8333
template < class _InIt1, class _InIt2, class _OutIt >
inline _OutIt set_union ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest ) {

    return :: std :: set_union ( _First1, _Last1, _First2, _Last2, _Dest, less < > { } );
}
#line 8439 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2, class _OutIt, class _Pr >
inline _OutIt set_intersection (
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified ( _Dest );
    while ( _UFirst1 != _ULast1 && _UFirst2 != _ULast2 ) {
        if ( static_cast < bool > ( _Pred ( * _UFirst1, * _UFirst2 ) ) ) {
            ++ _UFirst1;
        } else if ( _Pred ( * _UFirst2, * _UFirst1 ) ) {
            ++ _UFirst2;
        } else {
            * _UDest = * _UFirst1;
            ++ _UDest;
            ++ _UFirst1;
            ++ _UFirst2;
        }
    }

    _Seek_wrapped ( _Dest, _UDest );
    return _Dest;
}
#line 8469
template < class _InIt1, class _InIt2, class _OutIt >
inline _OutIt set_intersection ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest ) {

    return :: std :: set_intersection ( _First1, _Last1, _First2, _Last2, _Dest, less < > { } );
}
#line 8571 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2, class _OutIt, class _Pr >
inline _OutIt set_difference (
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified ( _Dest );
    while ( _UFirst1 != _ULast1 && _UFirst2 != _ULast2 ) {
        if ( static_cast < bool > ( _Pred ( * _UFirst1, * _UFirst2 ) ) ) {
            * _UDest = * _UFirst1;
            ++ _UDest;
            ++ _UFirst1;
        } else {
            if ( ! _Pred ( * _UFirst2, * _UFirst1 ) ) {
                ++ _UFirst1;
            }

            ++ _UFirst2;
        }
    }

    _Seek_wrapped ( _Dest, _Copy_unchecked ( _UFirst1, _ULast1, _UDest ) );
    return _Dest;
}
#line 8602
template < class _InIt1, class _InIt2, class _OutIt >
inline _OutIt set_difference ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest ) {

    return :: std :: set_difference ( _First1, _Last1, _First2, _Last2, _Dest, less < > { } );
}
#line 8700 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _InIt1, class _InIt2, class _OutIt, class _Pr >
inline _OutIt set_symmetric_difference (
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred ) {

    _Adl_verify_range ( _First1, _Last1 );
    _Adl_verify_range ( _First2, _Last2 );
    auto _UFirst1 = _Get_unwrapped ( _First1 );
    const auto _ULast1 = _Get_unwrapped ( _Last1 );
    auto _UFirst2 = _Get_unwrapped ( _First2 );
    const auto _ULast2 = _Get_unwrapped ( _Last2 );
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified ( _Dest );
    while ( _UFirst1 != _ULast1 && _UFirst2 != _ULast2 ) {
        if ( static_cast < bool > ( _Pred ( * _UFirst1, * _UFirst2 ) ) ) {
            * _UDest = * _UFirst1;
            ++ _UDest;
            ++ _UFirst1;
        } else if ( _Pred ( * _UFirst2, * _UFirst1 ) ) {
            * _UDest = * _UFirst2;
            ++ _UDest;
            ++ _UFirst2;
        } else {
            ++ _UFirst1;
            ++ _UFirst2;
        }
    }

    _UDest = _Copy_unchecked ( _UFirst1, _ULast1, _UDest );
    _Seek_wrapped ( _Dest, _Copy_unchecked ( _UFirst2, _ULast2, _UDest ) );
    return _Dest;
}
#line 8733
template < class _InIt1, class _InIt2, class _OutIt >
inline _OutIt set_symmetric_difference (
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest ) {

    return :: std :: set_symmetric_difference ( _First1, _Last1, _First2, _Last2, _Dest, less < > { } );
}
#line 8851 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Pr >
constexpr _FwdIt _Max_element_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {
    _FwdIt _Found = _First;
    if ( _First != _Last ) {
        while ( ++ _First != _Last ) {
            if ( static_cast < bool > ( _Pred ( * _Found, * _First ) ) ) {
                _Found = _First;
            }
        }
    }

    return _Found;
}
#line 8865
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] constexpr _FwdIt max_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {
    _Adl_verify_range ( _First, _Last );
    _Seek_wrapped ( _First, _Max_element_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Pass_fn ( _Pred ) ) );
    return _First;
}
#line 8872
template < class _FwdIt >
[ [ nodiscard ] ] constexpr _FwdIt max_element ( _FwdIt _First, _FwdIt _Last ) {
    return :: std :: max_element ( _First, _Last, less < > { } );
}
#line 8942 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Pr >
constexpr _FwdIt _Min_element_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {
    _FwdIt _Found = _First;
    if ( _First != _Last ) {
        while ( ++ _First != _Last ) {
            if ( static_cast < bool > ( _Pred ( * _First, * _Found ) ) ) {
                _Found = _First;
            }
        }
    }

    return _Found;
}
#line 8956
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] constexpr _FwdIt min_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {
    _Adl_verify_range ( _First, _Last );
    _Seek_wrapped ( _First, _Min_element_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Pass_fn ( _Pred ) ) );
    return _First;
}
#line 8963
template < class _FwdIt >
[ [ nodiscard ] ] constexpr _FwdIt min_element ( _FwdIt _First, _FwdIt _Last ) {
    return :: std :: min_element ( _First, _Last, less < > { } );
}
#line 9033 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _FwdIt, class _Pr >
constexpr pair < _FwdIt, _FwdIt > _Minmax_element_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    pair < _FwdIt, _FwdIt > _Found ( _First, _First );

    if ( _First != _Last ) {
        while ( ++ _First != _Last ) {
            _FwdIt _Next = _First;
            if ( ++ _Next == _Last ) {
                if ( static_cast < bool > ( _Pred ( * _First, * _Found . first ) ) ) {
                    _Found . first = _First;
                } else if ( ! static_cast < bool > ( _Pred ( * _First, * _Found . second ) ) ) {
                    _Found . second = _First;
                }
            } else {
                if ( static_cast < bool > ( _Pred ( * _Next, * _First ) ) ) {
                    if ( static_cast < bool > ( _Pred ( * _Next, * _Found . first ) ) ) {
                        _Found . first = _Next;
                    }
                    if ( ! static_cast < bool > ( _Pred ( * _First, * _Found . second ) ) ) {
                        _Found . second = _First;
                    }
                } else {
                    if ( static_cast < bool > ( _Pred ( * _First, * _Found . first ) ) ) {
                        _Found . first = _First;
                    }
                    if ( ! static_cast < bool > ( _Pred ( * _Next, * _Found . second ) ) ) {
                        _Found . second = _Next;
                    }
                }
                _First = _Next;
            }
        }
    }

    return _Found;
}
#line 9071
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] constexpr pair < _FwdIt, _FwdIt > minmax_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    const auto _Result = _Minmax_element_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Pass_fn ( _Pred ) );
    _Seek_wrapped ( _Last, _Result . second );
    _Seek_wrapped ( _First, _Result . first );
    return { _First, _Last };
}
#line 9081
template < class _FwdIt >
[ [ nodiscard ] ] constexpr pair < _FwdIt, _FwdIt > minmax_element ( _FwdIt _First, _FwdIt _Last ) {

    return :: std :: minmax_element ( _First, _Last, less < > { } );
}
#line 9192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Ty ( max ) ( initializer_list < _Ty > _Ilist, _Pr _Pred ) {

    const _Ty * _Res = _Max_element_unchecked ( _Ilist . begin ( ), _Ilist . end ( ), _Pass_fn ( _Pred ) );
    return * _Res;
}
#line 9199
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty ( max ) ( initializer_list < _Ty > _Ilist ) {

    return ( :: std :: max ) ( _Ilist, less < > { } );
}
#line 9270
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr _Ty ( min ) ( initializer_list < _Ty > _Ilist, _Pr _Pred ) {

    const _Ty * _Res = _Min_element_unchecked ( _Ilist . begin ( ), _Ilist . end ( ), _Pass_fn ( _Pred ) );
    return * _Res;
}
#line 9277
template < class _Ty >
[ [ nodiscard ] ] constexpr _Ty ( min ) ( initializer_list < _Ty > _Ilist ) {

    return ( :: std :: min ) ( _Ilist, less < > { } );
}
#line 9340
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr pair < const _Ty &, const _Ty & > minmax ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred ) noexcept (
    noexcept ( static_cast < bool > ( _Pred ( _Right, _Left ) ) ) ) {

    if ( static_cast < bool > ( _Pred ( _Right, _Left ) ) ) {
        return { _Right, _Left };
    }

    return { _Left, _Right };
}
#line 9351
template < class _Ty, class _Pr >
[ [ nodiscard ] ] constexpr pair < _Ty, _Ty > minmax ( initializer_list < _Ty > _Ilist, _Pr _Pred ) {

    pair < const _Ty *, const _Ty * > _Res = _Minmax_element_unchecked ( _Ilist . begin ( ), _Ilist . end ( ), _Pass_fn ( _Pred ) );
    return pair < _Ty, _Ty > ( * _Res . first, * _Res . second );
}
#line 9358
template < class _Ty >
[ [ nodiscard ] ] constexpr pair < const _Ty &, const _Ty & > minmax ( const _Ty & _Left, const _Ty & _Right ) noexcept (
    noexcept ( _Right < _Left ) ) {

    if ( _Right < _Left ) {
        ;
        return { _Right, _Left };
    }

    return { _Left, _Right };
}
#line 9370
template < class _Ty >
[ [ nodiscard ] ] constexpr pair < _Ty, _Ty > minmax ( initializer_list < _Ty > _Ilist ) {

    return :: std :: minmax ( _Ilist, less < > { } );
}
#line 9470
template < class _BidIt, class _Pr >
inline bool next_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UNext = _ULast;
    if ( _UFirst == _ULast || _UFirst == -- _UNext ) {
        return false;
    }

    for (;; ) {
        auto _UNext1 = _UNext;
        if ( static_cast < bool > ( _Pred ( * -- _UNext, * _UNext1 ) ) ) {
            auto _UMid = _ULast;
            do {
                -- _UMid;
            } while ( ! static_cast < bool > ( _Pred ( * _UNext, * _UMid ) ) );

            :: std :: iter_swap ( _UNext, _UMid );
            :: std :: reverse ( _UNext1, _ULast );
            return true;
        }

        if ( _UNext == _UFirst ) {
            :: std :: reverse ( _UFirst, _ULast );
            return false;
        }
    }
}
#line 9501
template < class _BidIt >
inline bool next_permutation ( _BidIt _First, _BidIt _Last ) {

    return :: std :: next_permutation ( _First, _Last, less < > { } );
}
#line 9578
template < class _BidIt, class _Pr >
inline bool prev_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    auto _UNext = _ULast;
    if ( _UFirst == _ULast || _UFirst == -- _UNext ) {
        return false;
    }

    for (;; ) {
        auto _UNext1 = _UNext;
        if ( static_cast < bool > ( _Pred ( * _UNext1, * -- _UNext ) ) ) {
            auto _UMid = _ULast;
            do {
                -- _UMid;
            } while ( ! static_cast < bool > ( _Pred ( * _UMid, * _UNext ) ) );

            :: std :: iter_swap ( _UNext, _UMid );
            :: std :: reverse ( _UNext1, _ULast );
            return true;
        }

        if ( _UNext == _UFirst ) {
            :: std :: reverse ( _UFirst, _ULast );
            return false;
        }
    }
}
#line 9609
template < class _BidIt >
inline bool prev_permutation ( _BidIt _First, _BidIt _Last ) {

    return :: std :: prev_permutation ( _First, _Last, less < > { } );
}
#line 9686
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] inline _FwdIt is_sorted_until ( const _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    auto _UFirst = _Get_unwrapped ( _First );
    auto _ULast = _Get_unwrapped ( _Last );
    if ( _UFirst != _ULast ) {
        for ( auto _UNext = _UFirst; ++ _UNext != _ULast; ++ _UFirst ) {
            if ( static_cast < bool > ( _Pred ( * _UNext, * _UFirst ) ) ) {
                _ULast = _UNext;
                break;
            }
        }
    }

    _Seek_wrapped ( _Last, _ULast );
    return _Last;
}
#line 9705
template < class _FwdIt, class _Pr >
[ [ nodiscard ] ] inline bool is_sorted ( _FwdIt _First, _FwdIt _Last, _Pr _Pred ) {

    _Adl_verify_range ( _First, _Last );
    const auto _UFirst = _Get_unwrapped ( _First );
    const auto _ULast = _Get_unwrapped ( _Last );
    return :: std :: is_sorted_until ( _UFirst, _ULast, _Pass_fn ( _Pred ) ) == _ULast;
}
#line 9714
template < class _FwdIt >
[ [ nodiscard ] ] inline _FwdIt is_sorted_until ( _FwdIt _First, _FwdIt _Last ) {

    return :: std :: is_sorted_until ( _First, _Last, less < > { } );
}
#line 9720
template < class _FwdIt >
[ [ nodiscard ] ] inline bool is_sorted ( _FwdIt _First, _FwdIt _Last ) {
    return :: std :: is_sorted ( _First, _Last, less < > { } );
}
#line 9942 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
}
#line 9945
#pragma warning(pop)
#pragma pack ( pop )
#line 9949 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
#pragma external_header(pop)
#line 19 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
#pragma external_header(push)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 22
namespace std { 
#line 24
[[nodiscard]] inline unsigned long _Floor_of_log_2(size_t _Value) noexcept { 
#line 25
_Value |= ((size_t)1); 
#line 26
unsigned long _Result; 
#line 41
_BitScanReverse64(&_Result, _Value); 
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"
return _Result; 
#line 48
} 
#line 50
[[nodiscard]] inline unsigned long _Ceiling_of_log_2(const size_t _Value) noexcept { 
#line 52
return (1) + _Floor_of_log_2(_Value - (1)); 
#line 53
} 
#line 55
[[nodiscard]] inline uint32_t _Bit_scan_reverse(const uint32_t _Value) noexcept { 
#line 56
unsigned long _Index; 
#line 58
if (_BitScanReverse(&_Index, _Value)) { 
#line 59
return _Index + (1); 
#line 60
}  
#line 62
return 0; 
#line 63
} 
#line 65
[[nodiscard]] inline uint32_t _Bit_scan_reverse(const uint64_t _Value) noexcept { 
#line 66
unsigned long _Index; 
#line 69
if (_BitScanReverse64(&_Index, _Value)) { 
#line 70
return _Index + (1); 
#line 71
}  
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"
return 0; 
#line 87
} 
#line 89
}
#line 93
#pragma warning(pop)
#pragma pack ( pop )
#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 27
#pragma warning(disable : 4127)
#line 29
namespace std { 
#line 52
template< class _Seed_seq, class _Self, class _Engine = _Self> using _Enable_if_seed_seq_t = enable_if_t< ((!is_convertible_v< remove_cv_t< _Seed_seq> , typename _Self::result_type> ) && (!is_same_v< remove_cv_t< _Seed_seq> , _Self> )) && (!is_same_v< remove_cv_t< _Seed_seq> , _Engine> ), int> ; 
#line 59
constexpr long double _Pi = (3.1415926535897931L); 
#line 60
constexpr long double _Exp1 = (2.7182818284590451L); 
#line 61
constexpr long double _Two32 = (4294967296.0L); 
#line 62
constexpr long double _Two31 = (2147483648.0L); 
#line 64
float __cdecl _XLgamma(float); 
#line 65
double __cdecl _XLgamma(double); 
#line 66
long double __cdecl _XLgamma(long double); 
#line 68
constexpr int _Nwords = 4; 
#line 70
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & _Write (
    basic_ostream < _Elem, _Traits > & _Os, long double _Dx ) {
    int _Ex;
    long double _Frac = :: frexpl ( _Dx, & _Ex );
    for ( int _Nw = 0; _Nw < _Nwords; ++ _Nw ) {
        _Frac *= _Two31;
        long _Digits = static_cast < long > ( _Frac );
        _Frac -= _Digits;
        _Os << ' ' << _Digits;
    }
    _Os << ' ' << _Ex;
    return _Os;
}
#line 85
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & _Read (
    basic_istream < _Elem, _Traits > & _Is, long double & _Dx ) {
    long double _Frac = (0.0);
    long _Digits;
    for ( int _Nw = 0; _Nw < _Nwords; ++ _Nw ) {
        _Is >> _Digits;
        long double _Temp = _Digits / _Two31;
        for ( int _Idx = 0; _Idx < _Nw; ++ _Idx ) {
            _Temp /= _Two31;
        }

        _Frac += _Temp;
    }
    _Is >> _Digits;
    _Dx = :: ldexpl ( _Frac, _Digits );
    return _Is;
}
#line 104
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & _In ( basic_istream < _Elem, _Traits > & _Is, _Ty & _Dx ) {
    long double _Vx;
    _Ty _Max = ( numeric_limits < _Ty > :: max ) ( );
    _Read ( _Is, _Vx );
    if ( :: fabsl ( _Vx ) <= _Max ) {
        _Dx = static_cast < _Ty > ( _Vx );
    } else if ( _Vx < 0 ) {
        _Dx = - _Max;
    } else {
        _Dx = _Max;
    }

    return _Is;
}
#line 120
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & _Out ( basic_ostream < _Elem, _Traits > & _Os, _Ty _Dx ) {
    return _Write ( _Os, _Dx );
}
#line 125
template < class _Elem, class _Traits, class _Ty >
class _Wrap_istream {
public :
    _Wrap_istream ( basic_istream < _Elem, _Traits > & _Is ) : _Str ( _Is ) { }

    _Ty operator ( ) ( ) {
        _Ty _Data;
        _Str >> _Data;
        if ( ! _Str ) {
            _Xinvalid_argument ( "input stream corrupted" );
        }

        return _Data;
    }

    _Wrap_istream & operator = ( const _Wrap_istream & ) = delete;

private :
    basic_istream < _Elem, _Traits > & _Str;
};
#line 146
class seed_seq { 
#line 148
public: using result_type = unsigned; 
#line 150
seed_seq() { } 
#line 152
template < class _Ty >
    seed_seq ( initializer_list < _Ty > _Ilist ) {
        _Construct ( _Ilist . begin ( ), _Ilist . end ( ) );
    }
#line 157
template < class _InIt >
    seed_seq ( _InIt _First, _InIt _Last ) {
        _Construct ( _First, _Last );
    }
#line 162
template < class _RanIt >
    void generate ( _RanIt _First, _RanIt _Last ) const {
        _Adl_verify_range ( _First, _Last );
        auto _UFirst = _Get_unwrapped ( _First );
        const auto _Nx = static_cast < size_t > ( _Get_unwrapped ( _Last ) - _UFirst );

        if ( 0 < _Nx ) {
            const size_t _Sx = _Myvec . size ( );
            const size_t _Tx = 623 <= _Nx ? 11 : 68 <= _Nx ? 7 : 39 <= _Nx ? 5 : 7 <= _Nx ? 3 : ( _Nx - 1 ) / 2;
            const size_t _Px = ( _Nx - _Tx ) / 2;
            const size_t _Qx = _Px + _Tx;
            const size_t _Mx = _Nx <= _Sx ? _Sx + 1 : _Nx;
            size_t _Kx;

            _Iter_value_t < _RanIt > _Mask = _Iter_value_t < _RanIt > ( 1 ) << 31;
            _Mask <<= 1;
            _Mask -= 1;

            for ( _Kx = 0; _Kx < _Nx; ++ _Kx ) {
                _UFirst [ _Kx ] = 2341178251U;
            }

            for ( _Kx = 0; _Kx < _Mx; ++ _Kx ) {
                result_type _Rx1 =
                    1664525 * _Xor27 ( _UFirst [ _Kx % _Nx ] ^ _UFirst [ ( _Kx + _Px ) % _Nx ] ^ _UFirst [ ( _Kx - 1 ) % _Nx ] );

                size_t _Off;
                if ( _Kx == 0 ) {
                    _Off = _Sx;
                } else if ( _Kx <= _Sx ) {
                    _Off = _Kx % _Nx + _Myvec [ _Kx - 1 ];
                } else {
                    _Off = _Kx % _Nx;
                }
                result_type _Rx2 = static_cast < result_type > ( ( _Rx1 + _Off ) & _Mask );

                _UFirst [ ( _Kx + _Px ) % _Nx ] = ( _UFirst [ ( _Kx + _Px ) % _Nx ] + _Rx1 ) & _Mask;
                _UFirst [ ( _Kx + _Qx ) % _Nx ] = ( _UFirst [ ( _Kx + _Qx ) % _Nx ] + _Rx2 ) & _Mask;
                _UFirst [ _Kx % _Nx ] = _Rx2;
            }
            for (; _Kx < _Mx + _Nx; ++ _Kx ) {
                result_type _Rx3 =
                    1566083941 * _Xor27 ( _UFirst [ _Kx % _Nx ] + _UFirst [ ( _Kx + _Px ) % _Nx ] + _UFirst [ ( _Kx - 1 ) % _Nx ] );
                result_type _Rx4 = static_cast < result_type > ( ( _Rx3 - _Kx % _Nx ) & _Mask );

                _UFirst [ ( _Kx + _Px ) % _Nx ] = ( _UFirst [ ( _Kx + _Px ) % _Nx ] ^ _Rx3 ) & _Mask;
                _UFirst [ ( _Kx + _Qx ) % _Nx ] = ( _UFirst [ ( _Kx + _Qx ) % _Nx ] ^ _Rx4 ) & _Mask;
                _UFirst [ _Kx % _Nx ] = _Rx4;
            }
        }
    }
#line 214
template < class _OutIt >
    void param ( _OutIt _Dest ) const {
        :: std :: copy ( _Myvec . begin ( ), _Myvec . end ( ), _Dest );
    }
#line 219
[[nodiscard]] size_t size() const noexcept { 
#line 220
return (_Myvec).size(); 
#line 221
} 
#line 223
seed_seq(const seed_seq &) = delete;
#line 224
void operator=(const seed_seq &) = delete;
#line 227
private: template < class _InIt >
    void _Construct ( _InIt _First, _InIt _Last ) {
        for (; _First != _Last; ++ _First ) {
            _Myvec . push_back ( static_cast < unsigned int > ( * _First ) );
        }
    }
#line 234
result_type _Xor27(result_type _Val) const { 
#line 235
return _Val ^ (_Val >> 27); 
#line 236
} 
#line 238
vector< unsigned>  _Myvec; 
#line 239
}; 
#line 241
template < class _Real, size_t _Bits, class _Gen >
[ [ nodiscard ] ] _Real generate_canonical ( _Gen & _Gx ) {
    static_assert ( _Is_any_of_v < _Real, float, double, long double >, "invalid template argument for generate_canonical: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long doubl" "e" );

    const size_t _Digits = static_cast < size_t > ( numeric_limits < _Real > :: digits );
    const size_t _Minbits = _Digits < _Bits ? _Digits : _Bits;

    const _Real _Gxmin = static_cast < _Real > ( ( _Gx . min ) ( ) );
    const _Real _Gxmax = static_cast < _Real > ( ( _Gx . max ) ( ) );
    const _Real _Rx = ( _Gxmax - _Gxmin ) + _Real { 1 };

    const int _Ceil = static_cast < int > ( :: std :: ceil ( static_cast < _Real > ( _Minbits ) / :: std :: log2 ( _Rx ) ) );
    const int _Kx = _Ceil < 1 ? 1 : _Ceil;

    _Real _Ans { 0 };
    _Real _Factor { 1 };

    for ( int _Idx = 0; _Idx < _Kx; ++ _Idx ) {
        _Ans += ( static_cast < _Real > ( _Gx ( ) ) - _Gxmin ) * _Factor;
        _Factor *= _Rx;
    }

    return _Ans / _Factor;
}
#line 268
constexpr int _MP_len = 5; 
#line 269
using _MP_arr = uint64_t [_MP_len]; 
#line 271
[[nodiscard]] uint64_t __cdecl _MP_Get(_MP_arr) noexcept; 
#line 272
void __cdecl _MP_Add(_MP_arr, uint64_t) noexcept; 
#line 273
void __cdecl _MP_Mul(_MP_arr, uint64_t, uint64_t) noexcept; 
#line 274
void __cdecl _MP_Rem(_MP_arr, uint64_t) noexcept; 
#line 276
template < class _Uint, _Uint _Ax, _Uint _Cx, _Uint _Mx >
[ [ nodiscard ] ] _Uint _Next_linear_congruential_value ( _Uint _Prev ) noexcept {









    if constexpr ( _Ax == 0 ) {
        return static_cast < _Uint > ( _Cx );
    } else if constexpr ( _Mx == 0 ) {




        return static_cast < _Uint > ( static_cast < _Uint > ( _Ax * _Prev ) + _Cx );
    } else if constexpr ( _Cx <= 4294967295U && static_cast < _Uint > ( _Mx - 1 ) <= ( 4294967295U - _Cx ) / _Ax ) {

        const auto _Mul =
            static_cast < unsigned int > ( _Prev ) * static_cast < unsigned int > ( _Ax ) + static_cast < unsigned int > ( _Cx );
        return static_cast < _Uint > ( _Mul % _Mx );
    } else if constexpr ( _Cx <= 18446744073709551615Ui64 && static_cast < _Uint > ( _Mx - 1 ) <= ( 18446744073709551615Ui64 - _Cx ) / _Ax ) {

        const auto _Mul = static_cast < unsigned long long > ( _Prev ) * _Ax + _Cx;
        return static_cast < _Uint > ( _Mul % _Mx );
    } else {
        _MP_arr _Wx;
        _MP_Mul ( _Wx, _Prev, _Ax );
        _MP_Add ( _Wx, _Cx );
        _MP_Rem ( _Wx, _Mx );
        return static_cast < _Uint > ( _MP_Get ( _Wx ) );
    }
}
#line 313
template < class _Seed_seq >
[ [ nodiscard ] ] constexpr unsigned int _Seed_seq_to_uint ( _Seed_seq & _Seq ) {
    unsigned int _Arr [ 4 ] { };
    _Seq . generate ( _Arr, _Arr + 4 );
    return _Arr [ 3 ];
}
#line 320
template < class _Seed_seq >
[ [ nodiscard ] ] constexpr unsigned long long _Seed_seq_to_ull ( _Seed_seq & _Seq ) {
    unsigned int _Arr [ 5 ] { };
    _Seq . generate ( _Arr, _Arr + 5 );
    unsigned long long _Result = _Arr [ 4 ];
    _Result <<= 32;
    _Result |= _Arr [ 3 ];
    return _Result;
}
#line 330
template < class _Uint, _Uint _Cx, _Uint _Mx >
[ [ nodiscard ] ] constexpr _Uint _Get_linear_congruential_seed ( _Uint _Sx ) noexcept {
    if constexpr ( _Mx != 0 ) {
        _Sx %= _Mx;
    }

    if constexpr ( _Cx == 0 ) {
        if ( _Sx == 0 ) {
            _Sx = _Uint { 1 };
        }
    }

    return _Sx;
}
#line 345
template < class _Uint, _Uint _Cx, _Uint _Mx, class _Seed_seq >
[ [ nodiscard ] ] _Uint _Get_linear_congruential_seed_from_seq ( _Seed_seq & _Seq ) {
    _Uint _Sx;
    if constexpr ( _Mx == 0 ) {
        if constexpr ( sizeof ( _Uint ) <= sizeof ( unsigned int ) ) {
            _Sx = static_cast < _Uint > ( _Seed_seq_to_uint ( _Seq ) );
        } else {
            _Sx = static_cast < _Uint > ( _Seed_seq_to_ull ( _Seq ) );
        }
    } else if constexpr ( _Mx <= 4294967295U ) {
        _Sx = static_cast < _Uint > ( _Seed_seq_to_uint ( _Seq ) % _Mx );
    } else {
        _Sx = static_cast < _Uint > ( _Seed_seq_to_ull ( _Seq ) % _Mx );
    }

    return _Get_linear_congruential_seed < _Uint, _Cx, _Mx > ( _Sx );
}
#line 363
template < class _Uint, _Uint _Ax, _Uint _Cx, _Uint _Mx >
class linear_congruential_engine {
public :
    static_assert ( _Is_any_of_v < _Uint, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for linear_congruential_engine: N4659 29.6.1.1 [rand.req.genl]/1f requires one of unsigned short, unsi" "gned int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Uint > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    static_assert ( 0 == _Mx || ( _Ax < _Mx && _Cx < _Mx ), "invalid template argument for linear_congruential_engine" );

    using result_type = _Uint;
    static constexpr result_type multiplier = _Ax;
    static constexpr result_type increment = _Cx;
    static constexpr result_type modulus = _Mx;

    [ [ nodiscard ] ] static constexpr result_type ( min ) ( ) noexcept {

        return _Cx == 0;
    }

#pragma warning(push)
#pragma warning(disable : 4309)
    [ [ nodiscard ] ] static constexpr result_type ( max ) ( ) noexcept {

        return static_cast < result_type > ( _Mx - 1U );
    }
#pragma warning(pop)

    static constexpr result_type default_seed = 1U;

    linear_congruential_engine ( ) noexcept
        : _Prev ( _Get_linear_congruential_seed < result_type, _Cx, _Mx > ( default_seed ) ) { }

    explicit linear_congruential_engine ( result_type _Sx ) noexcept
        : _Prev ( _Get_linear_congruential_seed < result_type, _Cx, _Mx > ( _Sx ) ) { }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, linear_congruential_engine > = 0 >
    explicit linear_congruential_engine ( _Seed_seq & _Seq )
        : _Prev ( _Get_linear_congruential_seed_from_seq < result_type, _Cx, _Mx > ( _Seq ) ) { }

    void seed ( result_type _Sx = default_seed ) noexcept {

        _Prev = _Get_linear_congruential_seed < result_type, _Cx, _Mx > ( _Sx );
    }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, linear_congruential_engine > = 0 >
    void seed ( _Seed_seq & _Seq ) {
        _Prev = _Get_linear_congruential_seed_from_seq < result_type, _Cx, _Mx > ( _Seq );
    }

    [ [ nodiscard ] ] _Uint operator ( ) ( ) noexcept {
        _Prev = _Next_linear_congruential_value < result_type, _Ax, _Cx, _Mx > ( _Prev );
        return _Prev;
    }

    void discard ( unsigned long long _Nskip ) noexcept {

        auto _Temp = _Prev;
        for (; 0 < _Nskip; -- _Nskip ) {
            _Temp = _Next_linear_congruential_value < _Uint, _Ax, _Cx, _Mx > ( _Temp );
        }

        _Prev = _Temp;
    }




    friend bool operator == ( const linear_congruential_engine & _Lhs, const linear_congruential_engine & _Rhs ) noexcept
     {
        return _Lhs . _Prev == _Rhs . _Prev;
    }




    friend bool operator != ( const linear_congruential_engine & _Lhs, const linear_congruential_engine & _Rhs ) noexcept
     {
        return _Lhs . _Prev != _Rhs . _Prev;
    }

    template < class _Elem, class _Traits >
    friend basic_istream < _Elem, _Traits > & operator >> (
        basic_istream < _Elem, _Traits > & _Istr, linear_congruential_engine & _Eng ) {
        return _Istr >> _Eng . _Prev;
    }

    template < class _Elem, class _Traits >
    friend basic_ostream < _Elem, _Traits > & operator << (
        basic_ostream < _Elem, _Traits > & _Ostr, const linear_congruential_engine & _Eng ) {
        return _Ostr << _Eng . _Prev;
    }

private :
    result_type _Prev;
};
#line 457
template < class _Uint, _Uint _Ax, _Uint _Cx, _Uint _Mx >
class linear_congruential {
public :
    static_assert ( _Is_any_of_v < _Uint, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for linear_congruential: N4659 29.6.1.1 [rand.req.genl]/1f requires one of unsigned short, unsigned in" "t, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Uint > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    static_assert ( 0 == _Mx || ( _Ax < _Mx && _Cx < _Mx ), "invalid template argument for linear_congruential" );

    using result_type = _Uint;

    static constexpr _Uint multiplier = _Ax;
    static constexpr _Uint increment = _Cx;
    static constexpr _Uint modulus = _Mx;

    linear_congruential ( ) noexcept
        : _Prev ( _Get_linear_congruential_seed < _Uint, _Cx, _Mx > ( 1U ) ) { }

    explicit linear_congruential ( _Uint _Xx0 ) noexcept
        : _Prev ( _Get_linear_congruential_seed < _Uint, _Cx, _Mx > ( _Xx0 ) ) { }

    template < class _Gen, _Enable_if_seed_seq_t < _Gen, linear_congruential > = 0 >
    linear_congruential ( _Gen & _Seq ) : _Prev ( _Get_linear_congruential_seed < _Uint, _Cx, _Mx > ( _Seq ( ) ) ) { }

    void seed ( _Uint _Xx0 = 1U ) noexcept {

        _Prev = _Get_linear_congruential_seed < _Uint, _Cx, _Mx > ( _Xx0 );
    }

    template < class _Gen, _Enable_if_seed_seq_t < _Gen, linear_congruential > = 0 >
    void seed ( _Gen & _Seq ) {
        _Prev = _Get_linear_congruential_seed < _Uint, _Cx, _Mx > ( _Seq ( ) );
    }

    [ [ nodiscard ] ] _Uint ( min ) ( ) const noexcept {

        return _Cx == 0;
    }

#pragma warning(push)
#pragma warning(disable : 4309)
    [ [ nodiscard ] ] _Uint ( max ) ( ) const noexcept {

        return static_cast < _Uint > ( _Mx - 1U );
    }
#pragma warning(pop)

    [ [ nodiscard ] ] _Uint operator ( ) ( ) noexcept {

        _Prev = _Next_linear_congruential_value < _Uint, _Ax, _Cx, _Mx > ( _Prev );
        return _Prev;
    }

    void discard ( unsigned long long _Nskip ) noexcept {

        auto _Temp = _Prev;
        for (; 0 < _Nskip; -- _Nskip ) {
            _Temp = _Next_linear_congruential_value < _Uint, _Ax, _Cx, _Mx > ( _Temp );
        }

        _Prev = _Temp;
    }




    friend bool operator == ( const linear_congruential & _Lhs, const linear_congruential & _Rhs ) noexcept
     {
        return _Lhs . _Prev == _Rhs . _Prev;
    }




    friend bool operator != ( const linear_congruential & _Lhs, const linear_congruential & _Rhs ) noexcept
     {
        return _Lhs . _Prev != _Rhs . _Prev;
    }

    template < class _Elem, class _Traits >
    friend basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr, linear_congruential & _Eng ) {
        return _Istr >> _Eng . _Prev;
    }

    template < class _Elem, class _Traits >
    friend basic_ostream < _Elem, _Traits > & operator << (
        basic_ostream < _Elem, _Traits > & _Ostr, const linear_congruential & _Eng ) {
        return _Ostr << _Eng . _Prev;
    }

private :
    _Uint _Prev;
};
#line 549
template < class _Ty, size_t _Nw >
struct _Circ_buf {
    _Ty _At ( size_t _Ix ) const {
        return _Ax [ _Base ( _Ix ) ];
    }

    bool _Equals ( const _Circ_buf & _Right ) const {
        const _Ty * _Last1 = _Ax + _Idx;
        const _Ty * _Last2 = _Right . _Ax + _Right . _Idx;
        const _Ty * _First;
        const _Ty * _Last;
        const _Ty * _Other;
        bool _Use2 = _Base ( ) < _Right . _Base ( );

        if ( _Use2 ) {

            _First = _Right . _Ax + _Right . _Base ( );
            _Last = _Last2;
            _Other = _Ax + _Base ( );
        } else {

            _First = _Ax + _Base ( );
            _Last = _Last1;
            _Other = _Right . _Ax + _Right . _Base ( );
        }

        ptrdiff_t _Nx0 = _Nw;
        while ( 0 < _Nx0 ) {




            const _Ty * _Limit = _First < _Last ? _Last : _Use2 ? _Right . _Ax + 2 * _Nw : _Ax + 2 * _Nw;
            _Nx0 -= _Limit - _First;
            while ( _First != _Limit ) {
                if ( * _First ++ != * _Other ++ ) {
                    return false;
                }
            }

            _First = _Other;
            _Last = _Use2 ? _Last1 : _Last2;
            _Other = _Use2 ? _Right . _Ax : _Ax;
            _Use2 = ! _Use2;
        }
        return true;
    }

    size_t _Base ( size_t _Ix = 0 ) const {
        return ( _Ix += _Idx ) < _Nw ? ( _Ix + _Nw ) : ( _Ix - _Nw );
    }

    unsigned int _Idx;
    _Ty _Ax [ 2 * _Nw ];
};
#line 605
template < class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits >
class _Swc_base : public _Circ_buf < _Ty, _Rx > {
public :
    using result_type = _Ty;
    using _Traits = _Swc_Traits;
    using _Mybase = _Circ_buf < _Ty, _Rx >;
    using _Seed_t = typename _Swc_Traits :: _Seed_t;

    static constexpr size_t short_lag = _Sx;
    static constexpr size_t long_lag = _Rx;
    static constexpr _Seed_t default_seed = static_cast < _Seed_t > ( 19780503U );

    _Swc_base ( ) {
        seed ( );
    }

    _Swc_base ( _Seed_t _Xx0 ) {
        seed ( _Xx0 );
    }

    template < class _Gen, _Enable_if_seed_seq_t < _Gen, _Swc_base > = 0 >
    _Swc_base ( _Gen & _Gx ) {
        seed ( _Gx );
    }

    void seed ( _Seed_t _Value = default_seed ) {
        _Seed ( _Value, false, true_type { } );
    }

    template < class _Gen >
    void seed ( _Gen & _Gx, bool _Readcy = false ) {
        _Seed ( _Gx, _Readcy, is_arithmetic < _Gen > { } );
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return _Swc_Traits :: _Max;
    }

    [ [ nodiscard ] ] result_type operator ( ) ( ) {
        const auto _Ix = 2 * _Rx <= this -> _Idx ? 0 : this -> _Idx;
        if ( _Ix < _Sx ) {
            _Setx ( _Ix, this -> _Ax [ _Ix + 2 * _Rx - _Sx ], this -> _Ax [ _Ix + _Rx ] );
        } else if ( _Ix < _Rx ) {
            _Setx ( _Ix, this -> _Ax [ _Ix - _Sx ], this -> _Ax [ _Ix + _Rx ] );
        } else {
            _Setx ( _Ix, this -> _Ax [ _Ix - _Sx ], this -> _Ax [ _Ix - _Rx ] );
        }

        this -> _Idx = _Ix + 1;
        return this -> _Ax [ _Ix ];
    }

    void discard ( unsigned long long _Nskip ) {
        for (; 0 < _Nskip; -- _Nskip ) {
            ( void ) ( * this ) ( );
        }
    }

    bool _Equals ( const _Swc_base & _Right ) const {
        return _Mybase :: _Equals ( _Right ) && _Carry == _Right . _Carry;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Swc_Traits :: _Write ( _Ostr, * this, _Carry );
        return _Ostr;
    }

protected :
    template < class _Gen >
    void _Seed ( _Gen & _Gx, bool _Readcy, true_type ) {
        linear_congruential < _Seed_t, 40014U, 0U, 2147483563U > _Lc ( _Gx == 0U ? default_seed : _Gx );
        _Reset ( _Lc, _Readcy );
    }

    template < class _Gen >
    void _Seed ( _Gen & _Gx, bool _Readcy, false_type ) {
        _Reset ( _Gx, _Readcy );
    }

    template < class _Gen >
    void _Reset ( _Gen & _Gx, bool _Readcy ) {
        _Carry = _Swc_Traits :: _Reset ( _Gx, this -> _Ax, _Readcy );
        this -> _Idx = _Rx;
    }

    void _Setx ( size_t _Ix, _Ty _Xis, _Ty _Xir ) {
        bool _Underflowed = false;
        _Ty _Newx = _Xis;
        if ( _Newx < _Xir ) {
            _Underflowed = true;
        }

        _Newx -= _Xir;
        if ( _Newx < static_cast < typename _Swc_Traits :: _UCy_t > ( _Carry ) ) {
            _Underflowed = true;
        }

        _Newx -= _Carry;
        if ( _Underflowed ) {
            _Newx += _Swc_Traits :: _Mod;
            _Carry = _Swc_Traits :: _Cy;
        } else {
            _Carry = 0;
        }

        this -> _Ax [ _Ix ] = _Newx;
    }

    typename _Swc_Traits :: _Cy_t _Carry;
};
#line 721
template < class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits >
[ [ nodiscard ] ] bool operator == (
    const _Swc_base < _Ty, _Sx, _Rx, _Swc_Traits > & _Left, const _Swc_base < _Ty, _Sx, _Rx, _Swc_Traits > & _Right ) {
    return _Left . _Equals ( _Right );
}
#line 727
template < class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits >
[ [ nodiscard ] ] bool operator != (
    const _Swc_base < _Ty, _Sx, _Rx, _Swc_Traits > & _Left, const _Swc_base < _Ty, _Sx, _Rx, _Swc_Traits > & _Right ) {
    return ! _Left . _Equals ( _Right );
}
#line 733
template < class _Elem, class _Traits, class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits >
basic_istream < _Elem, _Traits > & operator >> (
    basic_istream < _Elem, _Traits > & _Istr, _Swc_base < _Ty, _Sx, _Rx, _Swc_Traits > & _Eng ) {
    _Wrap_istream < _Elem, _Traits, typename _Swc_Traits :: _Seed_t > _Gen ( _Istr );
    _Eng . seed ( _Gen, true );
    return _Istr;
}
#line 741
template < class _Elem, class _Traits, class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits >
basic_ostream < _Elem, _Traits > & operator << (
    basic_ostream < _Elem, _Traits > & _Ostr, const _Swc_base < _Ty, _Sx, _Rx, _Swc_Traits > & _Eng ) {
    return _Eng . _Write ( _Ostr );
}
#line 747
template< class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits> constexpr const size_t _Swc_base< _Ty, _Sx, _Rx, _Swc_Traits> ::short_lag; 
#line 750
template< class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits> constexpr const size_t _Swc_base< _Ty, _Sx, _Rx, _Swc_Traits> ::long_lag; 
#line 753
template < class _Ty, _Ty _Mx, size_t _Nw >
struct _Swc_traits {
    using _Cy_t = int;
    using _UCy_t = unsigned int;
    using _Mod_t = _Ty;
    using _Seed_t = _Ty;

    static constexpr _Cy_t _Cy = 1;
    static constexpr _Mod_t _Mod = _Mx;
    static constexpr _Ty _Max = _Mx - 1;

    static int _Get_wc ( ) {
        int _Kx;

        if constexpr ( _Mx == 0 ) {
            _Kx = ( 8 * sizeof ( _Ty ) + 31 ) / 32;
        } else {
            unsigned long long _Val = 1Ui64 << 32;
            for ( _Kx = 1; 0 < _Val && _Val < _Mx; ++ _Kx ) {
                _Val = _Val << 32;
            }
        }

        return _Kx;
    }

    template < class _Gen >
    static _Cy_t _Reset ( _Gen & _Gx, _Ty * _Ax, bool _Readcy ) {


        int _Kx = _Get_wc ( );

        for ( size_t _Ix = 0; _Ix < _Nw; ++ _Ix ) {
            _Ax [ _Ix ] = _Gx ( );
            for ( int _Jx = 1; _Jx < _Kx; ++ _Jx ) {
                _Ax [ _Ix ] |= static_cast < _Ty > ( _Gx ( ) ) << ( 32 * _Jx );
            }
        }

        _Cy_t _Ans = _Reduce ( _Ax );
        if ( ! _Readcy ) {
            return _Ans;
        } else {
            return static_cast < _Cy_t > ( _Gx ( ) );
        }
    }

#pragma warning(push)
#pragma warning(disable : 4724)
    static _Cy_t _Reduce ( _Ty * _Ax ) {
        if constexpr ( _Mx != 0 ) {
            for ( size_t _Ix = 0; _Ix < _Nw; ++ _Ix ) {
                _Ax [ _Ix ] = _Ax [ _Ix ] % _Mx;
            }
        }

        return _Ax [ _Nw - 1 ] == 0;
    }
#pragma warning(pop)

    template < class _Elem, class _Traits >
    static void _Write (
        basic_ostream < _Elem, _Traits > & _Ostr, const _Circ_buf < _Ty, _Nw > & _Buf, _Cy_t _Cy ) {
        int _Kx = _Get_wc ( );

        for ( size_t _Ix = 0; _Ix < _Nw; ++ _Ix ) {
            for ( int _Jx = 1; _Jx <= _Kx; ++ _Jx ) {
                unsigned int _Word = static_cast < unsigned int > ( _Buf . _At ( _Ix ) >> ( ( _Kx - _Jx ) * 32 ) );
                _Ostr << _Word << ' ';
            }
        }

        _Ostr << _Cy;
    }
};
#line 829
template < class _Ty, _Ty _Mx, size_t _Sx, size_t _Rx >
class subtract_with_carry
    : public _Swc_base < _Ty, _Sx, _Rx, _Swc_traits < _Ty, _Mx, _Rx > > {
public :
    using _Mybase = _Swc_base < _Ty, _Sx, _Rx, _Swc_traits < _Ty, _Mx, _Rx >>;

    static constexpr _Ty modulus = _Mx;

    using _Mybase :: default_seed;

    subtract_with_carry ( ) : _Mybase ( default_seed ) { }

    explicit subtract_with_carry ( _Ty _Xx0 ) : _Mybase ( _Xx0 ) { }

    template < class _Gen, _Enable_if_seed_seq_t < _Gen, subtract_with_carry > = 0 >
    subtract_with_carry ( _Gen & _Gx ) : _Mybase ( _Gx ) { }
};
#line 847
template < class _Ty, size_t _Wx, size_t _Sx, size_t _Rx >
class subtract_with_carry_engine : public subtract_with_carry < _Ty, ( _Ty { 1 } << ( _Wx - 1 ) ) << 1, _Sx, _Rx > {

public :
    static_assert ( _Is_any_of_v < _Ty, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for subtract_with_carry_engine: N4659 29.6.1.1 [rand.req.genl]/1f requires one of unsigned short, unsi" "gned int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Ty > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    static_assert ( 0U < _Sx && _Sx < _Rx && 0 < _Wx && _Wx <= numeric_limits < _Ty > :: digits,
        "invalid template argument for subtract_with_carry_engine" );

    static constexpr _Ty _Mx = ( _Ty { 1 } << ( _Wx - 1 ) ) << 1;
    static constexpr size_t word_size = _Wx;
    static constexpr size_t short_lag = _Sx;
    static constexpr size_t long_lag = _Rx;

    using _Mybase = subtract_with_carry < _Ty, _Mx, _Sx, _Rx >;
    using _Traits = typename _Mybase :: _Traits;
    using result_type = _Ty;

    using _Mybase :: default_seed;

    subtract_with_carry_engine ( ) : _Mybase ( default_seed ) { }

    explicit subtract_with_carry_engine ( _Ty _Xx0 ) : _Mybase ( _Xx0 ) { }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, subtract_with_carry_engine > = 0 >
    explicit subtract_with_carry_engine ( _Seed_seq & _Seq ) : _Mybase ( ) {
        seed ( _Seq );
    }

    void seed ( _Ty _Value = default_seed ) {
        this -> _Seed ( _Value, false, true_type { } );
    }

    static constexpr int _Kx = ( 8 * sizeof ( _Ty ) + 31 ) / 32;

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, subtract_with_carry_engine > = 0 >
    void seed ( _Seed_seq & _Seq ) {
        unsigned long _Arr [ _Kx * _Rx ];
        _Seq . generate ( & _Arr [ 0 ], & _Arr [ _Kx * _Rx ] );

        size_t _Idx0 = 0;
        for ( size_t _Ix = 0; _Ix < _Rx; ++ _Ix, _Idx0 += _Kx ) {
            this -> _Ax [ _Ix ] = _Arr [ _Idx0 ];
            for ( int _Jx = 1; _Jx < _Kx; ++ _Jx ) {
                this -> _Ax [ _Ix ] |= static_cast < _Ty > ( _Arr [ _Idx0 + _Jx ] ) << ( 32 * _Jx );
            }

            constexpr bool _Mod_non_zero = _Traits :: _Mod != 0;
            if constexpr ( _Mod_non_zero ) {
                this -> _Ax [ _Ix ] %= _Traits :: _Mod;
            }
        }

        this -> _Carry = _Traits :: _Reduce ( this -> _Ax );
        this -> _Idx = _Rx;
    }

    [ [ nodiscard ] ] static constexpr _Ty ( min ) ( ) {
        return 0;
    }

    [ [ nodiscard ] ] static constexpr _Ty ( max ) ( ) {
        return _Mx - 1;
    }
};
#line 914
template< class _Ty, size_t _Wx, size_t _Rx> 
#line 915
struct _Swc_01_traits { 
#line 916
using _Cy_t = _Ty; 
#line 917
using _UCy_t = _Ty; 
#line 918
using _Mod_t = _Ty; 
#line 919
using _Seed_t = unsigned; 
#line 921
static const _Cy_t _Cy; 
#line 922
static const _Mod_t _Mod; 
#line 923
static const _Ty _Max; 
#line 924
static constexpr int _Nwords = ((_Wx + (31)) / (32)); 
#line 926
template < class _Gen >
    static _Cy_t _Reset ( _Gen & _Gx, _Ty * _Ax, bool _Readcy ) {


        for ( size_t _Ix = 0; _Ix < _Rx; ++ _Ix ) {
            _Ty _Factor = 1;
            _Ty _Val = 0;
            for ( int _Jx = 0; _Jx < _Nwords - 1; ++ _Jx ) {
                _Factor /= static_cast < _Ty > ( _Two32 );
                _Val += _Gx ( ) * _Factor;
            }
            _Ty _Temp = ( static_cast < unsigned long > ( _Gx ( ) ) & _Mask ) / _Scale1;
            _Val += ( _Temp - static_cast < unsigned long > ( _Temp ) ) * _Factor;
            _Ax [ _Ix ] = _Val;
        }
        if ( ! _Readcy ) {
            return _Ax [ _Rx - 1 ] != 0 ? 0 : _Cy;
        } else {
            return _Gx ( ) == 0 ? 0 : _Cy;
        }
    }
#line 948
template < class _Elem, class _Traits >
    static void _Write (
        basic_ostream < _Elem, _Traits > & _Ostr, const _Circ_buf < _Ty, _Rx > & _Buf, _Cy_t _Cy ) {
        for ( size_t _Ix = 0; _Ix < _Rx; ++ _Ix ) {
            _Ty _Val = _Buf . _At ( _Ix );
            unsigned long _Temp;
            for ( int _Jx = 0; _Jx < _Nwords - 1; ++ _Jx ) {
                _Val *= static_cast < _Ty > ( _Two32 );
                _Temp = static_cast < unsigned long > ( _Val );
                _Val -= _Temp;
                _Ostr << _Temp << ' ';
            }
            _Temp = static_cast < unsigned long > ( _Val * _Scale1 );
            _Ostr << _Temp << ' ';
        }
        _Ostr << ( _Cy ? 1 : 0 );
    }
#line 967
private: static const _Ty _Scale1; 
#line 968
static constexpr unsigned long _Mask = (~((~0UL) << (_Wx % (32)))); 
#line 969
}; 
#line 971
template< class _Ty, size_t _Wx, size_t _Rx> const typename _Swc_01_traits< _Ty, _Wx, _Rx> ::_Cy_t 
#line 973
_Swc_01_traits< _Ty, _Wx, _Rx> ::_Cy = static_cast< _Cy_t>(::ldexp((1.0), static_cast< int>(-(static_cast< ptrdiff_t>(_Wx))))); 
#line 976
template< class _Ty, size_t _Wx, size_t _Rx> const typename _Swc_01_traits< _Ty, _Wx, _Rx> ::_Mod_t 
#line 977
_Swc_01_traits< _Ty, _Wx, _Rx> ::_Mod = (1); 
#line 979
template< class _Ty, size_t _Wx, size_t _Rx> const _Ty 
#line 980
_Swc_01_traits< _Ty, _Wx, _Rx> ::_Max = (1); 
#line 982
template< class _Ty, size_t _Wx, size_t _Rx> const _Ty 
#line 983
_Swc_01_traits< _Ty, _Wx, _Rx> ::_Scale1 = static_cast< _Ty>(::ldexp((1.0), _Wx % (32))); 
#line 985
template < class _Ty, size_t _Wx, size_t _Sx, size_t _Rx >
class [ [ deprecated ( "warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning." ) ] ] subtract_with_carry_01
    : public _Swc_base < _Ty, _Sx, _Rx, _Swc_01_traits < _Ty, _Wx, _Rx > > {
public :
    static constexpr size_t word_size = _Wx;

    using _Mybase = _Swc_base < _Ty, _Sx, _Rx, _Swc_01_traits < _Ty, _Wx, _Rx >>;

    subtract_with_carry_01 ( ) : _Mybase ( ) { }

    explicit subtract_with_carry_01 ( typename _Mybase :: _Seed_t _Value ) : _Mybase ( _Value ) { }

    template < class _Gen, _Enable_if_seed_seq_t < _Gen, subtract_with_carry_01 > = 0 >
    subtract_with_carry_01 ( _Gen & _Gx ) : _Mybase ( _Gx ) { }
};
#line 1001
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 1002
template< class _Ty, size_t _Wx, size_t _Sx, size_t _Rx> constexpr const size_t subtract_with_carry_01< _Ty, _Wx, _Sx, _Rx> ::word_size; 
#line 1004
__pragma( warning(pop)) 
#line 1008 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
template < class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx, _Ty _Bx, int _Tx, _Ty _Cx, int _Lx >
class mersenne_twister : public _Circ_buf < _Ty, _Nx > {
public :
    using result_type = _Ty;

    static constexpr int word_size = _Wx;
    static constexpr int state_size = _Nx;
    static constexpr int shift_size = _Mx;
    static constexpr int mask_bits = _Rx;
    static constexpr _Ty parameter_a = _Px;
    static constexpr int output_u = _Ux;
    static constexpr int output_s = _Sx;
    static constexpr _Ty output_b = _Bx;
    static constexpr int output_t = _Tx;
    static constexpr _Ty output_c = _Cx;
    static constexpr int output_l = _Lx;

    static constexpr _Ty default_seed = 5489U;

    mersenne_twister ( ) : _Dxval ( _WMSK ) {
        seed ( default_seed, static_cast < _Ty > ( 1812433253 ) );
    }

    explicit mersenne_twister ( _Ty _Xx0, _Ty _Dxarg = _WMSK, _Ty _Fxarg = static_cast < _Ty > ( 1812433253 ) )
        : _Dxval ( _Dxarg ) {
        seed ( _Xx0, _Fxarg );
    }

    template < class _Gen, _Enable_if_seed_seq_t < _Gen, mersenne_twister > = 0 >
    explicit mersenne_twister ( _Gen & _Gx ) : _Dxval ( _WMSK ) {
        seed ( _Gx );
    }

    void seed ( _Ty _Xx0 = default_seed, _Ty _Fx = static_cast < _Ty > ( 1812433253 ) ) {

        _Ty _Prev = this -> _Ax [ 0 ] = _Xx0 & _WMSK;
        for ( size_t _Ix = 1; _Ix < _Nx; ++ _Ix ) {
            _Prev = this -> _Ax [ _Ix ] = ( _Ix + _Fx * ( _Prev ^ ( _Prev >> ( _Wx - 2 ) ) ) ) & _WMSK;
        }

        this -> _Idx = _Nx;
    }

    template < class _Gen, _Enable_if_seed_seq_t < _Gen, mersenne_twister > = 0 >
    void seed ( _Gen & _Gx, bool = false ) {
        for ( size_t _Ix = 0; _Ix < _Nx; ++ _Ix ) {
            this -> _Ax [ _Ix ] = _Gx ( ) & _WMSK;
        }

        this -> _Idx = _Nx;
    }

    template < class _Elem, class _S_Traits >
    basic_ostream < _Elem, _S_Traits > & _Write ( basic_ostream < _Elem, _S_Traits > & _Ostr ) const {
        for ( size_t _Ix = 0; _Ix < _Nx; ++ _Ix ) {
            _Ostr << this -> _At ( _Ix ) << ' ';
        }

        return _Ostr;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return _WMSK;
    }

    [ [ nodiscard ] ] result_type operator ( ) ( ) {
        if ( this -> _Idx == _Nx ) {
            _Refill_upper ( );
        } else if ( 2 * _Nx <= this -> _Idx ) {
            _Refill_lower ( );
        }

        _Ty _Res = this -> _Ax [ this -> _Idx ++ ] & _WMSK;
        _Res ^= ( _Res >> _Ux ) & _Dxval;
        _Res ^= ( _Res << _Sx ) & _Bx;
        _Res ^= ( _Res << _Tx ) & _Cx;
        _Res ^= ( _Res & _WMSK ) >> _Lx;
        return _Res;
    }

    void discard ( unsigned long long _Nskip ) {
        for (; 0 < _Nskip; -- _Nskip ) {
            ( void ) ( * this ) ( );
        }
    }

protected :


        void _Refill_lower ( ) {
        size_t _Ix;
        for ( _Ix = 0; _Ix < _Nx - _Mx; ++ _Ix ) {
            _Ty _Tmp = ( this -> _Ax [ _Ix + _Nx ] & _HMSK ) | ( this -> _Ax [ _Ix + _Nx + 1 ] & _LMSK );
            this -> _Ax [ _Ix ] = ( _Tmp >> 1 ) ^ ( _Tmp & 1 ? _Px : 0 ) ^ this -> _Ax [ _Ix + _Nx + _Mx ];
        }

        for (; _Ix < _Nx - 1; ++ _Ix ) {
            _Ty _Tmp = ( this -> _Ax [ _Ix + _Nx ] & _HMSK ) | ( this -> _Ax [ _Ix + _Nx + 1 ] & _LMSK );
            this -> _Ax [ _Ix ] = ( _Tmp >> 1 ) ^ ( _Tmp & 1 ? _Px : 0 ) ^ this -> _Ax [ _Ix - _Nx + _Mx ];
        }

        _Ty _Tmp = ( this -> _Ax [ _Ix + _Nx ] & _HMSK ) | ( this -> _Ax [ 0 ] & _LMSK );
        this -> _Ax [ _Ix ] = ( _Tmp >> 1 ) ^ ( _Tmp & 1 ? _Px : 0 ) ^ this -> _Ax [ _Mx - 1 ];
        this -> _Idx = 0;
    }

    void _Refill_upper ( ) {
        size_t _Ix;
        for ( _Ix = _Nx; _Ix < 2 * _Nx; ++ _Ix ) {
            _Ty _Tmp = ( this -> _Ax [ _Ix - _Nx ] & _HMSK ) | ( this -> _Ax [ _Ix - _Nx + 1 ] & _LMSK );
            this -> _Ax [ _Ix ] = ( _Tmp >> 1 ) ^ ( _Tmp & 1 ? _Px : 0 ) ^ this -> _Ax [ _Ix - _Nx + _Mx ];
        }
    }

    _Ty _Dxval;

    static constexpr _Ty _WMSK = ~ ( ( ~ _Ty { 0 } << ( _Wx - 1 ) ) << 1 );
    static constexpr _Ty _HMSK = ( _WMSK << _Rx ) & _WMSK;
    static constexpr _Ty _LMSK = ~ _HMSK & _WMSK;
};
#line 1133
template < class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx, _Ty _Bx, int _Tx, _Ty _Cx, int _Lx >
[ [ nodiscard ] ] bool operator == ( const mersenne_twister < _Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx > & _Left,
    const mersenne_twister < _Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx > & _Right ) {
    return _Left . _Equals ( _Right );
}
#line 1139
template < class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx, _Ty _Bx, int _Tx, _Ty _Cx, int _Lx >
[ [ nodiscard ] ] bool operator != ( const mersenne_twister < _Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx > & _Left,
    const mersenne_twister < _Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx > & _Right ) {
    return ! _Left . _Equals ( _Right );
}
#line 1145
template < class _Elem, class _S_Traits, class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx,
    _Ty _Bx, int _Tx, _Ty _Cx, int _Lx >
basic_istream < _Elem, _S_Traits > & operator >> ( basic_istream < _Elem, _S_Traits > & _Istr,
    mersenne_twister < _Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx > & _Eng ) {
    _Wrap_istream < _Elem, _S_Traits, _Ty > _Gen ( _Istr );
    _Eng . seed ( _Gen );
    return _Istr;
}
#line 1154
template < class _Elem, class _S_Traits, class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx,
    _Ty _Bx, int _Tx, _Ty _Cx, int _Lx >
basic_ostream < _Elem, _S_Traits > & operator << ( basic_ostream < _Elem, _S_Traits > & _Ostr,
    const mersenne_twister < _Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx > & _Eng ) {
    return _Eng . _Write ( _Ostr );
}
#line 1161
template < class _Ty, size_t _Wx, size_t _Nx, size_t _Mx, size_t _Rx, _Ty _Px, size_t _Ux, _Ty _Dx, size_t _Sx, _Ty _Bx,
    size_t _Tx, _Ty _Cx, size_t _Lx, _Ty _Fx >
class mersenne_twister_engine : public mersenne_twister < _Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx > {
public :
    static constexpr unsigned long long _Max = ( ( ( 1Ui64 << ( _Wx - 1 ) ) - 1 ) << 1 ) + 1;

    static_assert ( _Is_any_of_v < _Ty, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for mersenne_twister_engine: N4659 29.6.1.1 [rand.req.genl]/1f requires one of unsigned short, unsigne" "d int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Ty > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    static_assert ( 0 < _Mx && _Mx <= _Nx && 2U < _Wx && _Rx <= _Wx && _Ux <= _Wx && _Sx <= _Wx && _Tx <= _Wx
                      && _Lx <= _Wx && _Wx <= numeric_limits < _Ty > :: digits && _Px <= _Max && _Bx <= _Max && _Cx <= _Max
                      && _Dx <= _Max && _Fx <= _Max,
        "invalid template argument for mersenne_twister_engine" );

    using _Mybase = mersenne_twister < _Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx >;
    using result_type = _Ty;

    static constexpr size_t word_size = _Wx;
    static constexpr size_t state_size = _Nx;
    static constexpr size_t shift_size = _Mx;
    static constexpr size_t mask_bits = _Rx;
    static constexpr _Ty xor_mask = _Px;
    static constexpr size_t tempering_u = _Ux;
    static constexpr _Ty tempering_d = _Dx;
    static constexpr size_t tempering_s = _Sx;
    static constexpr _Ty tempering_b = _Bx;
    static constexpr size_t tempering_t = _Tx;
    static constexpr _Ty tempering_c = _Cx;
    static constexpr size_t tempering_l = _Lx;
    static constexpr _Ty initialization_multiplier = _Fx;

    static constexpr result_type default_seed = 5489U;

    mersenne_twister_engine ( ) : _Mybase ( default_seed, _Dx, _Fx ) { }

    explicit mersenne_twister_engine ( result_type _Xx0 ) : _Mybase ( _Xx0, _Dx, _Fx ) { }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, mersenne_twister_engine > = 0 >
    explicit mersenne_twister_engine ( _Seed_seq & _Seq ) : _Mybase ( default_seed, _Dx, _Fx ) {
        seed ( _Seq );
    }

    void seed ( result_type _Xx0 = default_seed ) {
        _Mybase :: seed ( _Xx0, _Fx );
    }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, mersenne_twister_engine > = 0 >
    void seed ( _Seed_seq & _Seq ) {
        constexpr int _Kx = ( _Wx + 31 ) / 32;
        unsigned long _Arr [ _Kx * _Nx ];
        _Seq . generate ( & _Arr [ 0 ], & _Arr [ _Kx * _Nx ] );

        int _Idx0 = 0;
        _Ty _Sum = 0;
        for ( size_t _Ix = 0; _Ix < _Nx; ++ _Ix, _Idx0 += _Kx ) {
            this -> _Ax [ _Ix ] = _Arr [ _Idx0 ];
            for ( int _Jx = 1; _Jx < _Kx; ++ _Jx ) {
                this -> _Ax [ _Ix ] |= static_cast < _Ty > ( _Arr [ _Idx0 + _Jx ] ) << ( 32 * _Jx );
            }

            this -> _Ax [ _Ix ] &= this -> _WMSK;

            if ( _Ix == 0 ) {
                _Sum = this -> _Ax [ _Ix ] >> _Rx;
            } else {
                _Sum |= this -> _Ax [ _Ix ];
            }
        }

        if ( _Sum == 0 ) {
            this -> _Ax [ 0 ] = this -> _WMSK;
        }

        this -> _Idx = _Nx;
    }

    [ [ nodiscard ] ] static constexpr result_type ( min ) ( ) {
        return 0;
    }

    [ [ nodiscard ] ] static constexpr result_type ( max ) ( ) {
        return _Mybase :: _WMSK;
    }
};
#line 1245
template < class _Engine, int _Px, int _Rx >
class discard_block {
public :
    using base_type = _Engine;
    using result_type = typename _Engine :: result_type;

    static constexpr int block_size = _Px;
    static constexpr int used_block = _Rx;

    discard_block ( ) : _Eng ( ), _Nx ( 0 ) { }

    explicit discard_block ( const _Engine & _Ex ) : _Eng ( _Ex ), _Nx ( 0 ) { }

    explicit discard_block ( result_type _Seed ) : _Eng ( _Seed ), _Nx ( 0 ) { }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, discard_block, _Engine > = 0 >
    explicit discard_block ( _Seed_seq & _Seq ) : _Eng ( _Seq ), _Nx ( 0 ) { }

    void seed ( ) {
        _Eng . seed ( );
        _Nx = 0;
    }

    void seed ( result_type _Xx0 ) {
        _Eng . seed ( _Xx0 );
        _Nx = 0;
    }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, discard_block > = 0 >
    void seed ( _Seed_seq & _Seq ) {
        _Eng . seed ( _Seq );
        _Nx = 0;
    }

    [ [ nodiscard ] ] const base_type & base ( ) const noexcept {
        return _Eng;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return ( _Eng . min ) ( );
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return ( _Eng . max ) ( );
    }

    [ [ nodiscard ] ] result_type operator ( ) ( ) {
        if ( _Rx <= _Nx ) {
            while ( _Nx ++ < _Px ) {
                ( void ) _Eng ( );
            }

            _Nx = 0;
        }
        ++ _Nx;
        return _Eng ( );
    }

    void discard ( unsigned long long _Nskip ) {
        for (; 0 < _Nskip; -- _Nskip ) {
            ( void ) ( * this ) ( );
        }
    }

    bool _Equals ( const discard_block & _Right ) const {
        return _Eng == _Right . _Eng && _Nx == _Right . _Nx;
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        return _Istr >> _Eng >> _Nx;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        return _Ostr << _Eng << ' ' << _Nx;
    }

private :
    base_type _Eng;
    int _Nx;
};
#line 1328
template< class _Engine, int _Px, int _Rx> constexpr const int discard_block< _Engine, _Px, _Rx> ::block_size; 
#line 1331
template< class _Engine, int _Px, int _Rx> constexpr const int discard_block< _Engine, _Px, _Rx> ::used_block; 
#line 1334
template < class _Engine, int _Px, int _Rx >
[ [ nodiscard ] ] bool operator == (
    const discard_block < _Engine, _Px, _Rx > & _Left, const discard_block < _Engine, _Px, _Rx > & _Right ) {
    return _Left . _Equals ( _Right );
}
#line 1340
template < class _Engine, int _Px, int _Rx >
[ [ nodiscard ] ] bool operator != (
    const discard_block < _Engine, _Px, _Rx > & _Left, const discard_block < _Engine, _Px, _Rx > & _Right ) {
    return ! ( _Left == _Right );
}
#line 1346
template < class _Elem, class _Traits, class _Engine, int _Px, int _Rx >
basic_istream < _Elem, _Traits > & operator >> (
    basic_istream < _Elem, _Traits > & _Istr, discard_block < _Engine, _Px, _Rx > & _Eng ) {
    return _Eng . _Read ( _Istr );
}
#line 1352
template < class _Elem, class _Traits, class _Engine, int _Px, int _Rx >
basic_ostream < _Elem, _Traits > & operator << (
    basic_ostream < _Elem, _Traits > & _Ostr, const discard_block < _Engine, _Px, _Rx > & _Eng ) {
    return _Eng . _Write ( _Ostr );
}
#line 1358
template < class _Engine, size_t _Px, size_t _Rx >
class discard_block_engine : public discard_block < _Engine, _Px, _Rx > {
public :
    static_assert ( 0 < _Rx && _Rx <= _Px, "invalid template argument for discard_block_engine" );

    using _Mybase = discard_block < _Engine, _Px, _Rx >;
    using result_type = typename _Engine :: result_type;

    discard_block_engine ( ) : _Mybase ( ) { }

    explicit discard_block_engine ( const _Engine & _Ex ) : _Mybase ( _Ex ) { }

    explicit discard_block_engine ( _Engine && _Ex ) : _Mybase ( :: std :: move ( _Ex ) ) { }

    explicit discard_block_engine ( result_type _Xx0 ) : _Mybase ( _Xx0 ) { }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, discard_block_engine, _Engine > = 0 >
    explicit discard_block_engine ( _Seed_seq & _Seq ) : _Mybase ( _Seq ) { }

    [ [ nodiscard ] ] static constexpr typename _Engine :: result_type ( min ) ( ) {
        return ( _Engine :: min ) ( );
    }

    [ [ nodiscard ] ] static constexpr typename _Engine :: result_type ( max ) ( ) {
        return ( _Engine :: max ) ( );
    }
};
#line 1386
template < class _Engine, size_t _Wx, class _UIntType >
class independent_bits_engine {
public :
    static_assert ( _Is_any_of_v < _UIntType, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for independent_bits_engine: N4659 29.6.1.1 [rand.req.genl]/1f requires one of unsigned short, unsigne" "d int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _UIntType > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    static_assert (
        0 < _Wx && _Wx <= numeric_limits < _UIntType > :: digits, "invalid template argument for independent_bits_engine" );

    using base_type = _Engine;
    using result_type = _UIntType;
    using _Eres = typename _Engine :: result_type;

    independent_bits_engine ( ) {
        _Init ( );
    }

    explicit independent_bits_engine ( const _Engine & _Ex ) : _Eng ( _Ex ) {
        _Init ( );
    }

    explicit independent_bits_engine ( _Engine && _Ex ) : _Eng ( :: std :: move ( _Ex ) ) {
        _Init ( );
    }

    explicit independent_bits_engine ( result_type _Xx0 ) : _Eng ( static_cast < _Eres > ( _Xx0 ) ) {
        _Init ( );
    }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, independent_bits_engine, _Engine > = 0 >
    explicit independent_bits_engine ( _Seed_seq & _Seq ) : _Eng ( _Seq ) {
        _Init ( );
    }

    void seed ( ) {
        _Eng . seed ( );
    }

    void seed ( result_type _Xx0 ) {
        _Eng . seed ( static_cast < _Eres > ( _Xx0 ) );
    }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, independent_bits_engine > = 0 >
    void seed ( _Seed_seq & _Seq ) {
        _Eng . seed ( _Seq );
    }

    [ [ nodiscard ] ] const _Engine & base ( ) const noexcept {
        return _Eng;
    }

    [ [ nodiscard ] ] static constexpr result_type ( min ) ( ) {
        return 0;
    }

    [ [ nodiscard ] ] static constexpr result_type ( max ) ( ) {
        return ( ( result_type { 1 } << ( _Wx - 1 ) ) << 1 ) - 1;
    }

    [ [ nodiscard ] ] result_type operator ( ) ( ) {
        size_t _Idx = 0;
        result_type _Res = 0;
        result_type _Mask = ( ( result_type { 1 } << ( _Wx0 - 1 ) ) << 1 ) - 1;
        _Eres _Val;

        for (; _Idx < _Nx0; ++ _Idx ) {
            for (;; ) {
                _Val = _Eng ( ) - ( _Engine :: min ) ( );
                if ( _Val <= _Yx0 ) {
                    break;
                }
            }
            _Res = _Res << _Wx0 | ( static_cast < result_type > ( _Val ) & _Mask );
        }

        _Mask = _Mask << 1 | 1;
        for (; _Idx < _Nx; ++ _Idx ) {
            for (;; ) {
                _Val = _Eng ( ) - ( _Engine :: min ) ( );
                if ( _Val <= _Yx1 ) {
                    break;
                }
            }
            _Res = _Res << ( _Wx0 + 1 ) | ( static_cast < result_type > ( _Val ) & _Mask );
        }
        return _Res;
    }

    void discard ( unsigned long long _Nskip ) {
        for (; 0 < _Nskip; -- _Nskip ) {
            ( void ) ( * this ) ( );
        }
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        return _Istr >> _Eng;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        return _Ostr << _Eng;
    }

private :
    void _Init ( ) {
        size_t _Mx = 0;
        _Eres _Rx = ( _Engine :: max ) ( ) - ( _Engine :: min ) ( ) + 1;

        _Eres _Tmp = _Rx;
        if ( _Tmp == 0 ) {
            _Mx = 1;
            -- _Tmp;
        }
        for (; 1 < _Tmp; _Tmp >>= 1 ) {
            ++ _Mx;
        }

        for ( size_t _Nfix = 0;; ++ _Nfix ) {
            _Nx = ( _Wx + _Mx - 1 ) / _Mx + _Nfix;
            _Wx0 = _Wx / _Nx;
            _Nx0 = _Nx - _Wx % _Nx;
            _Yx0 = ( _Rx >> _Wx0 ) << _Wx0;
            _Yx1 = ( ( ( _Rx >> _Wx0 ) >> 1 ) << _Wx0 ) << 1;
            if ( _Nfix == 1 || _Rx - _Yx0 <= _Yx0 / _Nx ) {
                break;
            }
        }
        -- _Yx0;
        -- _Yx1;
    }

    _Engine _Eng;
    size_t _Nx0;
    size_t _Nx;
    size_t _Wx0;
    _Eres _Yx0;
    _Eres _Yx1;
};
#line 1525
template < class _Engine, size_t _Wx, class _UIntType >
[ [ nodiscard ] ] bool operator == ( const independent_bits_engine < _Engine, _Wx, _UIntType > & _Left,
    const independent_bits_engine < _Engine, _Wx, _UIntType > & _Right ) {
    return _Left . base ( ) == _Right . base ( );
}
#line 1531
template < class _Engine, size_t _Wx, class _UIntType >
[ [ nodiscard ] ] bool operator != ( const independent_bits_engine < _Engine, _Wx, _UIntType > & _Left,
    const independent_bits_engine < _Engine, _Wx, _UIntType > & _Right ) {
    return ! ( _Left == _Right );
}
#line 1537
template < class _Elem, class _Traits, class _Engine, size_t _Wx, class _UIntType >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    independent_bits_engine < _Engine, _Wx, _UIntType > & _Eng ) {
    return _Eng . _Read ( _Istr );
}
#line 1543
template < class _Elem, class _Traits, class _Engine, size_t _Wx, class _UIntType >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const independent_bits_engine < _Engine, _Wx, _UIntType > & _Eng ) {
    return _Eng . _Write ( _Ostr );
}
#line 1549
template < class _Engine, size_t _Kx >
class shuffle_order_engine {
public :
    static_assert ( 0 < _Kx, "invalid template argument for shuffle_order_engine" );

    using base_type = _Engine;
    using result_type = typename _Engine :: result_type;

    static constexpr size_t table_size = _Kx;

    shuffle_order_engine ( ) {
        _Init ( );
    }

    explicit shuffle_order_engine ( const _Engine & _Ex ) : _Eng ( _Ex ) {
        _Init ( );
    }

    explicit shuffle_order_engine ( _Engine && _Ex ) : _Eng ( :: std :: move ( _Ex ) ) {
        _Init ( );
    }

    explicit shuffle_order_engine ( result_type _Xx0 ) : _Eng ( _Xx0 ) {
        _Init ( );
    }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, shuffle_order_engine, _Engine > = 0 >
    explicit shuffle_order_engine ( _Seed_seq & _Seq ) : _Eng ( _Seq ) {
        _Init ( );
    }

    void seed ( ) {
        _Eng . seed ( );
        _Init ( );
    }

    void seed ( result_type _Xx0 ) {
        _Eng . seed ( _Xx0 );
        _Init ( );
    }

    template < class _Seed_seq, _Enable_if_seed_seq_t < _Seed_seq, shuffle_order_engine > = 0 >
    void seed ( _Seed_seq & _Seq ) {
        _Eng . seed ( _Seq );
        _Init ( );
    }

    [ [ nodiscard ] ] const _Engine & base ( ) const noexcept {
        return _Eng;
    }

    [ [ nodiscard ] ] static constexpr result_type ( min ) ( ) {
        return ( _Engine :: min ) ( );
    }

    [ [ nodiscard ] ] static constexpr result_type ( max ) ( ) {
        return ( _Engine :: max ) ( );
    }

    [ [ nodiscard ] ] result_type operator ( ) ( ) {
        size_t _Idx = static_cast < size_t > ( static_cast < double > ( _Yx - ( _Eng . min ) ( ) ) * _Scale );

        _Yx = _Arr [ _Idx ];
        _Arr [ _Idx ] = _Eng ( );
        return _Yx;
    }

    void discard ( unsigned long long _Nskip ) {
        for (; 0 < _Nskip; -- _Nskip ) {
            ( void ) ( * this ) ( );
        }
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Istr >> _Eng;
        for ( size_t _Idx = 0; _Idx < _Kx; ++ _Idx ) {
            _Istr >> _Arr [ _Idx ];
        }

        return _Istr >> _Yx;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Ostr << _Eng;
        for ( size_t _Idx = 0; _Idx < _Kx; ++ _Idx ) {
            _Ostr << ' ' << _Arr [ _Idx ];
        }

        return _Ostr << ' ' << _Yx;
    }

private :
    void _Init ( ) {
        for ( size_t _Idx = 0; _Idx < _Kx; ++ _Idx ) {
            _Arr [ _Idx ] = _Eng ( );
        }

        _Yx = _Eng ( );
        _Scale =
            static_cast < double > ( _Kx ) / ( static_cast < double > ( ( _Eng . max ) ( ) ) - static_cast < double > ( ( _Eng . min ) ( ) ) + (1.0) );
    }

    _Engine _Eng;
    result_type _Arr [ _Kx ];
    result_type _Yx;
    double _Scale;
};
#line 1659
template < class _Engine, size_t _Kx >
[ [ nodiscard ] ] bool operator == (
    const shuffle_order_engine < _Engine, _Kx > & _Left, const shuffle_order_engine < _Engine, _Kx > & _Right ) {
    return _Left . base ( ) == _Right . base ( );
}
#line 1665
template < class _Engine, size_t _Kx >
[ [ nodiscard ] ] bool operator != (
    const shuffle_order_engine < _Engine, _Kx > & _Left, const shuffle_order_engine < _Engine, _Kx > & _Right ) {
    return ! ( _Left == _Right );
}
#line 1671
template < class _Elem, class _Traits, class _Engine, size_t _Kx >
basic_istream < _Elem, _Traits > & operator >> (
    basic_istream < _Elem, _Traits > & _Istr, shuffle_order_engine < _Engine, _Kx > & _Eng ) {
    return _Eng . _Read ( _Istr );
}
#line 1677
template < class _Elem, class _Traits, class _Engine, size_t _Kx >
basic_ostream < _Elem, _Traits > & operator << (
    basic_ostream < _Elem, _Traits > & _Ostr, const shuffle_order_engine < _Engine, _Kx > & _Eng ) {
    return _Eng . _Write ( _Ostr );
}
#line 1683
template < class _Ty = int >
class uniform_int {
public :
    using result_type = _Ty;

    struct param_type {
        using distribution_type = uniform_int;

        param_type ( ) {
            _Init ( 0, 9 );
        }

        explicit param_type ( result_type _Min0, result_type _Max0 = 9 ) {
            _Init ( _Min0, _Max0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Min == _Right . _Min && _Max == _Right . _Max;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] result_type a ( ) const {
            return _Min;
        }

        [ [ nodiscard ] ] result_type b ( ) const {
            return _Max;
        }

        void _Init ( _Ty _Min0, _Ty _Max0 ) {
            ;
            _Min = _Min0;
            _Max = _Max0;
        }

        result_type _Min;
        result_type _Max;
    };

    uniform_int ( ) : _Par ( 0, 9 ) { }

    explicit uniform_int ( _Ty _Min0, _Ty _Max0 = 9 ) : _Par ( _Min0, _Max0 ) { }

    explicit uniform_int ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] result_type a ( ) const {
        return _Par . a ( );
    }

    [ [ nodiscard ] ] result_type b ( ) const {
        return _Par . b ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return _Par . _Min;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return _Par . _Max;
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par . _Min, _Par . _Max );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 . _Min, _Par0 . _Max );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, result_type _Nx ) const {
        return _Eval ( _Eng, 0, _Nx - 1 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Min0;
        _Ty _Max0;
        _Istr >> _Min0 >> _Max0;
        _Par . _Init ( _Min0, _Max0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        return _Ostr << _Par . _Min << ' ' << _Par . _Max;
    }

private :
    using _Uty = make_unsigned_t < _Ty >;

    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, _Ty _Min, _Ty _Max ) const {
        _Rng_from_urng < _Uty, _Engine > _Generator ( _Eng );

        const _Uty _Umin = _Adjust ( static_cast < _Uty > ( _Min ) );
        const _Uty _Umax = _Adjust ( static_cast < _Uty > ( _Max ) );

        _Uty _Uret;

        if ( _Umax - _Umin == static_cast < _Uty > ( - 1 ) ) {
            _Uret = static_cast < _Uty > ( _Generator . _Get_all_bits ( ) );
        } else {
            _Uret = static_cast < _Uty > ( _Generator ( static_cast < _Uty > ( _Umax - _Umin + 1 ) ) );
        }

        return static_cast < _Ty > ( _Adjust ( static_cast < _Uty > ( _Uret + _Umin ) ) );
    }

    static _Uty _Adjust ( _Uty _Uval ) {
        if constexpr ( is_signed_v < _Ty > ) {
            const _Uty _Adjuster = ( static_cast < _Uty > ( - 1 ) >> 1 ) + 1;

            if ( _Uval < _Adjuster ) {
                return static_cast < _Uty > ( _Uval + _Adjuster );
            } else {
                return static_cast < _Uty > ( _Uval - _Adjuster );
            }
        } else {
            return _Uval;
        }
    }

    param_type _Par;
};
#line 1824
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    uniform_int < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 1830
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const uniform_int < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 1836
template < class _Ty = int >
class uniform_int_distribution : public uniform_int < _Ty > {
public :
    static_assert ( _Is_any_of_v < _Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for uniform_int_distribution: N4659 29.6.1.1 [rand.req.genl]/1e requires one of short, int, long, long" " long, unsigned short, unsigned int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Ty > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    using _Mybase = uniform_int < _Ty >;
    using _Mypbase = typename _Mybase :: param_type;
    using result_type = typename _Mybase :: result_type;

    struct param_type : _Mypbase {
        using distribution_type = uniform_int_distribution;

        param_type ( ) : _Mypbase ( 0, ( numeric_limits < _Ty > :: max ) ( ) ) { }

        explicit param_type ( result_type _Min0, result_type _Max0 = ( numeric_limits < _Ty > :: max ) ( ) )
            : _Mypbase ( _Min0, _Max0 ) { }

        param_type ( const _Mypbase & _Right ) : _Mypbase ( _Right ) { }
    };

    uniform_int_distribution ( ) : _Mybase ( 0, ( numeric_limits < _Ty > :: max ) ( ) ) { }

    explicit uniform_int_distribution ( _Ty _Min0, _Ty _Max0 = ( numeric_limits < _Ty > :: max ) ( ) ) : _Mybase ( _Min0, _Max0 ) { }

    explicit uniform_int_distribution ( const param_type & _Par0 ) : _Mybase ( _Par0 ) { }
};
#line 1863
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const uniform_int_distribution < _Ty > & _Left, const uniform_int_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 1868
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const uniform_int_distribution < _Ty > & _Left, const uniform_int_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 1873
class bernoulli_distribution { 
#line 1875
public: using result_type = bool; 
#line 1877
struct param_type { 
#line 1878
using distribution_type = bernoulli_distribution; 
#line 1880
param_type() { 
#line 1881
this->_Init((0.5)); 
#line 1882
} 
#line 1884
explicit param_type(double _Px0) { 
#line 1885
this->_Init(_Px0); 
#line 1886
} 
#line 1888
[[nodiscard]] bool operator==(const param_type &_Right) const { 
#line 1889
return (_Px) == (_Right._Px); 
#line 1890
} 
#line 1892
[[nodiscard]] bool operator!=(const param_type &_Right) const { 
#line 1893
return !((*this) == _Right); 
#line 1894
} 
#line 1896
[[nodiscard]] double p() const { 
#line 1897
return _Px; 
#line 1898
} 
#line 1900
void _Init(double _Px0) { 
#line 1901
; 
#line 1903
(_Px) = _Px0; 
#line 1904
} 
#line 1906
double _Px; 
#line 1907
}; 
#line 1909
bernoulli_distribution() : _Par((0.5)) { } 
#line 1911
explicit bernoulli_distribution(double _Px0) : _Par(_Px0) { } 
#line 1913
explicit bernoulli_distribution(const param_type &_Par0) : _Par(_Par0) { } 
#line 1915
[[nodiscard]] double p() const { 
#line 1916
return (_Par).p(); 
#line 1917
} 
#line 1919
[[nodiscard]] param_type param() const { 
#line 1920
return _Par; 
#line 1921
} 
#line 1923
void param(const param_type &_Par0) { 
#line 1924
(_Par) = _Par0; 
#line 1925
} 
#line 1927
[[nodiscard]] result_type min() const { 
#line 1928
return false; 
#line 1929
} 
#line 1931
[[nodiscard]] result_type max() const { 
#line 1932
return true; 
#line 1933
} 
#line 1935
void reset() { } 
#line 1937
template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }
#line 1942
template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }
#line 1947
template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        double _Px0;
        _In ( _Istr, _Px0 );
        _Par . _Init ( _Px0 );
        return _Istr;
    }
#line 1955
template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Px );
        return _Ostr;
    }
#line 1962
private: template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        return ( :: std :: generate_canonical < double, static_cast < size_t > ( - 1 ) > ( _Eng ) ) < _Par0 . _Px;
    }
#line 1967
param_type _Par; 
#line 1968
}; 
#line 1970
[[nodiscard]] inline bool operator==(const bernoulli_distribution &_Left, const bernoulli_distribution &_Right) { 
#line 1971
return ((_Left.param()) == (_Right.param())); 
#line 1972
} 
#line 1974
[[nodiscard]] inline bool operator!=(const bernoulli_distribution &_Left, const bernoulli_distribution &_Right) { 
#line 1975
return !(_Left == _Right); 
#line 1976
} 
#line 1978
template < class _Elem, class _Traits >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    bernoulli_distribution & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 1984
template < class _Elem, class _Traits >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const bernoulli_distribution & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 1994
template < class _Flt, class _Ty >
[ [ nodiscard ] ] _Flt _Float_upper_bound ( _Ty _Val ) {
    static_assert ( is_unsigned_v < _Ty > && is_integral_v < _Ty > && is_floating_point_v < _Flt >,
        "invalid template argument for _Float_upper_bound" );
    constexpr auto _Ty_digits = numeric_limits < _Ty > :: digits;
    constexpr auto _Flt_digits = numeric_limits < _Flt > :: digits;
    using _Ty_32or64 = conditional_t < _Ty_digits <= 32, uint32_t, uint64_t >;

    if constexpr ( _Ty_digits <= _Flt_digits ) {
        return static_cast < _Flt > ( _Val ) + _Flt { 1 };
    } else {
#pragma warning(push)
#pragma warning(disable : 4146 4293)
        constexpr auto _Mask = static_cast < _Ty > ( - 1 ) << ( _Ty_digits - _Flt_digits );




        const auto _Log_plus1 = _Bit_scan_reverse ( static_cast < _Ty_32or64 > ( _Val | _Ty { 1 } ) );

        const auto _Shifted_mask = _Mask >> ( _Ty_digits - _Log_plus1 );
        const auto _Ceil_ulp = _Shifted_mask & - _Shifted_mask;
        _Val &= _Shifted_mask;
        if ( _Val == _Mask ) {

            constexpr auto _Big_ulp = static_cast < _Flt > ( _Mask & - _Mask );
            return static_cast < _Flt > ( _Val ) + _Big_ulp;
        } else {
            return static_cast < _Flt > ( _Val + _Ceil_ulp );
        }
#pragma warning(pop)
    }
}
#line 2028 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
template < class _Ty = int >
class geometric_distribution {
public :
    using _Ty1 = double;

    using result_type = _Ty;

    static_assert ( _Is_any_of_v < _Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for geometric_distribution: N4659 29.6.1.1 [rand.req.genl]/1e requires one of short, int, long, long l" "ong, unsigned short, unsigned int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Ty > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    struct param_type {
        using distribution_type = geometric_distribution;

        param_type ( ) {
            _Init ( _Ty1 ( (0.5) ) );
        }

        explicit param_type ( _Ty1 _Px0 ) {
            _Init ( _Px0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Px == _Right . _Px;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty1 p ( ) const {
            return _Px;
        }

        void _Init ( _Ty1 _Px0 ) {
            ;
            _Px = _Px0;
            _Log_1_p = :: log ( 1 - _Px );
        }

        _Ty1 _Px;
        _Ty1 _Log_1_p;
    };

    geometric_distribution ( ) : _Par ( _Ty1 ( (0.5) ) ) { }

    explicit geometric_distribution ( _Ty1 _Px0 ) : _Par ( _Px0 ) { }

    explicit geometric_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty1 p ( ) const {
        return _Par . p ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return ( numeric_limits < result_type > :: max ) ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty1 _Px0;
        _In ( _Istr, _Px0 );
        _Par . _Init ( _Px0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Px );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        using _Uty = make_unsigned_t < _Ty >;
        constexpr auto _Ty_max { ( numeric_limits < _Ty > :: max ) ( ) };
        const auto _Ty1_max { _Float_upper_bound < _Ty1 > ( static_cast < _Uty > ( _Ty_max ) ) };

        _Ty1 _Val;
        do {
            _Val = :: log ( ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) ) ) / _Par0 . _Log_1_p;
        } while ( _Val >= _Ty1_max );
        return static_cast < _Ty > ( _Val );
    }

    param_type _Par;
};
#line 2139
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const geometric_distribution < _Ty > & _Left, const geometric_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 2144
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const geometric_distribution < _Ty > & _Left, const geometric_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 2149
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    geometric_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 2155
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const geometric_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 2161
template < class _Ty = int >
class _Small_poisson_distribution {
public :
    using _Ty1 = double;

    template < class _Engine >
    [ [ nodiscard ] ] _Ty operator ( ) ( _Engine & _Eng ) const {
        _Ty _Res;
        _Ty1 _Val;
        for ( _Res = 0, _Val = (1.0);; ++ _Res ) {
            _Val *= ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) );
            if ( _Val <= _Gx0 ) {
                break;
            }
        }
        return _Res;
    }

    void _Init ( const _Ty1 & _Mean0 ) {
        _Gx0 = :: exp ( - _Mean0 );
    }

private :
    _Ty1 _Gx0;
};
#line 2187
template < class _Ty = int >
class poisson_distribution {
public :
    using _Ty1 = double;

    using result_type = _Ty;

    static_assert ( _Is_any_of_v < _Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for poisson_distribution: N4659 29.6.1.1 [rand.req.genl]/1e requires one of short, int, long, long lon" "g, unsigned short, unsigned int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Ty > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    struct param_type {
        using distribution_type = poisson_distribution;

        param_type ( ) {
            _Init ( _Ty1 ( 1 ) );
        }

        explicit param_type ( _Ty1 _Mean0 ) {
            _Init ( _Mean0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Mean == _Right . _Mean;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty1 mean ( ) const {
            return _Mean;
        }

        void _Init ( _Ty1 _Mean0 ) {
            ;
            _Mean = _Mean0;
            _Sqrt = :: sqrt ( (2.0) * _Mean0 );
            _Logm = :: log ( _Mean0 );
            _Gx1 = _Mean0 * _Logm - _XLgamma ( _Mean0 + (1.0) );
            _Small . _Init ( _Mean0 );
        }

        _Ty1 _Mean;
        _Ty1 _Sqrt;
        _Ty1 _Logm;
        _Ty1 _Gx1;

        _Small_poisson_distribution < _Ty > _Small;
    };

    poisson_distribution ( ) : _Par ( _Ty1 ( 1 ) ) { }

    explicit poisson_distribution ( _Ty1 _Mean0 ) : _Par ( _Mean0 ) { }

    explicit poisson_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty1 mean ( ) const {
        return _Par . mean ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return ( numeric_limits < result_type > :: max ) ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty1 _Mean0;
        _In ( _Istr, _Mean0 );
        _Par . _Init ( _Mean0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Mean );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        if ( _Par0 . _Mean < (12.0) ) {
            return _Par0 . _Small ( _Eng );
        }

        for (;; ) {
            using _Uty = make_unsigned_t < _Ty >;
            constexpr auto _Ty_max { ( numeric_limits < _Ty > :: max ) ( ) };
            const auto _Ty1_max { _Float_upper_bound < _Ty1 > ( static_cast < _Uty > ( _Ty_max ) ) };

            _Ty _Res;
            _Ty1 _Yx;
            for (;; ) {
                _Yx = static_cast < _Ty1 > ( :: tan ( _Pi * ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) ) ) );
                const _Ty1 _Mx { _Par0 . _Sqrt * _Yx + _Par0 . _Mean };
                if ( (0.0) <= _Mx && _Mx < _Ty1_max ) {
                    _Res = static_cast < _Ty > ( _Mx );
                    break;
                }
            }

            if ( ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) )
                <= (0.9000000000000000222) * ( (1.0) + _Yx * _Yx ) * :: exp ( _Res * _Par0 . _Logm - _XLgamma ( _Res + (1.0) ) - _Par0 . _Gx1 ) ) {
                return _Res;
            }
        }
    }

    param_type _Par;
};
#line 2321
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const poisson_distribution < _Ty > & _Left, const poisson_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 2326
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const poisson_distribution < _Ty > & _Left, const poisson_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 2331
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    poisson_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 2337
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const poisson_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 2343
template < class _Ty = int >
class binomial_distribution {
public :
    using _Ty1 = double;

    using result_type = _Ty;

    static_assert ( _Is_any_of_v < _Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for binomial_distribution: N4659 29.6.1.1 [rand.req.genl]/1e requires one of short, int, long, long lo" "ng, unsigned short, unsigned int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Ty > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    struct param_type {
        using distribution_type = binomial_distribution;

        param_type ( ) {
            _Init ( 1, _Ty1 ( (0.5) ) );
        }

        explicit param_type ( _Ty _Tx0, _Ty1 _Px0 = _Ty1 ( (0.5) ) ) {
            _Init ( _Tx0, _Px0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Tx == _Right . _Tx && _Px == _Right . _Px;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty t ( ) const {
            return _Tx;
        }

        [ [ nodiscard ] ] _Ty1 p ( ) const {
            return _Px;
        }

        void _Init ( _Ty _Tx0, _Ty1 _Px0 ) {
            ;
            ;
            _Tx = _Tx0;
            _Px = _Px0;
            _Pp = _Px < (0.5) ? _Px : ( (1.0) - _Px );
            _Mean = _Tx * _Pp;
            _Gx1 = _XLgamma ( _Tx + (1.0) );
            _Sqrt = :: sqrt ( 2 * _Mean * ( 1 - _Pp ) );
            _Logp = :: log ( _Pp );
            _Logp1 = :: log ( (1.0) - _Pp );
            _Small . _Init ( _Mean );
        }

        _Ty _Tx;
        _Ty1 _Px;
        _Ty1 _Pp;
        _Ty1 _Mean;
        _Ty1 _Gx1;
        _Ty1 _Sqrt;
        _Ty1 _Logp;
        _Ty1 _Logp1;

        _Small_poisson_distribution < _Ty > _Small;
    };

    binomial_distribution ( ) : _Par ( 1, _Ty1 ( (0.5) ) ) { }

    explicit binomial_distribution ( _Ty _Tx0, _Ty1 _Px0 = _Ty1 ( (0.5) ) ) : _Par ( _Tx0, _Px0 ) { }

    explicit binomial_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty t ( ) const {
        return _Par . t ( );
    }

    [ [ nodiscard ] ] _Ty1 p ( ) const {
        return _Par . p ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return _Par . t ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Tx0;
        _Ty1 _Px0;
        _In ( _Istr, _Px0 );
        _In ( _Istr, _Tx0 );
        _Par . _Init ( _Tx0, _Px0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Px );
        _Out ( _Ostr, _Par . _Tx );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval (
        _Engine & _Eng, const param_type & _Par0 ) const {
        _Ty _Res;
        if ( _Par0 . _Tx < 25 ) {
            _Res = 0;
            for ( _Ty _Ix = 0; _Ix < _Par0 . _Tx; ++ _Ix ) {
                if ( ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) ) < _Par0 . _Px ) {
                    ++ _Res;
                }
            }

            return _Res;
        } else if ( _Par0 . _Mean < (1.0) ) {

            const _Ty1 _Rand = ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) );






            const _Ty1 _Ub =
                ( :: std :: min ) ( _Par0 . _Mean, _Ty1 { (0.367879441171442334) } * _Par0 . _Pp + _Ty1 { (0.632120558828557666) } );
            if ( _Rand > _Ub ) {
                _Res = _Ty { 0 };
            } else {
                _Ty _Denom = _Par0 . _Tx;
                _Ty1 _Sum = :: log ( _Ty1 { (1.0) } - _Rand ) / _Denom;
                while ( _Sum >= _Par0 . _Logp1 && -- _Denom != 0 ) {
                    _Sum += :: log ( _Ty1 { (1.0) } - ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) ) ) / _Denom;
                }
                _Res = static_cast < _Ty > ( _Par0 . _Tx - _Denom );
            }
        } else {
            using _Uty = make_unsigned_t < _Ty >;
            const auto _Ty1_Tx { _Float_upper_bound < _Ty1 > ( static_cast < _Uty > ( _Par0 . _Tx ) ) };

            for (;; ) {
                _Ty1 _Yx;
                for (;; ) {
                    _Yx = static_cast < _Ty1 > ( :: tan ( _Pi * ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) ) ) );
                    const _Ty1 _Mx { _Par0 . _Sqrt * _Yx + _Par0 . _Mean };
                    if ( (0.0) <= _Mx && _Mx < _Ty1_Tx ) {
                        _Res = static_cast < _Ty > ( _Mx );
                        break;
                    }
                }
                if ( ( :: std :: generate_canonical < _Ty1, static_cast < size_t > ( - 1 ) > ( _Eng ) )
                    <= (1.199999999999999956) * _Par0 . _Sqrt * ( (1.0) + _Yx * _Yx )
                           * :: exp ( _Par0 . _Gx1 - _XLgamma ( _Res + (1.0) ) - _XLgamma ( _Par0 . _Tx - _Res + (1.0) )
                                       + _Res * _Par0 . _Logp + ( _Par0 . _Tx - _Res ) * _Par0 . _Logp1 ) ) {
                    break;
                }
            }
        }
        return _Par0 . _Px == _Par0 . _Pp ? _Res : static_cast < _Ty > ( _Par0 . _Tx - _Res );
    }

    param_type _Par;
};
#line 2527
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const binomial_distribution < _Ty > & _Left, const binomial_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 2532
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const binomial_distribution < _Ty > & _Left, const binomial_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 2537
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    binomial_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 2543
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const binomial_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 2549
template < class _Ty = double >
class uniform_real {
public :
    using result_type = _Ty;

    struct param_type {
        using distribution_type = uniform_real;

        param_type ( ) {
            _Init ( _Ty { 0 }, _Ty { 1 } );
        }

        explicit param_type ( _Ty _Min0, _Ty _Max0 = _Ty { 1 } ) {
            _Init ( _Min0, _Max0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Min == _Right . _Min && _Max == _Right . _Max;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] result_type a ( ) const {
            return _Min;
        }

        [ [ nodiscard ] ] result_type b ( ) const {
            return _Max;
        }

        void _Init ( _Ty _Min0, _Ty _Max0 ) {
            ;

            _Min = _Min0;
            _Max = _Max0;
        }

        result_type _Min;
        result_type _Max;
    };

    uniform_real ( ) : _Par ( _Ty { 0 }, _Ty { 1 } ) { }

    explicit uniform_real ( _Ty _Min0, _Ty _Max0 = _Ty { 1 } ) : _Par ( _Min0, _Max0 ) { }

    explicit uniform_real ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] result_type a ( ) const {
        return _Par . a ( );
    }

    [ [ nodiscard ] ] result_type b ( ) const {
        return _Par . b ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return _Par . _Min;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return _Par . _Max;
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Min0;
        _Ty _Max0;
        _In ( _Istr, _Min0 );
        _In ( _Istr, _Max0 );
        _Par . _Init ( _Min0, _Max0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Min );
        _Out ( _Ostr, _Par . _Max );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        return ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) ) * ( _Par0 . _Max - _Par0 . _Min ) + _Par0 . _Min;
    }

    param_type _Par;
};
#line 2660 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    uniform_real < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 2666
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const uniform_real < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 2672
template < class _Ty = double >
class uniform_real_distribution : public uniform_real < _Ty > {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for uniform_real_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or lon" "g double" );

    using _Mybase = uniform_real < _Ty >;
    using _Mypbase = typename _Mybase :: param_type;
    using result_type = typename _Mybase :: result_type;

    struct param_type : _Mypbase {
        using distribution_type = uniform_real_distribution;

        param_type ( ) : _Mypbase ( _Ty { 0 }, _Ty { 1 } ) { }

        explicit param_type ( _Ty _Min0, _Ty _Max0 = _Ty { 1 } ) : _Mypbase ( _Min0, _Max0 ) { }

        param_type ( const _Mypbase & _Right ) : _Mypbase ( _Right ) { }
    };

    uniform_real_distribution ( ) : _Mybase ( _Ty { 0 }, _Ty { 1 } ) { }

    explicit uniform_real_distribution ( _Ty _Min0, _Ty _Max0 = _Ty { 1 } ) : _Mybase ( _Min0, _Max0 ) { }

    explicit uniform_real_distribution ( const param_type & _Par0 ) : _Mybase ( _Par0 ) { }
};
#line 2698
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const uniform_real_distribution < _Ty > & _Left, const uniform_real_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 2703
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const uniform_real_distribution < _Ty > & _Left, const uniform_real_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 2708
template < class _Ty = double >
class exponential_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for exponential_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long" " double" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = exponential_distribution;

        param_type ( ) {
            _Init ( _Ty { 1 } );
        }

        explicit param_type ( _Ty _Lambda0 ) {
            _Init ( _Lambda0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Lambda == _Right . _Lambda;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty lambda ( ) const {
            return _Lambda;
        }

        void _Init ( _Ty _Lambda0 ) {
            ;
            _Lambda = _Lambda0;
        }

        _Ty _Lambda;
    };

    exponential_distribution ( ) : _Par ( _Ty { 1 } ) { }

    explicit exponential_distribution ( _Ty _Lambda0 ) : _Par ( _Lambda0 ) { }

    explicit exponential_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty lambda ( ) const {
        return _Par . lambda ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Lambda0;
        _In ( _Istr, _Lambda0 );
        _Par . _Init ( _Lambda0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Lambda );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        return - :: log ( _Ty { 1 } - ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) ) ) / _Par0 . _Lambda;
    }

    param_type _Par;
};
#line 2807
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const exponential_distribution < _Ty > & _Left, const exponential_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 2812
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const exponential_distribution < _Ty > & _Left, const exponential_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 2817
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    exponential_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 2823
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const exponential_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 2829
template < class _Ty = double >
class normal_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for normal_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long doub" "le" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = normal_distribution;

        param_type ( ) {
            _Init ( (0.0), (1.0) );
        }

        explicit param_type ( _Ty _Mean0, _Ty _Sigma0 = (1.0) ) {
            _Init ( _Mean0, _Sigma0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Mean == _Right . _Mean && _Sigma == _Right . _Sigma;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty mean ( ) const {
            return _Mean;
        }

        [ [ nodiscard ] ] _Ty sigma ( ) const {
            return _Sigma;
        }

        [ [ nodiscard ] ] _Ty stddev ( ) const {
            return _Sigma;
        }

        void _Init ( _Ty _Mean0, _Ty _Sigma0 ) {
            ;
            _Mean = _Mean0;
            _Sigma = _Sigma0;
        }

        _Ty _Mean;
        _Ty _Sigma;
    };

    normal_distribution ( ) : _Par ( (0.0), (1.0) ), _Valid ( false ), _Xx2 ( 0 ) { }

    explicit normal_distribution ( _Ty _Mean0, _Ty _Sigma0 = (1.0) ) : _Par ( _Mean0, _Sigma0 ), _Valid ( false ), _Xx2 ( 0 ) { }

    explicit normal_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ), _Valid ( false ), _Xx2 ( 0 ) { }

    [ [ nodiscard ] ] _Ty mean ( ) const {
        return _Par . mean ( );
    }

    [ [ nodiscard ] ] _Ty sigma ( ) const {
        return _Par . sigma ( );
    }

    [ [ nodiscard ] ] _Ty stddev ( ) const {
        return _Par . sigma ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
        reset ( );
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return - numeric_limits < result_type > :: infinity ( );
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) {
        _Valid = false;
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) {
        reset ( );
        return _Eval ( _Eng, _Par0, false );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Mean0;
        _Ty _Sigma0;
        _In ( _Istr, _Mean0 );
        _In ( _Istr, _Sigma0 );
        _Par . _Init ( _Mean0, _Sigma0 );

        _Istr >> _Valid;
        _In ( _Istr, _Xx2 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Mean );
        _Out ( _Ostr, _Par . _Sigma );

        _Ostr << ' ' << _Valid;
        _Out ( _Ostr, _Xx2 );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0,
        bool _Keep = true ) {

        _Ty _Res;
        if ( _Keep && _Valid ) {
            _Res = _Xx2;
            _Valid = false;
        } else {
            _Ty _Vx1;
            _Ty _Vx2;
            _Ty _Sx;
            for (;; ) {
                _Vx1 = 2 * ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) ) - 1;
                _Vx2 = 2 * ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) ) - 1;
                _Sx = _Vx1 * _Vx1 + _Vx2 * _Vx2;
                if ( _Sx < _Ty { 1 } && _Vx1 != _Ty { 0 } && _Vx2 != _Ty { 0 } ) {

                    break;
                }
            }

            _Ty _LogSx;
            if ( _Sx > _Ty { (0.0001000000000000000048) } ) {
                _LogSx = :: std :: log ( _Sx );
            } else {


                const _Ty _Ln2 { _Ty { (0.6931471805599452862) } };
                const _Ty _Maxabs { ( :: std :: max ) ( :: std :: abs ( _Vx1 ), :: std :: abs ( _Vx2 ) ) };
                const int _ExpMax { :: std :: ilogb ( _Maxabs ) };
                _Vx1 = :: std :: scalbn ( _Vx1, - _ExpMax );
                _Vx2 = :: std :: scalbn ( _Vx2, - _ExpMax );
                _Sx = _Vx1 * _Vx1 + _Vx2 * _Vx2;
                _LogSx = :: std :: log ( _Sx ) + static_cast < _Ty > ( _ExpMax ) * ( _Ln2 * 2 );
            }

            const auto _Fx = _Ty { :: std :: sqrt ( _Ty { - 2 } * _LogSx / _Sx ) };
            if ( _Keep ) {
                _Xx2 = _Fx * _Vx2;
                _Valid = true;
            }
            _Res = _Fx * _Vx1;
        }
        return _Res * _Par0 . _Sigma + _Par0 . _Mean;
    }

    param_type _Par;
    bool _Valid;
    _Ty _Xx2;
};
#line 3003
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const normal_distribution < _Ty > & _Left, const normal_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 3008
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const normal_distribution < _Ty > & _Left, const normal_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3013
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    normal_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 3019
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const normal_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 3025
template < class _Ty = double >
class gamma_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for gamma_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long doubl" "e" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = gamma_distribution;

        param_type ( ) {
            _Init ( _Ty { 1 }, _Ty { 1 } );
        }

        explicit param_type ( _Ty _Alpha0, _Ty _Beta0 = _Ty { 1 } ) {
            _Init ( _Alpha0, _Beta0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Alpha == _Right . _Alpha && _Beta == _Right . _Beta;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty alpha ( ) const {
            return _Alpha;
        }

        [ [ nodiscard ] ] _Ty beta ( ) const {
            return _Beta;
        }

        void _Init ( _Ty _Alpha0, _Ty _Beta0 ) {
            ;
            ;
            _Alpha = _Alpha0;
            _Beta = _Beta0;
            _Px = static_cast < _Ty > ( _Exp1 / ( _Alpha + _Exp1 ) );
            _Sqrt = :: sqrt ( 2 * _Alpha - 1 );
        }

        _Ty _Alpha;
        _Ty _Beta;
        _Ty _Px;
        _Ty _Sqrt;
        exponential_distribution < _Ty > _Exp;
    };

    gamma_distribution ( ) : _Par ( _Ty { 1 }, _Ty { 1 } ) { }

    explicit gamma_distribution ( _Ty _Alpha0, _Ty _Beta0 = _Ty { 1 } ) : _Par ( _Alpha0, _Beta0 ) { }

    explicit gamma_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty alpha ( ) const {
        return _Par . alpha ( );
    }

    [ [ nodiscard ] ] _Ty beta ( ) const {
        return _Par . beta ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return result_type { (0.0) };
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Alpha0;
        _Ty _Beta0;
        _In ( _Istr, _Alpha0 );
        _In ( _Istr, _Beta0 );
        _Par . _Init ( _Alpha0, _Beta0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Alpha );
        _Out ( _Ostr, _Par . _Beta );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, param_type _Par0 ) const {
        _Ty _Ux;
        _Ty _Vx;
        _Ty _Xx;
        _Ty _Yx;
        _Ty _Qx;
        int _Count;
        if ( _Par0 . _Alpha < 1 ) {

            for (;; ) {
                _Ux = ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) );
                do {
                    _Vx = ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) );
                } while ( _Vx == 0 );

                if ( _Ux < _Par0 . _Px ) {
                    _Xx = :: pow ( _Vx, _Ty { 1 } / _Par0 . _Alpha );
                    _Qx = :: exp ( - _Xx );
                } else {
                    _Xx = 1 - :: log ( _Vx );
                    _Qx = :: pow ( _Xx, _Par0 . _Alpha - 1 );
                }

                if ( ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) ) < _Qx ) {
                    return _Par0 . _Beta * _Xx;
                }
            }
        }

        if ( _Par0 . _Alpha == 1 ) {
            return _Par0 . _Beta * _Par0 . _Exp ( _Eng );
        }

        if ( _Par0 . _Alpha < (20.0) && ( _Count = static_cast < int > ( _Par0 . _Alpha ) ) == _Par0 . _Alpha ) {

            _Yx = ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) );
            while ( -- _Count ) {
                do {
                    _Ux = ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) );
                } while ( _Ux == 0 );

                _Yx *= _Ux;
            }
            return _Par0 . _Beta * - :: log ( _Yx );
        }


        for (;; ) {
            _Yx = static_cast < _Ty > ( :: tan ( _Pi * ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) ) ) );
            _Xx = _Par0 . _Sqrt * _Yx + _Par0 . _Alpha - 1;
            if ( 0 < _Xx
                && ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) ) <= ( 1 + _Yx * _Yx )
                                            * :: exp ( ( _Par0 . _Alpha - 1 ) * :: log ( _Xx / ( _Par0 . _Alpha - 1 ) )
                                                        - _Par0 . _Sqrt * _Yx ) ) {
                return _Par0 . _Beta * _Xx;
            }
        }
    }

    param_type _Par;
};
#line 3198
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const gamma_distribution < _Ty > & _Left, const gamma_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 3203
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const gamma_distribution < _Ty > & _Left, const gamma_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3208
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    gamma_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 3214
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const gamma_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 3220
template < class _Ty = double >
class weibull_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for weibull_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long dou" "ble" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = weibull_distribution;

        param_type ( ) {
            _Init ( _Ty { 1 }, _Ty { 1 } );
        }

        explicit param_type ( _Ty _Ax0, _Ty _Bx0 = _Ty { 1 } ) {
            _Init ( _Ax0, _Bx0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Ax == _Right . _Ax && _Bx == _Right . _Bx;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty a ( ) const {
            return _Ax;
        }

        [ [ nodiscard ] ] _Ty b ( ) const {
            return _Bx;
        }

        void _Init ( _Ty _Ax0, _Ty _Bx0 ) {
            ;
            ;
            _Ax = _Ax0;
            _Bx = _Bx0;
        }

        _Ty _Ax;
        _Ty _Bx;
    };

    weibull_distribution ( ) : _Par ( _Ty { 1 }, _Ty { 1 } ) { }

    explicit weibull_distribution ( _Ty _Ax0, _Ty _Bx0 = _Ty { 1 } ) : _Par ( _Ax0, _Bx0 ) { }

    explicit weibull_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty a ( ) const {
        return _Par . a ( );
    }

    [ [ nodiscard ] ] _Ty b ( ) const {
        return _Par . b ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Ax0;
        _Ty _Bx0;
        _In ( _Istr, _Ax0 );
        _In ( _Istr, _Bx0 );
        _Par . _Init ( _Ax0, _Bx0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Ax );
        _Out ( _Ostr, _Par . _Bx );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        _Ty _Px = ( _Ty { 1 } - ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) ) );
        return _Par0 . _Bx * :: pow ( - :: log ( _Px ), _Ty { 1 } / _Par0 . _Ax );
    }

    param_type _Par;
};
#line 3334
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const weibull_distribution < _Ty > & _Left, const weibull_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 3339
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const weibull_distribution < _Ty > & _Left, const weibull_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3344
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    weibull_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 3350
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const weibull_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 3356
template < class _Ty = double >
class extreme_value_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for extreme_value_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or lo" "ng double" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = extreme_value_distribution;

        param_type ( ) {
            _Init ( _Ty { 0 }, _Ty { 1 } );
        }

        explicit param_type ( _Ty _Ax0, _Ty _Bx0 = _Ty { 1 } ) {
            _Init ( _Ax0, _Bx0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Ax == _Right . _Ax && _Bx == _Right . _Bx;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty a ( ) const {
            return _Ax;
        }

        [ [ nodiscard ] ] _Ty b ( ) const {
            return _Bx;
        }

        void _Init ( _Ty _Ax0, _Ty _Bx0 ) {
            ;
            _Ax = _Ax0;
            _Bx = _Bx0;
        }

        _Ty _Ax;
        _Ty _Bx;
    };

    extreme_value_distribution ( ) : _Par ( _Ty { 0 }, _Ty { 1 } ) { }

    explicit extreme_value_distribution ( _Ty _Ax0, _Ty _Bx0 = _Ty { 1 } ) : _Par ( _Ax0, _Bx0 ) { }

    explicit extreme_value_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty a ( ) const {
        return _Par . a ( );
    }

    [ [ nodiscard ] ] _Ty b ( ) const {
        return _Par . b ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return - numeric_limits < result_type > :: infinity ( );
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Ax0;
        _Ty _Bx0;
        _In ( _Istr, _Ax0 );
        _In ( _Istr, _Bx0 );
        _Par . _Init ( _Ax0, _Bx0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Ax );
        _Out ( _Ostr, _Par . _Bx );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        _Ty _Px = ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) );
        return _Par0 . _Ax - _Par0 . _Bx * :: log ( - :: log ( _Px ) );
    }

    param_type _Par;
};
#line 3469
template < class _Ty >
[ [ nodiscard ] ] bool operator == (
    const extreme_value_distribution < _Ty > & _Left, const extreme_value_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 3475
template < class _Ty >
[ [ nodiscard ] ] bool operator != (
    const extreme_value_distribution < _Ty > & _Left, const extreme_value_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3481
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    extreme_value_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 3487
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const extreme_value_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 3493
template < class _Ty = double >
class lognormal_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for lognormal_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long d" "ouble" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = lognormal_distribution;

        param_type ( ) {
            _Init ( _Ty { 0 }, _Ty { 1 } );
        }

        explicit param_type ( _Ty _Mx0, _Ty _Sx0 = _Ty { 1 } ) {
            _Init ( _Mx0, _Sx0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Mx == _Right . _Mx && _Sx == _Right . _Sx;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty m ( ) const {
            return _Mx;
        }

        [ [ nodiscard ] ] _Ty s ( ) const {
            return _Sx;
        }

        void _Init ( _Ty _Mx0, _Ty _Sx0 ) {
            ;
            _Mx = _Mx0;
            _Sx = _Sx0;
        }

        _Ty _Mx;
        _Ty _Sx;
    };

    lognormal_distribution ( ) : _Par ( _Ty { 0 }, _Ty { 1 } ) { }

    explicit lognormal_distribution ( _Ty _Mx0, _Ty _Sx0 = _Ty { 1 } ) : _Par ( _Mx0, _Sx0 ) { }

    explicit lognormal_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty m ( ) const {
        return _Par . m ( );
    }

    [ [ nodiscard ] ] _Ty s ( ) const {
        return _Par . s ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return result_type { (0.0) };
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Mx0;
        _Ty _Sx0;
        _In ( _Istr, _Mx0 );
        _In ( _Istr, _Sx0 );
        _Par . _Init ( _Mx0, _Sx0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Mx );
        _Out ( _Ostr, _Par . _Sx );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, param_type _Par0 ) const {
        normal_distribution < _Ty > _Dist ( _Par0 . _Mx, _Par0 . _Sx );
        return :: exp ( _Dist ( _Eng ) );
    }

    param_type _Par;
};
#line 3606
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const lognormal_distribution < _Ty > & _Left, const lognormal_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 3611
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const lognormal_distribution < _Ty > & _Left, const lognormal_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3616
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    lognormal_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 3622
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const lognormal_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 3628
template < class _Ty = double >
class chi_squared_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for chi_squared_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long" " double" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = chi_squared_distribution;

        param_type ( ) {
            _Init ( _Ty { 1 } );
        }

        explicit param_type ( _Ty _Nx0 ) {
            _Init ( _Nx0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Nx == _Right . _Nx;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty n ( ) const {
            return _Nx;
        }

        void _Init ( _Ty _Nx0 ) {
            ;
            _Nx = _Nx0;
        }

        _Ty _Nx;
    };

    chi_squared_distribution ( ) : _Par ( _Ty { 1 } ) { }

    explicit chi_squared_distribution ( _Ty _Nx0 ) : _Par ( _Nx0 ) { }

    explicit chi_squared_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty n ( ) const {
        return _Par . n ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return result_type { (0.0) };
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Nx0;
        _Istr >> _Nx0;
        _Par . _Init ( _Nx0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        return _Ostr << ' ' << _Par . _Nx;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        gamma_distribution < _Ty > _Dist ( static_cast < _Ty > ( _Par0 . _Nx ) * static_cast < _Ty > ( (0.5) ), _Ty { 2 } );
        return _Dist ( _Eng );
    }

    param_type _Par;
};
#line 3727
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const chi_squared_distribution < _Ty > & _Left, const chi_squared_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 3732
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const chi_squared_distribution < _Ty > & _Left, const chi_squared_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3737
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    chi_squared_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 3743
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const chi_squared_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 3749
template < class _Ty = double >
class cauchy_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for cauchy_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long doub" "le" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = cauchy_distribution;

        param_type ( ) {
            _Init ( _Ty { 0 }, _Ty { 1 } );
        }

        explicit param_type ( _Ty _Ax0, _Ty _Bx0 = _Ty { 1 } ) {
            _Init ( _Ax0, _Bx0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Ax == _Right . _Ax && _Bx == _Right . _Bx;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty a ( ) const {
            return _Ax;
        }

        [ [ nodiscard ] ] _Ty b ( ) const {
            return _Bx;
        }

        void _Init ( _Ty _Ax0, _Ty _Bx0 ) {
            ;
            _Ax = _Ax0;
            _Bx = _Bx0;
        }

        _Ty _Ax;
        _Ty _Bx;
    };

    cauchy_distribution ( ) : _Par ( _Ty { 0 }, _Ty { 1 } ) { }

    explicit cauchy_distribution ( _Ty _Ax0, _Ty _Bx0 = _Ty { 1 } ) : _Par ( _Ax0, _Bx0 ) { }

    explicit cauchy_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty a ( ) const {
        return _Par . a ( );
    }

    [ [ nodiscard ] ] _Ty b ( ) const {
        return _Par . b ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return - numeric_limits < result_type > :: infinity ( );
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Ax0;
        _Ty _Bx0;
        _In ( _Istr, _Ax0 );
        _In ( _Istr, _Bx0 );
        _Par . _Init ( _Ax0, _Bx0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Ax );
        _Out ( _Ostr, _Par . _Bx );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        _Ty Px = ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) );
        return static_cast < _Ty > ( _Par0 . _Ax + _Par0 . _Bx * :: tan ( _Pi * ( Px - static_cast < _Ty > ( (0.5) ) ) ) );
    }

    param_type _Par;
};
#line 3862
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const cauchy_distribution < _Ty > & _Left, const cauchy_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 3867
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const cauchy_distribution < _Ty > & _Left, const cauchy_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 3872
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    cauchy_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 3878
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const cauchy_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 3884
template < class _Ty = double >
class _Beta_distribution {
public :
    using result_type = _Ty;

    explicit _Beta_distribution ( const _Ty & _Ax0 = _Ty { 1 }, const _Ty & _Bx0 = _Ty { 1 } ) {
        _Init ( _Ax0, _Bx0 );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        if ( _Ax < _Ty { 1 } && _Bx < _Ty { 1 } ) {
            _Ty _Wx;
            _Ty _Px1;
            _Ty _Px2;
            for (;; ) {
                _Px1 = ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) );
                _Px2 = ( :: std :: generate_canonical < _Ty, static_cast < size_t > ( - 1 ) > ( _Eng ) );
                _Px1 = :: pow ( _Px1, _Ty { 1 } / _Ax );
                _Px2 = :: pow ( _Px2, _Ty { 1 } / _Bx );
                _Wx = _Px1 + _Px2;
                if ( _Wx <= _Ty { 1 } && _Wx != _Ty { 0 } ) {
                    break;
                }
            }
            return _Px1 / _Wx;
        } else {
            _Ty _Px1;
            _Ty _Px2;
            _Ty _PSum;
            gamma_distribution < _Ty > _Dist1 ( _Ax, 1 );
            gamma_distribution < _Ty > _Dist2 ( _Bx, 1 );

            for (;; ) {
                _Px1 = _Dist1 ( _Eng );
                _Px2 = _Dist2 ( _Eng );
                _PSum = _Px1 + _Px2;

                if ( _PSum != _Ty { 0 } ) {
                    break;
                }
            }

            return _Px1 / _PSum;
        }
    }

private :
    void _Init ( _Ty _Ax0, _Ty _Bx0 ) {
        ;
        ;
        _Ax = _Ax0;
        _Bx = _Bx0;
    }

    _Ty _Ax;
    _Ty _Bx;
};
#line 3943
template < class _Ty = double >
class fisher_f_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for fisher_f_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long do" "uble" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = fisher_f_distribution;

        param_type ( ) {
            _Init ( _Ty { 1 }, _Ty { 1 } );
        }

        explicit param_type ( _Ty _Mx0, _Ty _Nx0 = _Ty { 1 } ) {
            _Init ( _Mx0, _Nx0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Mx == _Right . _Mx && _Nx == _Right . _Nx;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty m ( ) const {
            return _Mx;
        }

        [ [ nodiscard ] ] _Ty n ( ) const {
            return _Nx;
        }

        void _Init ( _Ty _Mx0, _Ty _Nx0 ) {
            ;
            ;
            _Mx = _Mx0;
            _Nx = _Nx0;
        }

        _Ty _Mx;
        _Ty _Nx;
    };

    fisher_f_distribution ( ) : _Par ( _Ty { 1 }, _Ty { 1 } ) { }

    explicit fisher_f_distribution ( _Ty _Mx0, _Ty _Nx0 = _Ty { 1 } ) : _Par ( _Mx0, _Nx0 ) { }

    explicit fisher_f_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty m ( ) const {
        return _Par . m ( );
    }

    [ [ nodiscard ] ] _Ty n ( ) const {
        return _Par . n ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return result_type ( 0 );
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Mx0;
        _Ty _Nx0;
        _Istr >> _Mx0 >> _Nx0;
        _Par . _Init ( _Mx0, _Nx0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Ostr << ' ' << _Par . _Mx << ' ' << _Par . _Nx;
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        _Ty _Px;
        _Ty _Vx1;
        _Ty _Vx2;
        const _Ty _Vx3 { 1 };
        _Vx1 = static_cast < _Ty > ( _Par0 . _Mx ) * static_cast < _Ty > ( (0.5) );
        _Vx2 = static_cast < _Ty > ( _Par0 . _Nx ) * static_cast < _Ty > ( (0.5) );
        _Beta_distribution < _Ty > _Dist ( _Vx1, _Vx2 );
        for (;; ) {
            _Px = _Dist ( _Eng );
            if ( _Px != _Vx3 ) {
                break;
            }
        }

        return ( _Vx2 / _Vx1 ) * ( _Px / ( _Vx3 - _Px ) );
    }

    param_type _Par;
};
#line 4068
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const fisher_f_distribution < _Ty > & _Left, const fisher_f_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 4073
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const fisher_f_distribution < _Ty > & _Left, const fisher_f_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 4078
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    fisher_f_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 4084
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const fisher_f_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 4090
template < class _Ty = double >
class student_t_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for student_t_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or long d" "ouble" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = student_t_distribution;

        param_type ( ) {
            _Init ( _Ty { 1 } );
        }

        explicit param_type ( _Ty _Nx0 ) {
            _Init ( _Nx0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Nx == _Right . _Nx;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty n ( ) const {
            return _Nx;
        }

        void _Init ( _Ty _Nx0 ) {
            ;
            _Nx = _Nx0;
        }

        _Ty _Nx;
    };

    student_t_distribution ( ) : _Par ( _Ty { 1 } ) { }

    explicit student_t_distribution ( _Ty _Nx0 ) : _Par ( _Nx0 ) { }

    explicit student_t_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty n ( ) const {
        return _Par . n ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return - numeric_limits < result_type > :: infinity ( );
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return numeric_limits < result_type > :: infinity ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Nx0;
        _Istr >> _Nx0;
        _Par . _Init ( _Nx0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        return _Ostr << ' ' << _Par . _Nx;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        _Ty _Vx1;
        _Ty _Vx2;
        _Ty _Rx0;
        _Ty _Rs;
        uniform_real < _Ty > _Dist ( - 1, 1 );
        for (;; ) {
            _Vx1 = _Dist ( _Eng );
            _Vx2 = _Dist ( _Eng );
            _Rs = _Vx1 * _Vx1 + _Vx2 * _Vx2;


            if ( _Rs < _Ty { 1 } && _Rs > _Ty { (9.999999999999999799e-13) } ) {
                break;
            }
        }
        _Rx0 = :: std :: sqrt ( _Rs );
        return _Vx1 * :: std :: sqrt ( _Par0 . _Nx * ( :: std :: pow ( _Rx0, - _Ty { 4 } / _Par0 . _Nx ) - _Ty { 1 } ) / _Rs );
    }

    param_type _Par;
};
#line 4204
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const student_t_distribution < _Ty > & _Left, const student_t_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 4209
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const student_t_distribution < _Ty > & _Left, const student_t_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 4214
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    student_t_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 4220
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const student_t_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 4226
template < class _Ty = int >
class negative_binomial_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for negative_binomial_distribution: N4659 29.6.1.1 [rand.req.genl]/1e requires one of short, int, long" ", long long, unsigned short, unsigned int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Ty > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    using result_type = _Ty;

    struct param_type {
        using distribution_type = negative_binomial_distribution;

        param_type ( ) {
            _Init ( 1, (0.5) );
        }

        explicit param_type ( _Ty _Kx0, double _Px0 = (0.5) ) {
            _Init ( _Kx0, _Px0 );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Kx == _Right . _Kx && _Px == _Right . _Px;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Ty k ( ) const {
            return _Kx;
        }

        [ [ nodiscard ] ] double p ( ) const {
            return _Px;
        }

        void _Init ( _Ty _Kx0, double _Px0 ) {
            ;

            ;

            _Kx = _Kx0;
            _Px = _Px0;
        }

        _Ty _Kx;
        double _Px;
    };

    negative_binomial_distribution ( ) : _Par ( 1, (0.5) ) { }

    explicit negative_binomial_distribution ( _Ty _Kx0, double _Px0 = (0.5) ) : _Par ( _Kx0, _Px0 ) { }

    explicit negative_binomial_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Ty k ( ) const {
        return _Par . k ( );
    }

    [ [ nodiscard ] ] double p ( ) const {
        return _Par . p ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return ( numeric_limits < result_type > :: max ) ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Ty _Kx0;
        double _Px0;
        _In ( _Istr, _Px0 );
        _In ( _Istr, _Kx0 );
        _Par . _Init ( _Kx0, _Px0 );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Out ( _Ostr, _Par . _Px );
        _Out ( _Ostr, _Par . _Kx );
        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        double _Vx1;
        gamma_distribution < double > _Dist1 (
            static_cast < double > ( _Par0 . _Kx ), static_cast < double > ( ( _Ty { 1 } - _Par0 . _Px ) / _Par0 . _Px ) );
        _Vx1 = _Dist1 ( _Eng );
        poisson_distribution < _Ty > _Dist2 ( _Vx1 );

        return _Dist2 ( _Eng );
    }

    param_type _Par;
};
#line 4347 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
template < class _Ty >
[ [ nodiscard ] ] bool operator == (
    const negative_binomial_distribution < _Ty > & _Left, const negative_binomial_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 4353
template < class _Ty >
[ [ nodiscard ] ] bool operator != (
    const negative_binomial_distribution < _Ty > & _Left, const negative_binomial_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 4359
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    negative_binomial_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 4365
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const negative_binomial_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 4371
template < class _Ty = int >
class discrete_distribution {
public :
    static_assert ( _Is_any_of_v < _Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long >, "invalid template argument for discrete_distribution: N4659 29.6.1.1 [rand.req.genl]/1e requires one of short, int, long, long lo" "ng, unsigned short, unsigned int, unsigned long, or unsigned long long" ); static_assert ( ! _Is_character < _Ty > :: value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed" );

    using _Myvec = vector < double >;
    using result_type = _Ty;

    struct param_type {
        using distribution_type = discrete_distribution;

        param_type ( _Uninitialized ) { }

        param_type ( ) {
            _Init ( );
        }

        template < class _InIt >
        param_type ( _InIt _First, _InIt _Last ) : _Pvec ( _First, _Last ) {
            _Init ( );
        }

        param_type ( initializer_list < double > _Ilist ) : _Pvec ( _Ilist ) {
            _Init ( );
        }

        template < class _Fn >
        param_type ( size_t _Count, double _Low, double _High, _Fn _Func ) {
            double _Range = _High - _Low;
            ;
            if ( _Count <= 0 ) {
                _Count = 1;
            }

            _Range /= static_cast < double > ( _Count );
            _Low += (0.5) * _Range;
            for ( size_t _Idx = 0; _Idx < _Count; ++ _Idx ) {
                _Pvec . push_back ( _Func ( _Low + _Idx * _Range ) );
            }

            _Init ( );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return _Pvec == _Right . _Pvec;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] _Myvec probabilities ( ) const {
            return _Pvec;
        }

        void _Init ( bool _Renorm = true ) {
            size_t _Size = _Pvec . size ( );
            size_t _Idx;

            if ( _Renorm ) {
                if ( _Pvec . empty ( ) ) {
                    _Pvec . push_back ( (1.0) );
                } else {
                    double _Sum = 0;

                    for ( _Idx = 0; _Idx < _Size; ++ _Idx ) {
                        ;
                        _Sum += _Pvec [ _Idx ];
                    }

                    ;
                    if ( _Sum != (1.0) ) {
                        for ( _Idx = 0; _Idx < _Size; ++ _Idx ) {
                            _Pvec [ _Idx ] /= _Sum;
                        }
                    }
                }
            }

            _Pcdf . assign ( 1, _Pvec [ 0 ] );
            for ( _Idx = 1; _Idx < _Size; ++ _Idx ) {
                _Pcdf . push_back ( _Pvec [ _Idx ] + _Pcdf [ _Idx - 1 ] );
            }
        }

        _Myvec _Pvec;
        _Myvec _Pcdf;
    };

    discrete_distribution ( ) { }

    template < class _InIt >
    discrete_distribution ( _InIt _First, _InIt _Last ) : _Par ( _First, _Last ) { }

    discrete_distribution ( initializer_list < double > _Ilist ) : _Par ( _Ilist ) { }

    template < class _Fn >
    discrete_distribution ( size_t _Count, double _Low, double _High, _Fn _Func ) : _Par ( _Count, _Low, _High, _Func ) { }

    explicit discrete_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] _Myvec probabilities ( ) const {
        return _Par . probabilities ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return 0;
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return static_cast < result_type > ( _Par . _Pvec . size ( ) - 1 );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr,
        param_type & _Par0 ) {
        size_t _Nvals;
        _Istr >> _Nvals;
        _Par0 . _Pvec . clear ( );
        for (; 0 < _Nvals; -- _Nvals ) {
            double _Val;
            _In ( _Istr, _Val );
            _Par0 . _Pvec . push_back ( _Val );
        }
        _Par0 . _Init ( false );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr,
        const param_type & _Par0 ) const {
        size_t _Nvals = _Par0 . _Pvec . size ( );
        _Ostr << ' ' << _Nvals;

        for ( size_t _Idx = 0; _Idx < _Par0 . _Pvec . size ( ); ++ _Idx ) {
            _Out ( _Ostr, _Par0 . _Pvec [ _Idx ] );
        }

        return _Ostr;
    }

private :
    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        double _Px = ( :: std :: generate_canonical < double, static_cast < size_t > ( - 1 ) > ( _Eng ) );
        const auto _First = _Par0 . _Pcdf . begin ( );
        const auto _Position = :: std :: lower_bound ( _First, _Prev_iter ( _Par0 . _Pcdf . end ( ) ), _Px );
        return static_cast < result_type > ( _Position - _First );
    }

public :
    param_type _Par;
};
#line 4545
template < class _Ty >
[ [ nodiscard ] ] bool operator == ( const discrete_distribution < _Ty > & _Left, const discrete_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 4550
template < class _Ty >
[ [ nodiscard ] ] bool operator != ( const discrete_distribution < _Ty > & _Left, const discrete_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 4555
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    discrete_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr, _Dist . _Par );
}
#line 4561
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const discrete_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr, _Dist . _Par );
}
#line 4567
template < class _Ty = double >
class piecewise_constant_distribution
    : public discrete_distribution < size_t > {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for piecewise_constant_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, " "or long double" );

    using _Mybase = discrete_distribution < size_t >;
    using _Mypbase = typename _Mybase :: param_type;
    using result_type = _Ty;

    struct param_type : _Mypbase {
        using distribution_type = piecewise_constant_distribution;

        param_type ( ) : _Bvec { 0, 1 } { }

        template < class _InIt1, class _InIt2 >
        param_type ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 ) : _Mypbase ( _Noinit ), _Bvec ( _First1, _Last1 ) {
            if ( 2 <= _Bvec . size ( ) ) {
                for ( size_t _Idx = 0; _Idx < _Bvec . size ( ) - 1; ++ _Idx ) {
                    this -> _Pvec . push_back ( static_cast < double > ( * _First2 ++ ) );
                }
            } else {
                _Bvec = { 0, 1 };
            }

            _Init ( );
        }

        template < class _Fn >
        param_type ( initializer_list < _Ty > _Ilist, _Fn _Func ) : _Mypbase ( _Noinit ) {
            if ( 2 <= _Ilist . size ( ) ) {
                _Bvec . assign ( _Ilist );

                for ( size_t _Idx = 0; _Idx < _Bvec . size ( ) - 1; ++ _Idx ) {
                    this -> _Pvec . push_back ( _Func ( _Ty { (0.5) } * ( _Bvec [ _Idx ] + _Bvec [ _Idx + 1 ] ) ) );
                }
            } else {
                _Bvec = { 0, 1 };
            }

            _Init ( );
        }

        template < class _Fn >
        param_type ( size_t _Count, _Ty _Low, _Ty _High, _Fn _Func ) : _Mypbase ( _Count, _Low, _High, _Func ) {
            _Ty _Range = _High - _Low;
            if ( _Count <= 0 ) {
                _Count = 1;
            }

            _Range /= static_cast < _Ty > ( _Count );
            for ( size_t _Idx = 0; _Idx <= _Count; ++ _Idx ) {
                _Bvec . push_back ( _Low + _Idx * _Range );
            }
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return static_cast < const _Mypbase & > ( * this ) == static_cast < const _Mypbase & > ( _Right ) && _Bvec == _Right . _Bvec;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] vector < _Ty > intervals ( ) const {
            return _Bvec;
        }

        [ [ nodiscard ] ] vector < _Ty > densities ( ) const {
            vector < _Ty > _Ans ( this -> _Pvec . begin ( ), this -> _Pvec . end ( ) );

            for ( size_t _Idx = 0; _Idx < _Ans . size ( ); ++ _Idx ) {
                _Ans [ _Idx ] /= _Bvec [ _Idx + 1 ] - _Bvec [ _Idx ];
            }

            return _Ans;
        }

        void _Init ( ) {
            _Mypbase :: _Init ( );
        }

        vector < _Ty > _Bvec;
    };

    piecewise_constant_distribution ( ) { }

    template < class _InIt1, class _InIt2 >
    piecewise_constant_distribution ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 ) : _Par ( _First1, _Last1, _First2 ) { }

    template < class _Fn >
    piecewise_constant_distribution ( initializer_list < _Ty > _Ilist, _Fn _Func ) : _Par ( _Ilist, _Func ) { }

    template < class _Fn >
    piecewise_constant_distribution ( size_t _Count, _Ty _Low, _Ty _High, _Fn _Func ) : _Par ( _Count, _Low, _High, _Func ) { }

    explicit piecewise_constant_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] vector < _Ty > intervals ( ) const {
        return _Par . intervals ( );
    }

    [ [ nodiscard ] ] vector < _Ty > densities ( ) const {
        return _Par . densities ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return _Par . _Bvec . front ( );
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return _Par . _Bvec . back ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr ) {
        _Mybase :: _Read ( _Istr, _Par );

        _Par . _Bvec . clear ( );
        for ( size_t _Idx = _Par . _Pvec . size ( ) + 1; 0 < _Idx; -- _Idx ) {
            double _Val;
            _In ( _Istr, _Val );
            _Par . _Bvec . push_back ( _Val );
        }
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Mybase :: _Write ( _Ostr, _Par );

        for ( size_t _Idx = 0; _Idx < _Par . _Bvec . size ( ); ++ _Idx ) {
            _Out ( _Ostr, _Par . _Bvec [ _Idx ] );
        }

        return _Ostr;
    }

    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        size_t _Px = _Mybase :: operator ( ) ( _Eng, _Par0 );
        uniform_real < _Ty > _Dist ( _Par0 . _Bvec [ _Px ], _Par0 . _Bvec [ _Px + 1 ] );
        return _Dist ( _Eng );
    }

    param_type _Par;
};
#line 4735
template < class _Ty >
[ [ nodiscard ] ] bool operator == (
    const piecewise_constant_distribution < _Ty > & _Left, const piecewise_constant_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 4741
template < class _Ty >
[ [ nodiscard ] ] bool operator != (
    const piecewise_constant_distribution < _Ty > & _Left, const piecewise_constant_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 4747
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    piecewise_constant_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr );
}
#line 4753
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const piecewise_constant_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 4759
template < class _Ty = double >
class piecewise_linear_distribution
    : public discrete_distribution < size_t > {
public :
    static_assert ( _Is_any_of_v < _Ty, float, double, long double >, "invalid template argument for piecewise_linear_distribution: N4659 29.6.1.1 [rand.req.genl]/1d requires one of float, double, or" " long double" );

    using _Mybase = discrete_distribution < size_t >;
    using _Mypbase = typename _Mybase :: param_type;
    using result_type = _Ty;

    struct param_type : _Mypbase {


        using distribution_type = piecewise_linear_distribution;

        param_type ( ) : _Bvec { 0, 1 } {
            this -> _Pvec . push_back ( (1.0) );
        }

        template < class _InIt1, class _InIt2 >
        param_type ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 ) : _Mypbase ( _Noinit ), _Bvec ( _First1, _Last1 ) {
            if ( 2 <= _Bvec . size ( ) ) {
                for ( size_t _Idx = 0; _Idx < _Bvec . size ( ); ++ _Idx ) {
                    this -> _Pvec . push_back ( static_cast < double > ( * _First2 ++ ) );
                }
            } else {
                _Bvec = { 0, 1 };
            }

            _Init ( );
        }

        template < class _Fn >
        param_type ( initializer_list < _Ty > _Ilist, _Fn _Func ) : _Mypbase ( _Noinit ) {
            if ( 2 <= _Ilist . size ( ) ) {
                _Bvec . assign ( _Ilist );

                for ( const auto & _Bval : _Bvec ) {
                    this -> _Pvec . push_back ( _Func ( _Bval ) );
                }
            } else {
                _Bvec = { 0, 1 };
            }

            _Init ( );
        }

        template < class _Fn >
        param_type ( size_t _Count, _Ty _Low, _Ty _High, _Fn _Func ) : _Mypbase ( _Noinit ) {
            _Ty _Range = _High - _Low;
            ;
            if ( _Count < 1 ) {
                _Count = 1;
            }

            _Range /= static_cast < double > ( _Count );
            for ( size_t _Idx = 0; _Idx <= _Count; ++ _Idx ) {
                _Ty _Bval = _Low + _Idx * _Range;
                _Bvec . push_back ( _Bval );
                this -> _Pvec . push_back ( _Func ( _Bval ) );
            }
            _Init ( );
        }

        [ [ nodiscard ] ] bool operator == ( const param_type & _Right ) const {
            return static_cast < const _Mypbase & > ( * this ) == static_cast < const _Mypbase & > ( _Right ) && _Bvec == _Right . _Bvec;
        }

        [ [ nodiscard ] ] bool operator != ( const param_type & _Right ) const {
            return ! ( * this == _Right );
        }

        [ [ nodiscard ] ] vector < _Ty > intervals ( ) const {
            return _Bvec;
        }

        [ [ nodiscard ] ] vector < _Ty > densities ( ) const {
            vector < _Ty > _Ans ( this -> _Pvec . begin ( ), this -> _Pvec . end ( ) );
            return _Ans;
        }

        [ [ nodiscard ] ] double _Piece_probability ( const size_t _Idx ) const {
            return (0.5) * ( this -> _Pvec [ _Idx ] + this -> _Pvec [ _Idx + 1 ] )
                 * static_cast < double > ( _Bvec [ _Idx + 1 ] - _Bvec [ _Idx ] );
        }

        void _Init ( bool _Renorm = true ) {
            size_t _Size = this -> _Pvec . size ( );
            size_t _Idx;

            if ( _Renorm ) {
                if ( this -> _Pvec . empty ( ) ) {
                    this -> _Pvec = { (1.0), (1.0) };
                } else {
                    double _Sum = 0;

                    ;

                    for ( _Idx = 1; _Idx < _Size; ++ _Idx ) {
                        ;

                        _Sum += _Piece_probability ( _Idx - 1 );
                    }

                    ;

                    if ( _Sum != (1.0) ) {
                        for ( _Idx = 0; _Idx < _Size; ++ _Idx ) {
                            this -> _Pvec [ _Idx ] /= _Sum;
                        }
                    }
                }
            }

            this -> _Pcdf . assign ( 1, _Piece_probability ( 0 ) );
            for ( _Idx = 2; _Idx < _Size; ++ _Idx ) {
                this -> _Pcdf . push_back ( _Piece_probability ( _Idx - 1 ) + this -> _Pcdf [ _Idx - 2 ] );
            }
        }

        vector < _Ty > _Bvec;
    };

    piecewise_linear_distribution ( ) { }

    template < class _InIt1, class _InIt2 >
    piecewise_linear_distribution ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 ) : _Par ( _First1, _Last1, _First2 ) { }

    template < class _Fn >
    piecewise_linear_distribution ( initializer_list < _Ty > _Ilist, _Fn _Func ) : _Par ( _Ilist, _Func ) { }

    template < class _Fn >
    piecewise_linear_distribution ( size_t _Count, _Ty _Low, _Ty _High, _Fn _Func ) : _Par ( _Count, _Low, _High, _Func ) { }

    explicit piecewise_linear_distribution ( const param_type & _Par0 ) : _Par ( _Par0 ) { }

    [ [ nodiscard ] ] vector < _Ty > intervals ( ) const {
        return _Par . intervals ( );
    }

    [ [ nodiscard ] ] vector < _Ty > densities ( ) const {
        return _Par . densities ( );
    }

    [ [ nodiscard ] ] param_type param ( ) const {
        return _Par;
    }

    void param ( const param_type & _Par0 ) {
        _Par = _Par0;
    }

    [ [ nodiscard ] ] result_type ( min ) ( ) const {
        return _Par . _Bvec . front ( );
    }

    [ [ nodiscard ] ] result_type ( max ) ( ) const {
        return _Par . _Bvec . back ( );
    }

    void reset ( ) { }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng ) const {
        return _Eval ( _Eng, _Par );
    }

    template < class _Engine >
    [ [ nodiscard ] ] result_type operator ( ) ( _Engine & _Eng, const param_type & _Par0 ) const {
        return _Eval ( _Eng, _Par0 );
    }

    template < class _Elem, class _Traits >
    basic_istream < _Elem, _Traits > & _Read ( basic_istream < _Elem, _Traits > & _Istr,
        param_type & _Par0 ) {
        size_t _Nvals;
        _Istr >> _Nvals;
        _Par0 . _Pvec . clear ( );
        for (; 0 < _Nvals; -- _Nvals ) {
            double _Val;
            _In ( _Istr, _Val );
            _Par0 . _Pvec . push_back ( _Val );
        }

        _Par0 . _Bvec . clear ( );
        for ( size_t _Idx = _Par0 . _Pvec . size ( ); 0 < _Idx; -- _Idx ) {
            double _Val;
            _In ( _Istr, _Val );
            _Par0 . _Bvec . push_back ( _Val );
        }
        _Par0 . _Init ( false );
        return _Istr;
    }

    template < class _Elem, class _Traits >
    basic_ostream < _Elem, _Traits > & _Write ( basic_ostream < _Elem, _Traits > & _Ostr ) const {
        _Mybase :: _Write ( _Ostr, _Par );

        for ( size_t _Idx = 0; _Idx < _Par . _Bvec . size ( ); ++ _Idx ) {
            _Out ( _Ostr, _Par . _Bvec [ _Idx ] );
        }

        return _Ostr;
    }

    template < class _Engine >
    result_type _Eval ( _Engine & _Eng, const param_type & _Par0 ) const {
        size_t _Px = _Mybase :: operator ( ) ( _Eng, _Par0 );
        double _Px0 = _Par0 . _Pvec [ _Px ];
        double _Px1 = _Par0 . _Pvec [ _Px + 1 ];
        uniform_real < _Ty > _Dist;
        result_type _Xx0 = _Dist ( _Eng );

        if ( _Px0 != _Px1 ) {
            _Xx0 = static_cast < result_type > (
                ( :: std :: sqrt ( _Px0 * _Px0 * ( (1.0) - _Xx0 ) + _Px1 * _Px1 * _Xx0 ) - _Px0 ) / ( _Px1 - _Px0 ) );
        }

        return _Par0 . _Bvec [ _Px ] + _Xx0 * ( _Par0 . _Bvec [ _Px + 1 ] - _Par0 . _Bvec [ _Px ] );
    }

    param_type _Par;
};
#line 4983 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
template < class _Ty >
[ [ nodiscard ] ] bool operator == (
    const piecewise_linear_distribution < _Ty > & _Left, const piecewise_linear_distribution < _Ty > & _Right ) {
    return _Left . param ( ) == _Right . param ( );
}
#line 4989
template < class _Ty >
[ [ nodiscard ] ] bool operator != (
    const piecewise_linear_distribution < _Ty > & _Left, const piecewise_linear_distribution < _Ty > & _Right ) {
    return ! ( _Left == _Right );
}
#line 4995
template < class _Elem, class _Traits, class _Ty >
basic_istream < _Elem, _Traits > & operator >> ( basic_istream < _Elem, _Traits > & _Istr,
    piecewise_linear_distribution < _Ty > & _Dist ) {
    return _Dist . _Read ( _Istr, _Dist . _Par );
}
#line 5001
template < class _Elem, class _Traits, class _Ty >
basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
    const piecewise_linear_distribution < _Ty > & _Dist ) {
    return _Dist . _Write ( _Ostr );
}
#line 5007
using minstd_rand0 = linear_congruential_engine< unsigned, 16807U, 0U, 2147483647U> ; 
#line 5008
using minstd_rand = linear_congruential_engine< unsigned, 48271U, 0U, 2147483647U> ; 
#line 5010
using mt19937 = mersenne_twister_engine< unsigned, 32Ui64, 624Ui64, 397Ui64, 31Ui64, 2567483615U, 11Ui64, 4294967295U, 7Ui64, 2636928640U, 15Ui64, 4022730752U, 18Ui64, 1812433253U> ; 
#line 5014
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 5015
using _Ranbase = subtract_with_carry< unsigned, 16777216U, 10Ui64, 24Ui64> ; 
#line 5016
[[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef discard_block< subtract_with_carry< unsigned, 16777216U, 10Ui64, 24Ui64> , 223, 24>  ranlux3; 
#line 5017
[[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef discard_block< subtract_with_carry< unsigned, 16777216U, 10Ui64, 24Ui64> , 389, 24>  ranlux4; 
#line 5019
[[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef subtract_with_carry_01< float, 24Ui64, 10Ui64, 24Ui64>  ranlux_base_01; 
#line 5020
[[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef subtract_with_carry_01< double, 48Ui64, 5Ui64, 12Ui64>  ranlux64_base_01; 
#line 5021
[[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef discard_block< subtract_with_carry_01< float, 24Ui64, 10Ui64, 24Ui64> , 223, 24>  ranlux3_01; 
#line 5022
[[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef discard_block< subtract_with_carry_01< float, 24Ui64, 10Ui64, 24Ui64> , 389, 24>  ranlux4_01; 
#line 5023
__pragma( warning(pop)) 
#line 5026 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
using mt19937_64 = mersenne_twister_engine< unsigned __int64, 64Ui64, 312Ui64, 156Ui64, 31Ui64, 13043109905998158313Ui64, 29Ui64, 6148914691236517205Ui64, 17Ui64, 8202884508482404352Ui64, 37Ui64, 18444473444759240704Ui64, 43Ui64, 6364136223846793005Ui64> ; 
#line 5029
using ranlux24_base = subtract_with_carry_engine< unsigned, 24Ui64, 10Ui64, 24Ui64> ; 
#line 5030
using ranlux48_base = subtract_with_carry_engine< unsigned __int64, 48Ui64, 5Ui64, 12Ui64> ; 
#line 5031
using ranlux24 = discard_block_engine< subtract_with_carry_engine< unsigned, 24Ui64, 10Ui64, 24Ui64> , 223Ui64, 23Ui64> ; 
#line 5032
using ranlux48 = discard_block_engine< subtract_with_carry_engine< unsigned __int64, 48Ui64, 5Ui64, 12Ui64> , 389Ui64, 11Ui64> ; 
#line 5033
using knuth_b = shuffle_order_engine< linear_congruential_engine< unsigned, 16807U, 0U, 2147483647U> , 256Ui64> ; 
#line 5035
using default_random_engine = mt19937; 
#line 5038
unsigned __cdecl _Random_device(); 
#line 5040
class random_device { 
#line 5042
public: using result_type = unsigned; 
#line 5044
random_device() { } 
#line 5046
explicit random_device(const string &) { } 
#line 5048
[[nodiscard]] static constexpr result_type min() { 
#line 5049
return 0; 
#line 5050
} 
#line 5052
[[nodiscard]] static constexpr result_type max() { 
#line 5053
return static_cast< result_type>(-1); 
#line 5054
} 
#line 5056
[[nodiscard]] double entropy() const noexcept { 
#line 5057
return (32.0); 
#line 5058
} 
#line 5060
[[nodiscard]] result_type operator()() { 
#line 5061
return _Random_device(); 
#line 5062
} 
#line 5064
random_device(const random_device &) = delete;
#line 5065
random_device &operator=(const random_device &) = delete;
#line 5066
}; 
#line 5069
__pragma( warning(push)) __pragma( warning(disable : 4996)) 
#line 5070
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 5071
using std::bernoulli_distribution;
#line 5072
using std::binomial_distribution;
#line 5073
using std::discard_block;
#line 5074
using std::exponential_distribution;
#line 5075
using std::gamma_distribution;
#line 5076
using std::geometric_distribution;
#line 5077
using std::linear_congruential;
#line 5078
using std::mersenne_twister;
#line 5079
using std::minstd_rand;
#line 5080
using std::minstd_rand0;
#line 5081
using std::mt19937;
#line 5082
using std::normal_distribution;
#line 5083
using std::poisson_distribution;
#line 5084
using std::random_device;
#line 5085
using std::ranlux3;
#line 5086
using std::ranlux3_01;
#line 5087
using std::ranlux4;
#line 5088
using std::ranlux4_01;
#line 5089
using std::ranlux64_base_01;
#line 5090
using std::ranlux_base_01;
#line 5091
using std::subtract_with_carry;
#line 5092
using std::subtract_with_carry_01;
#line 5093
using std::uniform_int;
#line 5094
using std::uniform_real;
#line 5095
using std::cauchy_distribution;
#line 5096
using std::chi_squared_distribution;
#line 5097
using std::default_random_engine;
#line 5098
using std::discard_block_engine;
#line 5099
using std::discrete_distribution;
#line 5100
using std::extreme_value_distribution;
#line 5101
using std::fisher_f_distribution;
#line 5102
using std::generate_canonical;
#line 5103
using std::independent_bits_engine;
#line 5104
using std::knuth_b;
#line 5105
using std::linear_congruential_engine;
#line 5106
using std::lognormal_distribution;
#line 5107
using std::mersenne_twister_engine;
#line 5108
using std::mt19937_64;
#line 5109
using std::negative_binomial_distribution;
#line 5110
using std::piecewise_constant_distribution;
#line 5111
using std::piecewise_linear_distribution;
#line 5112
using std::ranlux24;
#line 5113
using std::ranlux24_base;
#line 5114
using std::ranlux48;
#line 5115
using std::ranlux48_base;
#line 5116
using std::seed_seq;
#line 5117
using std::shuffle_order_engine;
#line 5118
using std::student_t_distribution;
#line 5119
using std::subtract_with_carry_engine;
#line 5120
using std::uniform_int_distribution;
#line 5121
using std::uniform_real_distribution;
#line 5122
using std::weibull_distribution;
#line 5123
}
#line 5124
__pragma( warning(pop)) 
#line 5126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
}
#line 5132
#pragma warning(pop)
#pragma pack ( pop )
#line 5136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
#pragma external_header(pop)
#line 20 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ratio"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 21
namespace std { 
#line 22
template< intmax_t _Val> 
#line 23
struct _Abs : public integral_constant< __int64, (((_Val) < (0)) ? -_Val : _Val)>  { }; 
#line 25
template< intmax_t _Ax, intmax_t _Bx, bool _Sfinae = false, bool 
#line 26
_Good = _Abs< _Ax> ::value <= (9223372036854775807i64 / ((_Bx == (0)) ? 1 : _Abs< _Bx> ::value))> 
#line 27
struct _Safe_mult : public integral_constant< __int64, _Ax * _Bx>  { }; 
#line 29
template< intmax_t _Ax, intmax_t _Bx, bool _Sfinae> 
#line 30
struct _Safe_mult< _Ax, _Bx, _Sfinae, false>  { 
#line 31
static_assert(_Sfinae, "integer arithmetic overflow");
#line 32
}; 
#line 34
template< intmax_t _Val> 
#line 35
struct _Sign_of : public integral_constant< __int64, (((_Val) < (0)) ? -1 : 1)>  { }; 
#line 37
template< intmax_t _Ax, intmax_t _Bx, bool _Good, bool _Also_good> 
#line 38
struct _Safe_addX : public integral_constant< __int64, _Ax + _Bx>  { }; 
#line 40
template< intmax_t _Ax, intmax_t _Bx> 
#line 41
struct _Safe_addX< _Ax, _Bx, false, false>  { 
#line 42
static_assert((_Always_false< std::_Safe_addX< _Ax, _Bx, false, false> > ), "integer arithmetic overflow");
#line 43
}; 
#line 45
template< intmax_t _Ax, intmax_t _Bx> 
#line 46
struct _Safe_add : public _Safe_addX< _Ax, _Bx, _Sign_of< _Ax> ::value != _Sign_of< _Bx> ::value, _Abs< _Ax> ::value <= (9223372036854775807i64 - _Abs< _Bx> ::value)> ::type { 
#line 49
}; 
#line 51
template< intmax_t _Ax, intmax_t _Bx> 
#line 52
struct _GcdX : public _GcdX< _Bx, _Ax % _Bx> ::type { }; 
#line 54
template< intmax_t _Ax> 
#line 55
struct _GcdX< _Ax, 0>  : public integral_constant< __int64, _Ax>  { }; 
#line 57
template< intmax_t _Ax, intmax_t _Bx> 
#line 58
struct _Gcd : public _GcdX< _Abs< _Ax> ::value, _Abs< _Bx> ::value> ::type { }; 
#line 61
template<> struct _Gcd< 0i64, 0i64>  : public integral_constant< __int64, 1i64>  { 
#line 63
}; 
#line 65
template< intmax_t _Nx, intmax_t _Dx = 1i64> 
#line 66
struct ratio { 
#line 67
static_assert((_Dx != (0)), "zero denominator");
#line 68
static_assert(((-9223372036854775807i64) <= _Nx), "numerator too negative");
#line 69
static_assert(((-9223372036854775807i64) <= _Dx), "denominator too negative");
#line 71
static constexpr intmax_t num = (((_Sign_of< _Nx> ::value * _Sign_of< _Dx> ::value) * _Abs< _Nx> ::value) / _Gcd< _Nx, _Dx> ::value); 
#line 74
static constexpr intmax_t den = (_Abs< _Dx> ::value / _Gcd< _Nx, _Dx> ::value); 
#line 76
using type = ratio< num, den> ; 
#line 77
}; 
#line 79
template< class _Ty> constexpr bool 
#line 80
_Is_ratio_v = false; 
#line 82
template< intmax_t _Rx1, intmax_t _Rx2> constexpr bool 
#line 83
_Is_ratio_v< ratio< _Rx1, _Rx2> >  = true; 
#line 85
template< class _Rx1, class _Rx2> 
#line 86
struct _Ratio_add { 
#line 87
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_add<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 89
static constexpr intmax_t _Nx1 = (_Rx1::num); 
#line 90
static constexpr intmax_t _Dx1 = (_Rx1::den); 
#line 91
static constexpr intmax_t _Nx2 = (_Rx2::num); 
#line 92
static constexpr intmax_t _Dx2 = (_Rx2::den); 
#line 94
static constexpr intmax_t _Gx = (_Gcd< _Dx1, _Dx2> ::value); 
#line 97
using type = typename ratio< _Safe_add< _Safe_mult< _Nx1, _Dx2 / _Gx> ::value, _Safe_mult< _Nx2, _Dx1 / _Gx> ::value> ::value, _Safe_mult< _Dx1, _Dx2 / _Gx> ::value> ::type; 
#line 100
}; 
#line 102
template< class _Rx1, class _Rx2> using ratio_add = typename _Ratio_add< _Rx1, _Rx2> ::type; 
#line 105
template< class _Rx1, class _Rx2> 
#line 106
struct _Ratio_subtract { 
#line 107
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_subtract<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 109
static constexpr intmax_t _Nx2 = (_Rx2::num); 
#line 110
static constexpr intmax_t _Dx2 = (_Rx2::den); 
#line 112
using type = ratio_add< _Rx1, ratio< -_Nx2, _Dx2> > ; 
#line 113
}; 
#line 115
template< class _Rx1, class _Rx2> using ratio_subtract = typename _Ratio_subtract< _Rx1, _Rx2> ::type; 
#line 118
template< class _Rx1, class _Rx2> 
#line 119
struct _Ratio_multiply { 
#line 120
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 122
static constexpr intmax_t _Nx1 = (_Rx1::num); 
#line 123
static constexpr intmax_t _Dx1 = (_Rx1::den); 
#line 124
static constexpr intmax_t _Nx2 = (_Rx2::num); 
#line 125
static constexpr intmax_t _Dx2 = (_Rx2::den); 
#line 127
static constexpr intmax_t _Gx = (_Gcd< _Nx1, _Dx2> ::value); 
#line 128
static constexpr intmax_t _Gy = (_Gcd< _Nx2, _Dx1> ::value); 
#line 130
using _Num = _Safe_mult< _Nx1 / _Gx, _Nx2 / _Gy, true> ; 
#line 131
using _Den = _Safe_mult< _Dx1 / _Gy, _Dx2 / _Gx, true> ; 
#line 132
}; 
#line 134
template< class _Rx1, class _Rx2, bool _Sfinae = true, class  = void> 
#line 135
struct _Ratio_multiply_sfinae { 
#line 136
static_assert(_Sfinae, "integer arithmetic overflow");
#line 137
}; 
#line 139
template< class _Rx1, class _Rx2, bool _Sfinae> 
#line 140
struct _Ratio_multiply_sfinae< _Rx1, _Rx2, _Sfinae, void_t< typename _Ratio_multiply< _Rx1, _Rx2> ::_Num::type, typename _Ratio_multiply< _Rx1, _Rx2> ::_Den::type> >  { 
#line 143
using type = ratio< _Ratio_multiply< _Rx1, _Rx2> ::_Num::value, _Ratio_multiply< _Rx1, _Rx2> ::_Den::value> ; 
#line 144
}; 
#line 146
template< class _Rx1, class _Rx2> using ratio_multiply = typename _Ratio_multiply_sfinae< _Rx1, _Rx2, false> ::type; 
#line 149
template< class _Rx1, class _Rx2> 
#line 150
struct _Ratio_divide { 
#line 151
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 153
static constexpr intmax_t _Nx2 = (_Rx2::num); 
#line 154
static constexpr intmax_t _Dx2 = (_Rx2::den); 
#line 156
using _Rx2_inverse = ratio< _Dx2, _Nx2> ; 
#line 157
}; 
#line 159
template< class _Rx1, class _Rx2, bool _Sfinae = true> using _Ratio_divide_sfinae = typename _Ratio_multiply_sfinae< _Rx1, typename _Ratio_divide< _Rx1, _Rx2> ::_Rx2_inverse, _Sfinae> ::type; 
#line 163
template< class _Rx1, class _Rx2> using ratio_divide = _Ratio_divide_sfinae< _Rx1, _Rx2, false> ; 
#line 166
template< class _Rx1, class _Rx2> 
#line 167
struct ratio_equal : public bool_constant< (_Rx1::num == _Rx2::num) && (_Rx1::den == _Rx2::den)>  { 
#line 168
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 169
}; 
#line 171
template< class _Rx1, class _Rx2> constexpr bool 
#line 172
ratio_equal_v = (ratio_equal< _Rx1, _Rx2> ::value); 
#line 174
template< class _Rx1, class _Rx2> 
#line 175
struct ratio_not_equal : public bool_constant< !ratio_equal_v< _Rx1, _Rx2> >  { 
#line 176
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_not_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 177
}; 
#line 179
template< class _Rx1, class _Rx2> constexpr bool 
#line 180
ratio_not_equal_v = (ratio_not_equal< _Rx1, _Rx2> ::value); 
#line 182
struct _Big_uint128 { 
#line 183
uint64_t _Upper; 
#line 184
uint64_t _Lower; 
#line 186
constexpr bool operator<(const _Big_uint128 _Rhs) const noexcept { 
#line 187
if ((_Upper) != (_Rhs._Upper)) { 
#line 188
return (_Upper) < (_Rhs._Upper); 
#line 189
}  
#line 191
return (_Lower) < (_Rhs._Lower); 
#line 192
} 
#line 193
}; 
#line 195
constexpr _Big_uint128 _Big_multiply(const uint64_t _Lfactor, const uint64_t 
#line 196
_Rfactor) noexcept { 
#line 197
const uint64_t _Llow = _Lfactor & 4294967295Ui64; 
#line 198
const uint64_t _Lhigh = _Lfactor >> 32; 
#line 199
const uint64_t _Rlow = _Rfactor & 4294967295Ui64; 
#line 200
const uint64_t _Rhigh = _Rfactor >> 32; 
#line 202
uint64_t _Temp = _Llow * _Rlow; 
#line 203
const uint64_t _Lower32 = _Temp & 4294967295Ui64; 
#line 204
uint64_t _Carry = _Temp >> 32; 
#line 206
_Temp = ((_Llow * _Rhigh) + _Carry); 
#line 207
const uint64_t _Mid_lower = _Temp & 4294967295Ui64; 
#line 208
const uint64_t _Mid_upper = _Temp >> 32; 
#line 210
_Temp = ((_Lhigh * _Rlow) + _Mid_lower); 
#line 211
_Carry = (_Temp >> 32); 
#line 213
return {((_Lhigh * _Rhigh) + _Mid_upper) + _Carry, (_Temp << 32) + _Lower32}; 
#line 214
} 
#line 216
constexpr bool _Ratio_less(const int64_t _Nx1, const int64_t _Dx1, const int64_t _Nx2, const int64_t _Dx2) noexcept { 
#line 217
if ((_Nx1 >= (0)) && (_Nx2 >= (0))) { 
#line 218
return ((_Big_multiply(static_cast< uint64_t>(_Nx1), static_cast< uint64_t>(_Dx2))) < (_Big_multiply(static_cast< uint64_t>(_Nx2), static_cast< uint64_t>(_Dx1)))); 
#line 220
}  
#line 222
if ((_Nx1 < (0)) && (_Nx2 < (0))) { 
#line 223
return ((_Big_multiply(static_cast< uint64_t>(-_Nx2), static_cast< uint64_t>(_Dx1))) < (_Big_multiply(static_cast< uint64_t>(-_Nx1), static_cast< uint64_t>(_Dx2)))); 
#line 225
}  
#line 227
return _Nx1 < _Nx2; 
#line 228
} 
#line 230
template< class _Rx1, class _Rx2> 
#line 231
struct ratio_less : public bool_constant< _Ratio_less(_Rx1::num, _Rx1::den, _Rx2::num, _Rx2::den)>  { 
#line 232
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_less<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 233
}; 
#line 235
template< class _Rx1, class _Rx2> constexpr bool 
#line 236
ratio_less_v = (ratio_less< _Rx1, _Rx2> ::value); 
#line 238
template< class _Rx1, class _Rx2> 
#line 239
struct ratio_less_equal : public bool_constant< !ratio_less_v< _Rx2, _Rx1> >  { 
#line 240
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_less_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 242
}; 
#line 244
template< class _Rx1, class _Rx2> constexpr bool 
#line 245
ratio_less_equal_v = (ratio_less_equal< _Rx1, _Rx2> ::value); 
#line 247
template< class _Rx1, class _Rx2> 
#line 248
struct ratio_greater : public ratio_less< _Rx2, _Rx1> ::type { 
#line 249
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_greater<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 250
}; 
#line 252
template< class _Rx1, class _Rx2> constexpr bool 
#line 253
ratio_greater_v = (ratio_greater< _Rx1, _Rx2> ::value); 
#line 255
template< class _Rx1, class _Rx2> 
#line 256
struct ratio_greater_equal : public bool_constant< !ratio_less_v< _Rx1, _Rx2> >  { 
#line 257
static_assert((_Is_ratio_v< _Rx1>  && _Is_ratio_v< _Rx2> ), "ratio_greater_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
#line 259
}; 
#line 261
template< class _Rx1, class _Rx2> constexpr bool 
#line 262
ratio_greater_equal_v = (ratio_greater_equal< _Rx1, _Rx2> ::value); 
#line 264
using atto = ratio< 1i64, 1000000000000000000i64> ; 
#line 265
using femto = ratio< 1i64, 1000000000000000i64> ; 
#line 266
using pico = ratio< 1i64, 1000000000000i64> ; 
#line 267
using nano = ratio< 1i64, 1000000000i64> ; 
#line 268
using micro = ratio< 1i64, 1000000i64> ; 
#line 269
using milli = ratio< 1i64, 1000i64> ; 
#line 270
using centi = ratio< 1i64, 100i64> ; 
#line 271
using deci = ratio< 1i64, 10i64> ; 
#line 272
using deca = ratio< 10i64, 1i64> ; 
#line 273
using hecto = ratio< 100i64, 1i64> ; 
#line 274
using kilo = ratio< 1000i64, 1i64> ; 
#line 275
using mega = ratio< 1000000i64, 1i64> ; 
#line 276
using giga = ratio< 1000000000i64, 1i64> ; 
#line 277
using tera = ratio< 1000000000000i64, 1i64> ; 
#line 278
using peta = ratio< 1000000000000000i64, 1i64> ; 
#line 279
using exa = ratio< 1000000000000000000i64, 1i64> ; 
#line 280
}
#line 283
#pragma warning(pop)
#pragma pack ( pop )
#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ratio"
#pragma external_header(pop)
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 29
namespace std { 
#line 30
namespace chrono { 
#line 31
template< class _Rep> 
#line 32
struct treat_as_floating_point : public is_floating_point< _Rep>  { }; 
#line 34
template< class _Rep> constexpr bool 
#line 35
treat_as_floating_point_v = (treat_as_floating_point< _Rep> ::value); 
#line 37
template < class _Rep >
    struct duration_values {
        [ [ nodiscard ] ] static constexpr _Rep zero ( ) noexcept {

            return _Rep ( 0 );
        }

        [ [ nodiscard ] ] static constexpr _Rep ( min ) ( ) noexcept {

            return numeric_limits < _Rep > :: lowest ( );
        }

        [ [ nodiscard ] ] static constexpr _Rep ( max ) ( ) noexcept {

            return ( numeric_limits < _Rep > :: max ) ( );
        }
    };
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
template < class _Rep, class _Period = ratio < 1 > >
    class duration;
#line 74
template< class _Ty> constexpr bool 
#line 75
_Is_duration_v = _Is_specialization_v< _Ty, duration> ; 
#line 77
template < class _To, class _Rep, class _Period, enable_if_t < _Is_duration_v < _To >, int > = 0 >
    constexpr _To duration_cast ( const duration < _Rep, _Period > & ) noexcept (
        is_arithmetic_v < _Rep > && is_arithmetic_v < typename _To :: rep > );
#line 81
template < class _Rep, class _Period >
    class duration {
    public :
        using rep = _Rep;
        using period = typename _Period :: type;

        static_assert ( ! _Is_duration_v < _Rep >, "duration can\'t have duration as first template argument" );
        static_assert ( _Is_ratio_v < _Period >, "period not an instance of std::ratio" );
        static_assert ( 0 < _Period :: num, "period negative or zero" );

        constexpr duration ( ) = default;

        template < class _Rep2,
            enable_if_t < is_convertible_v < const _Rep2 &,
                            _Rep > && ( treat_as_floating_point_v < _Rep > || ! treat_as_floating_point_v < _Rep2 > ),
                int > = 0 >
        constexpr explicit duration ( const _Rep2 & _Val ) noexcept (
            is_arithmetic_v < _Rep > && is_arithmetic_v < _Rep2 > )
            : _MyRep ( static_cast < _Rep > ( _Val ) ) { }

        template < class _Rep2, class _Period2,
            enable_if_t <
                treat_as_floating_point_v <
                    _Rep > || ( _Ratio_divide_sfinae < _Period2, _Period > :: den == 1 && ! treat_as_floating_point_v < _Rep2 > ),
                int > = 0 >
        constexpr duration ( const duration < _Rep2, _Period2 > & _Dur ) noexcept (
            is_arithmetic_v < _Rep > && is_arithmetic_v < _Rep2 > )
            : _MyRep ( :: std :: chrono :: duration_cast < duration > ( _Dur ) . count ( ) ) { }

        [ [ nodiscard ] ] constexpr _Rep count ( ) const noexcept ( is_arithmetic_v < _Rep > ) {
            return _MyRep;
        }

        [ [ nodiscard ] ] constexpr common_type_t < duration > operator + ( ) const
            noexcept ( is_arithmetic_v < _Rep > ) {
            return common_type_t < duration > ( * this );
        }

        [ [ nodiscard ] ] constexpr common_type_t < duration > operator - ( ) const
            noexcept ( is_arithmetic_v < _Rep > ) {
            return common_type_t < duration > ( - _MyRep );
        }

        inline duration & operator ++ ( ) noexcept ( is_arithmetic_v < _Rep > ) {
            ++ _MyRep;
            return * this;
        }

        inline duration operator ++ ( int ) noexcept ( is_arithmetic_v < _Rep > ) {
            return duration ( _MyRep ++ );
        }

        inline duration & operator -- ( ) noexcept ( is_arithmetic_v < _Rep > ) {
            -- _MyRep;
            return * this;
        }

        inline duration operator -- ( int ) noexcept ( is_arithmetic_v < _Rep > ) {
            return duration ( _MyRep -- );
        }

        inline duration & operator += ( const duration & _Right ) noexcept ( is_arithmetic_v < _Rep > ) {
            _MyRep += _Right . _MyRep;
            return * this;
        }

        inline duration & operator -= ( const duration & _Right ) noexcept ( is_arithmetic_v < _Rep > ) {
            _MyRep -= _Right . _MyRep;
            return * this;
        }

        inline duration & operator *= ( const _Rep & _Right ) noexcept ( is_arithmetic_v < _Rep > ) {
            _MyRep *= _Right;
            return * this;
        }

        inline duration & operator /= ( const _Rep & _Right ) noexcept ( is_arithmetic_v < _Rep > ) {
            _MyRep /= _Right;
            return * this;
        }

        inline duration & operator %= ( const _Rep & _Right ) noexcept ( is_arithmetic_v < _Rep > ) {
            _MyRep %= _Right;
            return * this;
        }

        inline duration & operator %= ( const duration & _Right ) noexcept ( is_arithmetic_v < _Rep > ) {
            _MyRep %= _Right . count ( );
            return * this;
        }

        [ [ nodiscard ] ] static constexpr duration zero ( ) noexcept {

            return duration ( duration_values < _Rep > :: zero ( ) );
        }

        [ [ nodiscard ] ] static constexpr duration ( min ) ( ) noexcept {

            return duration ( ( duration_values < _Rep > :: min ) ( ) );
        }

        [ [ nodiscard ] ] static constexpr duration ( max ) ( ) noexcept {

            return duration ( ( duration_values < _Rep > :: max ) ( ) );
        }

    private :
        _Rep _MyRep;
    };
#line 191
template < class _Clock, class _Duration = typename _Clock :: duration >
    class time_point {
    public :
        using clock = _Clock;
        using duration = _Duration;
        using rep = typename _Duration :: rep;
        using period = typename _Duration :: period;

        static_assert ( _Is_duration_v < _Duration >,
            "N4885 [time.point.general]/1 mandates Duration to be a specialization of chrono::duration." );

        constexpr time_point ( ) = default;

        constexpr explicit time_point ( const _Duration & _Other ) noexcept ( is_arithmetic_v < rep > )
            : _MyDur ( _Other ) { }

        template < class _Duration2, enable_if_t < is_convertible_v < _Duration2, _Duration >, int > = 0 >
        constexpr time_point ( const time_point < _Clock, _Duration2 > & _Tp ) noexcept (
            is_arithmetic_v < rep > && is_arithmetic_v < typename _Duration2 :: rep > )
            : _MyDur ( _Tp . time_since_epoch ( ) ) { }

        [ [ nodiscard ] ] constexpr _Duration time_since_epoch ( ) const noexcept ( is_arithmetic_v < rep > ) {
            return _MyDur;
        }


















        inline time_point & operator += ( const _Duration & _Dur ) noexcept ( is_arithmetic_v < rep > ) {
            _MyDur += _Dur;
            return * this;
        }

        inline time_point & operator -= ( const _Duration & _Dur ) noexcept ( is_arithmetic_v < rep > ) {
            _MyDur -= _Dur;
            return * this;
        }

        [ [ nodiscard ] ] static constexpr time_point ( min ) ( ) noexcept {
            return time_point ( ( _Duration :: min ) ( ) );
        }

        [ [ nodiscard ] ] static constexpr time_point ( max ) ( ) noexcept {
            return time_point ( ( _Duration :: max ) ( ) );
        }

    private :
        _Duration _MyDur { duration :: zero ( ) };
    };
#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
}
#line 256
template< class _Rep, class _Period> constexpr bool 
#line 257
_Is_trivially_swappable_v< chrono::duration< _Rep, _Period> >  = _Is_trivially_swappable_v< _Rep> ; 
#line 259
template< class _Clock, class _Duration> constexpr bool 
#line 260
_Is_trivially_swappable_v< chrono::time_point< _Clock, _Duration> >  = _Is_trivially_swappable_v< _Duration> ; 
#line 263
template< intmax_t _Ax, intmax_t _Bx, bool  = (_Ax / _Gcd< _Ax, _Bx> ::value) <= (9223372036854775807i64 / _Bx)> 
#line 264
struct _Lcm : public integral_constant< __int64, (_Ax / _Gcd< _Ax, _Bx> ::value) * _Bx>  { }; 
#line 265
template< intmax_t _Ax, intmax_t _Bx> 
#line 266
struct _Lcm< _Ax, _Bx, false>  { }; 
#line 268
template< class _Rep1, class _Period1, class _Rep2, class _Period2> 
#line 269
struct common_type< chrono::duration< _Rep1, _Period1> , chrono::duration< _Rep2, _Period2> >  { 
#line 270
using type = chrono::duration< common_type_t< _Rep1, _Rep2> , ratio< _Gcd< _Period1::num, _Period2::num> ::value, _Lcm< _Period1::den, _Period2::den> ::value> > ; 
#line 272
}; 
#line 274
template< class _Clock, class _Duration1, class _Duration2> 
#line 275
struct common_type< chrono::time_point< _Clock, _Duration1> , chrono::time_point< _Clock, _Duration2> >  { 
#line 277
using type = chrono::time_point< _Clock, common_type_t< _Duration1, _Duration2> > ; 
#line 278
}; 
#line 280
namespace chrono { 
#line 281
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 > >
        operator + ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CD = common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 >>;
        return _CD ( _CD ( _Left ) . count ( ) + _CD ( _Right ) . count ( ) );
    }
#line 289
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 > >
        operator - ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CD = common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 >>;
        return _CD ( _CD ( _Left ) . count ( ) - _CD ( _Right ) . count ( ) );
    }
#line 297
template < class _Rep1, class _Period1, class _Rep2,
        enable_if_t < is_convertible_v < const _Rep2 &, common_type_t < _Rep1, _Rep2 > >, int > = 0 >
    [ [ nodiscard ] ] constexpr duration < common_type_t < _Rep1, _Rep2 >, _Period1 > operator * (
        const duration < _Rep1, _Period1 > & _Left,
        const _Rep2 & _Right ) noexcept ( is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CR = common_type_t < _Rep1, _Rep2 >;
        using _CD = duration < _CR, _Period1 >;
        return _CD ( _CD ( _Left ) . count ( ) * _Right );
    }
#line 307
template < class _Rep1, class _Rep2, class _Period2,
        enable_if_t < is_convertible_v < const _Rep1 &, common_type_t < _Rep1, _Rep2 > >, int > = 0 >
    [ [ nodiscard ] ] constexpr duration < common_type_t < _Rep1, _Rep2 >, _Period2 >
        operator * ( const _Rep1 & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        return _Right * _Left;
    }
#line 315
template< class _CR, class _Period1, class _Rep2, bool  = is_convertible_v< const _Rep2 &, _CR> > 
#line 316
struct _Duration_div_mod1 { 
#line 317
using type = duration< _CR, _Period1> ; 
#line 318
}; 
#line 320
template< class _CR, class _Period1, class _Rep2> 
#line 321
struct _Duration_div_mod1< _CR, _Period1, _Rep2, false>  { }; 
#line 323
template< class _CR, class _Period1, class _Rep2, bool  = _Is_duration_v< _Rep2> > 
#line 324
struct _Duration_div_mod { }; 
#line 326
template< class _CR, class _Period1, class _Rep2> 
#line 327
struct _Duration_div_mod< _CR, _Period1, _Rep2, false>  : public _Duration_div_mod1< _CR, _Period1, _Rep2>  { 
#line 329
}; 
#line 331
template < class _Rep1, class _Period1, class _Rep2 >
    [ [ nodiscard ] ] constexpr typename _Duration_div_mod < common_type_t < _Rep1, _Rep2 >, _Period1, _Rep2 > :: type operator / (
        const duration < _Rep1, _Period1 > & _Left,
        const _Rep2 & _Right ) noexcept ( is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CR = common_type_t < _Rep1, _Rep2 >;
        using _CD = duration < _CR, _Period1 >;
        return _CD ( _CD ( _Left ) . count ( ) / _Right );
    }
#line 340
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr common_type_t < _Rep1, _Rep2 >
        operator / ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CD = common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 >>;
        return _CD ( _Left ) . count ( ) / _CD ( _Right ) . count ( );
    }
#line 348
template < class _Rep1, class _Period1, class _Rep2 >
    [ [ nodiscard ] ] constexpr typename _Duration_div_mod < common_type_t < _Rep1, _Rep2 >, _Period1, _Rep2 > :: type operator % (
        const duration < _Rep1, _Period1 > & _Left,
        const _Rep2 & _Right ) noexcept ( is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CR = common_type_t < _Rep1, _Rep2 >;
        using _CD = duration < _CR, _Period1 >;
        return _CD ( _CD ( _Left ) . count ( ) % _Right );
    }
#line 357
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 > >
        operator % ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CD = common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 >>;
        return _CD ( _CD ( _Left ) . count ( ) % _CD ( _Right ) . count ( ) );
    }
#line 365
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr bool
        operator == ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CT = common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 >>;
        return _CT ( _Left ) . count ( ) == _CT ( _Right ) . count ( );
    }
#line 374
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr bool
        operator != ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        return ! ( _Left == _Right );
    }
#line 382 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr bool
        operator < ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        using _CT = common_type_t < duration < _Rep1, _Period1 >, duration < _Rep2, _Period2 >>;
        return _CT ( _Left ) . count ( ) < _CT ( _Right ) . count ( );
    }
#line 390
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr bool
        operator <= ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        return ! ( _Right < _Left );
    }
#line 397
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr bool
        operator > ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        return _Right < _Left;
    }
#line 404
template < class _Rep1, class _Period1, class _Rep2, class _Period2 >
    [ [ nodiscard ] ] constexpr bool
        operator >= ( const duration < _Rep1, _Period1 > & _Left, const duration < _Rep2, _Period2 > & _Right ) noexcept (
            is_arithmetic_v < _Rep1 > && is_arithmetic_v < _Rep2 > ) {
        return ! ( _Left < _Right );
    }
#line 424
template < class _To, class _Rep, class _Period, enable_if_t < _Is_duration_v < _To >, int > _Enabled >
    [ [ nodiscard ] ] constexpr _To duration_cast ( const duration < _Rep, _Period > & _Dur ) noexcept (
        is_arithmetic_v < _Rep > && is_arithmetic_v < typename _To :: rep > ) {

        using _CF = ratio_divide < _Period, typename _To :: period >;

        using _ToRep = typename _To :: rep;
        using _CR = common_type_t < _ToRep, _Rep, intmax_t >;

        constexpr bool _Num_is_one = _CF :: num == 1;
        constexpr bool _Den_is_one = _CF :: den == 1;

        if ( _Den_is_one ) {
            if ( _Num_is_one ) {
                return static_cast < _To > ( static_cast < _ToRep > ( _Dur . count ( ) ) );
            } else {
                return static_cast < _To > (
                    static_cast < _ToRep > ( static_cast < _CR > ( _Dur . count ( ) ) * static_cast < _CR > ( _CF :: num ) ) );
            }
        } else {
            if ( _Num_is_one ) {
                return static_cast < _To > (
                    static_cast < _ToRep > ( static_cast < _CR > ( _Dur . count ( ) ) / static_cast < _CR > ( _CF :: den ) ) );
            } else {
                return static_cast < _To > ( static_cast < _ToRep > (
                    static_cast < _CR > ( _Dur . count ( ) ) * static_cast < _CR > ( _CF :: num ) / static_cast < _CR > ( _CF :: den ) ) );
            }
        }
    }
#line 454
template < class _To, class _Rep, class _Period, enable_if_t < _Is_duration_v < _To >, int > = 0 >
    [ [ nodiscard ] ] constexpr _To floor ( const duration < _Rep, _Period > & _Dur ) noexcept (
        is_arithmetic_v < _Rep > && is_arithmetic_v < typename _To :: rep > ) {


        const _To _Casted { :: std :: chrono :: duration_cast < _To > ( _Dur ) };
        if ( _Casted > _Dur ) {
            return _To { _Casted . count ( ) - static_cast < typename _To :: rep > ( 1 ) };
        }

        return _Casted;
    }
#line 467
template < class _To, class _Rep, class _Period, enable_if_t < _Is_duration_v < _To >, int > = 0 >
    [ [ nodiscard ] ] constexpr _To ceil ( const duration < _Rep, _Period > & _Dur ) noexcept (
        is_arithmetic_v < _Rep > && is_arithmetic_v < typename _To :: rep > ) {


        const _To _Casted { :: std :: chrono :: duration_cast < _To > ( _Dur ) };
        if ( _Casted < _Dur ) {
            return _To { _Casted . count ( ) + static_cast < typename _To :: rep > ( 1 ) };
        }

        return _Casted;
    }
#line 480
template < class _Rep >
    constexpr bool _Is_even ( _Rep _Val ) noexcept ( is_arithmetic_v < _Rep > ) {

        return _Val % 2 == 0;
    }
#line 486
template < class _To, class _Rep, class _Period,
        enable_if_t < _Is_duration_v < _To > && ! treat_as_floating_point_v < typename _To :: rep >, int > = 0 >
    [ [ nodiscard ] ] constexpr _To round ( const duration < _Rep, _Period > & _Dur ) noexcept (
        is_arithmetic_v < _Rep > && is_arithmetic_v < typename _To :: rep > ) {

        const _To _Floored { :: std :: chrono :: floor < _To > ( _Dur ) };
        const _To _Ceiled { _Floored + _To { 1 } };
        const auto _Floor_adjustment = _Dur - _Floored;
        const auto _Ceil_adjustment = _Ceiled - _Dur;
        if ( _Floor_adjustment < _Ceil_adjustment
            || ( _Floor_adjustment == _Ceil_adjustment && _Is_even ( _Floored . count ( ) ) ) ) {
            return _Floored;
        }

        return _Ceiled;
    }
#line 503
template < class _Rep, class _Period, enable_if_t < numeric_limits < _Rep > :: is_signed, int > = 0 >
    [ [ nodiscard ] ] constexpr duration < _Rep, _Period > abs ( const duration < _Rep, _Period > _Dur ) noexcept (
        is_arithmetic_v < _Rep > ) {

        return _Dur < duration < _Rep, _Period > :: zero ( ) ? duration < _Rep, _Period > :: zero ( ) - _Dur : _Dur;
    }
#line 510
using nanoseconds = duration< __int64, ratio< 1i64, 1000000000i64> > ; 
#line 511
using microseconds = duration< __int64, ratio< 1i64, 1000000i64> > ; 
#line 512
using milliseconds = duration< __int64, ratio< 1i64, 1000i64> > ; 
#line 513
using seconds = duration< __int64> ; 
#line 514
using minutes = duration< int, ratio< 60i64> > ; 
#line 515
using hours = duration< int, ratio< 3600i64> > ; 
#line 523 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
template < class _Clock, class _Duration, class _Rep, class _Period >
    [ [ nodiscard ] ] constexpr time_point < _Clock, common_type_t < _Duration, duration < _Rep, _Period > > >
        operator + ( const time_point < _Clock, _Duration > & _Left, const duration < _Rep, _Period > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration :: rep > && is_arithmetic_v < _Rep > ) {
        using _RT = time_point < _Clock, common_type_t < _Duration, duration < _Rep, _Period >> >;
        return _RT ( _Left . time_since_epoch ( ) + _Right );
    }
#line 531
template < class _Rep, class _Period, class _Clock, class _Duration >
    [ [ nodiscard ] ] constexpr time_point < _Clock, common_type_t < duration < _Rep, _Period >, _Duration > >
        operator + ( const duration < _Rep, _Period > & _Left, const time_point < _Clock, _Duration > & _Right ) noexcept (
            is_arithmetic_v < _Rep > && is_arithmetic_v < typename _Duration :: rep > ) {
        return _Right + _Left;
    }
#line 538
template < class _Clock, class _Duration, class _Rep, class _Period >
    [ [ nodiscard ] ] constexpr time_point < _Clock, common_type_t < _Duration, duration < _Rep, _Period > > >
        operator - ( const time_point < _Clock, _Duration > & _Left, const duration < _Rep, _Period > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration :: rep > && is_arithmetic_v < _Rep > ) {
        using _RT = time_point < _Clock, common_type_t < _Duration, duration < _Rep, _Period >> >;
        return _RT ( _Left . time_since_epoch ( ) - _Right );
    }
#line 546
template < class _Clock, class _Duration1, class _Duration2 >
    [ [ nodiscard ] ] constexpr common_type_t < _Duration1, _Duration2 >
        operator - ( const time_point < _Clock, _Duration1 > & _Left, const time_point < _Clock, _Duration2 > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration1 :: rep > && is_arithmetic_v < typename _Duration2 :: rep > ) {
        return _Left . time_since_epoch ( ) - _Right . time_since_epoch ( );
    }
#line 553
template < class _Clock, class _Duration1, class _Duration2 >
    [ [ nodiscard ] ] constexpr bool
        operator == ( const time_point < _Clock, _Duration1 > & _Left, const time_point < _Clock, _Duration2 > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration1 :: rep > && is_arithmetic_v < typename _Duration2 :: rep > ) {
        return _Left . time_since_epoch ( ) == _Right . time_since_epoch ( );
    }
#line 561
template < class _Clock, class _Duration1, class _Duration2 >
    [ [ nodiscard ] ] constexpr bool
        operator != ( const time_point < _Clock, _Duration1 > & _Left, const time_point < _Clock, _Duration2 > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration1 :: rep > && is_arithmetic_v < typename _Duration2 :: rep > ) {
        return ! ( _Left == _Right );
    }
#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
template < class _Clock, class _Duration1, class _Duration2 >
    [ [ nodiscard ] ] constexpr bool
        operator < ( const time_point < _Clock, _Duration1 > & _Left, const time_point < _Clock, _Duration2 > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration1 :: rep > && is_arithmetic_v < typename _Duration2 :: rep > ) {
        return _Left . time_since_epoch ( ) < _Right . time_since_epoch ( );
    }
#line 576
template < class _Clock, class _Duration1, class _Duration2 >
    [ [ nodiscard ] ] constexpr bool
        operator <= ( const time_point < _Clock, _Duration1 > & _Left, const time_point < _Clock, _Duration2 > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration1 :: rep > && is_arithmetic_v < typename _Duration2 :: rep > ) {
        return ! ( _Right < _Left );
    }
#line 583
template < class _Clock, class _Duration1, class _Duration2 >
    [ [ nodiscard ] ] constexpr bool
        operator > ( const time_point < _Clock, _Duration1 > & _Left, const time_point < _Clock, _Duration2 > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration1 :: rep > && is_arithmetic_v < typename _Duration2 :: rep > ) {
        return _Right < _Left;
    }
#line 590
template < class _Clock, class _Duration1, class _Duration2 >
    [ [ nodiscard ] ] constexpr bool
        operator >= ( const time_point < _Clock, _Duration1 > & _Left, const time_point < _Clock, _Duration2 > & _Right ) noexcept (
            is_arithmetic_v < typename _Duration1 :: rep > && is_arithmetic_v < typename _Duration2 :: rep > ) {
        return ! ( _Left < _Right );
    }
#line 606
template < class _To, class _Clock, class _Duration, enable_if_t < _Is_duration_v < _To >, int > = 0 >
    [ [ nodiscard ] ] constexpr time_point < _Clock, _To > time_point_cast ( const time_point < _Clock, _Duration > & _Time ) noexcept (
        is_arithmetic_v < typename _Duration :: rep > && is_arithmetic_v < typename _To :: rep > ) {

        return time_point < _Clock, _To > ( :: std :: chrono :: duration_cast < _To > ( _Time . time_since_epoch ( ) ) );
    }
#line 613
template < class _To, class _Clock, class _Duration, enable_if_t < _Is_duration_v < _To >, int > = 0 >
    [ [ nodiscard ] ] constexpr time_point < _Clock, _To > floor ( const time_point < _Clock, _Duration > & _Time ) noexcept (
        is_arithmetic_v < typename _Duration :: rep > && is_arithmetic_v < typename _To :: rep > ) {

        return time_point < _Clock, _To > ( :: std :: chrono :: floor < _To > ( _Time . time_since_epoch ( ) ) );
    }
#line 620
template < class _To, class _Clock, class _Duration, enable_if_t < _Is_duration_v < _To >, int > = 0 >
    [ [ nodiscard ] ] constexpr time_point < _Clock, _To > ceil ( const time_point < _Clock, _Duration > & _Time ) noexcept (
        is_arithmetic_v < typename _Duration :: rep > && is_arithmetic_v < typename _To :: rep > ) {

        return time_point < _Clock, _To > ( :: std :: chrono :: ceil < _To > ( _Time . time_since_epoch ( ) ) );
    }
#line 627
template < class _To, class _Clock, class _Duration,
        enable_if_t < _Is_duration_v < _To > && ! treat_as_floating_point_v < typename _To :: rep >, int > = 0 >
    [ [ nodiscard ] ] constexpr time_point < _Clock, _To > round ( const time_point < _Clock, _Duration > & _Time ) noexcept (
        is_arithmetic_v < typename _Duration :: rep > && is_arithmetic_v < typename _To :: rep > ) {

        return time_point < _Clock, _To > ( :: std :: chrono :: round < _To > ( _Time . time_since_epoch ( ) ) );
    }
#line 635
struct system_clock { 
#line 636
using rep = __int64; 
#line 637
using period = ratio< 1i64, 10000000i64> ; 
#line 638
using duration = chrono::duration< __int64, ratio< 1i64, 10000000i64> > ; 
#line 639
using time_point = chrono::time_point< system_clock> ; 
#line 640
static constexpr bool is_steady = false; 
#line 642
[[nodiscard]] static time_point now() noexcept { 
#line 643
return ((chrono::time_point< system_clock> )(((chrono::duration< __int64, ratio< 1i64, 10000000i64> > )(_Xtime_get_ticks())))); 
#line 644
} 
#line 646
[[nodiscard]] static __time64_t to_time_t(const time_point &_Time) noexcept { 
#line 647
return duration_cast< chrono::duration< __int64> > (_Time.time_since_epoch()).count(); 
#line 648
} 
#line 650
[[nodiscard]] static time_point from_time_t(__time64_t _Tm) noexcept { 
#line 651
return time_point{seconds{_Tm}}; 
#line 652
} 
#line 653
}; 
#line 662 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
struct steady_clock { 
#line 663
using rep = __int64; 
#line 664
using period = nano; 
#line 665
using duration = nanoseconds; 
#line 666
using time_point = chrono::time_point< steady_clock> ; 
#line 667
static constexpr bool is_steady = true; 
#line 669
[[nodiscard]] static time_point now() noexcept { 
#line 670
const __int64 _Freq = _Query_perf_frequency(); 
#line 671
const __int64 _Ctr = _Query_perf_counter(); 
#line 672
static_assert((ratio< 1i64, 1000000000i64> ::num == (1)), "This assumes period::num == 1.");
#line 676
constexpr __int64 _TenMHz = (10000000); 
#line 677
if (_Freq == _TenMHz) { 
#line 678
static_assert(((ratio< 1i64, 1000000000i64> ::den % _TenMHz) == (0)), "It should never fail.");
#line 679
constexpr __int64 _Multiplier = (ratio< 1i64, 1000000000i64> ::den / _TenMHz); 
#line 680
return ((chrono::time_point< steady_clock> )(((chrono::duration< __int64, ratio< 1i64, 1000000000i64> > )(_Ctr * _Multiplier)))); 
#line 681
} else { 
#line 687
const __int64 _Whole = (_Ctr / _Freq) * ratio< 1i64, 1000000000i64> ::den; 
#line 688
const __int64 _Part = ((_Ctr % _Freq) * ratio< 1i64, 1000000000i64> ::den) / _Freq; 
#line 689
return ((chrono::time_point< steady_clock> )(((chrono::duration< __int64, ratio< 1i64, 1000000000i64> > )(_Whole + _Part)))); 
#line 690
}  
#line 691
} 
#line 692
}; 
#line 694
using high_resolution_clock = steady_clock; 
#line 695
}
#line 697
template < class _Rep, class _Period >
[ [ nodiscard ] ] bool _To_xtime_10_day_clamped ( :: xtime & _Xt, const :: std :: chrono :: duration < _Rep, _Period > & _Rel_time ) noexcept (
    is_arithmetic_v < _Rep > ) {




    constexpr :: std :: chrono :: nanoseconds _Ten_days { :: std :: chrono :: hours { 24 } * 10 };
    constexpr :: std :: chrono :: duration < double > _Ten_days_d { _Ten_days };
    :: std :: chrono :: nanoseconds _Tx0 = :: std :: chrono :: system_clock :: now ( ) . time_since_epoch ( );
    const bool _Clamped = _Ten_days_d < _Rel_time;
    if ( _Clamped ) {
        _Tx0 += _Ten_days;
    } else {
        _Tx0 += :: std :: chrono :: duration_cast < :: std :: chrono :: nanoseconds > ( _Rel_time );
    }

    const auto _Whole_seconds = :: std :: chrono :: duration_cast < :: std :: chrono :: seconds > ( _Tx0 );
    _Xt . sec = _Whole_seconds . count ( );
    _Tx0 -= _Whole_seconds;
    _Xt . nsec = static_cast < long > ( _Tx0 . count ( ) );
    return _Clamped;
}
#line 721
inline namespace literals { 
#line 722
inline namespace chrono_literals { 
#line 723
[[nodiscard]] constexpr chrono::hours operator ""h(unsigned __int64 _Val) noexcept { 
#line 724
return ((chrono::duration< int, ratio< 3600i64> > )(_Val)); 
#line 725
} 
#line 727
[[nodiscard]] constexpr chrono::duration< double, ratio< 3600i64> >  operator ""h(long double _Val) noexcept 
#line 728
{ 
#line 729
return ((chrono::duration< double, ratio< 3600i64> > )(_Val)); 
#line 730
} 
#line 732
[[nodiscard]] constexpr chrono::minutes operator ""min(unsigned __int64 _Val) noexcept { 
#line 733
return ((chrono::duration< int, ratio< 60i64> > )(_Val)); 
#line 734
} 
#line 736
[[nodiscard]] constexpr chrono::duration< double, ratio< 60i64> >  operator ""min(long double _Val) noexcept 
#line 737
{ 
#line 738
return ((chrono::duration< double, ratio< 60i64> > )(_Val)); 
#line 739
} 
#line 741
[[nodiscard]] constexpr chrono::seconds operator ""s(unsigned __int64 _Val) noexcept { 
#line 742
return ((chrono::duration< __int64> )(_Val)); 
#line 743
} 
#line 745
[[nodiscard]] constexpr chrono::duration< double>  operator ""s(long double _Val) noexcept { 
#line 746
return ((chrono::duration< double> )(_Val)); 
#line 747
} 
#line 749
[[nodiscard]] constexpr chrono::milliseconds operator ""ms(unsigned __int64 _Val) noexcept { 
#line 750
return ((chrono::duration< __int64, ratio< 1i64, 1000i64> > )(_Val)); 
#line 751
} 
#line 753
[[nodiscard]] constexpr chrono::duration< double, ratio< 1i64, 1000i64> >  operator ""ms(long double _Val) noexcept 
#line 754
{ 
#line 755
return ((chrono::duration< double, ratio< 1i64, 1000i64> > )(_Val)); 
#line 756
} 
#line 758
[[nodiscard]] constexpr chrono::microseconds operator ""us(unsigned __int64 _Val) noexcept { 
#line 759
return ((chrono::duration< __int64, ratio< 1i64, 1000000i64> > )(_Val)); 
#line 760
} 
#line 762
[[nodiscard]] constexpr chrono::duration< double, ratio< 1i64, 1000000i64> >  operator ""us(long double _Val) noexcept 
#line 763
{ 
#line 764
return ((chrono::duration< double, ratio< 1i64, 1000000i64> > )(_Val)); 
#line 765
} 
#line 767
[[nodiscard]] constexpr chrono::nanoseconds operator ""ns(unsigned __int64 _Val) noexcept { 
#line 768
return ((chrono::duration< __int64, ratio< 1i64, 1000000000i64> > )(_Val)); 
#line 769
} 
#line 771
[[nodiscard]] constexpr chrono::duration< double, ratio< 1i64, 1000000000i64> >  operator ""ns(long double _Val) noexcept 
#line 772
{ 
#line 773
return ((chrono::duration< double, ratio< 1i64, 1000000000i64> > )(_Val)); 
#line 774
} 
#line 775
}
#line 776
}
#line 778
namespace chrono { 
#line 779
using namespace literals::chrono_literals;
#line 780
}
#line 781
}
#line 785
#pragma warning(pop)
#pragma pack ( pop )
#line 789 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
#pragma external_header(pop)
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 46
namespace std { 
#line 5902 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"
}
#line 5905
#pragma warning(pop)
#pragma pack ( pop )
#line 5909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"
#pragma external_header(pop)
#line 21 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
#pragma external_header(push)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 24
namespace std { 
#line 25
template < class _Mydeque >
class _Deque_unchecked_const_iterator {
private :
    using _Size_type = typename _Mydeque :: size_type;

    static constexpr int _Block_size = _Mydeque :: _Block_size;

public :
    using iterator_category = random_access_iterator_tag;

    using value_type = typename _Mydeque :: value_type;
    using difference_type = typename _Mydeque :: difference_type;
    using pointer = typename _Mydeque :: const_pointer;
    using reference = const value_type &;

    _Deque_unchecked_const_iterator ( ) noexcept : _Mycont ( ), _Myoff ( 0 ) { }

    _Deque_unchecked_const_iterator ( _Size_type _Off, const _Container_base12 * _Pdeque ) noexcept
        : _Mycont ( static_cast < const _Mydeque * > ( _Pdeque ) ), _Myoff ( _Off ) { }

    [ [ nodiscard ] ] reference operator * ( ) const noexcept {
        _Size_type _Block = _Mycont -> _Getblock ( _Myoff );
        _Size_type _Off = _Myoff % _Block_size;
        return _Mycont -> _Map [ _Block ] [ _Off ];
    }

    [ [ nodiscard ] ] pointer operator -> ( ) const noexcept {
        return pointer_traits < pointer > :: pointer_to ( * * this );
    }

    _Deque_unchecked_const_iterator & operator ++ ( ) noexcept {
        ++ _Myoff;
        return * this;
    }

    _Deque_unchecked_const_iterator operator ++ ( int ) noexcept {
        _Deque_unchecked_const_iterator _Tmp = * this;
        ++ _Myoff;
        return _Tmp;
    }

    _Deque_unchecked_const_iterator & operator -- ( ) noexcept {
        -- _Myoff;
        return * this;
    }

    _Deque_unchecked_const_iterator operator -- ( int ) noexcept {
        _Deque_unchecked_const_iterator _Tmp = * this;
        -- _Myoff;
        return _Tmp;
    }

    _Deque_unchecked_const_iterator & operator += ( const difference_type _Off ) noexcept {
        _Myoff += _Off;
        return * this;
    }

    [ [ nodiscard ] ] _Deque_unchecked_const_iterator operator + ( const difference_type _Off ) const noexcept {
        _Deque_unchecked_const_iterator _Tmp = * this;
        return _Tmp += _Off;
    }

    _Deque_unchecked_const_iterator & operator -= ( const difference_type _Off ) noexcept {
        _Myoff -= _Off;
        return * this;
    }

    [ [ nodiscard ] ] _Deque_unchecked_const_iterator operator - ( const difference_type _Off ) const noexcept {
        _Deque_unchecked_const_iterator _Tmp = * this;
        return _Tmp -= _Off;
    }

    [ [ nodiscard ] ] difference_type operator - ( const _Deque_unchecked_const_iterator & _Right ) const noexcept {
        return static_cast < difference_type > ( _Myoff - _Right . _Myoff );
    }

    [ [ nodiscard ] ] reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] bool operator == ( const _Deque_unchecked_const_iterator & _Right ) const noexcept {
        return _Myoff == _Right . _Myoff;
    }






    [ [ nodiscard ] ] bool operator != ( const _Deque_unchecked_const_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] bool operator < ( const _Deque_unchecked_const_iterator & _Right ) const noexcept {
        return _Myoff < _Right . _Myoff;
    }

    [ [ nodiscard ] ] bool operator > ( const _Deque_unchecked_const_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] bool operator <= ( const _Deque_unchecked_const_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] bool operator >= ( const _Deque_unchecked_const_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }


    const _Container_base12 * _Getcont ( ) const noexcept {
        return _Mycont;
    }

    const _Mydeque * _Mycont;
    _Size_type _Myoff;
};
#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
template < class _Mydeque >
[ [ nodiscard ] ] _Deque_unchecked_const_iterator < _Mydeque > operator + (
    typename _Deque_unchecked_const_iterator < _Mydeque > :: difference_type _Off,
    _Deque_unchecked_const_iterator < _Mydeque > _Next ) noexcept {
    return _Next += _Off;
}
#line 150
template < class _Mydeque >
class _Deque_unchecked_iterator : public _Deque_unchecked_const_iterator < _Mydeque > {
private :
    using _Size_type = typename _Mydeque :: size_type;
    using _Mybase = _Deque_unchecked_const_iterator < _Mydeque >;

public :
    using iterator_category = random_access_iterator_tag;

    using value_type = typename _Mydeque :: value_type;
    using difference_type = typename _Mydeque :: difference_type;
    using pointer = typename _Mydeque :: pointer;
    using reference = value_type &;

    using _Mybase :: _Mybase;

    [ [ nodiscard ] ] reference operator * ( ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator * ( ) );
    }

    [ [ nodiscard ] ] pointer operator -> ( ) const noexcept {
        return pointer_traits < pointer > :: pointer_to ( * * this );
    }

    _Deque_unchecked_iterator & operator ++ ( ) noexcept {
        _Mybase :: operator ++ ( );
        return * this;
    }

    _Deque_unchecked_iterator operator ++ ( int ) noexcept {
        _Deque_unchecked_iterator _Tmp = * this;
        _Mybase :: operator ++ ( );
        return _Tmp;
    }

    _Deque_unchecked_iterator & operator -- ( ) noexcept {
        _Mybase :: operator -- ( );
        return * this;
    }

    _Deque_unchecked_iterator operator -- ( int ) noexcept {
        _Deque_unchecked_iterator _Tmp = * this;
        _Mybase :: operator -- ( );
        return _Tmp;
    }

    _Deque_unchecked_iterator & operator += ( const difference_type _Off ) noexcept {
        _Mybase :: operator += ( _Off );
        return * this;
    }

    [ [ nodiscard ] ] _Deque_unchecked_iterator operator + ( const difference_type _Off ) const noexcept {
        _Deque_unchecked_iterator _Tmp = * this;
        return _Tmp += _Off;
    }

    _Deque_unchecked_iterator & operator -= ( const difference_type _Off ) noexcept {
        _Mybase :: operator -= ( _Off );
        return * this;
    }

    [ [ nodiscard ] ] _Deque_unchecked_iterator operator - ( const difference_type _Off ) const noexcept {
        _Deque_unchecked_iterator _Tmp = * this;
        return _Tmp -= _Off;
    }

    [ [ nodiscard ] ] difference_type operator - ( const _Mybase & _Right ) const noexcept {
        return _Mybase :: operator - ( _Right );
    }

    [ [ nodiscard ] ] reference operator [ ] ( const difference_type _Off ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator [ ] ( _Off ) );
    }
};
#line 225
template < class _Mydeque >
[ [ nodiscard ] ] _Deque_unchecked_iterator < _Mydeque > operator + (
    typename _Deque_unchecked_iterator < _Mydeque > :: difference_type _Off,
    _Deque_unchecked_iterator < _Mydeque > _Next ) noexcept {
    return _Next += _Off;
}
#line 232
template < class _Mydeque >
class _Deque_const_iterator : public _Iterator_base12 {
private :
    using _Size_type = typename _Mydeque :: size_type;

    static constexpr int _Block_size = _Mydeque :: _Block_size;

public :
    using iterator_category = random_access_iterator_tag;

    using value_type = typename _Mydeque :: value_type;
    using difference_type = typename _Mydeque :: difference_type;
    using pointer = typename _Mydeque :: const_pointer;
    using reference = const value_type &;

    using _Mydeque_t = _Mydeque;
    enum { _EEN_DS = _Block_size };
    _Deque_const_iterator ( ) noexcept : _Myoff ( 0 ) {
        _Setcont ( nullptr );
    }

    _Deque_const_iterator ( _Size_type _Off, const _Container_base12 * _Pdeque ) noexcept : _Myoff ( _Off ) {
        _Setcont ( static_cast < const _Mydeque * > ( _Pdeque ) );
    }

    [ [ nodiscard ] ] reference operator * ( ) const noexcept {
        const auto _Mycont = static_cast < const _Mydeque * > ( this -> _Getcont ( ) );






        _Size_type _Block = _Mycont -> _Getblock ( _Myoff );
        _Size_type _Off = _Myoff % _Block_size;
        return _Mycont -> _Map [ _Block ] [ _Off ];
    }

    [ [ nodiscard ] ] pointer operator -> ( ) const noexcept {
        return pointer_traits < pointer > :: pointer_to ( * * this );
    }

    _Deque_const_iterator & operator ++ ( ) noexcept {






        ++ _Myoff;
        return * this;
    }

    _Deque_const_iterator operator ++ ( int ) noexcept {
        _Deque_const_iterator _Tmp = * this;
        ++ * this;
        return _Tmp;
    }

    _Deque_const_iterator & operator -- ( ) noexcept {






        -- _Myoff;
        return * this;
    }

    _Deque_const_iterator operator -- ( int ) noexcept {
        _Deque_const_iterator _Tmp = * this;
        -- * this;
        return _Tmp;
    }

    _Deque_const_iterator & operator += ( const difference_type _Off ) noexcept {










        _Myoff += _Off;
        return * this;
    }

    [ [ nodiscard ] ] _Deque_const_iterator operator + ( const difference_type _Off ) const noexcept {
        _Deque_const_iterator _Tmp = * this;
        return _Tmp += _Off;
    }

    _Deque_const_iterator & operator -= ( const difference_type _Off ) noexcept {
        return * this += - _Off;
    }

    [ [ nodiscard ] ] _Deque_const_iterator operator - ( const difference_type _Off ) const noexcept {
        _Deque_const_iterator _Tmp = * this;
        return _Tmp -= _Off;
    }

    [ [ nodiscard ] ] difference_type operator - ( const _Deque_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return static_cast < difference_type > ( this -> _Myoff - _Right . _Myoff );
    }

    [ [ nodiscard ] ] reference operator [ ] ( const difference_type _Off ) const noexcept {
        return * ( * this + _Off );
    }

    [ [ nodiscard ] ] bool operator == ( const _Deque_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return this -> _Myoff == _Right . _Myoff;
    }







    [ [ nodiscard ] ] bool operator != ( const _Deque_const_iterator & _Right ) const noexcept {
        return ! ( * this == _Right );
    }

    [ [ nodiscard ] ] bool operator < ( const _Deque_const_iterator & _Right ) const noexcept {
        _Compat ( _Right );
        return this -> _Myoff < _Right . _Myoff;
    }

    [ [ nodiscard ] ] bool operator > ( const _Deque_const_iterator & _Right ) const noexcept {
        return _Right < * this;
    }

    [ [ nodiscard ] ] bool operator <= ( const _Deque_const_iterator & _Right ) const noexcept {
        return ! ( _Right < * this );
    }

    [ [ nodiscard ] ] bool operator >= ( const _Deque_const_iterator & _Right ) const noexcept {
        return ! ( * this < _Right );
    }


    void _Compat ( const _Deque_const_iterator & _Right ) const noexcept {

        ( void ) _Right;



    }

    void _Setcont ( const _Mydeque * _Pdeque ) noexcept {
        this -> _Adopt ( _Pdeque );
    }

    using _Prevent_inheriting_unwrap = _Deque_const_iterator;

    [ [ nodiscard ] ] _Deque_unchecked_const_iterator < _Mydeque > _Unwrapped ( ) const noexcept {
        return { this -> _Myoff, this -> _Getcont ( ) };
    }

    void _Verify_offset ( const difference_type _Off ) const noexcept {

        ( void ) _Off;









    }








    void _Seek_to ( const _Deque_unchecked_const_iterator < _Mydeque > & _UIt ) noexcept {
        _Myoff = _UIt . _Myoff;
    }

    _Size_type _Myoff;
};
#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
template < class _Mydeque >
[ [ nodiscard ] ] _Deque_const_iterator < _Mydeque > operator + (
    typename _Deque_const_iterator < _Mydeque > :: difference_type _Off, _Deque_const_iterator < _Mydeque > _Next ) noexcept {
    return _Next += _Off;
}
#line 431
template < class _Mydeque >
class _Deque_iterator : public _Deque_const_iterator < _Mydeque > {
private :
    using _Size_type = typename _Mydeque :: size_type;
    using _Mybase = _Deque_const_iterator < _Mydeque >;

public :
    using _Deque_unchecked_type = _Deque_unchecked_iterator < _Mydeque >;
    using iterator_category = random_access_iterator_tag;

    using value_type = typename _Mydeque :: value_type;
    using difference_type = typename _Mydeque :: difference_type;
    using pointer = typename _Mydeque :: pointer;
    using reference = value_type &;

    using _Mybase :: _Mybase;

    [ [ nodiscard ] ] reference operator * ( ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator * ( ) );
    }

    [ [ nodiscard ] ] pointer operator -> ( ) const noexcept {
        return pointer_traits < pointer > :: pointer_to ( * * this );
    }

    _Deque_iterator & operator ++ ( ) noexcept {
        _Mybase :: operator ++ ( );
        return * this;
    }

    _Deque_iterator operator ++ ( int ) noexcept {
        _Deque_iterator _Tmp = * this;
        _Mybase :: operator ++ ( );
        return _Tmp;
    }

    _Deque_iterator & operator -- ( ) noexcept {
        _Mybase :: operator -- ( );
        return * this;
    }

    _Deque_iterator operator -- ( int ) noexcept {
        _Deque_iterator _Tmp = * this;
        _Mybase :: operator -- ( );
        return _Tmp;
    }

    _Deque_iterator & operator += ( const difference_type _Off ) noexcept {
        _Mybase :: operator += ( _Off );
        return * this;
    }

    [ [ nodiscard ] ] _Deque_iterator operator + ( const difference_type _Off ) const noexcept {
        _Deque_iterator _Tmp = * this;
        return _Tmp += _Off;
    }

    _Deque_iterator & operator -= ( const difference_type _Off ) noexcept {
        _Mybase :: operator -= ( _Off );
        return * this;
    }

    using _Mybase :: operator -;

    [ [ nodiscard ] ] _Deque_iterator operator - ( const difference_type _Off ) const noexcept {
        _Deque_iterator _Tmp = * this;
        return _Tmp -= _Off;
    }

    [ [ nodiscard ] ] reference operator [ ] ( const difference_type _Off ) const noexcept {
        return const_cast < reference > ( _Mybase :: operator [ ] ( _Off ) );
    }

    using _Prevent_inheriting_unwrap = _Deque_iterator;

    [ [ nodiscard ] ] _Deque_unchecked_iterator < _Mydeque > _Unwrapped ( ) const noexcept {
        return { this -> _Myoff, this -> _Getcont ( ) };
    }
};
#line 511
template < class _Mydeque >
[ [ nodiscard ] ] _Deque_iterator < _Mydeque > operator + (
    typename _Deque_iterator < _Mydeque > :: difference_type _Off, _Deque_iterator < _Mydeque > _Next ) noexcept {
    return _Next += _Off;
}
#line 517
template< class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class 
#line 518
_Reference, class _Const_reference, class _Mapptr_type> 
#line 519
struct _Deque_iter_types { 
#line 520
using value_type = _Value_type; 
#line 521
using size_type = _Size_type; 
#line 522
using difference_type = _Difference_type; 
#line 523
using pointer = _Pointer; 
#line 524
using const_pointer = _Const_pointer; 
#line 525
using _Mapptr = _Mapptr_type; 
#line 526
}; 
#line 528
template< class _Ty> 
#line 529
struct _Deque_simple_types : public _Simple_types< _Ty>  { 
#line 530
using _Mapptr = _Ty **; 
#line 531
}; 
#line 533
template < class _Val_types >
class _Deque_val : public _Container_base12 {
public :
    using value_type = typename _Val_types :: value_type;
    using size_type = typename _Val_types :: size_type;
    using difference_type = typename _Val_types :: difference_type;
    using pointer = typename _Val_types :: pointer;
    using const_pointer = typename _Val_types :: const_pointer;
    using reference = value_type &;
    using const_reference = const value_type &;
    using _Mapptr = typename _Val_types :: _Mapptr;

private :
    static constexpr size_t _Bytes = sizeof ( value_type );

public :
    static constexpr int _Block_size = _Bytes <= 1 ? 16
                                     : _Bytes <= 2 ? 8
                                     : _Bytes <= 4 ? 4
                                     : _Bytes <= 8 ? 2
                                                   : 1;

    _Deque_val ( ) noexcept : _Map ( ), _Mapsize ( 0 ), _Myoff ( 0 ), _Mysize ( 0 ) { }

    size_type _Getblock ( size_type _Off ) const noexcept {

        return ( _Off / _Block_size ) & ( _Mapsize - 1 );
    }

    _Mapptr _Map;
    size_type _Mapsize;
    size_type _Myoff;
    size_type _Mysize;
};
#line 568
template < class _Ty, class _Alloc = allocator < _Ty > >
class deque {
private :
    friend _Tidy_guard < deque >;
    static_assert ( ! 0 || is_same_v < _Ty, typename _Alloc :: value_type >,
        "deque<T, Allocator> requires that Allocator\'s value_type match T (See N4659 26.2.1 [container.requirements.general]/16 allocato" "r_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic." );

    using _Alty = _Rebind_alloc_t < _Alloc, _Ty >;
    using _Alty_traits = allocator_traits < _Alty >;
    using _Alpty = _Rebind_alloc_t < _Alloc, typename _Alty_traits :: pointer >;
    using _Alpty_traits = allocator_traits < _Alpty >;
    using _Mapptr = typename _Alpty_traits :: pointer;
    using _Alproxy_ty = _Rebind_alloc_t < _Alty, _Container_proxy >;
    using _Alproxy_traits = allocator_traits < _Alproxy_ty >;

    using _Scary_val = _Deque_val < conditional_t < _Is_simple_alloc_v < _Alty >, _Deque_simple_types < _Ty >,
        _Deque_iter_types < _Ty, typename _Alty_traits :: size_type, typename _Alty_traits :: difference_type,
            typename _Alty_traits :: pointer, typename _Alty_traits :: const_pointer, _Ty &, const _Ty &, _Mapptr >> >;

    static constexpr int _Minimum_map_size = 8;
    static constexpr int _Block_size = _Scary_val :: _Block_size;

public :
    using allocator_type = _Alloc;
    using value_type = _Ty;
    using size_type = typename _Alty_traits :: size_type;
    using difference_type = typename _Alty_traits :: difference_type;
    using pointer = typename _Alty_traits :: pointer;
    using const_pointer = typename _Alty_traits :: const_pointer;
    using reference = _Ty &;
    using const_reference = const _Ty &;

    using iterator = _Deque_iterator < _Scary_val >;
    using const_iterator = _Deque_const_iterator < _Scary_val >;
    using _Unchecked_iterator = _Deque_unchecked_iterator < _Scary_val >;
    using _Unchecked_const_iterator = _Deque_unchecked_const_iterator < _Scary_val >;

    using reverse_iterator = :: std :: reverse_iterator < iterator >;
    using const_reverse_iterator = :: std :: reverse_iterator < const_iterator >;
    enum { _EEN_DS = _Block_size };

    deque ( ) : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Get_data ( ) . _Alloc_proxy ( static_cast < _Alproxy_ty > ( _Getal ( ) ) );
    }

    explicit deque ( const _Alloc & _Al ) : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Get_data ( ) . _Alloc_proxy ( static_cast < _Alproxy_ty > ( _Getal ( ) ) );
    }

    explicit deque ( size_type _Count, const _Alloc & _Al = _Alloc ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
        resize ( _Count );
        _Proxy . _Release ( );
    }

    deque ( size_type _Count, const _Ty & _Val ) : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
        _Construct_n ( _Count, _Val );
        _Proxy . _Release ( );
    }

    deque ( size_type _Count, const _Ty & _Val, const _Alloc & _Al )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
        _Construct_n ( _Count, _Val );
        _Proxy . _Release ( );
    }

    deque ( const deque & _Right )
        : _Mypair ( _One_then_variadic_args_t { }, _Alty_traits :: select_on_container_copy_construction ( _Right . _Getal ( ) ) ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
        _Construct ( _Right . _Unchecked_begin ( ), _Right . _Unchecked_end ( ) );
        _Proxy . _Release ( );
    }

    deque ( const deque & _Right, const _Alloc & _Al ) : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
        _Construct ( _Right . _Unchecked_begin ( ), _Right . _Unchecked_end ( ) );
        _Proxy . _Release ( );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    deque ( _Iter _First, _Iter _Last ) : _Mypair ( _Zero_then_variadic_args_t { } ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
        _Construct ( _First, _Last );
        _Proxy . _Release ( );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    deque ( _Iter _First, _Iter _Last, const _Alloc & _Al ) : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
        _Construct ( _First, _Last );
        _Proxy . _Release ( );
    }

private :
    template < class _Iter >
    void _Construct ( _Iter _First, _Iter _Last ) {
        _Tidy_guard < deque > _Guard { this };
        for (; _First != _Last; ++ _First ) {
            emplace_back ( * _First );
        }

        _Guard . _Target = nullptr;
    }

    void _Construct_n ( size_type _Count, const _Ty & _Val ) {
        _Tidy_guard < deque > _Guard { this };
        for (; 0 < _Count; -- _Count ) {
            _Emplace_back_internal ( _Val );
        }

        _Guard . _Target = nullptr;
    }

public :
    deque ( deque && _Right ) : _Mypair ( _One_then_variadic_args_t { }, :: std :: move ( _Right . _Getal ( ) ) ) {
        _Get_data ( ) . _Alloc_proxy ( static_cast < _Alproxy_ty > ( _Getal ( ) ) );
        _Take_contents ( _Right );
    }

    deque ( deque && _Right, const _Alloc & _Al ) : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        if constexpr ( ! _Alty_traits :: is_always_equal :: value ) {
            if ( _Getal ( ) != _Right . _Getal ( ) ) {
                _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
                _Construct ( :: std :: make_move_iterator ( _Right . _Unchecked_begin ( ) ),
                    :: std :: make_move_iterator ( _Right . _Unchecked_end ( ) ) );
                _Proxy . _Release ( );
                return;
            }
        }

        _Get_data ( ) . _Alloc_proxy ( _Alproxy );
        _Take_contents ( _Right );
    }

private :
    void _Move_assign ( deque & _Right, _Equal_allocators ) noexcept {
        _Tidy ( );
        _Pocma ( _Getal ( ), _Right . _Getal ( ) );
        _Take_contents ( _Right );
    }

    void _Move_assign ( deque & _Right, _Propagate_allocators ) {
        auto & _Al = _Getal ( );
        auto & _Right_al = _Right . _Getal ( );
        if ( _Al == _Right_al ) {
            _Move_assign ( _Right, _Equal_allocators { } );
        } else {
            _Alproxy_ty _Alproxy ( _Al );
            _Alproxy_ty _Right_alproxy ( _Right_al );
            _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Right_alproxy, _Leave_proxy_unbound { } );
            _Tidy ( );
            _Pocma ( _Al, _Right_al );
            _Proxy . _Bind ( _Alproxy, :: std :: addressof ( _Get_data ( ) ) );
            _Take_contents ( _Right );
        }
    }

    void _Move_assign ( deque & _Right, _No_propagate_allocators ) {
        if ( _Getal ( ) == _Right . _Getal ( ) ) {
            _Move_assign ( _Right, _Equal_allocators { } );
        } else {
            assign (
                :: std :: make_move_iterator ( _Right . _Unchecked_begin ( ) ), :: std :: make_move_iterator ( _Right . _Unchecked_end ( ) ) );
        }
    }

public :
    deque & operator = ( deque && _Right ) noexcept ( _Alty_traits :: is_always_equal :: value ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Move_assign ( _Right, _Choose_pocma < _Alty > { } );
        }

        return * this;
    }

private :
    void _Take_contents ( deque & _Right ) noexcept {


        auto & _My_data = _Get_data ( );
        auto & _Right_data = _Right . _Get_data ( );
        _My_data . _Swap_proxy_and_iterators ( _Right_data );
        _My_data . _Map = _Right_data . _Map;
        _My_data . _Mapsize = _Right_data . _Mapsize;
        _My_data . _Myoff = _Right_data . _Myoff;
        _My_data . _Mysize = _Right_data . _Mysize;

        _Right_data . _Map = nullptr;
        _Right_data . _Mapsize = 0;
        _Right_data . _Myoff = 0;
        _Right_data . _Mysize = 0;
    }

public :
    void push_front ( _Ty && _Val ) {
        emplace_front ( :: std :: move ( _Val ) );
    }

    void push_back ( _Ty && _Val ) {
        _Orphan_all ( );
        _Emplace_back_internal ( :: std :: move ( _Val ) );
    }

    iterator insert ( const_iterator _Where, _Ty && _Val ) {
        return emplace ( _Where, :: std :: move ( _Val ) );
    }

    template < class ... _Valty >
    decltype ( auto ) emplace_front ( _Valty && ... _Val ) {
        _Orphan_all ( );

        if ( _Myoff ( ) % _Block_size == 0 && _Mapsize ( ) <= ( _Mysize ( ) + _Block_size ) / _Block_size ) {
            _Growmap ( 1 );
        }
        _Myoff ( ) &= _Mapsize ( ) * _Block_size - 1;
        size_type _Newoff = _Myoff ( ) != 0 ? _Myoff ( ) : _Mapsize ( ) * _Block_size;
        size_type _Block = _Getblock ( -- _Newoff );
        if ( _Map ( ) [ _Block ] == nullptr ) {
            _Map ( ) [ _Block ] = _Getal ( ) . allocate ( _Block_size );
        }

        _Alty_traits :: construct (
            _Getal ( ), _Unfancy ( _Map ( ) [ _Block ] + _Newoff % _Block_size ), :: std :: forward < _Valty > ( _Val ) ... );

        _Myoff ( ) = _Newoff;
        ++ _Mysize ( );




    }

    template < class ... _Valty >
    decltype ( auto ) emplace_back ( _Valty && ... _Val ) {
        _Orphan_all ( );
        _Emplace_back_internal ( :: std :: forward < _Valty > ( _Val ) ... );




    }

    template < class ... _Valty >
    iterator emplace ( const_iterator _Where, _Valty && ... _Val ) {
        const auto _Off = static_cast < size_type > ( _Where - begin ( ) );





        if ( _Off <= _Mysize ( ) / 2 ) {
            emplace_front ( :: std :: forward < _Valty > ( _Val ) ... );
            :: std :: rotate ( begin ( ), _Next_iter ( begin ( ) ), begin ( ) + static_cast < difference_type > ( 1 + _Off ) );
        } else {
            emplace_back ( :: std :: forward < _Valty > ( _Val ) ... );
            :: std :: rotate ( begin ( ) + static_cast < difference_type > ( _Off ), _Prev_iter ( end ( ) ), end ( ) );
        }
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    deque ( initializer_list < _Ty > _Ilist, const _Alloc & _Al = allocator_type ( ) )
        : _Mypair ( _One_then_variadic_args_t { }, _Al ) {
        _Alproxy_ty _Alproxy ( _Getal ( ) );
        _Container_proxy_ptr12 < _Alproxy_ty > _Proxy ( _Alproxy, _Get_data ( ) );
        _Construct ( _Ilist . begin ( ), _Ilist . end ( ) );
        _Proxy . _Release ( );
    }

    deque & operator = ( initializer_list < _Ty > _Ilist ) {
        assign ( _Ilist . begin ( ), _Ilist . end ( ) );
        return * this;
    }

    void assign ( initializer_list < _Ty > _Ilist ) {
        assign ( _Ilist . begin ( ), _Ilist . end ( ) );
    }

    iterator insert ( const_iterator _Where, initializer_list < _Ty > _Ilist ) {
        return insert ( _Where, _Ilist . begin ( ), _Ilist . end ( ) );
    }

    ~ deque ( ) noexcept {
        _Tidy ( );
        _Alproxy_ty _Proxy_allocator ( _Getal ( ) );
        _Delete_plain_internal ( _Proxy_allocator, :: std :: exchange ( _Get_data ( ) . _Myproxy, nullptr ) );
    }

    void _Copy_assign ( const deque & _Right, false_type ) {
        _Pocca ( _Getal ( ), _Right . _Getal ( ) );
        assign ( _Right . _Unchecked_begin ( ), _Right . _Unchecked_end ( ) );
    }

    void _Copy_assign ( const deque & _Right, true_type ) {
        if ( _Getal ( ) != _Right . _Getal ( ) ) {
            _Tidy ( );
            _Get_data ( ) . _Reload_proxy ( static_cast < _Alproxy_ty > ( _Getal ( ) ), static_cast < _Alproxy_ty > ( _Right . _Getal ( ) ) );
        }

        _Copy_assign ( _Right, false_type { } );
    }

    deque & operator = ( const deque & _Right ) {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Copy_assign ( _Right, _Choose_pocca < _Alty > { } );
        }

        return * this;
    }

    [ [ nodiscard ] ] iterator begin ( ) noexcept {
        return iterator ( _Myoff ( ), :: std :: addressof ( _Get_data ( ) ) );
    }

    [ [ nodiscard ] ] const_iterator begin ( ) const noexcept {
        return const_iterator ( _Myoff ( ), :: std :: addressof ( _Get_data ( ) ) );
    }

    [ [ nodiscard ] ] iterator end ( ) noexcept {
        return iterator ( _Myoff ( ) + _Mysize ( ), :: std :: addressof ( _Get_data ( ) ) );
    }

    [ [ nodiscard ] ] const_iterator end ( ) const noexcept {
        return const_iterator ( _Myoff ( ) + _Mysize ( ), :: std :: addressof ( _Get_data ( ) ) );
    }

    _Unchecked_iterator _Unchecked_begin ( ) noexcept {
        return _Unchecked_iterator ( _Myoff ( ), :: std :: addressof ( _Get_data ( ) ) );
    }

    _Unchecked_const_iterator _Unchecked_begin ( ) const noexcept {
        return _Unchecked_const_iterator ( _Myoff ( ), :: std :: addressof ( _Get_data ( ) ) );
    }

    _Unchecked_iterator _Unchecked_end ( ) noexcept {
        return _Unchecked_iterator ( _Myoff ( ) + _Mysize ( ), :: std :: addressof ( _Get_data ( ) ) );
    }

    _Unchecked_const_iterator _Unchecked_end ( ) const noexcept {
        return _Unchecked_const_iterator ( _Myoff ( ) + _Mysize ( ), :: std :: addressof ( _Get_data ( ) ) );
    }

    iterator _Make_iter ( const_iterator _Where ) const noexcept {
        return iterator ( _Where . _Myoff, :: std :: addressof ( _Get_data ( ) ) );
    }

    [ [ nodiscard ] ] reverse_iterator rbegin ( ) noexcept {
        return reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] const_reverse_iterator rbegin ( ) const noexcept {
        return const_reverse_iterator ( end ( ) );
    }

    [ [ nodiscard ] ] reverse_iterator rend ( ) noexcept {
        return reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] const_reverse_iterator rend ( ) const noexcept {
        return const_reverse_iterator ( begin ( ) );
    }

    [ [ nodiscard ] ] const_iterator cbegin ( ) const noexcept {
        return begin ( );
    }

    [ [ nodiscard ] ] const_iterator cend ( ) const noexcept {
        return end ( );
    }

    [ [ nodiscard ] ] const_reverse_iterator crbegin ( ) const noexcept {
        return rbegin ( );
    }

    [ [ nodiscard ] ] const_reverse_iterator crend ( ) const noexcept {
        return rend ( );
    }

    void shrink_to_fit ( ) {
        size_type _Oldcapacity = _Block_size * _Mapsize ( );
        size_type _Newcapacity = _Oldcapacity / 2;

        if ( _Newcapacity < _Block_size * _Minimum_map_size ) {
            _Newcapacity = _Block_size * _Minimum_map_size;
        }

        if ( ( empty ( ) && 0 < _Mapsize ( ) )
            || ( ! empty ( ) && size ( ) <= _Newcapacity && _Newcapacity < _Oldcapacity ) ) {
            deque _Tmp ( :: std :: make_move_iterator ( begin ( ) ), :: std :: make_move_iterator ( end ( ) ) );
            swap ( _Tmp );
        }
    }

    void resize ( size_type _Newsize ) {
        while ( _Mysize ( ) < _Newsize ) {
            emplace_back ( );
        }

        while ( _Newsize < _Mysize ( ) ) {
            pop_back ( );
        }
    }

    void resize ( size_type _Newsize, const _Ty & _Val ) {
        _Orphan_all ( );
        while ( _Mysize ( ) < _Newsize ) {
            _Emplace_back_internal ( _Val );
        }

        while ( _Newsize < _Mysize ( ) ) {
            pop_back ( );
        }
    }

    [ [ nodiscard ] ] size_type size ( ) const noexcept {
        return _Mysize ( );
    }

    [ [ nodiscard ] ] size_type max_size ( ) const noexcept {
        return ( :: std :: min ) (
            static_cast < size_type > ( ( numeric_limits < difference_type > :: max ) ( ) ), _Alty_traits :: max_size ( _Getal ( ) ) );
    }

    [ [ nodiscard ] ] bool empty ( ) const noexcept {
        return _Mysize ( ) == 0;
    }

    [ [ nodiscard ] ] allocator_type get_allocator ( ) const noexcept {
        return static_cast < allocator_type > ( _Getal ( ) );
    }

    [ [ nodiscard ] ] const_reference at ( size_type _Pos ) const {
        if ( _Mysize ( ) <= _Pos ) {
            _Xran ( );
        }

        return * ( begin ( ) + static_cast < difference_type > ( _Pos ) );
    }

    [ [ nodiscard ] ] reference at ( size_type _Pos ) {
        if ( _Mysize ( ) <= _Pos ) {
            _Xran ( );
        }

        return * ( begin ( ) + static_cast < difference_type > ( _Pos ) );
    }

    [ [ nodiscard ] ] const_reference operator [ ] ( size_type _Pos ) const noexcept {




        return * ( _Unchecked_begin ( ) + static_cast < difference_type > ( _Pos ) );
    }

    [ [ nodiscard ] ] reference operator [ ] ( size_type _Pos ) noexcept {




        return * ( _Unchecked_begin ( ) + static_cast < difference_type > ( _Pos ) );
    }

    [ [ nodiscard ] ] reference front ( ) noexcept {




        return * _Unchecked_begin ( );
    }

    [ [ nodiscard ] ] const_reference front ( ) const noexcept {




        return * _Unchecked_begin ( );
    }

    [ [ nodiscard ] ] reference back ( ) noexcept {




        return * _Prev_iter ( _Unchecked_end ( ) );
    }

    [ [ nodiscard ] ] const_reference back ( ) const noexcept {




        return * _Prev_iter ( _Unchecked_end ( ) );
    }

    void push_front ( const _Ty & _Val ) {
        emplace_front ( _Val );
    }

    void pop_front ( ) noexcept {















        size_type _Block = _Getblock ( _Myoff ( ) );
        _Alty_traits :: destroy ( _Getal ( ), _Unfancy ( _Map ( ) [ _Block ] + _Myoff ( ) % _Block_size ) );
        if ( -- _Mysize ( ) == 0 ) {
            _Myoff ( ) = 0;
        } else {
            ++ _Myoff ( );
        }

    }

private :
    template < class ... _Tys >
    void _Emplace_back_internal ( _Tys && ... _Vals ) {
        if ( ( _Myoff ( ) + _Mysize ( ) ) % _Block_size == 0 && _Mapsize ( ) <= ( _Mysize ( ) + _Block_size ) / _Block_size ) {
            _Growmap ( 1 );
        }
        _Myoff ( ) &= _Mapsize ( ) * _Block_size - 1;
        size_type _Newoff = _Myoff ( ) + _Mysize ( );
        size_type _Block = _Getblock ( _Newoff );
        if ( _Map ( ) [ _Block ] == nullptr ) {
            _Map ( ) [ _Block ] = _Getal ( ) . allocate ( _Block_size );
        }

        _Alty_traits :: construct (
            _Getal ( ), _Unfancy ( _Map ( ) [ _Block ] + _Newoff % _Block_size ), :: std :: forward < _Tys > ( _Vals ) ... );

        ++ _Mysize ( );
    }

public :
    void push_back ( const _Ty & _Val ) {
        _Orphan_all ( );
        _Emplace_back_internal ( _Val );
    }

    void pop_back ( ) noexcept {














        size_type _Newoff = _Myoff ( ) + _Mysize ( ) - 1;
        size_type _Block = _Getblock ( _Newoff );
        _Alty_traits :: destroy ( _Getal ( ), _Unfancy ( _Map ( ) [ _Block ] + _Newoff % _Block_size ) );
        if ( -- _Mysize ( ) == 0 ) {
            _Myoff ( ) = 0;
        }

    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    void assign ( _Iter _First, _Iter _Last ) {
        _Orphan_all ( );
        _Adl_verify_range ( _First, _Last );
        auto _UFirst = _Get_unwrapped ( _First );
        const auto _ULast = _Get_unwrapped ( _Last );
        auto _Myfirst = _Unchecked_begin ( );
        const auto _Mylast = _Unchecked_end ( );
        for (; _UFirst != _ULast; ++ _UFirst ) {
            if ( _Myfirst == _Mylast ) {
                do {
                    emplace_back ( * _UFirst );
                    ++ _UFirst;
                } while ( _UFirst != _ULast );
                return;
            }

            * _Myfirst = * _UFirst;
            ++ _Myfirst;
        }

        _Erase_last_n ( static_cast < size_type > ( _Mylast - _Myfirst ) );
    }

    void assign ( size_type _Count, const _Ty & _Val ) {
        _Orphan_all ( );
        auto _Myfirst = _Unchecked_begin ( );
        const auto _Oldsize = _Mysize ( );
        auto _Assign_count = ( :: std :: min ) ( _Count, _Oldsize );
        for (; 0 < _Assign_count; -- _Assign_count ) {
            * _Myfirst = _Val;
            ++ _Myfirst;
        }

        const auto _Shrink_by = _Oldsize - _Assign_count;
        auto _Extend_by = _Count - _Assign_count;
        _Erase_last_n ( _Shrink_by );
        for (; 0 < _Extend_by; -- _Extend_by ) {
            _Emplace_back_internal ( _Val );
        }
    }

    iterator insert ( const_iterator _Where, const _Ty & _Val ) {
        size_type _Off = static_cast < size_type > ( _Where - begin ( ) );





        if ( _Off <= _Mysize ( ) / 2 ) {
            push_front ( _Val );
            :: std :: rotate ( begin ( ), _Next_iter ( begin ( ) ), begin ( ) + static_cast < difference_type > ( 1 + _Off ) );
        } else {
            push_back ( _Val );
            :: std :: rotate ( begin ( ) + static_cast < difference_type > ( _Off ), _Prev_iter ( end ( ) ), end ( ) );
        }

        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    iterator insert ( const_iterator _Where, size_type _Count, const _Ty & _Val ) {

        size_type _Off = static_cast < size_type > ( _Where - begin ( ) );
        _Insert_n ( _Where, _Count, _Val );
        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    template < class _Iter, enable_if_t < _Is_iterator_v < _Iter >, int > = 0 >
    iterator insert ( const_iterator _Where, _Iter _First, _Iter _Last ) {

        size_type _Off = static_cast < size_type > ( _Where - begin ( ) );





        _Adl_verify_range ( _First, _Last );
        auto _UFirst = _Get_unwrapped ( _First );
        const auto _ULast = _Get_unwrapped ( _Last );

        size_type _Oldsize = _Mysize ( );

        if ( _UFirst != _ULast ) {
            if ( _Off <= _Mysize ( ) / 2 ) {
                try {
                for (; _UFirst != _ULast; ++ _UFirst ) {
                    emplace_front ( * _UFirst );
                }

                } catch ( ... ) {
                while ( _Oldsize < _Mysize ( ) ) {
                    pop_front ( );
                }

                throw;
                }

                size_type _Num = _Mysize ( ) - _Oldsize;
                :: std :: reverse ( begin ( ), begin ( ) + static_cast < difference_type > ( _Num ) );
                :: std :: rotate ( begin ( ), begin ( ) + static_cast < difference_type > ( _Num ),
                    begin ( ) + static_cast < difference_type > ( _Num + _Off ) );
            } else {
                try {
                _Orphan_all ( );
                for (; _UFirst != _ULast; ++ _UFirst ) {
                    _Emplace_back_internal ( * _UFirst );
                }

                } catch ( ... ) {
                while ( _Oldsize < _Mysize ( ) ) {
                    pop_back ( );
                }

                throw;
                }

                :: std :: rotate ( begin ( ) + static_cast < difference_type > ( _Off ),
                    begin ( ) + static_cast < difference_type > ( _Oldsize ), end ( ) );
            }
        }

        return begin ( ) + static_cast < difference_type > ( _Off );
    }

    iterator erase ( const_iterator _Where ) noexcept ( is_nothrow_move_assignable_v < value_type > ) {
        return erase ( _Where, _Next_iter ( _Where ) );
    }

    iterator erase ( const_iterator _First_arg, const_iterator _Last_arg ) noexcept (
        is_nothrow_move_assignable_v < value_type > ) {
        iterator _First = _Make_iter ( _First_arg );
        iterator _Last = _Make_iter ( _Last_arg );










        auto _Off = static_cast < size_type > ( _First - begin ( ) );
        auto _Count = static_cast < size_type > ( _Last - _First );


        if ( _Count == 0 ) {
            return _First;
        }

        if ( _Off < static_cast < size_type > ( end ( ) - _Last ) ) {
            :: std :: move_backward ( begin ( ), _First, _Last );
            for (; 0 < _Count; -- _Count ) {
                pop_front ( );
            }
        } else {
            :: std :: move ( _Last, end ( ), _First );
            for (; 0 < _Count; -- _Count ) {
                pop_back ( );
            }
        }







        return begin ( ) + static_cast < difference_type > ( _Off );
    }

private :
    void _Erase_last_n ( size_type _Count ) noexcept {
        for (; 0 < _Count; -- _Count ) {
            pop_back ( );
        }
    }

public :
    void clear ( ) noexcept {
        _Tidy ( );
    }

    void swap ( deque & _Right ) noexcept {
        if ( this != :: std :: addressof ( _Right ) ) {
            _Pocs ( _Getal ( ), _Right . _Getal ( ) );
            auto & _My_data = _Get_data ( );
            auto & _Right_data = _Right . _Get_data ( );
            _My_data . _Swap_proxy_and_iterators ( _Right_data );
            _Swap_adl ( _My_data . _Map, _Right_data . _Map );
            :: std :: swap ( _My_data . _Mapsize, _Right_data . _Mapsize );
            :: std :: swap ( _My_data . _Myoff, _Right_data . _Myoff );
            :: std :: swap ( _My_data . _Mysize, _Right_data . _Mysize );
        }
    }

private :
    void _Insert_n ( const_iterator _Where, size_type _Count, const _Ty & _Val ) {
        iterator _Mid;
        size_type _Num;
        size_type _Off = static_cast < size_type > ( _Where - begin ( ) );
        size_type _Oldsize = _Mysize ( );
        size_type _Rem = _Oldsize - _Off;





        if ( _Off < _Rem ) {
            try {
            if ( _Off < _Count ) {
                for ( _Num = _Count - _Off; 0 < _Num; -- _Num ) {
                    push_front ( _Val );
                }
                for ( _Num = _Off; 0 < _Num; -- _Num ) {
                    push_front ( begin ( ) [ static_cast < difference_type > ( _Count - 1 ) ] );
                }

                _Mid = begin ( ) + static_cast < difference_type > ( _Count );
                :: std :: fill ( _Mid, _Mid + static_cast < difference_type > ( _Off ), _Val );
            } else {
                for ( _Num = _Count; 0 < _Num; -- _Num ) {
                    push_front ( begin ( ) [ static_cast < difference_type > ( _Count - 1 ) ] );
                }

                _Mid = begin ( ) + static_cast < difference_type > ( _Count );
                _Alloc_temporary2 < _Alty > _Tmp ( _Getal ( ), _Val );
                :: std :: move ( _Mid + static_cast < difference_type > ( _Count ), _Mid + static_cast < difference_type > ( _Off ),
                    _Mid );
                :: std :: fill ( begin ( ) + static_cast < difference_type > ( _Off ), _Mid + static_cast < difference_type > ( _Off ),
                    _Tmp . _Get_value ( ) );
            }
            } catch ( ... ) {
            while ( _Oldsize < _Mysize ( ) ) {
                pop_front ( );
            }

            throw;
            }
        } else {
            try {
            if ( _Rem < _Count ) {
                _Orphan_all ( );
                for ( _Num = _Count - _Rem; 0 < _Num; -- _Num ) {
                    _Emplace_back_internal ( _Val );
                }
                for ( _Num = 0; _Num < _Rem; ++ _Num ) {
                    _Emplace_back_internal ( begin ( ) [ static_cast < difference_type > ( _Off + _Num ) ] );
                }

                _Mid = begin ( ) + static_cast < difference_type > ( _Off );
                :: std :: fill ( _Mid, _Mid + static_cast < difference_type > ( _Rem ), _Val );
            } else {
                for ( _Num = 0; _Num < _Count; ++ _Num ) {
                    _Emplace_back_internal (
                        begin ( ) [ static_cast < difference_type > ( _Off + _Rem - _Count + _Num ) ] );
                }

                _Mid = begin ( ) + static_cast < difference_type > ( _Off );
                _Alloc_temporary2 < _Alty > _Tmp ( _Getal ( ), _Val );
                :: std :: move_backward ( _Mid, _Mid + static_cast < difference_type > ( _Rem - _Count ),
                    _Mid + static_cast < difference_type > ( _Rem ) );
                :: std :: fill ( _Mid, _Mid + static_cast < difference_type > ( _Count ),
                    _Tmp . _Get_value ( ) );
            }
            } catch ( ... ) {
            _Erase_last_n ( _Mysize ( ) - _Oldsize );
            throw;
            }
        }
    }

    [ [ noreturn ] ] void _Xlen ( ) const {
        _Xlength_error ( "deque<T> too long" );
    }

    [ [ noreturn ] ] void _Xran ( ) const {
        _Xout_of_range ( "invalid deque<T> subscript" );
    }

    void _Growmap ( size_type _Count ) {
        static_assert ( 1 < _Minimum_map_size, "The _Xlen() test should always be performed." );

        _Alpty _Almap ( _Getal ( ) );
        size_type _Newsize = 0 < _Mapsize ( ) ? _Mapsize ( ) : 1;
        while ( _Newsize - _Mapsize ( ) < _Count || _Newsize < _Minimum_map_size ) {

            if ( max_size ( ) / _Block_size - _Newsize < _Newsize ) {
                _Xlen ( );
            }

            _Newsize *= 2;
        }
        _Count = _Newsize - _Mapsize ( );

        size_type _Myboff = _Myoff ( ) / _Block_size;
        _Mapptr _Newmap = _Almap . allocate ( _Mapsize ( ) + _Count );
        _Mapptr _Myptr = _Newmap + _Myboff;

        _Myptr = :: std :: uninitialized_copy ( _Map ( ) + _Myboff, _Map ( ) + _Mapsize ( ), _Myptr );
        if ( _Myboff <= _Count ) {
            _Myptr = :: std :: uninitialized_copy ( _Map ( ), _Map ( ) + _Myboff, _Myptr );
            _Uninitialized_value_construct_n_unchecked1 ( _Myptr, _Count - _Myboff );
            _Uninitialized_value_construct_n_unchecked1 ( _Newmap, _Myboff );
        } else {
            :: std :: uninitialized_copy ( _Map ( ), _Map ( ) + _Count, _Myptr );
            _Myptr = :: std :: uninitialized_copy ( _Map ( ) + _Count, _Map ( ) + _Myboff, _Newmap );
            _Uninitialized_value_construct_n_unchecked1 ( _Myptr, _Count );
        }

        _Destroy_range ( _Map ( ) + _Myboff, _Map ( ) + _Mapsize ( ) );
        if ( _Map ( ) != _Mapptr ( ) ) {
            _Almap . deallocate ( _Map ( ), _Mapsize ( ) );
        }

        _Map ( ) = _Newmap;
        _Mapsize ( ) += _Count;
    }

    void _Tidy ( ) noexcept {
        _Orphan_all ( );

        _Alpty _Almap ( _Getal ( ) );
        while ( ! empty ( ) ) {
            pop_back ( );
        }

        for ( size_type _Block = _Mapsize ( ); 0 < _Block; ) {
            if ( _Map ( ) [ -- _Block ] ) {
                _Getal ( ) . deallocate ( _Map ( ) [ _Block ], _Block_size );
                _Destroy_in_place ( _Map ( ) [ _Block ] );
            }
        }

        if ( _Map ( ) != _Mapptr ( ) ) {
            _Almap . deallocate ( _Map ( ), _Mapsize ( ) );
        }

        _Mapsize ( ) = 0;
        _Map ( ) = _Mapptr ( );
    }






















    size_type _Getblock ( size_type _Off ) const noexcept {
        return _Get_data ( ) . _Getblock ( _Off );
    }

    void _Orphan_all ( ) noexcept {
        _Get_data ( ) . _Orphan_all ( );
    }

    _Alty & _Getal ( ) noexcept {
        return _Mypair . _Get_first ( );
    }

    const _Alty & _Getal ( ) const noexcept {
        return _Mypair . _Get_first ( );
    }

    _Scary_val & _Get_data ( ) noexcept {
        return _Mypair . _Myval2;
    }

    const _Scary_val & _Get_data ( ) const noexcept {
        return _Mypair . _Myval2;
    }

    _Mapptr & _Map ( ) noexcept {
        return _Get_data ( ) . _Map;
    }

    const _Mapptr & _Map ( ) const noexcept {
        return _Get_data ( ) . _Map;
    }

    size_type & _Mapsize ( ) noexcept {
        return _Get_data ( ) . _Mapsize;
    }

    const size_type & _Mapsize ( ) const noexcept {
        return _Get_data ( ) . _Mapsize;
    }

    size_type & _Myoff ( ) noexcept {
        return _Get_data ( ) . _Myoff;
    }

    const size_type & _Myoff ( ) const noexcept {
        return _Get_data ( ) . _Myoff;
    }

    size_type & _Mysize ( ) noexcept {
        return _Get_data ( ) . _Mysize;
    }

    const size_type & _Mysize ( ) const noexcept {
        return _Get_data ( ) . _Mysize;
    }

    _Compressed_pair < _Alty, _Scary_val > _Mypair;
};
#line 1580 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
template < class _Ty, class _Alloc >
void swap ( deque < _Ty, _Alloc > & _Left, deque < _Ty, _Alloc > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 1585
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] bool operator == ( const deque < _Ty, _Alloc > & _Left, const deque < _Ty, _Alloc > & _Right ) {
    return _Left . size ( ) == _Right . size ( )
        && :: std :: equal ( _Left . _Unchecked_begin ( ), _Left . _Unchecked_end ( ), _Right . _Unchecked_begin ( ) );
}
#line 1592
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] bool operator != ( const deque < _Ty, _Alloc > & _Left, const deque < _Ty, _Alloc > & _Right ) {
    return ! ( _Left == _Right );
}
#line 1605 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] bool operator < ( const deque < _Ty, _Alloc > & _Left, const deque < _Ty, _Alloc > & _Right ) {
    return :: std :: lexicographical_compare (
        _Left . _Unchecked_begin ( ), _Left . _Unchecked_end ( ), _Right . _Unchecked_begin ( ), _Right . _Unchecked_end ( ) );
}
#line 1611
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] bool operator <= ( const deque < _Ty, _Alloc > & _Left, const deque < _Ty, _Alloc > & _Right ) {
    return ! ( _Right < _Left );
}
#line 1616
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] bool operator > ( const deque < _Ty, _Alloc > & _Left, const deque < _Ty, _Alloc > & _Right ) {
    return _Right < _Left;
}
#line 1621
template < class _Ty, class _Alloc >
[ [ nodiscard ] ] bool operator >= ( const deque < _Ty, _Alloc > & _Left, const deque < _Ty, _Alloc > & _Right ) {
    return ! ( _Left < _Right );
}
#line 1645 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
}
#line 1649
#pragma warning(pop)
#pragma pack ( pop )
#line 1653 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 22
namespace std { 
#line 23
template < class _Ty, class _Container = deque < _Ty > >
class queue {
public :
    using value_type = typename _Container :: value_type;
    using reference = typename _Container :: reference;
    using const_reference = typename _Container :: const_reference;
    using size_type = typename _Container :: size_type;
    using container_type = _Container;

    static_assert ( is_same_v < _Ty, value_type >, "container adaptors require consistent types" );

    queue ( ) = default;

    explicit queue ( const _Container & _Cont ) : c ( _Cont ) { }

    explicit queue ( _Container && _Cont ) noexcept ( is_nothrow_move_constructible_v < _Container > )
        : c ( :: std :: move ( _Cont ) ) { }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    explicit queue ( const _Alloc & _Al ) noexcept ( is_nothrow_constructible_v < _Container, const _Alloc & > )
        : c ( _Al ) { }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    queue ( const _Container & _Cont, const _Alloc & _Al ) : c ( _Cont, _Al ) { }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    queue ( _Container && _Cont, const _Alloc & _Al ) noexcept (
        is_nothrow_constructible_v < _Container, _Container, const _Alloc & > )
        : c ( :: std :: move ( _Cont ), _Al ) { }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    queue ( const queue & _Right, const _Alloc & _Al ) : c ( _Right . c, _Al ) { }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    queue ( queue && _Right, const _Alloc & _Al ) noexcept (
        is_nothrow_constructible_v < _Container, _Container, const _Alloc & > )
        : c ( :: std :: move ( _Right . c ), _Al ) { }

    [ [ nodiscard ] ] bool empty ( ) const noexcept ( noexcept ( c . empty ( ) ) ) {
        return c . empty ( );
    }

    [ [ nodiscard ] ] size_type size ( ) const noexcept ( noexcept ( c . size ( ) ) ) {
        return c . size ( );
    }

    [ [ nodiscard ] ] reference front ( ) noexcept ( noexcept ( c . front ( ) ) ) {
        return c . front ( );
    }

    [ [ nodiscard ] ] const_reference front ( ) const noexcept ( noexcept ( c . front ( ) ) ) {
        return c . front ( );
    }

    [ [ nodiscard ] ] reference back ( ) noexcept ( noexcept ( c . back ( ) ) ) {
        return c . back ( );
    }

    [ [ nodiscard ] ] const_reference back ( ) const noexcept ( noexcept ( c . back ( ) ) ) {
        return c . back ( );
    }

    void push ( const value_type & _Val ) {
        c . push_back ( _Val );
    }

    void push ( value_type && _Val ) {
        c . push_back ( :: std :: move ( _Val ) );
    }

    template < class ... _Valty >
    decltype ( auto ) emplace ( _Valty && ... _Val ) {



        c . emplace_back ( :: std :: forward < _Valty > ( _Val ) ... );

    }

    void pop ( ) noexcept ( noexcept ( c . pop_front ( ) ) ) {
        c . pop_front ( );
    }

    void swap ( queue & _Right ) noexcept ( _Is_nothrow_swappable < _Container > :: value ) {
        _Swap_adl ( c, _Right . c );
    }

    [ [ nodiscard ] ] const _Container & _Get_container ( ) const noexcept {
        return c;
    }

protected :
    _Container c { };
};
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
template < class _Ty, class _Container >
[ [ nodiscard ] ] bool operator == ( const queue < _Ty, _Container > & _Left, const queue < _Ty, _Container > & _Right ) {
    return _Left . _Get_container ( ) == _Right . _Get_container ( );
}
#line 134
template < class _Ty, class _Container >
[ [ nodiscard ] ] bool operator != ( const queue < _Ty, _Container > & _Left, const queue < _Ty, _Container > & _Right ) {
    return _Left . _Get_container ( ) != _Right . _Get_container ( );
}
#line 139
template < class _Ty, class _Container >
[ [ nodiscard ] ] bool operator < ( const queue < _Ty, _Container > & _Left, const queue < _Ty, _Container > & _Right ) {
    return _Left . _Get_container ( ) < _Right . _Get_container ( );
}
#line 144
template < class _Ty, class _Container >
[ [ nodiscard ] ] bool operator > ( const queue < _Ty, _Container > & _Left, const queue < _Ty, _Container > & _Right ) {
    return _Left . _Get_container ( ) > _Right . _Get_container ( );
}
#line 149
template < class _Ty, class _Container >
[ [ nodiscard ] ] bool operator <= ( const queue < _Ty, _Container > & _Left, const queue < _Ty, _Container > & _Right ) {
    return _Left . _Get_container ( ) <= _Right . _Get_container ( );
}
#line 154
template < class _Ty, class _Container >
[ [ nodiscard ] ] bool operator >= ( const queue < _Ty, _Container > & _Left, const queue < _Ty, _Container > & _Right ) {
    return _Left . _Get_container ( ) >= _Right . _Get_container ( );
}
#line 167
template < class _Ty, class _Container, enable_if_t < _Is_swappable < _Container > :: value, int > = 0 >
void swap ( queue < _Ty, _Container > & _Left, queue < _Ty, _Container > & _Right ) noexcept ( noexcept ( _Left . swap ( _Right ) ) ) {
    _Left . swap ( _Right );
}
#line 172
template< class _Ty, class _Container, class _Alloc> 
#line 173
struct uses_allocator< queue< _Ty, _Container> , _Alloc>  : public std::uses_allocator< _Container, _Alloc> ::type { }; 
#line 175
template < class _Ty, class _Container = vector < _Ty >, class _Pr = less < typename _Container :: value_type > >
class priority_queue {
public :
    using value_type = typename _Container :: value_type;
    using reference = typename _Container :: reference;
    using const_reference = typename _Container :: const_reference;
    using size_type = typename _Container :: size_type;
    using container_type = _Container;
    using value_compare = _Pr;

    static_assert ( is_same_v < _Ty, value_type >, "container adaptors require consistent types" );

    priority_queue ( ) = default;

    explicit priority_queue ( const _Pr & _Pred ) noexcept (
        is_nothrow_default_constructible_v < _Container > && is_nothrow_copy_constructible_v < value_compare > )
        : c ( ), comp ( _Pred ) { }

    priority_queue ( const _Pr & _Pred, const _Container & _Cont ) : c ( _Cont ), comp ( _Pred ) {
        :: std :: make_heap ( c . begin ( ), c . end ( ), comp );
    }

    priority_queue ( const _Pr & _Pred, _Container && _Cont ) : c ( :: std :: move ( _Cont ) ), comp ( _Pred ) {
        :: std :: make_heap ( c . begin ( ), c . end ( ), comp );
    }

    template < class _InIt >
    priority_queue ( _InIt _First, _InIt _Last, const _Pr & _Pred, const _Container & _Cont ) : c ( _Cont ), comp ( _Pred ) {
        c . insert ( c . end ( ), _First, _Last );
        :: std :: make_heap ( c . begin ( ), c . end ( ), comp );
    }

    template < class _InIt >
    priority_queue ( _InIt _First, _InIt _Last ) : c ( _First, _Last ), comp ( ) {
        :: std :: make_heap ( c . begin ( ), c . end ( ), comp );
    }

    template < class _InIt >
    priority_queue ( _InIt _First, _InIt _Last, const _Pr & _Pred ) : c ( _First, _Last ), comp ( _Pred ) {
        :: std :: make_heap ( c . begin ( ), c . end ( ), comp );
    }

    template < class _InIt >
    priority_queue ( _InIt _First, _InIt _Last, const _Pr & _Pred, _Container && _Cont ) : c ( :: std :: move ( _Cont ) ), comp ( _Pred ) {
        c . insert ( c . end ( ), _First, _Last );
        :: std :: make_heap ( c . begin ( ), c . end ( ), comp );
    }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    explicit priority_queue ( const _Alloc & _Al ) noexcept ( is_nothrow_constructible_v < _Container, const _Alloc & > &&
            is_nothrow_default_constructible_v < value_compare > )
        : c ( _Al ), comp ( ) { }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    priority_queue ( const _Pr & _Pred, const _Alloc & _Al ) noexcept ( is_nothrow_constructible_v < _Container, const _Alloc & > &&
            is_nothrow_copy_constructible_v < value_compare > )
        : c ( _Al ), comp ( _Pred ) { }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    priority_queue ( const _Pr & _Pred, const _Container & _Cont, const _Alloc & _Al ) : c ( _Cont, _Al ), comp ( _Pred ) {
        :: std :: make_heap ( c . begin ( ), c . end ( ), comp );
    }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    priority_queue ( const _Pr & _Pred, _Container && _Cont, const _Alloc & _Al ) : c ( :: std :: move ( _Cont ), _Al ), comp ( _Pred ) {
        :: std :: make_heap ( c . begin ( ), c . end ( ), comp );
    }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    priority_queue ( const priority_queue & _Right, const _Alloc & _Al ) : c ( _Right . c, _Al ), comp ( _Right . comp ) { }

    template < class _Alloc, enable_if_t < uses_allocator_v < _Container, _Alloc >, int > = 0 >
    priority_queue ( priority_queue && _Right, const _Alloc & _Al ) noexcept (
        is_nothrow_constructible_v < _Container, _Container, const _Alloc & > &&
            is_nothrow_move_constructible_v < value_compare > )
        : c ( :: std :: move ( _Right . c ), _Al ), comp ( :: std :: move ( _Right . comp ) ) { }

    [ [ nodiscard ] ] bool empty ( ) const noexcept ( noexcept ( c . empty ( ) ) ) {
        return c . empty ( );
    }

    [ [ nodiscard ] ] size_type size ( ) const noexcept ( noexcept ( c . size ( ) ) ) {
        return c . size ( );
    }

    [ [ nodiscard ] ] const_reference top ( ) const noexcept ( noexcept ( c . front ( ) ) ) {
        return c . front ( );
    }

    void push ( const value_type & _Val ) {
        c . push_back ( _Val );
        :: std :: push_heap ( c . begin ( ), c . end ( ), comp );
    }

    void push ( value_type && _Val ) {
        c . push_back ( :: std :: move ( _Val ) );
        :: std :: push_heap ( c . begin ( ), c . end ( ), comp );
    }

    template < class ... _Valty >
    void emplace ( _Valty && ... _Val ) {
        c . emplace_back ( :: std :: forward < _Valty > ( _Val ) ... );
        :: std :: push_heap ( c . begin ( ), c . end ( ), comp );
    }

    void pop ( ) {
        :: std :: pop_heap ( c . begin ( ), c . end ( ), comp );
        c . pop_back ( );
    }

    void swap ( priority_queue & _Right ) noexcept (
        _Is_nothrow_swappable < _Container > :: value && _Is_nothrow_swappable < _Pr > :: value ) {
        _Swap_adl ( c, _Right . c );
        _Swap_adl ( comp, _Right . comp );
    }

protected :
    _Container c { };
    _Pr comp { };
};
#line 314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
template < class _Ty, class _Container, class _Pr,
    enable_if_t < _Is_swappable < _Container > :: value && _Is_swappable < _Pr > :: value, int > = 0 >
void swap ( priority_queue < _Ty, _Container, _Pr > & _Left, priority_queue < _Ty, _Container, _Pr > & _Right ) noexcept (
    noexcept ( _Left . swap ( _Right ) ) ) {
    _Left . swap ( _Right );
}
#line 321
template< class _Ty, class _Container, class _Pr, class _Alloc> 
#line 322
struct uses_allocator< priority_queue< _Ty, _Container, _Pr> , _Alloc>  : public std::uses_allocator< _Container, _Alloc> ::type { }; 
#line 324
}
#line 328
#pragma warning(pop)
#pragma pack ( pop )
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
#pragma external_header(pop)
#line 22 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
#pragma external_header(push)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
#pragma external_header(push)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"
#pragma external_header(push)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"
#pragma external_header(push)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_startup.h"
#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#line 15
__pragma( pack ( push, 8 )) extern "C" {
#line 24
typedef 
#line 19
enum _crt_argv_mode { 
#line 21
_crt_argv_no_arguments, 
#line 22
_crt_argv_unexpanded_arguments, 
#line 23
_crt_argv_expanded_arguments
#line 24
} _crt_argv_mode; 
#line 30
typedef 
#line 26
enum _crt_exit_return_mode { 
#line 28
_crt_exit_terminate_process, 
#line 29
_crt_exit_return_to_caller
#line 30
} _crt_exit_return_mode; 
#line 37
typedef 
#line 32
enum _crt_exit_cleanup_mode { 
#line 34
_crt_exit_full_cleanup, 
#line 35
_crt_exit_quick_cleanup, 
#line 36
_crt_exit_no_cleanup
#line 37
} _crt_exit_cleanup_mode; 
#line 39
extern _crt_exit_return_mode __current_exit_return_mode; 
#line 43
__vcrt_bool __cdecl __vcrt_initialize(); 
#line 44
__vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool _Terminating); 
#line 45
__vcrt_bool __cdecl __vcrt_uninitialize_critical(); 
#line 46
__vcrt_bool __cdecl __vcrt_thread_attach(); 
#line 47
__vcrt_bool __cdecl __vcrt_thread_detach(); 
#line 49
int __cdecl __isa_available_init(); 
#line 50
_crt_argv_mode __cdecl _get_startup_argv_mode(); 
#line 54
}__pragma( pack ( pop )) 
#line 56
#pragma warning(pop)
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 28
struct _EXCEPTION_POINTERS; 
#line 30
int __cdecl _seh_filter_dll(unsigned long _ExceptionNum, _EXCEPTION_POINTERS * _ExceptionPtr); 
#line 35
int __cdecl _seh_filter_exe(unsigned long _ExceptionNum, _EXCEPTION_POINTERS * _ExceptionPtr); 
#line 52
typedef 
#line 47
enum _crt_app_type { 
#line 49
_crt_unknown_app, 
#line 50
_crt_console_app, 
#line 51
_crt_gui_app
#line 52
} _crt_app_type; 
#line 54
_crt_app_type __cdecl _query_app_type(); 
#line 56
void __cdecl _set_app_type(_crt_app_type _Type); 
#line 60
typedef int (__cdecl *_UserMathErrorFunctionPointer)(_exception *); 
#line 62
void __cdecl __setusermatherr(_UserMathErrorFunctionPointer _UserMathErrorFunction); 
#line 66
int __cdecl _is_c_termination_complete(); 
#line 75
errno_t __cdecl _configure_narrow_argv(_crt_argv_mode mode); 
#line 79
errno_t __cdecl _configure_wide_argv(_crt_argv_mode mode); 
#line 85
int __cdecl _initialize_narrow_environment(); 
#line 86
int __cdecl _initialize_wide_environment(); 
#line 88
char **__cdecl _get_initial_narrow_environment(); 
#line 89
__wchar_t **__cdecl _get_initial_wide_environment(); 
#line 91
char *__cdecl _get_narrow_winmain_command_line(); 
#line 92
__wchar_t *__cdecl _get_wide_winmain_command_line(); 
#line 94
char **__cdecl __p__acmdln(); 
#line 95
__wchar_t **__cdecl __p__wcmdln(); 
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"
typedef void (__cdecl *_PVFV)(void); 
#line 113
typedef int (__cdecl *_PIFV)(void); 
#line 114
typedef void (__cdecl *_PVFI)(int); 
#line 117
void __cdecl _initterm(_PVFV * _First, _PVFV * _Last); 
#line 122
int __cdecl _initterm_e(_PIFV * _First, _PIFV * _Last); 
#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"
typedef 
#line 137
struct _onexit_table_t { 
#line 139
_PVFV *_first; 
#line 140
_PVFV *_last; 
#line 141
_PVFV *_end; 
#line 142
} _onexit_table_t; 
#line 144
int __cdecl _initialize_onexit_table(_onexit_table_t * _Table); 
#line 148
int __cdecl _register_onexit_function(_onexit_table_t * _Table, _onexit_t _Function); 
#line 153
int __cdecl _execute_onexit_table(_onexit_table_t * _Table); 
#line 157
int __cdecl _crt_atexit(_PVFV _Function); 
#line 161
int __cdecl _crt_at_quick_exit(_PVFV _Function); 
#line 175
__crt_bool __cdecl __acrt_initialize(); 
#line 178
__crt_bool __cdecl __acrt_uninitialize(__crt_bool _Terminating); 
#line 183
__crt_bool __cdecl __acrt_uninitialize_critical(__crt_bool _Terminating); 
#line 188
__crt_bool __cdecl __acrt_thread_attach(); 
#line 191
__crt_bool __cdecl __acrt_thread_detach(); 
#line 197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"
}__pragma( pack ( pop )) 
#line 199
#pragma warning(pop)
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"
#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )
#line 21
__pragma( pack ( push, 8 )) extern "C" {
#line 42
__declspec(noreturn) void __cdecl exit(int _Code); 
#line 43
__declspec(noreturn) void __cdecl _exit(int _Code); 
#line 44
__declspec(noreturn) void __cdecl _Exit(int _Code); 
#line 45
__declspec(noreturn) void __cdecl quick_exit(int _Code); 
#line 46
__declspec(noreturn) void __cdecl abort(); 
#line 48
int __cdecl system(const char * _Command); 
#line 50
void __cdecl _cexit(); 
#line 51
void __cdecl _c_exit(); 
#line 53
typedef void (__stdcall *_tls_callback_type)(void *, unsigned long, void *); 
#line 54
void __cdecl _register_thread_local_exe_atexit_callback(_tls_callback_type _Callback); 
#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"
typedef void (__cdecl *_beginthread_proc_type)(void *); 
#line 85
typedef unsigned (__stdcall *_beginthreadex_proc_type)(void *); 
#line 87
uintptr_t __cdecl _beginthread(_beginthread_proc_type _StartAddress, unsigned _StackSize, void * _ArgList); 
#line 93
void __cdecl _endthread(); 
#line 96
uintptr_t __cdecl _beginthreadex(void * _Security, unsigned _StackSize, _beginthreadex_proc_type _StartAddress, void * _ArgList, unsigned _InitFlag, unsigned * _ThrdAddr); 
#line 105
void __cdecl _endthreadex(unsigned _ReturnCode); 
#line 113
int __cdecl _getpid(); 
#line 115
intptr_t __cdecl _cwait(int * _TermStat, intptr_t _ProcHandle, int _Action); 
#line 121
intptr_t __cdecl _execl(const char * _FileName, const char * _Arguments, ...); 
#line 126
intptr_t __cdecl _execle(const char * _FileName, const char * _Arguments, ...); 
#line 131
intptr_t __cdecl _execlp(const char * _FileName, const char * _Arguments, ...); 
#line 136
intptr_t __cdecl _execlpe(const char * _FileName, const char * _Arguments, ...); 
#line 141
intptr_t __cdecl _execv(const char * _FileName, const char *const * _Arguments); 
#line 146
intptr_t __cdecl _execve(const char * _FileName, const char *const * _Arguments, const char *const * _Environment); 
#line 152
intptr_t __cdecl _execvp(const char * _FileName, const char *const * _Arguments); 
#line 157
intptr_t __cdecl _execvpe(const char * _FileName, const char *const * _Arguments, const char *const * _Environment); 
#line 163
intptr_t __cdecl _spawnl(int _Mode, const char * _FileName, const char * _Arguments, ...); 
#line 169
intptr_t __cdecl _spawnle(int _Mode, const char * _FileName, const char * _Arguments, ...); 
#line 175
intptr_t __cdecl _spawnlp(int _Mode, const char * _FileName, const char * _Arguments, ...); 
#line 181
intptr_t __cdecl _spawnlpe(int _Mode, const char * _FileName, const char * _Arguments, ...); 
#line 187
intptr_t __cdecl _spawnv(int _Mode, const char * _FileName, const char *const * _Arguments); 
#line 193
intptr_t __cdecl _spawnve(int _Mode, const char * _FileName, const char *const * _Arguments, const char *const * _Environment); 
#line 200
intptr_t __cdecl _spawnvp(int _Mode, const char * _FileName, const char *const * _Arguments); 
#line 206
intptr_t __cdecl _spawnvpe(int _Mode, const char * _FileName, const char *const * _Arguments, const char *const * _Environment); 
#line 213
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using LoadLibrary ins" "tead. See online help for details.")) intptr_t __cdecl 
#line 214
_loaddll(char * _FileName); 
#line 218
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using FreeLibrary ins" "tead. See online help for details.")) int __cdecl 
#line 219
_unloaddll(intptr_t _Handle); 
#line 223
typedef int (__cdecl *_GetDllProcAddrProcType)(void); 
#line 225
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetProcAddress " "instead. See online help for details.")) _GetDllProcAddrProcType __cdecl 
#line 226
_getdllprocaddr(intptr_t _Handle, char * _ProcedureName, intptr_t _Ordinal); 
#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"
intptr_t __cdecl cwait(int * _TermStat, intptr_t _ProcHandle, int _Action); 
#line 257
intptr_t __cdecl execl(const char * _FileName, const char * _Arguments, ...); 
#line 263
intptr_t __cdecl execle(const char * _FileName, const char * _Arguments, ...); 
#line 269
intptr_t __cdecl execlp(const char * _FileName, const char * _Arguments, ...); 
#line 275
intptr_t __cdecl execlpe(const char * _FileName, const char * _Arguments, ...); 
#line 281
intptr_t __cdecl execv(const char * _FileName, const char *const * _Arguments); 
#line 287
intptr_t __cdecl execve(const char * _FileName, const char *const * _Arguments, const char *const * _Environment); 
#line 294
intptr_t __cdecl execvp(const char * _FileName, const char *const * _Arguments); 
#line 300
intptr_t __cdecl execvpe(const char * _FileName, const char *const * _Arguments, const char *const * _Environment); 
#line 307
intptr_t __cdecl spawnl(int _Mode, const char * _FileName, const char * _Arguments, ...); 
#line 314
intptr_t __cdecl spawnle(int _Mode, const char * _FileName, const char * _Arguments, ...); 
#line 321
intptr_t __cdecl spawnlp(int _Mode, const char * _FileName, const char * _Arguments, ...); 
#line 328
intptr_t __cdecl spawnlpe(int _Mode, const char * _FileName, const char * _Arguments, ...); 
#line 335
intptr_t __cdecl spawnv(int _Mode, const char * _FileName, const char *const * _Arguments); 
#line 341
intptr_t __cdecl spawnve(int _Mode, const char * _FileName, const char *const * _Arguments, const char *const * _Environment); 
#line 349
intptr_t __cdecl spawnvp(int _Mode, const char * _FileName, const char *const * _Arguments); 
#line 356
intptr_t __cdecl spawnvpe(int _Mode, const char * _FileName, const char *const * _Arguments, const char *const * _Environment); 
#line 364
int __cdecl getpid(); 
#line 372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"
}__pragma( pack ( pop )) 
#line 374
#pragma warning(pop)
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
#pragma external_header(push)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 24
namespace std { 
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
template< bool _Same, class _Dest, class ..._Srcs> constexpr bool 
#line 39
_Tuple_implicit_v0 = false; 
#line 41
template< class ..._Dests, class ..._Srcs> constexpr bool 
#line 42
_Tuple_implicit_v0< true, tuple< _Dests...> , _Srcs...>  = conjunction_v< is_constructible< _Dests, _Srcs> ..., is_convertible< _Srcs, _Dests> ...> ; 
#line 45
template< class _Dest, class ..._Srcs> 
#line 46
struct _Tuple_implicit_val : public bool_constant< _Tuple_implicit_v0< tuple_size_v< _Dest>  == sizeof...(_Srcs), _Dest, _Srcs...> >  { 
#line 47
}; 
#line 50
template< bool _Same, class _Dest, class ..._Srcs> constexpr bool 
#line 51
_Tuple_explicit_v0 = false; 
#line 53
template< class ..._Dests, class ..._Srcs> constexpr bool 
#line 54
_Tuple_explicit_v0< true, tuple< _Dests...> , _Srcs...>  = conjunction_v< is_constructible< _Dests, _Srcs> ..., negation< conjunction< is_convertible< _Srcs, _Dests> ...> > > ; 
#line 57
template< class _Dest, class ..._Srcs> 
#line 58
struct _Tuple_explicit_val : public bool_constant< _Tuple_explicit_v0< tuple_size_v< _Dest>  == sizeof...(_Srcs), _Dest, _Srcs...> >  { 
#line 59
}; 
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
template< bool _Same, class _Dest, class ..._Srcs> constexpr bool 
#line 63
_Tuple_constructible_v0 = false; 
#line 65
template< class ..._Dests, class ..._Srcs> constexpr bool 
#line 66
_Tuple_constructible_v0< true, tuple< _Dests...> , _Srcs...>  = conjunction_v< is_constructible< _Dests, _Srcs> ...> ; 
#line 69
template< class _Dest, class ..._Srcs> constexpr bool 
#line 70
_Tuple_constructible_v = _Tuple_constructible_v0< tuple_size_v< _Dest>  == sizeof...(_Srcs), _Dest, _Srcs...> ; 
#line 73
template< class _Dest, class ..._Srcs> 
#line 74
struct _Tuple_constructible_val : public bool_constant< _Tuple_constructible_v< _Dest, _Srcs...> >  { }; 
#line 76
template< bool _Same, class _Dest, class ..._Srcs> constexpr bool 
#line 77
_Tuple_nothrow_constructible_v0 = false; 
#line 79
template< class ..._Dests, class ..._Srcs> constexpr bool 
#line 80
_Tuple_nothrow_constructible_v0< true, tuple< _Dests...> , _Srcs...>  = conjunction_v< is_nothrow_constructible< _Dests, _Srcs> ...> ; 
#line 83
template< class _Dest, class ..._Srcs> constexpr bool 
#line 84
_Tuple_nothrow_constructible_v = _Tuple_nothrow_constructible_v0< tuple_size_v< _Dest>  == sizeof...(_Srcs), _Dest, _Srcs...> ; 
#line 87
template< bool _Same, class _Dest, class ..._Srcs> constexpr bool 
#line 88
_Tuple_assignable_v0 = false; 
#line 90
template< class ..._Dests, class ..._Srcs> constexpr bool 
#line 91
_Tuple_assignable_v0< true, tuple< _Dests...> , _Srcs...>  = conjunction_v< is_assignable< _Dests &, _Srcs> ...> ; 
#line 94
template< class _Dest, class ..._Srcs> constexpr bool 
#line 95
_Tuple_assignable_v = _Tuple_assignable_v0< tuple_size_v< _Dest>  == sizeof...(_Srcs), _Dest, _Srcs...> ; 
#line 98
template< class _Dest, class ..._Srcs> 
#line 99
struct _Tuple_assignable_val : public bool_constant< _Tuple_assignable_v< _Dest, _Srcs...> >  { }; 
#line 101
template< bool _Same, class _Dest, class ..._Srcs> constexpr bool 
#line 102
_Tuple_nothrow_assignable_v0 = false; 
#line 104
template< class ..._Dests, class ..._Srcs> constexpr bool 
#line 105
_Tuple_nothrow_assignable_v0< true, tuple< _Dests...> , _Srcs...>  = conjunction_v< is_nothrow_assignable< _Dests &, _Srcs> ...> ; 
#line 108
template< class _Dest, class ..._Srcs> constexpr bool 
#line 109
_Tuple_nothrow_assignable_v = _Tuple_nothrow_assignable_v0< tuple_size_v< _Dest>  == sizeof...(_Srcs), _Dest, _Srcs...> ; 
#line 113
template< class _Myself, class ..._Other> 
#line 114
struct _Tuple_convert_copy_val : public true_type { }; 
#line 116
template< class _This, class _Uty> 
#line 117
struct _Tuple_convert_copy_val< tuple< _This> , _Uty>  : public bool_constant< !disjunction_v< is_same< _This, _Uty> , is_constructible< _This, const tuple< _Uty>  &> , is_convertible< const tuple< _Uty>  &, _This> > >  { 
#line 119
}; 
#line 122
template< class _Myself, class ..._Other> 
#line 123
struct _Tuple_convert_move_val : public true_type { }; 
#line 125
template< class _This, class _Uty> 
#line 126
struct _Tuple_convert_move_val< tuple< _This> , _Uty>  : public bool_constant< !disjunction_v< is_same< _This, _Uty> , is_constructible< _This, tuple< _Uty> > , is_convertible< tuple< _Uty> , _This> > >  { 
#line 128
}; 
#line 131
template< class _Myself, class _This2, class ..._Rest2> 
#line 132
struct _Tuple_perfect_val : public true_type { }; 
#line 134
template< class _Myself, class _This2> 
#line 135
struct _Tuple_perfect_val< _Myself, _This2>  : public bool_constant< !is_same_v< _Myself, remove_const_t< remove_reference_t< _This2> > > >  { 
#line 136
}; 
#line 138
struct _Ignore { 
#line 139
template < class _Ty >
    constexpr const _Ignore & operator = ( const _Ty & ) const noexcept {

        return * this;
    }
#line 144
}; 
#line 146
constexpr _Ignore ignore{}; 
#line 153
template < class _Ty >
struct _Tuple_val {
    constexpr _Tuple_val ( ) : _Val ( ) { }

    template < class _Other >
    constexpr _Tuple_val ( _Other && _Arg ) : _Val ( :: std :: forward < _Other > ( _Arg ) ) { }

    template < class _Alloc, class ... _Other, enable_if_t < ! uses_allocator_v < _Ty, _Alloc >, int > = 0 >
    constexpr _Tuple_val ( const _Alloc &, allocator_arg_t, _Other && ... _Arg ) : _Val ( :: std :: forward < _Other > ( _Arg ) ... ) { }

    template < class _Alloc, class ... _Other,
        enable_if_t < conjunction_v < :: std :: uses_allocator < _Ty, _Alloc >,
                        :: std :: is_constructible < _Ty, :: std :: allocator_arg_t, const _Alloc &, _Other ... >>,
            int > = 0 >
    constexpr _Tuple_val ( const _Alloc & _Al, allocator_arg_t, _Other && ... _Arg )
        : _Val ( allocator_arg, _Al, :: std :: forward < _Other > ( _Arg ) ... ) { }

    template < class _Alloc, class ... _Other,
        enable_if_t < conjunction_v < :: std :: uses_allocator < _Ty, _Alloc >,
                        :: std :: negation < :: std :: is_constructible < _Ty, :: std :: allocator_arg_t, const _Alloc &, _Other ... >> >,
            int > = 0 >
    constexpr _Tuple_val ( const _Alloc & _Al, allocator_arg_t, _Other && ... _Arg )
        : _Val ( :: std :: forward < _Other > ( _Arg ) ..., _Al ) { }

    _Ty _Val;
};
#line 180
struct _Exact_args_t { 
#line 181
explicit _Exact_args_t() = default;
#line 182
}; 
#line 184
struct _Unpack_tuple_t { 
#line 185
explicit _Unpack_tuple_t() = default;
#line 186
}; 
#line 188
struct _Alloc_exact_args_t { 
#line 189
explicit _Alloc_exact_args_t() = default;
#line 190
}; 
#line 192
struct _Alloc_unpack_tuple_t { 
#line 193
explicit _Alloc_unpack_tuple_t() = default;
#line 194
}; 
#line 196
template< class ..._Types> class tuple; 
#line 200
template<> class tuple< >  { 
#line 202
public: constexpr tuple() noexcept = default;
#line 204
constexpr tuple(const std::tuple< >  &) noexcept { } 
#line 206
template < class _Alloc >
    inline tuple ( allocator_arg_t, const _Alloc & ) noexcept { }
#line 209
template < class _Alloc >
    inline tuple ( allocator_arg_t, const _Alloc &, const tuple & ) noexcept { }
#line 212
template < class _Tag, enable_if_t < is_same_v < _Tag, :: std :: _Exact_args_t >, int > = 0 >
    constexpr tuple ( _Tag ) noexcept { }
#line 215
template < class _Tag, class _Alloc, enable_if_t < is_same_v < _Tag, :: std :: _Alloc_exact_args_t >, int > = 0 >
    constexpr tuple ( _Tag, const _Alloc & ) noexcept { }
#line 218
constexpr std::tuple< >  &operator=(const std::tuple< >  &) = default;
#line 220
void swap(std::tuple< >  &) noexcept { } 
#line 222
constexpr bool _Equals(const std::tuple< >  &) const noexcept { 
#line 223
return true; 
#line 224
} 
#line 231
[[nodiscard]] constexpr bool _Less(const std::tuple< >  &) const noexcept { 
#line 232
return false; 
#line 233
} 
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
}; 
#line 237
template < class _This, class ... _Rest >
class tuple < _This, _Rest ... > : private tuple < _Rest ... > {
public :
    using _This_type = _This;
    using _Mybase = tuple < _Rest ... >;

    template < class _Tag, class _This2, class ... _Rest2, enable_if_t < is_same_v < _Tag, :: std :: _Exact_args_t >, int > = 0 >
    constexpr tuple ( _Tag, _This2 && _This_arg, _Rest2 && ... _Rest_arg )
        : _Mybase ( _Exact_args_t { }, :: std :: forward < _Rest2 > ( _Rest_arg ) ... ), _Myfirst ( :: std :: forward < _This2 > ( _This_arg ) ) { }

    template < class _Tag, class _Tpl, size_t ... _Indices, enable_if_t < is_same_v < _Tag, :: std :: _Unpack_tuple_t >, int > = 0 >
    constexpr tuple ( _Tag, _Tpl && _Right, index_sequence < _Indices ... > );

    template < class _Tag, class _Tpl, enable_if_t < is_same_v < _Tag, :: std :: _Unpack_tuple_t >, int > = 0 >
    constexpr tuple ( _Tag, _Tpl && _Right )
        : tuple ( _Unpack_tuple_t { }, :: std :: forward < _Tpl > ( _Right ),
            make_index_sequence < tuple_size_v < remove_reference_t < _Tpl >> > { } ) { }

    template < class _Tag, class _Alloc, class _This2, class ... _Rest2,
        enable_if_t < is_same_v < _Tag, :: std :: _Alloc_exact_args_t >, int > = 0 >
    constexpr tuple ( _Tag, const _Alloc & _Al, _This2 && _This_arg, _Rest2 && ... _Rest_arg )
        : _Mybase ( _Alloc_exact_args_t { }, _Al, :: std :: forward < _Rest2 > ( _Rest_arg ) ... ),
          _Myfirst ( _Al, allocator_arg, :: std :: forward < _This2 > ( _This_arg ) ) { }

    template < class _Tag, class _Alloc, class _Tpl, size_t ... _Indices,
        enable_if_t < is_same_v < _Tag, :: std :: _Alloc_unpack_tuple_t >, int > = 0 >
    constexpr tuple ( _Tag, const _Alloc & _Al, _Tpl && _Right, index_sequence < _Indices ... > );

    template < class _Tag, class _Alloc, class _Tpl, enable_if_t < is_same_v < _Tag, :: std :: _Alloc_unpack_tuple_t >, int > = 0 >
    constexpr tuple ( _Tag, const _Alloc & _Al, _Tpl && _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, :: std :: forward < _Tpl > ( _Right ),
            make_index_sequence < tuple_size_v < remove_reference_t < _Tpl >> > { } ) { }











    template < class _This2 = _This,
        enable_if_t < conjunction_v < is_default_constructible < _This2 >, is_default_constructible < _Rest > ...,
                        _Is_implicitly_default_constructible < _This2 >, _Is_implicitly_default_constructible < _Rest > ... >,
            int > = 0 >
    constexpr tuple ( ) noexcept ( conjunction_v < is_nothrow_default_constructible < _This2 >,
        is_nothrow_default_constructible < _Rest > ... > )
        : _Mybase ( ), _Myfirst ( ) { }

    template < class _This2 = _This,
        enable_if_t < conjunction_v < is_default_constructible < _This2 >, is_default_constructible < _Rest > ...,
                        negation < conjunction < _Is_implicitly_default_constructible < _This2 >,
                            _Is_implicitly_default_constructible < _Rest > ... >> >,
            int > = 0 >
    constexpr explicit tuple ( ) noexcept ( conjunction_v < is_nothrow_default_constructible < _This2 >,
        is_nothrow_default_constructible < _Rest > ... > )
        : _Mybase ( ), _Myfirst ( ) { }









    template < class _This2 = _This,
        enable_if_t < _Tuple_implicit_val < tuple, const _This2 &, const _Rest & ... > :: value, int > = 0 >
    constexpr tuple ( const _This & _This_arg, const _Rest & ... _Rest_arg ) noexcept (
        conjunction_v < is_nothrow_copy_constructible < _This2 >,
            is_nothrow_copy_constructible < _Rest > ... > )
        : tuple ( _Exact_args_t { }, _This_arg, _Rest_arg ... ) { }

    template < class _This2 = _This,
        enable_if_t < _Tuple_explicit_val < tuple, const _This2 &, const _Rest & ... > :: value, int > = 0 >
    constexpr explicit tuple ( const _This & _This_arg, const _Rest & ... _Rest_arg ) noexcept (
        conjunction_v < is_nothrow_copy_constructible < _This2 >,
            is_nothrow_copy_constructible < _Rest > ... > )
        : tuple ( _Exact_args_t { }, _This_arg, _Rest_arg ... ) { }











    template < class _This2, class ... _Rest2,
        enable_if_t <
            conjunction_v < _Tuple_perfect_val < tuple, _This2, _Rest2 ... >, _Tuple_implicit_val < tuple, _This2, _Rest2 ... >>,
            int > = 0 >
    constexpr tuple ( _This2 && _This_arg, _Rest2 && ... _Rest_arg ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, _This2, _Rest2 ... > )
        : tuple ( _Exact_args_t { }, :: std :: forward < _This2 > ( _This_arg ), :: std :: forward < _Rest2 > ( _Rest_arg ) ... ) { }

    template < class _This2, class ... _Rest2,
        enable_if_t <
            conjunction_v < _Tuple_perfect_val < tuple, _This2, _Rest2 ... >, _Tuple_explicit_val < tuple, _This2, _Rest2 ... >>,
            int > = 0 >
    constexpr explicit tuple ( _This2 && _This_arg, _Rest2 && ... _Rest_arg ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, _This2, _Rest2 ... > )
        : tuple ( _Exact_args_t { }, :: std :: forward < _This2 > ( _This_arg ), :: std :: forward < _Rest2 > ( _Rest_arg ) ... ) { }


    tuple ( const tuple & ) = default;
    tuple ( tuple && ) = default;










    template < class ... _Other, enable_if_t < conjunction_v < _Tuple_implicit_val < tuple, const _Other & ... >,
                                               _Tuple_convert_copy_val < tuple, _Other ... >>,
                                   int > = 0 >
    constexpr tuple ( const tuple < _Other ... > & _Right ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, const _Other & ... > )
        : tuple ( _Unpack_tuple_t { }, _Right ) { }

    template < class ... _Other, enable_if_t < conjunction_v < _Tuple_explicit_val < tuple, const _Other & ... >,
                                               _Tuple_convert_copy_val < tuple, _Other ... >>,
                                   int > = 0 >
    constexpr explicit tuple ( const tuple < _Other ... > & _Right ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, const _Other & ... > )
        : tuple ( _Unpack_tuple_t { }, _Right ) { }










    template < class ... _Other,
        enable_if_t < conjunction_v < _Tuple_implicit_val < tuple, _Other ... >, _Tuple_convert_move_val < tuple, _Other ... >>,
            int > = 0 >
    constexpr tuple ( tuple < _Other ... > && _Right ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, _Other ... > )
        : tuple ( _Unpack_tuple_t { }, :: std :: move ( _Right ) ) { }

    template < class ... _Other,
        enable_if_t < conjunction_v < _Tuple_explicit_val < tuple, _Other ... >, _Tuple_convert_move_val < tuple, _Other ... >>,
            int > = 0 >
    constexpr explicit tuple ( tuple < _Other ... > && _Right ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, _Other ... > )
        : tuple ( _Unpack_tuple_t { }, :: std :: move ( _Right ) ) { }










    template < class _First, class _Second,
        enable_if_t < _Tuple_implicit_val < tuple, const _First &, const _Second & > :: value, int > = 0 >
    constexpr tuple ( const pair < _First, _Second > & _Right ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, const _First &, const _Second & > )
        : tuple ( _Unpack_tuple_t { }, _Right ) { }

    template < class _First, class _Second,
        enable_if_t < _Tuple_explicit_val < tuple, const _First &, const _Second & > :: value, int > = 0 >
    constexpr explicit tuple ( const pair < _First, _Second > & _Right ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, const _First &, const _Second & > )
        : tuple ( _Unpack_tuple_t { }, _Right ) { }








    template < class _First, class _Second, enable_if_t < _Tuple_implicit_val < tuple, _First, _Second > :: value, int > = 0 >
    constexpr tuple ( pair < _First, _Second > && _Right ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, _First, _Second > )
        : tuple ( _Unpack_tuple_t { }, :: std :: move ( _Right ) ) { }

    template < class _First, class _Second, enable_if_t < _Tuple_explicit_val < tuple, _First, _Second > :: value, int > = 0 >
    constexpr explicit tuple ( pair < _First, _Second > && _Right ) noexcept (
        _Tuple_nothrow_constructible_v < tuple, _First, _Second > )
        : tuple ( _Unpack_tuple_t { }, :: std :: move ( _Right ) ) { }











    template < class _Alloc, class _This2 = _This,
        enable_if_t < conjunction_v < is_default_constructible < _This2 >, is_default_constructible < _Rest > ...,
                        _Is_implicitly_default_constructible < _This2 >, _Is_implicitly_default_constructible < _Rest > ... >,
            int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al )
        : _Mybase ( allocator_arg, _Al ), _Myfirst ( _Al, allocator_arg ) { }

    template < class _Alloc, class _This2 = _This,
        enable_if_t < conjunction_v < is_default_constructible < _This2 >, is_default_constructible < _Rest > ...,
                        negation < conjunction < _Is_implicitly_default_constructible < _This2 >,
                            _Is_implicitly_default_constructible < _Rest > ... >> >,
            int > = 0 >
    inline explicit tuple ( allocator_arg_t, const _Alloc & _Al )
        : _Mybase ( allocator_arg, _Al ), _Myfirst ( _Al, allocator_arg ) { }









    template < class _Alloc, class _This2 = _This,
        enable_if_t < _Tuple_implicit_val < tuple, const _This2 &, const _Rest & ... > :: value, int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al, const _This & _This_arg, const _Rest & ... _Rest_arg )
        : tuple ( _Alloc_exact_args_t { }, _Al, _This_arg, _Rest_arg ... ) { }

    template < class _Alloc, class _This2 = _This,
        enable_if_t < _Tuple_explicit_val < tuple, const _This2 &, const _Rest & ... > :: value, int > = 0 >
    inline explicit tuple ( allocator_arg_t, const _Alloc & _Al, const _This & _This_arg, const _Rest & ... _Rest_arg )
        : tuple ( _Alloc_exact_args_t { }, _Al, _This_arg, _Rest_arg ... ) { }











    template < class _Alloc, class _This2, class ... _Rest2,
        enable_if_t <
            conjunction_v < _Tuple_perfect_val < tuple, _This2, _Rest2 ... >, _Tuple_implicit_val < tuple, _This2, _Rest2 ... >>,
            int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al, _This2 && _This_arg, _Rest2 && ... _Rest_arg )
        : tuple ( _Alloc_exact_args_t { }, _Al, :: std :: forward < _This2 > ( _This_arg ), :: std :: forward < _Rest2 > ( _Rest_arg ) ... ) { }

    template < class _Alloc, class _This2, class ... _Rest2,
        enable_if_t <
            conjunction_v < _Tuple_perfect_val < tuple, _This2, _Rest2 ... >, _Tuple_explicit_val < tuple, _This2, _Rest2 ... >>,
            int > = 0 >
    inline explicit tuple ( allocator_arg_t, const _Alloc & _Al, _This2 && _This_arg, _Rest2 && ... _Rest_arg )
        : tuple ( _Alloc_exact_args_t { }, _Al, :: std :: forward < _This2 > ( _This_arg ), :: std :: forward < _Rest2 > ( _Rest_arg ) ... ) { }


    template < class _Alloc, class _This2 = _This,
        enable_if_t < _Tuple_constructible_v < tuple, const _This2 &, const _Rest & ... >, int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al, const tuple & _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, _Right ) { }

    template < class _Alloc, class _This2 = _This, enable_if_t < _Tuple_constructible_v < tuple, _This2, _Rest ... >, int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al, tuple && _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, :: std :: move ( _Right ) ) { }










    template < class _Alloc, class ... _Other,
        enable_if_t <
            conjunction_v < _Tuple_implicit_val < tuple, const _Other & ... >, _Tuple_convert_copy_val < tuple, _Other ... >>,
            int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al, const tuple < _Other ... > & _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, _Right ) { }

    template < class _Alloc, class ... _Other,
        enable_if_t <
            conjunction_v < _Tuple_explicit_val < tuple, const _Other & ... >, _Tuple_convert_copy_val < tuple, _Other ... >>,
            int > = 0 >
    inline explicit tuple ( allocator_arg_t, const _Alloc & _Al, const tuple < _Other ... > & _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, _Right ) { }











    template < class _Alloc, class ... _Other,
        enable_if_t < conjunction_v < _Tuple_implicit_val < tuple, _Other ... >, _Tuple_convert_move_val < tuple, _Other ... >>,
            int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al, tuple < _Other ... > && _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, :: std :: move ( _Right ) ) { }

    template < class _Alloc, class ... _Other,
        enable_if_t < conjunction_v < _Tuple_explicit_val < tuple, _Other ... >, _Tuple_convert_move_val < tuple, _Other ... >>,
            int > = 0 >
    inline explicit tuple ( allocator_arg_t, const _Alloc & _Al, tuple < _Other ... > && _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, :: std :: move ( _Right ) ) { }









    template < class _Alloc, class _First, class _Second,
        enable_if_t < _Tuple_implicit_val < tuple, const _First &, const _Second & > :: value, int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al, const pair < _First, _Second > & _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, _Right ) { }

    template < class _Alloc, class _First, class _Second,
        enable_if_t < _Tuple_explicit_val < tuple, const _First &, const _Second & > :: value, int > = 0 >
    inline explicit tuple ( allocator_arg_t, const _Alloc & _Al, const pair < _First, _Second > & _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, _Right ) { }









    template < class _Alloc, class _First, class _Second,
        enable_if_t < _Tuple_implicit_val < tuple, _First, _Second > :: value, int > = 0 >
    inline tuple ( allocator_arg_t, const _Alloc & _Al, pair < _First, _Second > && _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, :: std :: move ( _Right ) ) { }

    template < class _Alloc, class _First, class _Second,
        enable_if_t < _Tuple_explicit_val < tuple, _First, _Second > :: value, int > = 0 >
    inline explicit tuple ( allocator_arg_t, const _Alloc & _Al, pair < _First, _Second > && _Right )
        : tuple ( _Alloc_unpack_tuple_t { }, _Al, :: std :: move ( _Right ) ) { }


    tuple & operator = ( const volatile tuple & ) = delete;

    template < class _Myself = tuple, class _This2 = _This,
        enable_if_t < conjunction_v < :: std :: _Is_copy_assignable_no_precondition_check < _This2 >,
                        :: std :: _Is_copy_assignable_no_precondition_check < _Rest > ... >,
            int > = 0 >
    inline tuple & operator = ( _Identity_t < const _Myself & > _Right ) noexcept (
        conjunction_v < is_nothrow_copy_assignable < _This2 >, is_nothrow_copy_assignable < _Rest > ... > ) {
        _Myfirst . _Val = _Right . _Myfirst . _Val;
        _Get_rest ( ) = _Right . _Get_rest ( );
        return * this;
    }

    template < class _Myself = tuple, class _This2 = _This,
        enable_if_t < conjunction_v < :: std :: _Is_move_assignable_no_precondition_check < _This2 >,
                        :: std :: _Is_move_assignable_no_precondition_check < _Rest > ... >,
            int > = 0 >
    inline tuple & operator = ( _Identity_t < _Myself && > _Right ) noexcept (
        conjunction_v < is_nothrow_move_assignable < _This2 >, is_nothrow_move_assignable < _Rest > ... > ) {
        _Myfirst . _Val = :: std :: forward < _This > ( _Right . _Myfirst . _Val );
        _Get_rest ( ) = :: std :: forward < _Mybase > ( _Right . _Get_rest ( ) );
        return * this;
    }

    template < class ... _Other, enable_if_t < conjunction_v < :: std :: negation < :: std :: is_same < tuple, :: std :: tuple < _Other ... >> >,
                                               :: std :: _Tuple_assignable_val < tuple, const _Other & ... >>,
                                   int > = 0 >
    inline tuple & operator = ( const tuple < _Other ... > & _Right ) noexcept (
        _Tuple_nothrow_assignable_v < tuple, const _Other & ... > ) {
        _Myfirst . _Val = _Right . _Myfirst . _Val;
        _Get_rest ( ) = _Right . _Get_rest ( );
        return * this;
    }

    template < class ... _Other, enable_if_t < conjunction_v < :: std :: negation < :: std :: is_same < tuple, :: std :: tuple < _Other ... >> >,
                                               :: std :: _Tuple_assignable_val < tuple, _Other ... >>,
                                   int > = 0 >
    inline tuple & operator = ( tuple < _Other ... > && _Right ) noexcept (
        _Tuple_nothrow_assignable_v < tuple, _Other ... > ) {
        _Myfirst . _Val = :: std :: forward < typename tuple < _Other ... > :: _This_type > ( _Right . _Myfirst . _Val );
        _Get_rest ( ) = :: std :: forward < typename tuple < _Other ... > :: _Mybase > ( _Right . _Get_rest ( ) );
        return * this;
    }

    template < class _First, class _Second,
        enable_if_t < _Tuple_assignable_v < tuple, const _First &, const _Second & >, int > = 0 >
    inline tuple & operator = ( const pair < _First, _Second > & _Right ) noexcept (
        _Tuple_nothrow_assignable_v < tuple, const _First &, const _Second & > ) {
        _Myfirst . _Val = _Right . first;
        _Get_rest ( ) . _Myfirst . _Val = _Right . second;
        return * this;
    }

    template < class _First, class _Second, enable_if_t < _Tuple_assignable_v < tuple, _First, _Second >, int > = 0 >
    inline tuple & operator = ( pair < _First, _Second > && _Right ) noexcept (
        _Tuple_nothrow_assignable_v < tuple, _First, _Second > ) {
        _Myfirst . _Val = :: std :: forward < _First > ( _Right . first );
        _Get_rest ( ) . _Myfirst . _Val = :: std :: forward < _Second > ( _Right . second );
        return * this;
    }

    inline void swap ( tuple & _Right ) noexcept (
        conjunction_v < _Is_nothrow_swappable < _This >, _Is_nothrow_swappable < _Rest > ... > ) {
        _Swap_adl ( _Myfirst . _Val, _Right . _Myfirst . _Val );
        _Mybase :: swap ( _Right . _Get_rest ( ) );
    }

    constexpr _Mybase & _Get_rest ( ) noexcept {
        return * this;
    }

    constexpr const _Mybase & _Get_rest ( ) const noexcept {
        return * this;
    }

    template < class ... _Other >
    constexpr bool _Equals ( const tuple < _Other ... > & _Right ) const {
        return _Myfirst . _Val == _Right . _Myfirst . _Val && _Mybase :: _Equals ( _Right . _Get_rest ( ) );
    }












    template < class ... _Other >
    [ [ nodiscard ] ] constexpr bool _Less ( const tuple < _Other ... > & _Right ) const {
        return _Myfirst . _Val < _Right . _Myfirst . _Val
            || ( ! ( _Right . _Myfirst . _Val < _Myfirst . _Val ) && _Mybase :: _Less ( _Right . _Get_rest ( ) ) );
    }


    template < size_t _Index, class ... _Types >
    friend constexpr tuple_element_t < _Index, tuple < _Types ... >> & get ( tuple < _Types ... > & _Tuple ) noexcept;

    template < size_t _Index, class ... _Types >
    friend constexpr const tuple_element_t < _Index, tuple < _Types ... >> & get ( const tuple < _Types ... > & _Tuple ) noexcept;

    template < size_t _Index, class ... _Types >
    friend constexpr tuple_element_t < _Index, tuple < _Types ... >> && get ( tuple < _Types ... > && _Tuple ) noexcept;

    template < size_t _Index, class ... _Types >
    friend constexpr const tuple_element_t < _Index, tuple < _Types ... >> && get ( const tuple < _Types ... > && _Tuple ) noexcept;

    template < size_t _Index, class ... _Types >
    friend constexpr auto && _Tuple_get ( tuple < _Types ... > && _Tuple ) noexcept;

    template < class _Ty, class ... _Types >
    friend constexpr _Ty & get ( tuple < _Types ... > & _Tuple ) noexcept;

    template < class _Ty, class ... _Types >
    friend constexpr const _Ty & get ( const tuple < _Types ... > & _Tuple ) noexcept;

    template < class _Ty, class ... _Types >
    friend constexpr _Ty && get ( tuple < _Types ... > && _Tuple ) noexcept;

    template < class _Ty, class ... _Types >
    friend constexpr const _Ty && get ( const tuple < _Types ... > && _Tuple ) noexcept;

    _Tuple_val < _This > _Myfirst;
};
#line 737 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
template < class ... _Types1, class ... _Types2 >
[ [ nodiscard ] ] constexpr bool operator == ( const tuple < _Types1 ... > & _Left, const tuple < _Types2 ... > & _Right ) {
    static_assert ( sizeof ... ( _Types1 ) == sizeof ... ( _Types2 ), "cannot compare tuples of different sizes" );
    return _Left . _Equals ( _Right );
}
#line 752
template < class ... _Types1, class ... _Types2 >
[ [ nodiscard ] ] constexpr bool operator != ( const tuple < _Types1 ... > & _Left, const tuple < _Types2 ... > & _Right ) {
    return ! ( _Left == _Right );
}
#line 758 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
template < class ... _Types1, class ... _Types2 >
[ [ nodiscard ] ] constexpr bool operator < ( const tuple < _Types1 ... > & _Left, const tuple < _Types2 ... > & _Right ) {
    static_assert ( sizeof ... ( _Types1 ) == sizeof ... ( _Types2 ), "cannot compare tuples of different sizes" );
    return _Left . _Less ( _Right );
}
#line 764
template < class ... _Types1, class ... _Types2 >
[ [ nodiscard ] ] constexpr bool operator >= ( const tuple < _Types1 ... > & _Left, const tuple < _Types2 ... > & _Right ) {
    return ! ( _Left < _Right );
}
#line 769
template < class ... _Types1, class ... _Types2 >
[ [ nodiscard ] ] constexpr bool operator > ( const tuple < _Types1 ... > & _Left, const tuple < _Types2 ... > & _Right ) {
    return _Right < _Left;
}
#line 774
template < class ... _Types1, class ... _Types2 >
[ [ nodiscard ] ] constexpr bool operator <= ( const tuple < _Types1 ... > & _Left, const tuple < _Types2 ... > & _Right ) {
    return ! ( _Right < _Left );
}
#line 780 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
template < class ... _Types, enable_if_t < conjunction_v < :: std :: _Is_swappable < _Types > ... >, int > = 0 >
inline void swap ( tuple < _Types ... > & _Left, tuple < _Types ... > & _Right ) noexcept ( noexcept ( _Left . swap ( _Right ) ) ) {
    return _Left . swap ( _Right );
}
#line 785
template< class _Ty, class _Tuple> 
#line 786
struct _Tuple_element { }; 
#line 788
template< class _This, class ..._Rest> 
#line 789
struct _Tuple_element< _This, tuple< _This, _Rest...> >  { 
#line 790
static_assert((!_Is_any_of_v< _This, _Rest...> ), "duplicate type T in get<T>(tuple)");
#line 791
using _Ttype = tuple< _This, _Rest...> ; 
#line 792
}; 
#line 794
template< class _Ty, class _This, class ..._Rest> 
#line 795
struct _Tuple_element< _Ty, tuple< _This, _Rest...> >  { 
#line 796
using _Ttype = typename std::_Tuple_element< _Ty, tuple< _Rest...> > ::_Ttype; 
#line 797
}; 
#line 799
template < size_t _Index, class ... _Types >
[ [ nodiscard ] ] constexpr tuple_element_t < _Index, tuple < _Types ... > > & get ( tuple < _Types ... > & _Tuple ) noexcept {
    using _Ttype = typename tuple_element < _Index, tuple < _Types ... >> :: _Ttype;
    return static_cast < _Ttype & > ( _Tuple ) . _Myfirst . _Val;
}
#line 805
template < size_t _Index, class ... _Types >
[ [ nodiscard ] ] constexpr const tuple_element_t < _Index, tuple < _Types ... > > & get ( const tuple < _Types ... > & _Tuple ) noexcept {
    using _Ttype = typename tuple_element < _Index, tuple < _Types ... >> :: _Ttype;
    return static_cast < const _Ttype & > ( _Tuple ) . _Myfirst . _Val;
}
#line 811
template < size_t _Index, class ... _Types >
[ [ nodiscard ] ] constexpr tuple_element_t < _Index, tuple < _Types ... > > && get ( tuple < _Types ... > && _Tuple ) noexcept {
    using _Ty = tuple_element_t < _Index, tuple < _Types ... >>;
    using _Ttype = typename tuple_element < _Index, tuple < _Types ... >> :: _Ttype;
    return static_cast < _Ty && > ( static_cast < _Ttype & > ( _Tuple ) . _Myfirst . _Val );
}
#line 818
template < size_t _Index, class ... _Types >
[ [ nodiscard ] ] constexpr const tuple_element_t < _Index, tuple < _Types ... > > && get ( const tuple < _Types ... > && _Tuple ) noexcept {
    using _Ty = tuple_element_t < _Index, tuple < _Types ... >>;
    using _Ttype = typename tuple_element < _Index, tuple < _Types ... >> :: _Ttype;
    return static_cast < const _Ty && > ( static_cast < const _Ttype & > ( _Tuple ) . _Myfirst . _Val );
}
#line 825
template < size_t _Index, class ... _Types >
[ [ nodiscard ] ] constexpr auto && _Tuple_get ( tuple < _Types ... > && _Tuple ) noexcept {

    using _Ty = tuple_element_t < _Index, tuple < _Types ... >>;
    using _Ttype = typename tuple_element < _Index, tuple < _Types ... >> :: _Ttype;
    return static_cast < _Ty && > ( static_cast < _Ttype & > ( _Tuple ) . _Myfirst . _Val );
}
#line 833
template < class _Ty, class ... _Types >
[ [ nodiscard ] ] constexpr _Ty & get ( tuple < _Types ... > & _Tuple ) noexcept {
    using _Ttype = typename _Tuple_element < _Ty, tuple < _Types ... >> :: _Ttype;
    return static_cast < _Ttype & > ( _Tuple ) . _Myfirst . _Val;
}
#line 839
template < class _Ty, class ... _Types >
[ [ nodiscard ] ] constexpr const _Ty & get ( const tuple < _Types ... > & _Tuple ) noexcept {
    using _Ttype = typename _Tuple_element < _Ty, tuple < _Types ... >> :: _Ttype;
    return static_cast < const _Ttype & > ( _Tuple ) . _Myfirst . _Val;
}
#line 845
template < class _Ty, class ... _Types >
[ [ nodiscard ] ] constexpr _Ty && get ( tuple < _Types ... > && _Tuple ) noexcept {
    using _Ttype = typename _Tuple_element < _Ty, tuple < _Types ... >> :: _Ttype;
    return static_cast < _Ty && > ( static_cast < _Ttype & > ( _Tuple ) . _Myfirst . _Val );
}
#line 851
template < class _Ty, class ... _Types >
[ [ nodiscard ] ] constexpr const _Ty && get ( const tuple < _Types ... > && _Tuple ) noexcept {
    using _Ttype = typename _Tuple_element < _Ty, tuple < _Types ... >> :: _Ttype;
    return static_cast < const _Ty && > ( static_cast < const _Ttype & > ( _Tuple ) . _Myfirst . _Val );
}
#line 857
template < class _This, class ... _Rest >
template < class _Tag, class _Tpl, size_t ... _Indices, enable_if_t < is_same_v < _Tag, :: std :: _Unpack_tuple_t >, int > >
constexpr tuple < _This, _Rest ... > :: tuple ( _Tag, _Tpl && _Right, index_sequence < _Indices ... > )
    : tuple ( _Exact_args_t { }, :: std :: get < _Indices > ( :: std :: forward < _Tpl > ( _Right ) ) ... ) { }
#line 862
template < class _This, class ... _Rest >
template < class _Tag, class _Alloc, class _Tpl, size_t ... _Indices,
    enable_if_t < is_same_v < _Tag, :: std :: _Alloc_unpack_tuple_t >, int > >
constexpr tuple < _This, _Rest ... > :: tuple ( _Tag, const _Alloc & _Al, _Tpl && _Right, index_sequence < _Indices ... > )
    : tuple ( _Alloc_exact_args_t { }, _Al, :: std :: get < _Indices > ( :: std :: forward < _Tpl > ( _Right ) ) ... ) { }
#line 868
template < class ... _Types >
[ [ nodiscard ] ] constexpr tuple < _Unrefwrap_t < _Types > ... > make_tuple ( _Types && ... _Args ) {
    using _Ttype = tuple < _Unrefwrap_t < _Types > ... >;
    return _Ttype ( :: std :: forward < _Types > ( _Args ) ... );
}
#line 874
template < class ... _Types >
[ [ nodiscard ] ] constexpr tuple < _Types & ... > tie ( _Types & ... _Args ) noexcept {
    using _Ttype = tuple < _Types & ... >;
    return _Ttype ( _Args ... );
}
#line 880
template < class ... _Types >
[ [ nodiscard ] ] constexpr tuple < _Types && ... > forward_as_tuple ( _Types && ... _Args ) noexcept {
    return tuple < _Types && ... > ( :: std :: forward < _Types > ( _Args ) ... );
}
#line 885
template< class _Seq_type1, class _Seq_type2> struct _Cat_sequences; 
#line 888
template< size_t ..._Indexes1, size_t ..._Indexes2> 
#line 889
struct _Cat_sequences< index_sequence< _Indexes1...> , index_sequence< _Indexes2...> >  { 
#line 891
using type = index_sequence< _Indexes1..., _Indexes2...> ; 
#line 892
}; 
#line 894
template< class _Ty, size_t _Size> class array; 
#line 897
template< size_t _Idx, class _Ty, size_t _Size> 
#line 898
[[nodiscard]] constexpr _Ty &
#line 897
get(array< _Ty, _Size>  & _Arr) noexcept; 
#line 900
template< size_t _Idx, class _Ty, size_t _Size> 
#line 901
[[nodiscard]] constexpr const _Ty &
#line 900
get(const array< _Ty, _Size>  & _Arr) noexcept; 
#line 903
template< size_t _Idx, class _Ty, size_t _Size> 
#line 904
[[nodiscard]] constexpr _Ty &&
#line 903
get(array< _Ty, _Size>  && _Arr) noexcept; 
#line 906
template< size_t _Idx, class _Ty, size_t _Size> 
#line 907
[[nodiscard]] constexpr const _Ty &&
#line 906
get(const array< _Ty, _Size>  && _Arr) noexcept; 
#line 909
template< class _Ty, class ..._For_array> 
#line 910
struct _View_as_tuple { 
#line 911
static_assert((_Always_false< _Ty> ), "Unsupported tuple_cat arguments.");
#line 912
}; 
#line 914
template< class ..._Types> 
#line 915
struct _View_as_tuple< tuple< _Types...> >  { 
#line 916
using type = tuple< _Types...> ; 
#line 917
}; 
#line 919
template< class _Ty1, class _Ty2> 
#line 920
struct _View_as_tuple< pair< _Ty1, _Ty2> >  { 
#line 921
using type = tuple< _Ty1, _Ty2> ; 
#line 922
}; 
#line 924
template< class _Ty, class ..._Types> 
#line 925
struct _View_as_tuple< array< _Ty, 0> , _Types...>  { 
#line 926
using type = tuple< _Types...> ; 
#line 927
}; 
#line 929
template< class _Ty, size_t _Size, class ..._Types> 
#line 930
struct _View_as_tuple< array< _Ty, _Size> , _Types...>  : public std::_View_as_tuple< array< _Ty, _Size - (1)> , _Ty, _Types...>  { 
#line 932
}; 
#line 934
template< size_t _Nx, class _Ty> 
#line 935
struct _Repeat_for : public integral_constant< unsigned __int64, _Nx>  { }; 
#line 937
template< class _Ret, class _Kx_arg, class _Ix_arg, size_t _Ix_next, class ..._Tuples> 
#line 938
struct _Tuple_cat2 { 
#line 939
static_assert((sizeof...(_Tuples) == (0)), "Unsupported tuple_cat arguments.");
#line 940
using type = _Ret; 
#line 941
using _Kx_arg_seq = _Kx_arg; 
#line 942
using _Ix_arg_seq = _Ix_arg; 
#line 943
}; 
#line 945
template< class ..._Types1, class _Kx_arg, size_t ..._Ix, size_t _Ix_next, class ..._Types2, class ..._Rest> 
#line 946
struct _Tuple_cat2< tuple< _Types1...> , _Kx_arg, index_sequence< _Ix...> , _Ix_next, tuple< _Types2...> , _Rest...>  : public std::_Tuple_cat2< tuple< _Types1..., _Types2...> , typename _Cat_sequences< _Kx_arg, index_sequence_for< _Types2...> > ::type, index_sequence< _Ix..., (_Repeat_for< _Ix_next, _Types2> ::value)...> , _Ix_next + (1), _Rest...>  { 
#line 950
}; 
#line 952
template< class ..._Tuples> 
#line 953
struct _Tuple_cat1 : public _Tuple_cat2< tuple< > , integer_sequence< unsigned __int64> , integer_sequence< unsigned __int64> , 0Ui64, typename _View_as_tuple< decay_t< _Tuples> > ::type...>  { 
#line 956
}; 
#line 958
template < class _Ret, size_t ... _Kx, size_t ... _Ix, class _Ty >
constexpr _Ret _Tuple_cat ( index_sequence < _Kx ... >, index_sequence < _Ix ... >, _Ty && _Arg ) {
    return _Ret ( :: std :: get < _Kx > ( :: std :: get < _Ix > ( :: std :: forward < _Ty > ( _Arg ) ) ) ... );
}
#line 963
template < class ... _Tuples >
[ [ nodiscard ] ] constexpr typename _Tuple_cat1 < _Tuples ... > :: type tuple_cat ( _Tuples && ... _Tpls ) {
    using _Cat1 = _Tuple_cat1 < _Tuples ... >;
    return _Tuple_cat < typename _Cat1 :: type > ( typename _Cat1 :: _Kx_arg_seq ( ), typename _Cat1 :: _Ix_arg_seq ( ),
        :: std :: forward_as_tuple ( :: std :: forward < _Tuples > ( _Tpls ) ... ) );
}
#line 996 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
template< class ..._Types, class _Alloc> 
#line 997
struct uses_allocator< tuple< _Types...> , _Alloc>  : public true_type { }; 
#line 1000
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 1001
using std::get;
#line 1002
using std::ignore;
#line 1003
using std::make_tuple;
#line 1004
using std::ref;
#line 1005
using std::tie;
#line 1006
using std::tuple;
#line 1007
}
#line 1010 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
}
#line 1014
#pragma warning(pop)
#pragma pack ( pop )
#line 1018 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 32
namespace std { 
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
class thread { 
#line 39
public: class id; 
#line 41
using native_handle_type = void *; 
#line 43
thread() noexcept : _Thr{} { } 
#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
private: template < class _Tuple, size_t ... _Indices >
    static unsigned int __stdcall _Invoke ( void * _RawVals ) noexcept {

        const unique_ptr < _Tuple > _FnVals ( static_cast < _Tuple * > ( _RawVals ) );
        _Tuple & _Tup = * _FnVals;
        :: std :: invoke ( :: std :: move ( :: std :: get < _Indices > ( _Tup ) ) ... );
        _Cnd_do_broadcast_at_thread_exit ( );
        return 0;
    }
#line 60
template < class _Tuple, size_t ... _Indices >
    [ [ nodiscard ] ] static constexpr auto _Get_invoke ( index_sequence < _Indices ... > ) noexcept {
        return & _Invoke < _Tuple, _Indices ... >;
    }
#line 65
template < class _Fn, class ... _Args >
    void _Start ( _Fn && _Fx, _Args && ... _Ax ) {
        using _Tuple = tuple < decay_t < _Fn >, decay_t < _Args > ... >;
        auto _Decay_copied = :: std :: make_unique < _Tuple > ( :: std :: forward < _Fn > ( _Fx ), :: std :: forward < _Args > ( _Ax ) ... );
        constexpr auto _Invoker_proc = _Get_invoke < _Tuple > ( make_index_sequence < 1 + sizeof ... ( _Args ) > { } );

#pragma warning(push)
#pragma warning(disable : 5039)


        _Thr . _Hnd =
            reinterpret_cast < void * > ( :: _beginthreadex ( nullptr, 0, _Invoker_proc, _Decay_copied . get ( ), 0, & _Thr . _Id ) );
#pragma warning(pop)

        if ( _Thr . _Hnd ) {
            ( void ) _Decay_copied . release ( );
        } else {
            _Thr . _Id = 0;
            _Throw_Cpp_error ( _RESOURCE_UNAVAILABLE_TRY_AGAIN );
        }
    }
#line 88
public: template < class _Fn, class ... _Args, enable_if_t < ! is_same_v < _Remove_cvref_t < _Fn >, thread >, int > = 0 >
    [ [ nodiscard ] ] explicit thread ( _Fn && _Fx, _Args && ... _Ax ) {
        _Start ( :: std :: forward < _Fn > ( _Fx ), :: std :: forward < _Args > ( _Ax ) ... );
    }
#line 93
~thread() noexcept { 
#line 94
if (this->joinable()) { 
#line 95
::std::terminate(); 
#line 96
}  
#line 97
} 
#line 99
thread(thread &&_Other) noexcept : _Thr(::std::exchange(_Other._Thr, {})) { } 
#line 101
thread &operator=(thread &&_Other) noexcept { 
#line 102
if (this->joinable()) { 
#line 103
::std::terminate(); 
#line 104
}  
#line 106
(_Thr) = ::std::exchange(_Other._Thr, {}); 
#line 107
return *this; 
#line 108
} 
#line 110
thread(const thread &) = delete;
#line 111
thread &operator=(const thread &) = delete;
#line 113
void swap(thread &_Other) noexcept { 
#line 114
::std::swap(_Thr, _Other._Thr); 
#line 115
} 
#line 117
[[nodiscard]] bool joinable() const noexcept { 
#line 118
return ((_Thr)._Id) != (0); 
#line 119
} 
#line 121
void join() { 
#line 122
if (!this->joinable()) { 
#line 123
_Throw_Cpp_error(_INVALID_ARGUMENT); 
#line 124
}  
#line 126
if (((_Thr)._Id) == _Thrd_id()) { 
#line 127
_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR); 
#line 128
}  
#line 130
if (_Thrd_join(_Thr, nullptr) != (_Thrd_success)) { 
#line 131
_Throw_Cpp_error(_NO_SUCH_PROCESS); 
#line 132
}  
#line 134
(_Thr) = {}; 
#line 135
} 
#line 137
void detach() { 
#line 138
if (!this->joinable()) { 
#line 139
_Throw_Cpp_error(_INVALID_ARGUMENT); 
#line 140
}  
#line 142
_Check_C_return(_Thrd_detach(_Thr)); 
#line 143
(_Thr) = {}; 
#line 144
} 
#line 146
[[nodiscard]] inline id get_id() const noexcept; 
#line 148
[[nodiscard]] static unsigned hardware_concurrency() noexcept { 
#line 149
return _Thrd_hardware_concurrency(); 
#line 150
} 
#line 152
[[nodiscard]] native_handle_type native_handle() { 
#line 153
return (_Thr)._Hnd; 
#line 154
} 
#line 157
private: _Thrd_t _Thr; 
#line 158
}; 
#line 160
template < class _Rep, class _Period >
[ [ nodiscard ] ] auto _To_absolute_time ( const chrono :: duration < _Rep, _Period > & _Rel_time ) noexcept {
    constexpr auto _Zero = chrono :: duration < _Rep, _Period > :: zero ( );
    const auto _Now = chrono :: steady_clock :: now ( );
    decltype ( _Now + _Rel_time ) _Abs_time = _Now;
    if ( _Rel_time > _Zero ) {
        constexpr auto _Forever = ( chrono :: steady_clock :: time_point :: max ) ( );
        if ( _Abs_time < _Forever - _Rel_time ) {
            _Abs_time += _Rel_time;
        } else {
            _Abs_time = _Forever;
        }
    }
    return _Abs_time;
}
#line 176
namespace this_thread { 
#line 177
[[nodiscard]] inline thread::id get_id() noexcept; 
#line 179
inline void yield() noexcept { 
#line 180
_Thrd_yield(); 
#line 181
} 
#line 183
inline void sleep_until(const xtime *_Abs_time) { 
#line 184
_Thrd_sleep(_Abs_time); 
#line 185
} 
#line 187
template < class _Clock, class _Duration >
    void sleep_until ( const chrono :: time_point < _Clock, _Duration > & _Abs_time ) {



        for (;; ) {
            const auto _Now = _Clock :: now ( );
            if ( _Abs_time <= _Now ) {
                return;
            }

            :: xtime _Tgt;
            ( void ) _To_xtime_10_day_clamped ( _Tgt, _Abs_time - _Now );
            _Thrd_sleep ( & _Tgt );
        }
    }
#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
template < class _Rep, class _Period >
    void sleep_for ( const chrono :: duration < _Rep, _Period > & _Rel_time ) {
        sleep_until ( _To_absolute_time ( _Rel_time ) );
    }
#line 208
}
#line 210
class thread::id { 
#line 212
public: id() noexcept : _Id((0)) { } 
#line 215
private: id(_Thrd_id_t _Other_id) : _Id(_Other_id) { } 
#line 217
_Thrd_id_t _Id; 
#line 219
friend id thread::get_id() const noexcept; 
#line 220
friend inline id this_thread::get_id() noexcept; 
#line 221
friend inline bool operator==(id _Left, id _Right) noexcept; 
#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
friend inline bool operator<(id _Left, id _Right) noexcept; 
#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
template < class _Ch, class _Tr >
    friend basic_ostream < _Ch, _Tr > & operator << ( basic_ostream < _Ch, _Tr > & _Str, thread :: id _Id );
#line 229
friend struct hash< id> ; 
#line 230
}; 
#line 232
[[nodiscard]] inline thread::id thread::get_id() const noexcept { 
#line 233
return (_Thr)._Id; 
#line 234
} 
#line 236
[[nodiscard]] inline thread::id this_thread::get_id() noexcept { 
#line 237
return _Thrd_id(); 
#line 238
} 
#line 240
inline void swap(thread &_Left, thread &_Right) noexcept { 
#line 241
_Left.swap(_Right); 
#line 242
} 
#line 244
[[nodiscard]] inline bool operator==(thread::id _Left, thread::id _Right) noexcept { 
#line 245
return (_Left._Id) == (_Right._Id); 
#line 246
} 
#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
[[nodiscard]] inline bool operator!=(thread::id _Left, thread::id _Right) noexcept { 
#line 254
return !(_Left == _Right); 
#line 255
} 
#line 257
[[nodiscard]] inline bool operator<(thread::id _Left, thread::id _Right) noexcept { 
#line 258
return (_Left._Id) < (_Right._Id); 
#line 259
} 
#line 261
[[nodiscard]] inline bool operator<=(thread::id _Left, thread::id _Right) noexcept { 
#line 262
return !(_Right < _Left); 
#line 263
} 
#line 265
[[nodiscard]] inline bool operator>(thread::id _Left, thread::id _Right) noexcept { 
#line 266
return (_Right < _Left); 
#line 267
} 
#line 269
[[nodiscard]] inline bool operator>=(thread::id _Left, thread::id _Right) noexcept { 
#line 270
return !(_Left < _Right); 
#line 271
} 
#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
template < class _Ch, class _Tr >
basic_ostream < _Ch, _Tr > & operator << ( basic_ostream < _Ch, _Tr > & _Str, thread :: id _Id ) {
    return _Str << _Id . _Id;
}
#line 280
#pragma pack(8)
template<> 
#line 280
struct hash< thread::id>  { 
#line 281
typedef thread::id argument_type; 
#line 282
typedef size_t result_type; 
#line 284
[[nodiscard]] size_t operator()(const thread::id _Keyval) const noexcept { 
#line 285
return _Hash_representation(_Keyval._Id); 
#line 286
} 
#line 287
}; 
#pragma pack()
#line 378 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
}
#line 382
#pragma warning(pop)
#pragma pack ( pop )
#line 386 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
#pragma external_header(pop)
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 30
namespace std { 
#line 33
class condition_variable; 
#line 34
class condition_variable_any; 
#line 36
class _Mutex_base { 
#line 38
public: _Mutex_base(int _Flags = 0) noexcept { 
#line 39
_Mtx_init_in_situ(this->_Mymtx(), _Flags | (_Mtx_try)); 
#line 40
} 
#line 42
~_Mutex_base() noexcept { 
#line 43
_Mtx_destroy_in_situ(this->_Mymtx()); 
#line 44
} 
#line 46
_Mutex_base(const _Mutex_base &) = delete;
#line 47
_Mutex_base &operator=(const _Mutex_base &) = delete;
#line 49
void lock() { 
#line 50
_Check_C_return(_Mtx_lock(this->_Mymtx())); 
#line 51
} 
#line 53
[[nodiscard]] bool try_lock() { 
#line 54
const auto _Res = _Mtx_trylock(this->_Mymtx()); 
#line 55
switch (_Res) { 
#line 56
case _Thrd_success:  
#line 57
return true; 
#line 58
case _Thrd_busy:  
#line 59
return false; 
#line 60
default:  
#line 61
_Throw_C_error(_Res); 
#line 62
}  
#line 63
} 
#line 65
void unlock() { 
#line 66
_Mtx_unlock(this->_Mymtx()); 
#line 67
} 
#line 69
using native_handle_type = void *; 
#line 71
[[nodiscard]] native_handle_type native_handle() { 
#line 72
return _Mtx_getconcrtcs(this->_Mymtx()); 
#line 73
} 
#line 76
friend class condition_variable; 
#line 77
friend class condition_variable_any; 
#line 79
private: aligned_storage_t< 80Ui64, 8Ui64>  _Mtx_storage; 
#line 81
_Mtx_t _Mymtx() noexcept { 
#line 82
return reinterpret_cast< _Mtx_t>(&(_Mtx_storage)); 
#line 83
} 
#line 84
}; 
#line 86
class mutex : public _Mutex_base { 
#line 88
public: mutex() noexcept : _Mutex_base() 
#line 89
{ } 
#line 91
mutex(const mutex &) = delete;
#line 92
mutex &operator=(const mutex &) = delete;
#line 93
}; 
#line 95
class recursive_mutex : public _Mutex_base { 
#line 97
public: recursive_mutex() : _Mutex_base(_Mtx_recursive) { } 
#line 99
[[nodiscard]] bool try_lock() noexcept { 
#line 100
return this->_Mutex_base::try_lock(); 
#line 101
} 
#line 103
recursive_mutex(const recursive_mutex &) = delete;
#line 104
recursive_mutex &operator=(const recursive_mutex &) = delete;
#line 105
}; 
#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
struct adopt_lock_t { 
#line 109
explicit adopt_lock_t() = default;
#line 110
}; 
#line 112
struct defer_lock_t { 
#line 113
explicit defer_lock_t() = default;
#line 114
}; 
#line 116
struct try_to_lock_t { 
#line 117
explicit try_to_lock_t() = default;
#line 118
}; 
#line 120
constexpr adopt_lock_t adopt_lock{}; 
#line 121
constexpr defer_lock_t defer_lock{}; 
#line 122
constexpr try_to_lock_t try_to_lock{}; 
#line 124
template < class _Mutex >
class unique_lock {
public :
    using mutex_type = _Mutex;

    unique_lock ( ) noexcept : _Pmtx ( nullptr ), _Owns ( false ) { }

    [ [ nodiscard ] ] explicit unique_lock ( _Mutex & _Mtx )
        : _Pmtx ( :: std :: addressof ( _Mtx ) ), _Owns ( false ) {
        _Pmtx -> lock ( );
        _Owns = true;
    }

    [ [ nodiscard ] ] unique_lock ( _Mutex & _Mtx, adopt_lock_t )
        : _Pmtx ( :: std :: addressof ( _Mtx ) ), _Owns ( true ) { }

    unique_lock ( _Mutex & _Mtx, defer_lock_t ) noexcept
        : _Pmtx ( :: std :: addressof ( _Mtx ) ), _Owns ( false ) { }

    [ [ nodiscard ] ] unique_lock ( _Mutex & _Mtx, try_to_lock_t )
        : _Pmtx ( :: std :: addressof ( _Mtx ) ), _Owns ( _Pmtx -> try_lock ( ) ) { }

    template < class _Rep, class _Period >
    [ [ nodiscard ] ] unique_lock ( _Mutex & _Mtx, const chrono :: duration < _Rep, _Period > & _Rel_time )
        : _Pmtx ( :: std :: addressof ( _Mtx ) ), _Owns ( _Pmtx -> try_lock_for ( _Rel_time ) ) { }

    template < class _Clock, class _Duration >
    [ [ nodiscard ] ] unique_lock ( _Mutex & _Mtx, const chrono :: time_point < _Clock, _Duration > & _Abs_time )
        : _Pmtx ( :: std :: addressof ( _Mtx ) ), _Owns ( _Pmtx -> try_lock_until ( _Abs_time ) ) {




    }

    [ [ nodiscard ] ] unique_lock ( _Mutex & _Mtx, const xtime * _Abs_time )
        : _Pmtx ( :: std :: addressof ( _Mtx ) ), _Owns ( false ) {
        _Owns = _Pmtx -> try_lock_until ( _Abs_time );
    }

    [ [ nodiscard ] ] unique_lock ( unique_lock && _Other ) noexcept : _Pmtx ( _Other . _Pmtx ), _Owns ( _Other . _Owns ) {
        _Other . _Pmtx = nullptr;
        _Other . _Owns = false;
    }

    unique_lock & operator = ( unique_lock && _Other ) {
        if ( this != :: std :: addressof ( _Other ) ) {
            if ( _Owns ) {
                _Pmtx -> unlock ( );
            }

            _Pmtx = _Other . _Pmtx;
            _Owns = _Other . _Owns;
            _Other . _Pmtx = nullptr;
            _Other . _Owns = false;
        }
        return * this;
    }

    ~ unique_lock ( ) noexcept {
        if ( _Owns ) {
            _Pmtx -> unlock ( );
        }
    }

    unique_lock ( const unique_lock & ) = delete;
    unique_lock & operator = ( const unique_lock & ) = delete;

    void lock ( ) {
        _Validate ( );
        _Pmtx -> lock ( );
        _Owns = true;
    }

    [ [ nodiscard ] ] bool try_lock ( ) {
        _Validate ( );
        _Owns = _Pmtx -> try_lock ( );
        return _Owns;
    }

    template < class _Rep, class _Period >
    [ [ nodiscard ] ] bool try_lock_for ( const chrono :: duration < _Rep, _Period > & _Rel_time ) {
        _Validate ( );
        _Owns = _Pmtx -> try_lock_for ( _Rel_time );
        return _Owns;
    }

    template < class _Clock, class _Duration >
    [ [ nodiscard ] ] bool try_lock_until ( const chrono :: time_point < _Clock, _Duration > & _Abs_time ) {



        _Validate ( );
        _Owns = _Pmtx -> try_lock_until ( _Abs_time );
        return _Owns;
    }

    [ [ nodiscard ] ] bool try_lock_until ( const xtime * _Abs_time ) {
        _Validate ( );
        _Owns = _Pmtx -> try_lock_until ( _Abs_time );
        return _Owns;
    }

    void unlock ( ) {
        if ( ! _Pmtx || ! _Owns ) {
            _Throw_system_error ( errc :: operation_not_permitted );
        }

        _Pmtx -> unlock ( );
        _Owns = false;
    }

    void swap ( unique_lock & _Other ) noexcept {
        :: std :: swap ( _Pmtx, _Other . _Pmtx );
        :: std :: swap ( _Owns, _Other . _Owns );
    }

    _Mutex * release ( ) noexcept {
        _Mutex * _Res = _Pmtx;
        _Pmtx = nullptr;
        _Owns = false;
        return _Res;
    }

    [ [ nodiscard ] ] bool owns_lock ( ) const noexcept {
        return _Owns;
    }

    explicit operator bool ( ) const noexcept {
        return _Owns;
    }

    [ [ nodiscard ] ] _Mutex * mutex ( ) const noexcept {
        return _Pmtx;
    }

private :
    _Mutex * _Pmtx;
    bool _Owns;

    void _Validate ( ) const {
        if ( ! _Pmtx ) {
            _Throw_system_error ( errc :: operation_not_permitted );
        }

        if ( _Owns ) {
            _Throw_system_error ( errc :: resource_deadlock_would_occur );
        }
    }
};
#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
template < class _Mutex >
void swap ( unique_lock < _Mutex > & _Left, unique_lock < _Mutex > & _Right ) noexcept {
    _Left . swap ( _Right );
}
#line 280
template < size_t ... _Indices, class ... _LockN >
void _Lock_from_locks ( const int _Target, index_sequence < _Indices ... >, _LockN & ... _LkN ) {
    int _Ignored [ ] = { ( ( static_cast < int > ( _Indices ) == _Target ? ( void ) _LkN . lock ( ) : void ( ) ), 0 ) ... };
    ( void ) _Ignored;
}
#line 286
template < size_t ... _Indices, class ... _LockN >
bool _Try_lock_from_locks (
    const int _Target, index_sequence < _Indices ... >, _LockN & ... _LkN ) {
    bool _Result { };
    int _Ignored [ ] = { ( ( static_cast < int > ( _Indices ) == _Target ? ( void ) ( _Result = _LkN . try_lock ( ) ) : void ( ) ), 0 ) ... };
    ( void ) _Ignored;
    return _Result;
}
#line 295
template < size_t ... _Indices, class ... _LockN >
void _Unlock_locks ( const int _First, const int _Last, index_sequence < _Indices ... >, _LockN & ... _LkN ) noexcept
 {

    int _Ignored [ ] = {
        ( ( _First <= static_cast < int > ( _Indices ) && static_cast < int > ( _Indices ) < _Last ? ( void ) _LkN . unlock ( ) : void ( ) ),
            0 ) ... };
    ( void ) _Ignored;
}
#line 305
template < class ... _LockN >
int _Try_lock_range ( const int _First, const int _Last, _LockN & ... _LkN ) {
    using _Indices = index_sequence_for < _LockN ... >;
    int _Next = _First;
    try {
    for (; _Next != _Last; ++ _Next ) {
        if ( ! _Try_lock_from_locks ( _Next, _Indices { }, _LkN ... ) ) {
            _Unlock_locks ( _First, _Next, _Indices { }, _LkN ... );
            return _Next;
        }
    }
    } catch ( ... ) {
    _Unlock_locks ( _First, _Next, _Indices { }, _LkN ... );
    throw;
    }

    return - 1;
}
#line 324
template < class _Lock0, class _Lock1, class _Lock2, class ... _LockN >
int _Try_lock1 ( _Lock0 & _Lk0, _Lock1 & _Lk1, _Lock2 & _Lk2, _LockN & ... _LkN ) {
    return _Try_lock_range ( 0, sizeof ... ( _LockN ) + 3, _Lk0, _Lk1, _Lk2, _LkN ... );
}
#line 329
template < class _Lock0, class _Lock1 >
int _Try_lock1 ( _Lock0 & _Lk0, _Lock1 & _Lk1 ) {

    if ( ! _Lk0 . try_lock ( ) ) {
        return 0;
    }

    try {
    if ( ! _Lk1 . try_lock ( ) ) {
        _Lk0 . unlock ( );
        return 1;
    }
    } catch ( ... ) {
    _Lk0 . unlock ( );
    throw;
    }

    return - 1;
}
#line 349
template < class _Lock0, class _Lock1, class ... _LockN >
[ [ nodiscard ] ] int try_lock ( _Lock0 & _Lk0, _Lock1 & _Lk1, _LockN & ... _LkN ) {
    return _Try_lock1 ( _Lk0, _Lk1, _LkN ... );
}
#line 354
template < class ... _LockN >
int _Lock_attempt ( const int _Hard_lock, _LockN & ... _LkN ) {

    using _Indices = index_sequence_for < _LockN ... >;
    _Lock_from_locks ( _Hard_lock, _Indices { }, _LkN ... );
    int _Failed = - 1;
    int _Backout_start = _Hard_lock;

    try {
    _Failed = _Try_lock_range ( 0, _Hard_lock, _LkN ... );
    if ( _Failed == - 1 ) {
        _Backout_start = 0;
        _Failed = _Try_lock_range ( _Hard_lock + 1, sizeof ... ( _LockN ), _LkN ... );
        if ( _Failed == - 1 ) {
            return - 1;
        }
    }
    } catch ( ... ) {
    _Unlock_locks ( _Backout_start, _Hard_lock + 1, _Indices { }, _LkN ... );
    throw;
    }


    _Unlock_locks ( _Backout_start, _Hard_lock + 1, _Indices { }, _LkN ... );
    :: std :: this_thread :: yield ( );
    return _Failed;
}
#line 382
template < class _Lock0, class _Lock1, class _Lock2, class ... _LockN >
void _Lock_nonmember1 ( _Lock0 & _Lk0, _Lock1 & _Lk1, _Lock2 & _Lk2, _LockN & ... _LkN ) {

    int _Hard_lock = 0;
    while ( _Hard_lock != - 1 ) {
        _Hard_lock = _Lock_attempt ( _Hard_lock, _Lk0, _Lk1, _Lk2, _LkN ... );
    }
}
#line 391
template < class _Lock0, class _Lock1 >
bool _Lock_attempt_small ( _Lock0 & _Lk0, _Lock1 & _Lk1 ) {

    _Lk0 . lock ( );
    try {
    if ( _Lk1 . try_lock ( ) ) {
        return false;
    }
    } catch ( ... ) {
    _Lk0 . unlock ( );
    throw;
    }

    _Lk0 . unlock ( );
    :: std :: this_thread :: yield ( );
    return true;
}
#line 409
template < class _Lock0, class _Lock1 >
void _Lock_nonmember1 ( _Lock0 & _Lk0, _Lock1 & _Lk1 ) {

    while ( _Lock_attempt_small ( _Lk0, _Lk1 ) && _Lock_attempt_small ( _Lk1, _Lk0 ) ) {
    }
}
#line 416
template < class _Lock0, class _Lock1, class ... _LockN >
void lock ( _Lock0 & _Lk0, _Lock1 & _Lk1, _LockN & ... _LkN ) {
    _Lock_nonmember1 ( _Lk0, _Lk1, _LkN ... );
}
#line 421
template < class _Mutex >
class [ [ nodiscard ] ] lock_guard {
public :
    using mutex_type = _Mutex;

    explicit lock_guard ( _Mutex & _Mtx ) : _MyMutex ( _Mtx ) {
        _MyMutex . lock ( );
    }

    lock_guard ( _Mutex & _Mtx, adopt_lock_t ) : _MyMutex ( _Mtx ) { }

    ~ lock_guard ( ) noexcept {
        _MyMutex . unlock ( );
    }

    lock_guard ( const lock_guard & ) = delete;
    lock_guard & operator = ( const lock_guard & ) = delete;

private :
    _Mutex & _MyMutex;
};
#line 515 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
extern "C" [[nodiscard]] __declspec(dllimport) int __stdcall __std_init_once_begin_initialize(void ** _LpInitOnce, unsigned long _DwFlags, int * _FPending, void ** _LpContext) noexcept; 
#line 526
extern "C" [[nodiscard]] __declspec(dllimport) int __stdcall __std_init_once_complete(void ** _LpInitOnce, unsigned long _DwFlags, void * _LpContext) noexcept; 
#line 531
constexpr unsigned long _Init_once_init_failed = 4UL; 
#line 533
struct _Init_once_completer { 
#line 534
once_flag &_Once; 
#line 535
unsigned long _DwFlags; 
#line 536
~_Init_once_completer() { 
#line 537
if (__std_init_once_complete(&((_Once)._Opaque), _DwFlags, nullptr) == 0) { 
#line 538
::abort(); 
#line 539
}  
#line 540
} 
#line 541
}; 
#line 543
template < class _Fn, class ... _Args >
void ( call_once ) ( once_flag & _Once, _Fn && _Fx, _Args && ... _Ax ) noexcept (
    noexcept ( :: std :: invoke ( :: std :: forward < _Fn > ( _Fx ), :: std :: forward < _Args > ( _Ax ) ... ) ) ) {


    int _Pending;
    if ( __std_init_once_begin_initialize ( & _Once . _Opaque, 0, & _Pending, nullptr ) == 0 ) {
        :: abort ( );
    }

    if ( _Pending != 0 ) {
        _Init_once_completer _Op { _Once, _Init_once_init_failed };
        :: std :: invoke ( :: std :: forward < _Fn > ( _Fx ), :: std :: forward < _Args > ( _Ax ) ... );
        _Op . _DwFlags = 0;
    }
}
#line 565
enum class cv_status { 
#line 566
no_timeout, 
#line 567
timeout
#line 568
}; 
#line 570
class condition_variable { 
#line 572
public: using native_handle_type = _Cnd_t; 
#line 574
condition_variable() { 
#line 575
_Cnd_init_in_situ(this->_Mycnd()); 
#line 576
} 
#line 578
~condition_variable() noexcept { 
#line 579
_Cnd_destroy_in_situ(this->_Mycnd()); 
#line 580
} 
#line 582
condition_variable(const condition_variable &) = delete;
#line 583
condition_variable &operator=(const condition_variable &) = delete;
#line 585
void notify_one() noexcept { 
#line 586
_Cnd_signal(this->_Mycnd()); 
#line 587
} 
#line 589
void notify_all() noexcept { 
#line 590
_Cnd_broadcast(this->_Mycnd()); 
#line 591
} 
#line 593
void wait(unique_lock< mutex>  &_Lck) { 
#line 595
_Cnd_wait(this->_Mycnd(), _Lck.mutex()->_Mymtx()); 
#line 596
} 
#line 598
template < class _Predicate >
    void wait ( unique_lock < mutex > & _Lck, _Predicate _Pred ) {
        while ( ! _Pred ( ) ) {
            wait ( _Lck );
        }
    }
#line 605
template < class _Rep, class _Period >
    cv_status wait_for ( unique_lock < mutex > & _Lck, const chrono :: duration < _Rep, _Period > & _Rel_time ) {

        if ( _Rel_time <= chrono :: duration < _Rep, _Period > :: zero ( ) ) {
            return cv_status :: timeout;
        }



        :: xtime _Tgt;
        const bool _Clamped = _To_xtime_10_day_clamped ( _Tgt, _Rel_time );
        const cv_status _Result = wait_until ( _Lck, & _Tgt );
        if ( _Clamped ) {
            return cv_status :: no_timeout;
        }

        return _Result;
    }
#line 624
template < class _Rep, class _Period, class _Predicate >
    bool wait_for ( unique_lock < mutex > & _Lck, const chrono :: duration < _Rep, _Period > & _Rel_time, _Predicate _Pred ) {

        return _Wait_until1 ( _Lck, _To_absolute_time ( _Rel_time ), _Pred );
    }
#line 630
template < class _Clock, class _Duration >
    cv_status wait_until ( unique_lock < mutex > & _Lck, const chrono :: time_point < _Clock, _Duration > & _Abs_time ) {




        for (;; ) {
            const auto _Now = _Clock :: now ( );
            if ( _Abs_time <= _Now ) {
                return cv_status :: timeout;
            }

            :: xtime _Tgt;
            ( void ) _To_xtime_10_day_clamped ( _Tgt, _Abs_time - _Now );
            const cv_status _Result = wait_until ( _Lck, & _Tgt );
            if ( _Result == cv_status :: no_timeout ) {
                return cv_status :: no_timeout;
            }
        }
    }
#line 651 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
template < class _Clock, class _Duration, class _Predicate >
    bool wait_until (
        unique_lock < mutex > & _Lck, const chrono :: time_point < _Clock, _Duration > & _Abs_time, _Predicate _Pred ) {




        return _Wait_until1 ( _Lck, _Abs_time, _Pred );
    }
#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
cv_status wait_until(unique_lock< mutex>  &_Lck, const xtime *_Abs_time) { 
#line 663
if (!(_Mtx_current_owns(_Lck.mutex()->_Mymtx()))) { 
#line 664
_Throw_Cpp_error(_OPERATION_NOT_PERMITTED); 
#line 665
}  
#line 668
const int _Res = _Cnd_timedwait(this->_Mycnd(), _Lck.mutex()->_Mymtx(), _Abs_time); 
#line 669
switch (_Res) { 
#line 670
case _Thrd_success:  
#line 671
return cv_status::no_timeout; 
#line 672
case _Thrd_timedout:  
#line 673
return cv_status::timeout; 
#line 674
default:  
#line 675
_Throw_C_error(_Res); 
#line 676
}  
#line 677
} 
#line 679
template < class _Predicate >
    bool wait_until ( unique_lock < mutex > & _Lck, const xtime * _Abs_time, _Predicate _Pred ) {

        return _Wait_until1 ( _Lck, _Abs_time, _Pred );
    }
#line 685
[[nodiscard]] native_handle_type native_handle() { 
#line 686
return this->_Mycnd(); 
#line 687
} 
#line 689
void _Register(unique_lock< mutex>  &_Lck, int *_Ready) { 
#line 690
_Cnd_register_at_thread_exit(this->_Mycnd(), _Lck.release()->_Mymtx(), _Ready); 
#line 691
} 
#line 693
void _Unregister(mutex &_Mtx) { 
#line 694
_Cnd_unregister_at_thread_exit(_Mtx._Mymtx()); 
#line 695
} 
#line 698
private: aligned_storage_t< 72Ui64, 8Ui64>  _Cnd_storage; 
#line 700
_Cnd_t _Mycnd() noexcept { 
#line 701
return reinterpret_cast< _Cnd_t>(&(_Cnd_storage)); 
#line 702
} 
#line 704
template < class _Predicate >
    bool _Wait_until1 ( unique_lock < mutex > & _Lck, const xtime * _Abs_time, _Predicate & _Pred ) {

        while ( ! _Pred ( ) ) {
            if ( wait_until ( _Lck, _Abs_time ) == cv_status :: timeout ) {
                return _Pred ( );
            }
        }

        return true;
    }
#line 716
template < class _Clock, class _Duration, class _Predicate >
    bool _Wait_until1 (
        unique_lock < mutex > & _Lck, const chrono :: time_point < _Clock, _Duration > & _Abs_time, _Predicate & _Pred ) {
        while ( ! _Pred ( ) ) {
            const auto _Now = _Clock :: now ( );
            if ( _Abs_time <= _Now ) {
                return false;
            }

            :: xtime _Tgt;
            const bool _Clamped = _To_xtime_10_day_clamped ( _Tgt, _Abs_time - _Now );
            if ( wait_until ( _Lck, & _Tgt ) == cv_status :: timeout && ! _Clamped ) {
                return _Pred ( );
            }
        }

        return true;
    }
#line 734
}; 
#line 736
struct _UInt_is_zero { 
#line 737
const unsigned &_UInt; 
#line 739
[[nodiscard]] bool operator()() const { 
#line 740
return (_UInt) == (0); 
#line 741
} 
#line 742
}; 
#line 744
class timed_mutex { 
#line 746
public: timed_mutex() noexcept : _My_locked((0)) { } 
#line 748
timed_mutex(const timed_mutex &) = delete;
#line 749
timed_mutex &operator=(const timed_mutex &) = delete;
#line 751
void lock() { 
#line 752
unique_lock< mutex>  _Lock(_My_mutex); 
#line 753
while ((_My_locked) != (0)) { 
#line 754
(_My_cond).wait(_Lock); 
#line 755
}  
#line 757
(_My_locked) = 4294967295U; 
#line 758
} 
#line 760
[[nodiscard]] bool try_lock() noexcept { 
#line 761
lock_guard< mutex>  _Lock(_My_mutex); 
#line 762
if ((_My_locked) != (0)) { 
#line 763
return false; 
#line 764
} else { 
#line 765
(_My_locked) = 4294967295U; 
#line 766
return true; 
#line 767
}  
#line 768
} 
#line 770
void unlock() { 
#line 771
{ 
#line 773
lock_guard< mutex>  _Lock(_My_mutex); 
#line 774
(_My_locked) = (0); 
#line 775
} 
#line 776
(_My_cond).notify_one(); 
#line 777
} 
#line 779
template < class _Rep, class _Period >
    [ [ nodiscard ] ] bool try_lock_for ( const chrono :: duration < _Rep, _Period > & _Rel_time ) {
        return try_lock_until ( _To_absolute_time ( _Rel_time ) );
    }
#line 784
template < class _Time >
    bool _Try_lock_until ( _Time _Abs_time ) {
        unique_lock < mutex > _Lock ( _My_mutex );
        if ( ! _My_cond . wait_until ( _Lock, _Abs_time, _UInt_is_zero { _My_locked } ) ) {
            return false;
        }

        _My_locked = 4294967295U;
        return true;
    }
#line 795
template < class _Clock, class _Duration >
    [ [ nodiscard ] ] bool try_lock_until ( const chrono :: time_point < _Clock, _Duration > & _Abs_time ) {




        return _Try_lock_until ( _Abs_time );
    }
#line 804 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
[[nodiscard]] bool try_lock_until(const xtime *_Abs_time) { 
#line 805
return this->_Try_lock_until(_Abs_time); 
#line 806
} 
#line 809
private: mutex _My_mutex; 
#line 810
condition_variable _My_cond; 
#line 811
unsigned _My_locked; 
#line 812
}; 
#line 814
class recursive_timed_mutex { 
#line 816
public: recursive_timed_mutex() noexcept : _My_locked((0)) { } 
#line 818
recursive_timed_mutex(const recursive_timed_mutex &) = delete;
#line 819
recursive_timed_mutex &operator=(const recursive_timed_mutex &) = delete;
#line 821
void lock() { 
#line 822
const thread::id _Tid = this_thread::get_id(); 
#line 824
unique_lock< mutex>  _Lock(_My_mutex); 
#line 826
if ((_Tid == (_My_owner))) { 
#line 827
if ((_My_locked) < 4294967295U) { 
#line 828
++(_My_locked); 
#line 829
} else { 
#line 830
_Throw_system_error(errc::device_or_resource_busy); 
#line 831
}  
#line 832
} else { 
#line 833
while ((_My_locked) != (0)) { 
#line 834
(_My_cond).wait(_Lock); 
#line 835
}  
#line 837
(_My_locked) = (1); 
#line 838
(_My_owner) = _Tid; 
#line 839
}  
#line 840
} 
#line 842
[[nodiscard]] bool try_lock() noexcept { 
#line 843
const thread::id _Tid = this_thread::get_id(); 
#line 845
lock_guard< mutex>  _Lock(_My_mutex); 
#line 847
if ((_Tid == (_My_owner))) { 
#line 848
if ((_My_locked) < 4294967295U) { 
#line 849
++(_My_locked); 
#line 850
} else { 
#line 851
return false; 
#line 852
}  
#line 853
} else { 
#line 854
if ((_My_locked) != (0)) { 
#line 855
return false; 
#line 856
} else { 
#line 857
(_My_locked) = (1); 
#line 858
(_My_owner) = _Tid; 
#line 859
}  
#line 860
}  
#line 861
return true; 
#line 862
} 
#line 864
void unlock() { 
#line 865
bool _Do_notify = false; 
#line 867
{ 
#line 868
lock_guard< mutex>  _Lock(_My_mutex); 
#line 869
--(_My_locked); 
#line 870
if ((_My_locked) == (0)) { 
#line 871
_Do_notify = true; 
#line 872
(_My_owner) = thread::id(); 
#line 873
}  
#line 874
} 
#line 876
if (_Do_notify) { 
#line 877
(_My_cond).notify_one(); 
#line 878
}  
#line 879
} 
#line 881
template < class _Rep, class _Period >
    [ [ nodiscard ] ] bool try_lock_for ( const chrono :: duration < _Rep, _Period > & _Rel_time ) {
        return try_lock_until ( _To_absolute_time ( _Rel_time ) );
    }
#line 886
template < class _Time >
    bool _Try_lock_until ( _Time _Abs_time ) {
        const thread :: id _Tid = this_thread :: get_id ( );

        unique_lock < mutex > _Lock ( _My_mutex );

        if ( _Tid == _My_owner ) {
            if ( _My_locked < 4294967295U ) {
                ++ _My_locked;
            } else {
                return false;
            }
        } else {
            if ( ! _My_cond . wait_until ( _Lock, _Abs_time, _UInt_is_zero { _My_locked } ) ) {
                return false;
            }

            _My_locked = 1;
            _My_owner = _Tid;
        }
        return true;
    }
#line 909
template < class _Clock, class _Duration >
    [ [ nodiscard ] ] bool try_lock_until ( const chrono :: time_point < _Clock, _Duration > & _Abs_time ) {




        return _Try_lock_until ( _Abs_time );
    }
#line 918 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
[[nodiscard]] bool try_lock_until(const xtime *_Abs_time) { 
#line 919
return this->_Try_lock_until(_Abs_time); 
#line 920
} 
#line 923
private: mutex _My_mutex; 
#line 924
condition_variable _My_cond; 
#line 925
unsigned _My_locked; 
#line 926
thread::id _My_owner; 
#line 927
}; 
#line 929 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
}
#line 932
#pragma warning(pop)
#pragma pack ( pop )
#line 936 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
#pragma external_header(pop)
#line 23 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
#pragma pack ( push, 8 )
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 )
#line 30
namespace std { 
#line 31
template < class _Lock >
struct [ [ nodiscard ] ] _Unlock_guard {
    explicit _Unlock_guard ( _Lock & _Mtx_ ) : _Mtx ( _Mtx_ ) {
        _Mtx . unlock ( );
    }

    ~ _Unlock_guard ( ) noexcept {




        _Mtx . lock ( );
    }

    _Unlock_guard ( const _Unlock_guard & ) = delete;
    _Unlock_guard & operator = ( const _Unlock_guard & ) = delete;

private :
    _Lock & _Mtx;
};
#line 52
class condition_variable_any { 
#line 54
public: condition_variable_any() : _Myptr{::std::make_shared< mutex> ()} { 
#line 55
_Cnd_init_in_situ(this->_Mycnd()); 
#line 56
} 
#line 58
~condition_variable_any() noexcept { 
#line 59
_Cnd_destroy_in_situ(this->_Mycnd()); 
#line 60
} 
#line 62
condition_variable_any(const condition_variable_any &) = delete;
#line 63
condition_variable_any &operator=(const condition_variable_any &) = delete;
#line 65
void notify_one() noexcept { 
#line 66
lock_guard< mutex>  _Guard{(*(_Myptr))}; 
#line 67
_Cnd_signal(this->_Mycnd()); 
#line 68
} 
#line 70
void notify_all() noexcept { 
#line 71
lock_guard< mutex>  _Guard{(*(_Myptr))}; 
#line 72
_Cnd_broadcast(this->_Mycnd()); 
#line 73
} 
#line 75
template < class _Lock >
    void wait ( _Lock & _Lck ) noexcept {
        const shared_ptr < mutex > _Ptr = _Myptr;
        unique_lock < mutex > _Guard { * _Ptr };
        _Unlock_guard < _Lock > _Unlock_outer { _Lck };
        _Cnd_wait ( _Mycnd ( ), _Ptr -> _Mymtx ( ) );
        _Guard . unlock ( );
    }
#line 84
template < class _Lock, class _Predicate >
    void wait ( _Lock & _Lck, _Predicate _Pred ) noexcept ( noexcept ( static_cast < bool > ( _Pred ( ) ) ) ) {

        while ( ! static_cast < bool > ( _Pred ( ) ) ) {
            wait ( _Lck );
        }
    }
#line 92
template < class _Lock, class _Clock, class _Duration >
    cv_status wait_until ( _Lock & _Lck, const chrono :: time_point < _Clock, _Duration > & _Abs_time ) {




        return wait_for ( _Lck, _Abs_time - _Clock :: now ( ) );
    }
#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
template < class _Lock, class _Clock, class _Duration, class _Predicate >
    bool wait_until ( _Lock & _Lck, const chrono :: time_point < _Clock, _Duration > & _Abs_time, _Predicate _Pred ) {




        while ( ! _Pred ( ) ) {
            if ( wait_until ( _Lck, _Abs_time ) == cv_status :: timeout ) {
                return _Pred ( );
            }
        }

        return true;
    }
#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
template < class _Lock, class _Rep, class _Period >
    cv_status wait_for ( _Lock & _Lck, const chrono :: duration < _Rep, _Period > & _Rel_time ) {
        if ( _Rel_time <= chrono :: duration < _Rep, _Period > :: zero ( ) ) {
            _Unlock_guard < _Lock > _Unlock_outer { _Lck };
            ( void ) _Unlock_outer;
            return cv_status :: timeout;
        }



        :: xtime _Tgt;
        const bool _Clamped = _To_xtime_10_day_clamped ( _Tgt, _Rel_time );
        const cv_status _Result = _Wait_until ( _Lck, & _Tgt );
        if ( _Clamped ) {
            return cv_status :: no_timeout;
        }

        return _Result;
    }
#line 136
template < class _Lock, class _Rep, class _Period, class _Predicate >
    bool wait_for ( _Lock & _Lck, const chrono :: duration < _Rep, _Period > & _Rel_time, _Predicate _Pred ) {

        return wait_until ( _Lck, _To_absolute_time ( _Rel_time ), :: std :: move ( _Pred ) );
    }
#line 142
template < class _Lock >
    cv_status wait_until ( _Lock & _Lck, const xtime * const _Abs_time ) {
        return _Wait_until ( _Lck, _Abs_time );
    }
#line 147
template < class _Lock, class _Predicate >
    bool wait_until ( _Lock & _Lck, const xtime * const _Abs_time, _Predicate _Pred ) {

        while ( ! _Pred ( ) ) {
            if ( _Wait_until ( _Lck, _Abs_time ) == cv_status :: timeout ) {
                return _Pred ( );
            }
        }
        return true;
    }
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
private: shared_ptr< mutex>  _Myptr; 
#line 249
aligned_storage_t< 72Ui64, 8Ui64>  _Cnd_storage; 
#line 251
[[nodiscard]] _Cnd_t _Mycnd() noexcept { 
#line 252
return reinterpret_cast< _Cnd_t>(&(_Cnd_storage)); 
#line 253
} 
#line 255
template < class _Lock >
    cv_status _Wait_until ( _Lock & _Lck, const xtime * const _Abs_time ) {
        const shared_ptr < mutex > _Ptr = _Myptr;
        unique_lock < mutex > _Guard { * _Ptr };
        _Unlock_guard < _Lock > _Unlock_outer { _Lck };
        const int _Res = _Cnd_timedwait ( _Mycnd ( ), _Ptr -> _Mymtx ( ), _Abs_time );
        _Guard . unlock ( );

        switch ( _Res ) {
        case _Thrd_success :
            return cv_status :: no_timeout;
        case _Thrd_timedout :
            return cv_status :: timeout;
        default :
            _Throw_C_error ( _Res );
        }
    }
#line 272
}; 
#line 274
inline void notify_all_at_thread_exit(condition_variable &_Cnd, unique_lock< mutex>  _Lck) { 
#line 276
_Cnd._Register(_Lck, nullptr); 
#line 277
} 
#line 278
}
#line 281
#pragma warning(pop)
#pragma pack ( pop )
#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
#pragma external_header(pop)
#line 26 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
inline void check(cudaError_t err, const char *const func, const char *const file, const int line) 
#line 27
{ 
#line 28
if (err != (cudaSuccess)) 
#line 29
{ 
#line 30
(((((((((std::cerr << ("CUDA Runtime Error at: "))) << file)) << (":"))) << line)) << (std::endl)); 
#line 31
(((((((std::cerr << (cudaGetErrorString(err)))) << (" "))) << func)) << (std::endl)); 
#line 32
std::exit(1); 
#line 33
}  
#line 34
} 
#line 37
inline void check_last(const char *const file, const int line) 
#line 38
{ 
#line 39
const cudaError_t err{cudaPeekAtLastError()}; 
#line 40
if (err != (cudaSuccess)) 
#line 41
{ 
#line 42
(((((((((std::cerr << ("CUDA Runtime Error at: "))) << file)) << (":"))) << line)) << (std::endl)); 
#line 43
(((std::cerr << (cudaGetErrorString(err)))) << (std::endl)); 
#line 44
std::exit(1); 
#line 45
}  
#line 46
} 
#line 48
const unsigned MOD = (65537); 
#line 49
const unsigned SPECIAL = (MOD - (1)); 
#line 50
const unsigned ROOT = (3); 
#line 51
const unsigned ROOT_INV = (21846); 
#line 52
const unsigned MAX_LOG = (16); 
#line 54
const unsigned LOG_LEN_WARP = (5); 
#line 55
const unsigned LEN_WARP = (1 << LOG_LEN_WARP); 
#line 56
const unsigned ALGO_N_2_CUTOFF = (16); 
#line 57
const unsigned ALGO_NLOGN_CUTOFF = (32); 
#line 58
const unsigned ALGO_BLOCK_CUTOFF = (512); 
#line 60
const unsigned LOG_DATA = (10); 
#line 61
const unsigned LOG_SYMBOL = (LOG_DATA - (1)); 
#line 62
const unsigned LOG_SEG = (LOG_SYMBOL - (1)); 
#line 63
const unsigned SYMBOL_PER_PACKET = (1 << LOG_SYMBOL); 
#line 64
const unsigned NUM_OF_PACKET = (1 << (MAX_LOG - LOG_SYMBOL)); 
#line 65
const unsigned NUM_OF_NEED_PACKET = (NUM_OF_PACKET >> 1); 
#line 66
const unsigned SEG_PER_PACKET = (1 << LOG_SEG); 
#line 67
const unsigned SEG_DIFF = (1 << (MAX_LOG - (1))); 
#line 68
const unsigned NUM_OF_NEED_SYMBOL = (1 << (MAX_LOG - (1))); 
#line 70
const unsigned LEN_ROOT_LAYER_POW = ((1 << MAX_LOG) - 1); 
#line 71
const unsigned LEN_ROOT_LAYER_POW_2 = (LEN_ROOT_LAYER_POW << 1); 
#line 72
const unsigned LEN_N_POS = ((1 << (MAX_LOG + (1))) - 1); 
#line 73
const unsigned LEN_PACKET_PRODUCT = (NUM_OF_PACKET * (SYMBOL_PER_PACKET << 1)); 
#line 74
const unsigned LEN_ONE_PACKET_PRODUCT = (1 << (LOG_SYMBOL + (1))); 
#line 76
const unsigned LEN_SMALL = NUM_OF_NEED_SYMBOL; 
#line 77
const unsigned LEN_LARGE = (LEN_SMALL << 1); 
#line 78
const unsigned SIZE_SMALL = (LEN_SMALL * sizeof(unsigned)); 
#line 79
const unsigned SIZE_LARGE = (LEN_LARGE * sizeof(unsigned)); 
#line 80
const unsigned SIZE_ONE_PACKET_PRODUCT = (LEN_ONE_PACKET_PRODUCT * sizeof(unsigned)); 
#line 82
const unsigned LEN_ENCODE_P = NUM_OF_NEED_SYMBOL; 
#line 83
const unsigned LEN_ENCODE_Y = (NUM_OF_NEED_SYMBOL << 1); 
#line 84
const unsigned LEN_DECODE_X = NUM_OF_NEED_SYMBOL; 
#line 85
const unsigned LEN_DECODE_Y = NUM_OF_NEED_SYMBOL; 
#line 86
const unsigned LEN_DECODE_P = NUM_OF_NEED_SYMBOL; 
#line 87
const unsigned LEN_BATCH = LEN_WARP; 
#line 89
const unsigned LEN_ENCODE_P_BATCH = (LEN_ENCODE_P * LEN_BATCH); 
#line 90
const unsigned LEN_ENCODE_Y_BATCH = (LEN_ENCODE_Y * LEN_BATCH); 
#line 91
const unsigned LEN_DECODE_X_BATCH = (LEN_DECODE_X * LEN_BATCH); 
#line 92
const unsigned LEN_DECODE_Y_BATCH = (LEN_DECODE_Y * LEN_BATCH); 
#line 93
const unsigned LEN_DECODE_P_BATCH = (LEN_DECODE_P * LEN_BATCH); 
#line 94
const unsigned LEN_SMALL_BATCH = (LEN_SMALL * LEN_BATCH); 
#line 95
const unsigned LEN_LARGE_BATCH = (LEN_LARGE * LEN_BATCH); 
#line 97
const unsigned MAX_ACTIVE_ENCODE_BATCH = (100); 
#line 98
const unsigned MAX_ACTIVE_DECODE_BATCH = (100); 
#line 100
const size_t SIZE_ENCODE_P_BATCH = (sizeof(unsigned) * LEN_ENCODE_P_BATCH); 
#line 101
const size_t SIZE_ENCODE_Y_BATCH = (sizeof(unsigned) * LEN_ENCODE_Y_BATCH); 
#line 102
const size_t SIZE_DECODE_X_BATCH = (sizeof(unsigned) * LEN_DECODE_X_BATCH); 
#line 103
const size_t SIZE_DECODE_Y_BATCH = (sizeof(unsigned) * LEN_DECODE_Y_BATCH); 
#line 104
const size_t SIZE_DECODE_P_BATCH = (sizeof(unsigned) * LEN_DECODE_P_BATCH); 
#line 105
const size_t SIZE_SMALL_BATCH = (sizeof(unsigned) * LEN_SMALL_BATCH); 
#line 106
const size_t SIZE_LARGE_BATCH = (sizeof(unsigned) * LEN_LARGE_BATCH); 
#line 108
const size_t SIZE_ENCODE_P_BATCH_SLOT = ((sizeof(unsigned) * LEN_ENCODE_P_BATCH) * MAX_ACTIVE_ENCODE_BATCH); 
#line 109
const size_t SIZE_ENCODE_Y_BATCH_SLOT = ((sizeof(unsigned) * LEN_ENCODE_Y_BATCH) * MAX_ACTIVE_ENCODE_BATCH); 
#line 111
const size_t SIZE_DECODE_X_BATCH_SLOT = ((sizeof(unsigned) * LEN_DECODE_X_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 112
const size_t SIZE_DECODE_Y_BATCH_SLOT = ((sizeof(unsigned) * LEN_DECODE_Y_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 113
const size_t SIZE_DECODE_P_BATCH_SLOT = ((sizeof(unsigned) * LEN_DECODE_P_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 114
const size_t SIZE_DECODE_T1_BATCH_SLOT = ((sizeof(unsigned) * LEN_LARGE_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 115
const size_t SIZE_DECODE_T2_BATCH_SLOT = ((sizeof(unsigned) * LEN_LARGE_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 116
const size_t SIZE_DECODE_AX_BATCH_SLOT = ((sizeof(unsigned) * LEN_LARGE_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 117
const size_t SIZE_DECODE_DAX_BATCH_SLOT = ((sizeof(unsigned) * LEN_SMALL_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 118
const size_t SIZE_DECODE_VDAX_BATCH_SLOT = ((sizeof(unsigned) * LEN_LARGE_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 119
const size_t SIZE_DECODE_N1_BATCH_SLOT = ((sizeof(unsigned) * LEN_SMALL_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 120
const size_t SIZE_DECODE_N2_BATCH_SLOT = ((sizeof(unsigned) * LEN_LARGE_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 121
const size_t SIZE_DECODE_N3_BATCH_SLOT = ((sizeof(unsigned) * LEN_SMALL_BATCH) * MAX_ACTIVE_DECODE_BATCH); 
#line 123
unsigned **h_encode_p_batch_slot; 
#line 124
unsigned **h_encode_y_batch_slot; 
#line 125
unsigned **h_decode_x_batch_slot; 
#line 126
unsigned **h_decode_y_batch_slot; 
#line 127
unsigned **h_decode_p_batch_slot; 
#line 129
unsigned *d_encode_p_batch_slot; 
#line 130
unsigned *d_encode_y_batch_slot; 
#line 131
unsigned *d_decode_x_batch_slot; 
#line 132
unsigned *d_decode_y_batch_slot; 
#line 133
unsigned *d_decode_p_batch_slot; 
#line 134
unsigned *d_decode_t1_batch_slot; 
#line 135
unsigned *d_decode_t2_batch_slot; 
#line 136
unsigned *d_decode_ax_batch_slot; 
#line 137
unsigned *d_decode_dax_batch_slot; 
#line 138
unsigned *d_decode_vdax_batch_slot; 
#line 139
unsigned *d_decode_n1_batch_slot; 
#line 140
unsigned *d_decode_n2_batch_slot; 
#line 141
unsigned *d_decode_n3_batch_slot; 
#line 143
unsigned *d_N_pos; 
#line 144
unsigned *d_root_pow; 
#line 145
unsigned *d_root_inv_pow; 
#line 146
unsigned *d_inv; 
#line 147
unsigned *d_root_layer_pow; 
#line 148
unsigned *d_packet_product; 
#line 150
struct CB_DATA { 
#line 151
unsigned slot_id; 
#line 152
unsigned *dst; 
#line 153
unsigned *src; 
#line 154
size_t size_res; 
#line 155
std::queue< unsigned>  &slot; 
#line 156
std::mutex &mt; 
#line 157
std::condition_variable &cv; 
#line 158
}; 
#line 160
std::queue< unsigned>  encode_batch_slot, decode_batch_slot; 
#line 161
std::mutex mt_encode_slot, mt_decode_slot; 
#line 162
std::condition_variable cv_encode_slot, cv_decode_slot; 
#line 164
inline unsigned pop_slot(std::queue< unsigned>  &slot, std::mutex &mt, std::condition_variable &cv) { 
#line 165
std::unique_lock< std::mutex>  lock(mt); 
#line 166
cv.wait(lock, [&]{ return !(slot).empty(); } ); 
#line 167
unsigned id = slot.front(); 
#line 168
slot.pop(); 
#line 169
return id; 
#line 170
} 
#line 172
inline void push_slot(unsigned id, std::queue< unsigned>  &slot, std::mutex &mt, std::condition_variable &cv) { 
#line 173
{ 
#line 174
std::lock_guard< std::mutex>  lock(mt); 
#line 175
slot.push(id); 
#line 176
} 
#line 177
cv.notify_one(); 
#line 178
} 
#line 180
void init_batch_slot() { 
#line 182
for (unsigned i = (0); i < MAX_ACTIVE_ENCODE_BATCH; i++) { 
#line 183
push_slot(i, encode_batch_slot, mt_encode_slot, cv_encode_slot); }  
#line 185
for (unsigned i = (0); i < MAX_ACTIVE_DECODE_BATCH; i++) { 
#line 186
push_slot(i, decode_batch_slot, mt_decode_slot, cv_decode_slot); }  
#line 188
} 
#line 190
void __stdcall h_end_batch_slot(void *data) { 
#line 192
CB_DATA *dat = static_cast< CB_DATA *>(data); 
#line 194
memcpy(dat->dst, dat->src, dat->size_res); 
#line 195
push_slot(dat->slot_id, dat->slot, dat->mt, dat->cv); 
#line 197
delete dat; 
#line 198
} 
#line 200
__forceinline void build_launch_param(unsigned log_n, unsigned &n_th, unsigned &n_bl) { 
#line 201
if (log_n <= LOG_LEN_WARP) { 
#line 202
n_th = (1 << log_n); 
#line 203
n_bl = (1); 
#line 204
} else 
#line 205
{ 
#line 206
unsigned c_l2_sqrt_n = (log_n >> 1) + (log_n & (1)); 
#line 207
n_th = (1 << c_l2_sqrt_n); 
#line 208
n_bl = (1 << (log_n - c_l2_sqrt_n)); 
#line 209
}  
#line 210
} 
#line 212
__forceinline unsigned mul_mod(unsigned a, unsigned b) 
#line 213
{ 
#line 214
if ((a == SPECIAL) && (b == SPECIAL)) { 
#line 215
return 1; }  
#line 216
return (a * b) % MOD; 
#line 217
} 
#line 219
__forceinline unsigned div_mod(unsigned a, unsigned b, unsigned *
#line 220
d_inv) {int volatile ___ = 1;(void)a;(void)b;(void)d_inv;::exit(___);}
#if 0
#line 221
{ 
#line 222
return mul_mod(a, d_inv[b]); 
#line 223
} 
#endif
#line 225 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline unsigned add_mod(unsigned a, unsigned b) 
#line 226
{ 
#line 227
return (a + b) % MOD; 
#line 228
} 
#line 230
__forceinline unsigned sub_mod(unsigned a, unsigned b) 
#line 231
{ 
#line 232
return ((a - b) + MOD) % MOD; 
#line 233
} 
#line 235
__forceinline unsigned pow_mod(unsigned a, unsigned b) 
#line 236
{ 
#line 237
unsigned res = (1); 
#line 238
while (b > (0)) 
#line 239
{ 
#line 240
if (b & (1)) { 
#line 241
res = mul_mod(res, a); }  
#line 242
a = mul_mod(a, a); 
#line 243
b >>= 1; 
#line 244
}  
#line 245
return res; 
#line 246
} 
#line 248
void g_pre_fnt(unsigned *a, unsigned *b, unsigned st, unsigned *d_N_pos) ;
#if 0
#line 249
{ 
#line 251
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 252
(b[d_N_pos[st + id]]) = (a[id]); 
#line 254
} 
#endif
#line 256 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void g_end_fnt(unsigned *b, unsigned n, unsigned *d_inv) ;
#if 0
#line 257
{ 
#line 259
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 260
(b[id << 1]) = div_mod(b[id << 1], n, d_inv); 
#line 261
(b[(id << 1) | (1)]) = div_mod(b[(id << 1) | (1)], n, d_inv); 
#line 262
} 
#endif
#line 264 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void g_fnt_i(unsigned *b, unsigned i, bool inv, unsigned *
#line 265
d_root_layer_pow) ;
#if 0
#line 266
{ 
#line 268
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 270
unsigned haft_len = 1 << i; 
#line 271
unsigned bl_st = (id >> i) << (i + (1)), th_id = id & (haft_len - (1)); 
#line 272
unsigned pos = bl_st + th_id; 
#line 273
unsigned u = b[pos]; 
#line 274
unsigned v = mul_mod(b[pos + haft_len], d_root_layer_pow[(((LEN_ROOT_LAYER_POW * inv) + haft_len) - (1)) + th_id]); 
#line 275
(b[pos]) = add_mod(u, v); 
#line 276
(b[pos + haft_len]) = sub_mod(u, v); 
#line 277
} 
#endif
#line 279 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void fnt(unsigned *a, unsigned *b, unsigned log_na, unsigned log_nb, unsigned opt, unsigned *
#line 280
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv, cudaStream_t stream) 
#line 281
{ 
#line 292
unsigned nb = 1 << log_nb, wp = (opt & (2)) >> 1; 
#line 293
unsigned n_th, n_bl; 
#line 295
build_launch_param(log_na, n_th, n_bl); 
#line 296
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_pre_fnt(a, b, nb - (1), d_N_pos); 
#line 298
build_launch_param(log_nb - (1), n_th, n_bl); 
#line 299
for (unsigned i = (0); i < log_nb; i++) { 
#line 300
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_fnt_i(b, i, wp, d_root_layer_pow); }  
#line 302
if (opt & (1)) { 
#line 303
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_end_fnt(b, nb, d_inv); }  
#line 304
} 
#line 306
void g_fnt(unsigned *a, unsigned *b, unsigned log_na, unsigned log_nb, unsigned opt, unsigned *
#line 307
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) ;
#if 0
#line 308
{ 
#line 310
unsigned id = __device_builtin_variable_threadIdx.x; 
#line 311
unsigned na = 1 << log_na, nb = 1 << log_nb, wp = (opt & (2)) >> 1, st = nb - (1); 
#line 312
unsigned os1 = nb >> 1, os2 = LEN_ROOT_LAYER_POW * wp; 
#line 314
if (id < na) { (b[d_N_pos[st + id]]) = (a[id]); }  
#line 315
if (log_na == log_nb) { (b[d_N_pos[(st + id) + os1]]) = (a[id + os1]); }  
#line 317
__syncthreads(); 
#line 319
for (unsigned i = (0); i < log_nb; i++) { 
#line 321
unsigned haft_len = 1 << i; 
#line 322
unsigned bl_st = (id >> i) << (i + (1)), th_id = id & (haft_len - (1)); 
#line 323
unsigned pos = bl_st + th_id; 
#line 324
unsigned u = b[pos]; 
#line 325
unsigned v = mul_mod(b[pos + haft_len], d_root_layer_pow[((os2 + haft_len) - (1)) + th_id]); 
#line 326
(b[pos]) = add_mod(u, v); 
#line 327
(b[pos + haft_len]) = sub_mod(u, v); 
#line 329
__syncthreads(); 
#line 331
}  
#line 333
if (opt & (1)) { 
#line 334
(b[id]) = div_mod(b[id], nb, d_inv); 
#line 335
(b[id + os1]) = div_mod(b[id + os1], nb, d_inv); 
#line 337
}  
#line 339
} 
#endif
#line 341 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void d_sq_fnt(unsigned *a, unsigned *b, unsigned log_na, unsigned log_nb, unsigned opt, unsigned *
#line 342
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) {int volatile ___ = 1;(void)a;(void)b;(void)log_na;(void)log_nb;(void)opt;(void)d_N_pos;(void)d_root_layer_pow;(void)d_inv;::exit(___);}
#if 0
#line 343
{ 
#line 345
unsigned na = 1 << log_na, nb = 1 << log_nb, wp = (opt & (2)) >> 1, st = nb - (1); 
#line 346
unsigned os = LEN_ROOT_LAYER_POW * wp; 
#line 348
for (unsigned i = (0); i < na; i++) { 
#line 349
(b[d_N_pos[st + i]]) = (a[i]); }  
#line 351
for (unsigned i = (0); i < log_nb; i++) { 
#line 352
unsigned haft_len = 1 << i, len = haft_len << 1; 
#line 353
unsigned wlen = d_root_layer_pow[os + haft_len]; 
#line 354
for (unsigned j = (0); j < nb; j += len) { 
#line 355
unsigned w = (1); 
#line 356
for (unsigned k = (0); k < haft_len; k++) { 
#line 357
unsigned u = b[j + k], v = mul_mod(b[(j + k) + haft_len], w); 
#line 358
(b[j + k]) = add_mod(u, v); 
#line 359
(b[(j + k) + haft_len]) = sub_mod(u, v); 
#line 360
w = mul_mod(w, wlen); 
#line 361
}  
#line 362
}  
#line 363
}  
#line 365
if (opt & (1)) { 
#line 366
unsigned inv_nb = div_mod(1, nb, d_inv); 
#line 367
for (unsigned i = (0); i < nb; i++) { 
#line 368
(b[i]) = mul_mod(b[i], inv_nb); }  
#line 369
}  
#line 371
} 
#endif
#line 373 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void g_vector_mul_i(unsigned *a, unsigned *b, unsigned *c) ;
#if 0
#line 374
{ 
#line 376
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 377
(c[id]) = mul_mod(a[id], b[id]); 
#line 379
} 
#endif
#line 381 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void d_sq_vector_mul_i(unsigned *a, unsigned *b, unsigned *c, unsigned n) {int volatile ___ = 1;(void)a;(void)b;(void)c;(void)n;::exit(___);}
#if 0
#line 381
{ 
#line 383
for (unsigned i = (0); i < n; i++) { 
#line 384
(c[i]) = mul_mod(a[i], b[i]); }  
#line 386
} 
#endif
#line 388 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void d_poly_mul(unsigned *a, unsigned *b, unsigned *t1, unsigned *t2, unsigned *c, unsigned log_n, unsigned *
#line 389
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) {int volatile ___ = 1;(void)a;(void)b;(void)t1;(void)t2;(void)c;(void)log_n;(void)d_N_pos;(void)d_root_layer_pow;(void)d_inv;::exit(___);}
#if 0
#line 390
{ 
#line 395
unsigned na = 1 << log_n, nc = na << 1, size_nc = nc * sizeof(unsigned); 
#line 397
if (na <= ALGO_N_2_CUTOFF) 
#line 398
{ 
#line 399
for (unsigned i = (0); i < na; i++) 
#line 400
{ 
#line 401
(t1[i]) = (a[i]); 
#line 402
(t2[i]) = (b[i]); 
#line 403
}  
#line 404
memset(c, 0, size_nc); 
#line 405
for (unsigned i = (0); i < na; i++) { 
#line 406
for (unsigned j = (0); j < na; j++) { 
#line 407
(c[i + j]) = add_mod(c[i + j], mul_mod(t1[i], t2[j])); }  }  
#line 408
} else 
#line 410
{ 
#line 411
memset(t1, 0, size_nc); 
#line 412
memset(t2, 0, size_nc); 
#line 414
if (na <= ALGO_NLOGN_CUTOFF) { 
#line 416
d_sq_fnt(a, t1, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv); 
#line 417
d_sq_fnt(b, t2, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv); 
#line 419
d_sq_vector_mul_i(t1, t2, t1, nc); 
#line 421
d_sq_fnt(t1, c, log_n + (1), log_n + (1), 3, d_N_pos, d_root_layer_pow, d_inv); 
#line 423
} else 
#line 424
{ 
#line 426
cudaStream_t stream; 
#line 427
cudaStreamCreateWithFlags(&stream, 1); 
#line 438
if (na <= ALGO_BLOCK_CUTOFF) { 
#line 440
(__cudaPushCallConfiguration(1, na, 0, stream)) ? (void)0 : g_fnt(a, t1, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv); 
#line 441
(__cudaPushCallConfiguration(1, na, 0, stream)) ? (void)0 : g_fnt(b, t2, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv); 
#line 443
unsigned n_th, n_bl; 
#line 444
build_launch_param(log_n + (1), n_th, n_bl); 
#line 445
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_vector_mul_i(t1, t2, t1); 
#line 447
(__cudaPushCallConfiguration(1, na, 0, stream)) ? (void)0 : g_fnt(t1, c, log_n + (1), log_n + (1), 3, d_N_pos, d_root_layer_pow, d_inv); 
#line 449
} else 
#line 450
{ 
#line 452
fnt(a, t1, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 453
fnt(b, t2, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 455
unsigned n_th, n_bl; 
#line 456
build_launch_param(log_n + (1), n_th, n_bl); 
#line 457
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_vector_mul_i(t1, t2, t1); 
#line 459
fnt(t1, c, log_n + (1), log_n + (1), 3, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 461
}  
#line 463
cudaStreamDestroy(stream); 
#line 465
}  
#line 467
}  
#line 468
} 
#endif
#line 470 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void d_sq_poly_mul(unsigned *a, unsigned *b, unsigned *t1, unsigned *t2, unsigned *c, unsigned log_n, unsigned *
#line 471
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) {int volatile ___ = 1;(void)a;(void)b;(void)t1;(void)t2;(void)c;(void)log_n;(void)d_N_pos;(void)d_root_layer_pow;(void)d_inv;::exit(___);}
#if 0
#line 471
{ 
#line 476
unsigned na = 1 << log_n, nc = na << 1, size_nc = nc * sizeof(unsigned); 
#line 477
if (na <= ALGO_N_2_CUTOFF) 
#line 478
{ 
#line 479
for (unsigned i = (0); i < na; i++) 
#line 480
{ 
#line 481
(t1[i]) = (a[i]); 
#line 482
(t2[i]) = (b[i]); 
#line 483
}  
#line 484
memset(c, 0, size_nc); 
#line 485
for (unsigned i = (0); i < na; i++) { 
#line 486
for (unsigned j = (0); j < na; j++) { 
#line 487
(c[i + j]) = add_mod(c[i + j], mul_mod(t1[i], t2[j])); }  }  
#line 488
} else 
#line 489
{ 
#line 491
memset(t1, 0, size_nc); 
#line 492
memset(t2, 0, size_nc); 
#line 494
d_sq_fnt(a, t1, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv); 
#line 495
d_sq_fnt(b, t2, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv); 
#line 497
d_sq_vector_mul_i(t1, t2, t1, nc); 
#line 499
d_sq_fnt(t1, c, log_n + (1), log_n + (1), 3, d_N_pos, d_root_layer_pow, d_inv); 
#line 501
}  
#line 503
} 
#endif
#line 505 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
inline void h_poly_mul(unsigned *a, unsigned *b, unsigned *t1, unsigned *t2, unsigned *c, unsigned log_n, unsigned *
#line 506
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv, cudaStream_t stream) { 
#line 510
unsigned nc = 1 << (log_n + (1)), size_nc = nc * sizeof(unsigned); 
#line 512
cudaMemsetAsync(t1, 0, size_nc, stream); 
#line 513
cudaMemsetAsync(t2, 0, size_nc, stream); 
#line 515
fnt(a, t1, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 516
fnt(b, t2, log_n, log_n + (1), 0, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 518
unsigned n_th, n_bl; 
#line 519
build_launch_param(log_n + (1), n_th, n_bl); 
#line 520
(__cudaPushCallConfiguration(n_bl, n_th, 0, 0)) ? (void)0 : g_vector_mul_i(t1, t2, t1); 
#line 522
fnt(t1, c, log_n + (1), log_n + (1), 3, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 524
} 
#line 526
void g_poly_deriv(unsigned *ax, unsigned *dax) ;
#if 0
#line 527
{ 
#line 529
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 530
(dax[id]) = mul_mod(ax[id + (1)], id + (1)); 
#line 531
} 
#endif
#line 533 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void d_sq_poly_deriv(unsigned *ax, unsigned *dax, unsigned n) {int volatile ___ = 1;(void)ax;(void)dax;(void)n;::exit(___);}
#if 0
#line 533
{ 
#line 535
for (unsigned i = (0); i < n; i++) { 
#line 536
(dax[i]) = mul_mod(ax[i + (1)], i + (1)); }  
#line 538
} 
#endif
#line 540 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void g_build_product_i(unsigned *p, unsigned *t1, unsigned *t2, unsigned i, unsigned *
#line 541
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) ;
#if 0
#line 542
{ 
#line 544
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 545
unsigned st = id << (i + (1)), len = 1 << i; 
#line 546
d_poly_mul(p + st, (p + st) + len, t1 + st, t2 + st, p + st, i, d_N_pos, d_root_layer_pow, d_inv); 
#line 547
} 
#endif
#line 549 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void h_build_product(unsigned *p, unsigned *t1, unsigned *t2, unsigned log_n1, unsigned log_n2, cudaStream_t stream) 
#line 550
{ 
#line 554
for (unsigned i = log_n1; i < log_n2; i++) 
#line 555
{ 
#line 556
unsigned n_th, n_bl; 
#line 557
build_launch_param((log_n2 - i) - (1), n_th, n_bl); 
#line 558
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_build_product_i(p, t1, t2, i, d_N_pos, d_root_layer_pow, d_inv); 
#line 559
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 559); 
#line 560
}  
#line 561
} 
#line 563
void h_build_ax(unsigned *x, unsigned *p, unsigned *t1, unsigned *t2, cudaStream_t stream) 
#line 564
{ 
#line 569
for (unsigned i = (0); i < NUM_OF_NEED_PACKET; i++) 
#line 570
{ 
#line 571
unsigned st_p1 = i << (LOG_SYMBOL + (1)), st_p2 = (x[i << LOG_SYMBOL]) << 2; 
#line 572
check(cudaMemcpyAsync(p + st_p1, d_packet_product + st_p2, SIZE_ONE_PACKET_PRODUCT, cudaMemcpyDeviceToDevice, stream), "cudaMemcpyAsync(p + st_p1, d_packet_product + st_p2, SIZE_ONE_PACKET_PRODUCT, cudaMemcpyDeviceToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 572); 
#line 573
}  
#line 574
h_build_product(p, t1, t2, LOG_SYMBOL + (1), MAX_LOG, stream); 
#line 575
} 
#line 577
__forceinline void d_sq_build_ax(unsigned *x, unsigned *ax, unsigned *t1, unsigned *t2, unsigned *
#line 578
d_packet_product, unsigned *d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) {int volatile ___ = 1;(void)x;(void)ax;(void)t1;(void)t2;(void)d_packet_product;(void)d_N_pos;(void)d_root_layer_pow;(void)d_inv;::exit(___);}
#if 0
#line 578
{ 
#line 580
for (unsigned i = (0); i < NUM_OF_NEED_PACKET; i++) 
#line 581
{ 
#line 582
unsigned st_p1 = i << (LOG_SYMBOL + (1)), st_p2 = (x[i << LOG_SYMBOL]) << 2; 
#line 583
memcpy(ax + st_p1, d_packet_product + st_p2, SIZE_ONE_PACKET_PRODUCT); 
#line 584
}  
#line 586
for (unsigned i = (LOG_SYMBOL + (1)); i < MAX_LOG; i++) 
#line 587
{ 
#line 588
unsigned m = 1 << ((MAX_LOG - i) - (1)), len = 1 << i; 
#line 589
for (unsigned j = (0); j < m; j++) { 
#line 590
unsigned st = j << (i + (1)); 
#line 591
d_sq_poly_mul(ax + st, (ax + st) + len, t1 + st, t2 + st, ax + st, i, d_N_pos, d_root_layer_pow, d_inv); 
#line 592
}  
#line 593
}  
#line 595
} 
#endif
#line 597 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void g_build_n1(unsigned *n1, unsigned *vdax, unsigned *x, unsigned *y, unsigned *
#line 598
d_inv) ;
#if 0
#line 599
{ 
#line 601
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 602
(n1[id]) = div_mod(y[id], vdax[x[id]], d_inv); 
#line 604
} 
#endif
#line 606 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void d_sq_build_n1(unsigned *n1, unsigned *vdax, unsigned *x, unsigned *y, unsigned n_n1, unsigned *d_inv) {int volatile ___ = 1;(void)n1;(void)vdax;(void)x;(void)y;(void)n_n1;(void)d_inv;::exit(___);}
#if 0
#line 606
{ 
#line 608
for (unsigned i = (0); i < n_n1; i++) { 
#line 609
(n1[i]) = div_mod(y[i], vdax[x[i]], d_inv); }  
#line 611
} 
#endif
#line 613 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void g_build_n2(unsigned *n2, unsigned *n1, unsigned *x) ;
#if 0
#line 613
{ 
#line 615
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 616
(n2[x[id]]) = (n1[id]); 
#line 618
} 
#endif
#line 620 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void d_sq_build_n2(unsigned *n2, unsigned *n1, unsigned *x, unsigned n_n1) {int volatile ___ = 1;(void)n2;(void)n1;(void)x;(void)n_n1;::exit(___);}
#if 0
#line 620
{ 
#line 622
for (unsigned i = (0); i < n_n1; i++) { 
#line 623
(n2[x[i]]) = (n1[i]); }  
#line 625
} 
#endif
#line 627 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void g_build_n3(unsigned *n3, unsigned *p_n3) ;
#if 0
#line 627
{ 
#line 629
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 630
(n3[id]) = sub_mod(0, p_n3[id + (1)]); 
#line 632
} 
#endif
#line 634 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
__forceinline void d_sq_build_n3(unsigned *n3, unsigned *p_n3, unsigned n_n3) {int volatile ___ = 1;(void)n3;(void)p_n3;(void)n_n3;::exit(___);}
#if 0
#line 634
{ 
#line 636
for (unsigned i = (0); i < n_n3; i++) { 
#line 637
(n3[i]) = sub_mod(0, p_n3[i + (1)]); }  
#line 639
} 
#endif
#line 641 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
inline void h_build_px(unsigned *p, unsigned *ax, unsigned *n3, unsigned *t1, unsigned *t2, unsigned *
#line 642
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv, cudaStream_t stream) { 
#line 644
h_poly_mul(ax, n3, t1, t2, p, MAX_LOG - (1), d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 645
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 645); 
#line 647
} 
#line 649
__forceinline void d_sq_build_px(unsigned *p, unsigned *ax, unsigned *n3, unsigned *t1, unsigned *t2, unsigned *t3, unsigned *
#line 650
d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) {int volatile ___ = 1;(void)p;(void)ax;(void)n3;(void)t1;(void)t2;(void)t3;(void)d_N_pos;(void)d_root_layer_pow;(void)d_inv;::exit(___);}
#if 0
#line 650
{ 
#line 652
d_sq_poly_mul(ax, n3, t1, t2, t3, MAX_LOG - (1), d_N_pos, d_root_layer_pow, d_inv); 
#line 653
memcpy(p, t3, SIZE_SMALL); 
#line 655
} 
#endif
#line 657 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void h_encode(unsigned *p, unsigned *y) 
#line 658
{ 
#line 660
cudaStream_t stream; 
#line 661
check(cudaStreamCreate(&stream), "cudaStreamCreate(&stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 661); 
#line 663
unsigned *d_p; 
#line 664
unsigned *d_y; 
#line 665
check(cudaMallocAsync(&d_p, SIZE_SMALL, stream), "cudaMallocAsync(&d_p, SIZE_SMALL, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 665); 
#line 666
check(cudaMallocAsync(&d_y, SIZE_LARGE, stream), "cudaMallocAsync(&d_y, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 666); 
#line 667
check(cudaMemcpyAsync(d_p, p, SIZE_SMALL, cudaMemcpyHostToDevice, stream), "cudaMemcpyAsync(d_p, p, SIZE_SMALL, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 667); 
#line 668
check(cudaMemsetAsync(d_y, 0, SIZE_LARGE, stream), "cudaMemsetAsync(d_y, 0, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 668); 
#line 670
fnt(d_p, d_y, MAX_LOG - (1), MAX_LOG, 0, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 671
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 671); 
#line 673
check(cudaMemcpyAsync(y, d_y, SIZE_LARGE, cudaMemcpyDeviceToHost, stream), "cudaMemcpyAsync(y, d_y, SIZE_LARGE, cudaMemcpyDeviceToHost, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 673); 
#line 675
check(cudaFreeAsync(d_p, stream), "cudaFreeAsync(d_p, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 675); 
#line 676
check(cudaFreeAsync(d_y, stream), "cudaFreeAsync(d_y, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 676); 
#line 678
check(cudaStreamDestroy(stream), "cudaStreamDestroy(stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 678); 
#line 680
} 
#line 682
void g_encode_batch(unsigned *ps, unsigned *ys, unsigned *d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) ;
#if 0
#line 682
{ 
#line 684
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 685
unsigned offset_p = id * LEN_ENCODE_P; 
#line 686
unsigned offset_y = id * LEN_ENCODE_Y; 
#line 687
unsigned *p = ps + offset_p; 
#line 688
unsigned *y = ys + offset_y; 
#line 690
memset(y, 0, SIZE_LARGE); 
#line 691
d_sq_fnt(p, y, MAX_LOG - (1), MAX_LOG, 0, d_N_pos, d_root_layer_pow, d_inv); 
#line 693
} 
#endif
#line 695 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void h_encode_batch(unsigned *ps, unsigned *ys) { 
#line 697
cudaStream_t stream; 
#line 698
check(cudaStreamCreate(&stream), "cudaStreamCreate(&stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 698); 
#line 700
unsigned slot_id = pop_slot(encode_batch_slot, mt_encode_slot, cv_encode_slot); 
#line 701
unsigned *sl_ps = h_encode_p_batch_slot[slot_id]; 
#line 702
unsigned *sl_ys = h_encode_y_batch_slot[slot_id]; 
#line 704
memcpy(sl_ps, ps, SIZE_ENCODE_P_BATCH); 
#line 706
unsigned *d_ps = d_encode_p_batch_slot + ((1i64 * slot_id) * LEN_ENCODE_P_BATCH); 
#line 707
unsigned *d_ys = d_encode_y_batch_slot + ((1i64 * slot_id) * LEN_ENCODE_Y_BATCH); 
#line 708
check(cudaMemcpyAsync(d_ps, sl_ps, SIZE_ENCODE_P_BATCH, cudaMemcpyHostToDevice, stream), "cudaMemcpyAsync(d_ps, sl_ps, SIZE_ENCODE_P_BATCH, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 708); 
#line 710
(__cudaPushCallConfiguration(1, LEN_BATCH, 0, stream)) ? (void)0 : g_encode_batch(d_ps, d_ys, d_N_pos, d_root_layer_pow, d_inv); 
#line 711
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 711); 
#line 713
check(cudaMemcpyAsync(sl_ys, d_ys, SIZE_ENCODE_Y_BATCH, cudaMemcpyDeviceToHost, stream), "cudaMemcpyAsync(sl_ys, d_ys, SIZE_ENCODE_Y_BATCH, cudaMemcpyDeviceToHost, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 713); 
#line 715
CB_DATA *data = new CB_DATA{slot_id, ys, sl_ys, SIZE_ENCODE_Y_BATCH, encode_batch_slot, mt_encode_slot, cv_encode_slot}; 
#line 716
check(cudaLaunchHostFunc(stream, h_end_batch_slot, data), "cudaLaunchHostFunc(stream, h_end_batch_slot, data)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 716); 
#line 718
check(cudaStreamDestroy(stream), "cudaStreamDestroy(stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 718); 
#line 721
} 
#line 723
void h_decode(unsigned *x, unsigned *y, unsigned *p) 
#line 724
{ 
#line 726
cudaStream_t stream; 
#line 727
check(cudaStreamCreate(&stream), "cudaStreamCreate(&stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 727); 
#line 729
unsigned n_th, n_bl; 
#line 730
build_launch_param(MAX_LOG - (1), n_th, n_bl); 
#line 732
unsigned *t1; 
#line 733
unsigned *t2; 
#line 734
check(cudaMallocAsync(&t1, SIZE_LARGE, stream), "cudaMallocAsync(&t1, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 734); 
#line 735
check(cudaMallocAsync(&t2, SIZE_LARGE, stream), "cudaMallocAsync(&t2, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 735); 
#line 737
unsigned *ax; 
#line 738
check(cudaMallocAsync(&ax, SIZE_LARGE, stream), "cudaMallocAsync(&ax, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 738); 
#line 739
h_build_ax(x, ax, t1, t2, stream); 
#line 741
unsigned *dax; 
#line 742
check(cudaMallocAsync(&dax, SIZE_SMALL, stream), "cudaMallocAsync(&dax, SIZE_SMALL, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 742); 
#line 743
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_poly_deriv(ax, dax); 
#line 744
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 744); 
#line 746
unsigned *vdax; 
#line 747
check(cudaMallocAsync(&vdax, SIZE_LARGE, stream), "cudaMallocAsync(&vdax, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 747); 
#line 748
check(cudaMemsetAsync(vdax, 0, SIZE_LARGE, stream), "cudaMemsetAsync(vdax, 0, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 748); 
#line 749
fnt(dax, vdax, MAX_LOG - (1), MAX_LOG, 0, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 750
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 750); 
#line 752
unsigned *n1; 
#line 753
check(cudaMallocAsync(&n1, SIZE_SMALL, stream), "cudaMallocAsync(&n1, SIZE_SMALL, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 753); 
#line 754
check(cudaMemcpyAsync(t1, x, SIZE_SMALL, cudaMemcpyHostToDevice, stream), "cudaMemcpyAsync(t1, x, SIZE_SMALL, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 754); 
#line 755
check(cudaMemcpyAsync(t2, y, SIZE_SMALL, cudaMemcpyHostToDevice, stream), "cudaMemcpyAsync(t2, y, SIZE_SMALL, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 755); 
#line 756
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_build_n1(n1, vdax, t1, t2, d_inv); 
#line 757
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 757); 
#line 759
unsigned *n2; 
#line 760
unsigned *n3; 
#line 761
check(cudaMallocAsync(&n2, SIZE_LARGE, stream), "cudaMallocAsync(&n2, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 761); 
#line 762
check(cudaMallocAsync(&n3, SIZE_SMALL, stream), "cudaMallocAsync(&n3, SIZE_SMALL, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 762); 
#line 764
check(cudaMemsetAsync(n2, 0, SIZE_LARGE, stream), "cudaMemsetAsync(n2, 0, SIZE_LARGE, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 764); 
#line 765
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_build_n2(n2, n1, t1); 
#line 766
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 766); 
#line 768
fnt(n2, t2, MAX_LOG, MAX_LOG, 2, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 769
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 769); 
#line 770
(__cudaPushCallConfiguration(n_bl, n_th, 0, stream)) ? (void)0 : g_build_n3(n3, t2); 
#line 771
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 771); 
#line 773
h_build_px(n2, ax, n3, t1, t2, d_N_pos, d_root_layer_pow, d_inv, stream); 
#line 774
check(cudaMemcpyAsync(p, n2, SIZE_SMALL, cudaMemcpyDeviceToHost, stream), "cudaMemcpyAsync(p, n2, SIZE_SMALL, cudaMemcpyDeviceToHost, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 774); 
#line 776
check(cudaFreeAsync(t1, stream), "cudaFreeAsync(t1, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 776); 
#line 777
check(cudaFreeAsync(t2, stream), "cudaFreeAsync(t2, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 777); 
#line 778
check(cudaFreeAsync(ax, stream), "cudaFreeAsync(ax, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 778); 
#line 779
check(cudaFreeAsync(dax, stream), "cudaFreeAsync(dax, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 779); 
#line 780
check(cudaFreeAsync(vdax, stream), "cudaFreeAsync(vdax, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 780); 
#line 781
check(cudaFreeAsync(n1, stream), "cudaFreeAsync(n1, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 781); 
#line 782
check(cudaFreeAsync(n2, stream), "cudaFreeAsync(n2, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 782); 
#line 783
check(cudaFreeAsync(n3, stream), "cudaFreeAsync(n3, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 783); 
#line 785
check(cudaStreamDestroy(stream), "cudaStreamDestroy(stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 785); 
#line 787
} 
#line 789
void g_decode_batch(unsigned *xs, unsigned *ys, unsigned *ps, unsigned *
#line 790
t1s, unsigned *t2s, unsigned *axs, unsigned *daxs, unsigned *vdaxs, unsigned *n1s, unsigned *n2s, unsigned *n3s, unsigned *
#line 791
d_packet_product, unsigned *d_N_pos, unsigned *d_root_layer_pow, unsigned *d_inv) ;
#if 0
#line 791
{ 
#line 793
unsigned id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 794
unsigned offset_x = id * LEN_DECODE_X; 
#line 795
unsigned offset_y = id * LEN_DECODE_Y; 
#line 796
unsigned offset_p = id * LEN_DECODE_P; 
#line 797
unsigned offset_t1 = id * LEN_LARGE; 
#line 798
unsigned offset_t2 = id * LEN_LARGE; 
#line 799
unsigned offset_ax = id * LEN_LARGE; 
#line 800
unsigned offset_dax = id * LEN_SMALL; 
#line 801
unsigned offset_vdax = id * LEN_LARGE; 
#line 802
unsigned offset_n1 = id * LEN_SMALL; 
#line 803
unsigned offset_n2 = id * LEN_LARGE; 
#line 804
unsigned offset_n3 = id * LEN_SMALL; 
#line 806
unsigned *x = xs + offset_x; 
#line 807
unsigned *y = ys + offset_y; 
#line 808
unsigned *p = ps + offset_p; 
#line 809
unsigned *t1 = t1s + offset_t1; 
#line 810
unsigned *t2 = t2s + offset_t2; 
#line 811
unsigned *ax = axs + offset_ax; 
#line 812
unsigned *dax = daxs + offset_dax; 
#line 813
unsigned *vdax = vdaxs + offset_vdax; 
#line 814
unsigned *n1 = n1s + offset_n1; 
#line 815
unsigned *n2 = n2s + offset_n2; 
#line 816
unsigned *n3 = n3s + offset_n3; 
#line 818
d_sq_build_ax(x, ax, t1, t2, d_packet_product, d_N_pos, d_root_layer_pow, d_inv); 
#line 820
d_sq_poly_deriv(ax, dax, NUM_OF_NEED_SYMBOL); 
#line 822
memset(vdax, 0, SIZE_LARGE); 
#line 824
d_sq_fnt(dax, vdax, MAX_LOG - (1), MAX_LOG, 0, d_N_pos, d_root_layer_pow, d_inv); 
#line 826
d_sq_build_n1(n1, vdax, x, y, NUM_OF_NEED_SYMBOL, d_inv); 
#line 828
memset(n2, 0, SIZE_LARGE); 
#line 830
d_sq_build_n2(n2, n1, x, NUM_OF_NEED_SYMBOL); 
#line 832
d_sq_fnt(n2, t2, MAX_LOG, MAX_LOG, 2, d_N_pos, d_root_layer_pow, d_inv); 
#line 834
d_sq_build_n3(n3, t2, NUM_OF_NEED_SYMBOL); 
#line 836
d_sq_build_px(p, ax, n3, t1, t2, n2, d_N_pos, d_root_layer_pow, d_inv); 
#line 838
} 
#endif
#line 840 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
void h_decode_batch(unsigned *xs, unsigned *ys, unsigned *ps) { 
#line 842
cudaStream_t stream; 
#line 843
check(cudaStreamCreate(&stream), "cudaStreamCreate(&stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 843); 
#line 845
unsigned slot_id = pop_slot(decode_batch_slot, mt_decode_slot, cv_decode_slot); 
#line 846
unsigned *sl_xs = h_decode_x_batch_slot[slot_id]; 
#line 847
unsigned *sl_ys = h_decode_y_batch_slot[slot_id]; 
#line 848
unsigned *sl_ps = h_decode_p_batch_slot[slot_id]; 
#line 850
memcpy(sl_xs, xs, SIZE_DECODE_X_BATCH); 
#line 851
memcpy(sl_ys, ys, SIZE_DECODE_Y_BATCH); 
#line 853
unsigned *d_xs = d_decode_x_batch_slot + ((1i64 * slot_id) * LEN_DECODE_X_BATCH); 
#line 854
unsigned *d_ys = d_decode_y_batch_slot + ((1i64 * slot_id) * LEN_DECODE_Y_BATCH); 
#line 855
unsigned *d_ps = d_decode_p_batch_slot + ((1i64 * slot_id) * LEN_DECODE_P_BATCH); 
#line 856
unsigned *d_t1s = d_decode_t1_batch_slot + ((1i64 * slot_id) * LEN_LARGE_BATCH); 
#line 857
unsigned *d_t2s = d_decode_t2_batch_slot + ((1i64 * slot_id) * LEN_LARGE_BATCH); 
#line 858
unsigned *d_axs = d_decode_ax_batch_slot + ((1i64 * slot_id) * LEN_LARGE_BATCH); 
#line 859
unsigned *d_daxs = d_decode_dax_batch_slot + ((1i64 * slot_id) * LEN_SMALL_BATCH); 
#line 860
unsigned *d_vdaxs = d_decode_vdax_batch_slot + ((1i64 * slot_id) * LEN_LARGE_BATCH); 
#line 861
unsigned *d_n1s = d_decode_n1_batch_slot + ((1i64 * slot_id) * LEN_SMALL_BATCH); 
#line 862
unsigned *d_n2s = d_decode_n2_batch_slot + ((1i64 * slot_id) * LEN_LARGE_BATCH); 
#line 863
unsigned *d_n3s = d_decode_n3_batch_slot + ((1i64 * slot_id) * LEN_SMALL_BATCH); 
#line 865
check(cudaMemcpyAsync(d_xs, sl_xs, SIZE_DECODE_X_BATCH, cudaMemcpyHostToDevice, stream), "cudaMemcpyAsync(d_xs, sl_xs, SIZE_DECODE_X_BATCH, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 865); 
#line 866
check(cudaMemcpyAsync(d_ys, sl_ys, SIZE_DECODE_Y_BATCH, cudaMemcpyHostToDevice, stream), "cudaMemcpyAsync(d_ys, sl_ys, SIZE_DECODE_Y_BATCH, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 866); 
#line 868
(__cudaPushCallConfiguration(1, LEN_BATCH, 0, stream)) ? (void)0 : g_decode_batch(d_xs, d_ys, d_ps, d_t1s, d_t2s, d_axs, d_daxs, d_vdaxs, d_n1s, d_n2s, d_n3s, d_packet_product, d_N_pos, d_root_layer_pow, d_inv); 
#line 871
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 871); 
#line 873
check(cudaMemcpyAsync(sl_ps, d_ps, SIZE_DECODE_P_BATCH, cudaMemcpyDeviceToHost, stream), "cudaMemcpyAsync(sl_ps, d_ps, SIZE_DECODE_P_BATCH, cudaMemcpyDeviceToHost, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 873); 
#line 875
CB_DATA *data = new CB_DATA{slot_id, ps, sl_ps, SIZE_DECODE_P_BATCH, decode_batch_slot, mt_decode_slot, cv_decode_slot}; 
#line 876
check(cudaLaunchHostFunc(stream, h_end_batch_slot, data), "cudaLaunchHostFunc(stream, h_end_batch_slot, data)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 876); 
#line 878
check(cudaStreamDestroy(stream), "cudaStreamDestroy(stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 878); 
#line 880
} 
#line 882
void init() 
#line 883
{ 
#line 886
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 886); 
#line 887
check(cudaDeviceReset(), "cudaDeviceReset()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 887); 
#line 889
h_encode_p_batch_slot = ((unsigned **)malloc(MAX_ACTIVE_ENCODE_BATCH * sizeof(unsigned *))); 
#line 890
h_encode_y_batch_slot = ((unsigned **)malloc(MAX_ACTIVE_ENCODE_BATCH * sizeof(unsigned *))); 
#line 891
h_decode_x_batch_slot = ((unsigned **)malloc(MAX_ACTIVE_DECODE_BATCH * sizeof(unsigned *))); 
#line 892
h_decode_y_batch_slot = ((unsigned **)malloc(MAX_ACTIVE_DECODE_BATCH * sizeof(unsigned *))); 
#line 893
h_decode_p_batch_slot = ((unsigned **)malloc(MAX_ACTIVE_DECODE_BATCH * sizeof(unsigned *))); 
#line 895
for (unsigned i = (0); i < MAX_ACTIVE_ENCODE_BATCH; i++) { 
#line 896
check(cudaMallocHost(&(h_encode_p_batch_slot[i]), SIZE_ENCODE_P_BATCH), "cudaMallocHost(&(h_encode_p_batch_slot[i]), SIZE_ENCODE_P_BATCH)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 896); 
#line 897
check(cudaMallocHost(&(h_encode_y_batch_slot[i]), SIZE_ENCODE_Y_BATCH), "cudaMallocHost(&(h_encode_y_batch_slot[i]), SIZE_ENCODE_Y_BATCH)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 897); 
#line 898
}  
#line 900
for (unsigned i = (0); i < MAX_ACTIVE_ENCODE_BATCH; i++) { 
#line 901
check(cudaMallocHost(&(h_decode_x_batch_slot[i]), SIZE_DECODE_X_BATCH), "cudaMallocHost(&(h_decode_x_batch_slot[i]), SIZE_DECODE_X_BATCH)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 901); 
#line 902
check(cudaMallocHost(&(h_decode_y_batch_slot[i]), SIZE_DECODE_Y_BATCH), "cudaMallocHost(&(h_decode_y_batch_slot[i]), SIZE_DECODE_Y_BATCH)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 902); 
#line 903
check(cudaMallocHost(&(h_decode_p_batch_slot[i]), SIZE_DECODE_P_BATCH), "cudaMallocHost(&(h_decode_p_batch_slot[i]), SIZE_DECODE_P_BATCH)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 903); 
#line 904
}  
#line 906
check(cudaMalloc(&d_encode_p_batch_slot, SIZE_ENCODE_P_BATCH_SLOT), "cudaMalloc(&d_encode_p_batch_slot, SIZE_ENCODE_P_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 906); 
#line 907
check(cudaMalloc(&d_encode_y_batch_slot, SIZE_ENCODE_Y_BATCH_SLOT), "cudaMalloc(&d_encode_y_batch_slot, SIZE_ENCODE_Y_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 907); 
#line 909
check(cudaMalloc(&d_decode_x_batch_slot, SIZE_DECODE_X_BATCH_SLOT), "cudaMalloc(&d_decode_x_batch_slot, SIZE_DECODE_X_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 909); 
#line 910
check(cudaMalloc(&d_decode_y_batch_slot, SIZE_DECODE_Y_BATCH_SLOT), "cudaMalloc(&d_decode_y_batch_slot, SIZE_DECODE_Y_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 910); 
#line 911
check(cudaMalloc(&d_decode_p_batch_slot, SIZE_DECODE_P_BATCH_SLOT), "cudaMalloc(&d_decode_p_batch_slot, SIZE_DECODE_P_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 911); 
#line 912
check(cudaMalloc(&d_decode_t1_batch_slot, SIZE_DECODE_T1_BATCH_SLOT), "cudaMalloc(&d_decode_t1_batch_slot, SIZE_DECODE_T1_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 912); 
#line 913
check(cudaMalloc(&d_decode_t2_batch_slot, SIZE_DECODE_T2_BATCH_SLOT), "cudaMalloc(&d_decode_t2_batch_slot, SIZE_DECODE_T2_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 913); 
#line 914
check(cudaMalloc(&d_decode_ax_batch_slot, SIZE_DECODE_AX_BATCH_SLOT), "cudaMalloc(&d_decode_ax_batch_slot, SIZE_DECODE_AX_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 914); 
#line 915
check(cudaMalloc(&d_decode_dax_batch_slot, SIZE_DECODE_DAX_BATCH_SLOT), "cudaMalloc(&d_decode_dax_batch_slot, SIZE_DECODE_DAX_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 915); 
#line 916
check(cudaMalloc(&d_decode_vdax_batch_slot, SIZE_DECODE_VDAX_BATCH_SLOT), "cudaMalloc(&d_decode_vdax_batch_slot, SIZE_DECODE_VDAX_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 916); 
#line 917
check(cudaMalloc(&d_decode_n1_batch_slot, SIZE_DECODE_N1_BATCH_SLOT), "cudaMalloc(&d_decode_n1_batch_slot, SIZE_DECODE_N1_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 917); 
#line 918
check(cudaMalloc(&d_decode_n2_batch_slot, SIZE_DECODE_N2_BATCH_SLOT), "cudaMalloc(&d_decode_n2_batch_slot, SIZE_DECODE_N2_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 918); 
#line 919
check(cudaMalloc(&d_decode_n3_batch_slot, SIZE_DECODE_N3_BATCH_SLOT), "cudaMalloc(&d_decode_n3_batch_slot, SIZE_DECODE_N3_BATCH_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 919); 
#line 921
init_batch_slot(); 
#line 923
unsigned size_N_pos = (LEN_N_POS * sizeof(unsigned)); 
#line 924
unsigned *N_pos = (unsigned *)malloc(size_N_pos); 
#line 925
check(cudaMalloc(&d_N_pos, size_N_pos), "cudaMalloc(&d_N_pos, size_N_pos)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 925); 
#line 927
for (unsigned i = (1); i <= MAX_LOG; i++) 
#line 928
{ 
#line 929
unsigned n = 1 << i, st = n - (1); 
#line 930
for (unsigned j = (0); j < n; j++) { 
#line 931
(N_pos[st + j]) = j; }  
#line 932
}  
#line 934
for (unsigned i = (1); i <= MAX_LOG; i++) 
#line 935
{ 
#line 936
unsigned n = 1 << i, st = n - (1); 
#line 937
for (unsigned j = (0); j < n; j++) 
#line 938
{ 
#line 939
unsigned rev_num = (0); 
#line 940
for (unsigned k = (0); k < i; k++) 
#line 941
{ 
#line 942
if (j & (1 << k)) { 
#line 943
rev_num |= (1 << ((i - (1)) - k)); }  
#line 944
}  
#line 945
if (j < rev_num) { 
#line 946
std::swap(N_pos[st + j], N_pos[st + rev_num]); }  
#line 947
}  
#line 948
}  
#line 950
check(cudaMemcpy(d_N_pos, N_pos, size_N_pos, cudaMemcpyHostToDevice), "cudaMemcpy(d_N_pos, N_pos, size_N_pos, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 950); 
#line 951
free(N_pos); 
#line 953
unsigned size_root = (MOD * sizeof(unsigned)); 
#line 954
unsigned *root_pow = (unsigned *)malloc(size_root); 
#line 955
unsigned *root_inv_pow = (unsigned *)malloc(size_root); 
#line 956
unsigned *inv = (unsigned *)malloc(size_root); 
#line 957
check(cudaMalloc(&d_root_pow, size_root), "cudaMalloc(&d_root_pow, size_root)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 957); 
#line 958
check(cudaMalloc(&d_root_inv_pow, size_root), "cudaMalloc(&d_root_inv_pow, size_root)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 958); 
#line 959
check(cudaMalloc(&d_inv, size_root), "cudaMalloc(&d_inv, size_root)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 959); 
#line 961
(((root_pow[0]) = (1)), ((root_inv_pow[0]) = (1))), ((inv[0]) = (0)); 
#line 962
for (unsigned i = (1); i < MOD; i++) 
#line 963
{ 
#line 964
(root_pow[i]) = mul_mod(root_pow[i - (1)], ROOT); 
#line 965
(root_inv_pow[i]) = mul_mod(root_inv_pow[i - (1)], ROOT_INV); 
#line 966
(inv[i]) = pow_mod(i, MOD - (2)); 
#line 967
}  
#line 969
check(cudaMemcpy(d_root_pow, root_pow, size_root, cudaMemcpyHostToDevice), "cudaMemcpy(d_root_pow, root_pow, size_root, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 969); 
#line 970
check(cudaMemcpy(d_root_inv_pow, root_inv_pow, size_root, cudaMemcpyHostToDevice), "cudaMemcpy(d_root_inv_pow, root_inv_pow, size_root, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 970); 
#line 971
check(cudaMemcpy(d_inv, inv, size_root, cudaMemcpyHostToDevice), "cudaMemcpy(d_inv, inv, size_root, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 971); 
#line 973
unsigned size_root_layer_pow = (LEN_ROOT_LAYER_POW_2 * sizeof(unsigned)); 
#line 974
unsigned *root_layer_pow = (unsigned *)malloc(size_root_layer_pow); 
#line 975
check(cudaMalloc(&d_root_layer_pow, size_root_layer_pow), "cudaMalloc(&d_root_layer_pow, size_root_layer_pow)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 975); 
#line 977
for (unsigned i = (0); i < (2); i++) 
#line 978
{ 
#line 979
unsigned st_i = LEN_ROOT_LAYER_POW * i; 
#line 980
for (unsigned j = (0); j < MAX_LOG; j++) 
#line 981
{ 
#line 982
unsigned haft_len = 1 << j; 
#line 983
unsigned st_j = haft_len - (1); 
#line 984
unsigned ang = 1 << ((MAX_LOG - j) - (1)); 
#line 985
unsigned wn = (i) ? root_inv_pow[ang] : (root_pow[ang]), w = (1); 
#line 986
for (unsigned k = (0); k < haft_len; k++) 
#line 987
{ 
#line 988
(root_layer_pow[(st_i + st_j) + k]) = w; 
#line 989
w = mul_mod(w, wn); 
#line 990
}  
#line 991
}  
#line 992
}  
#line 994
check(cudaMemcpy(d_root_layer_pow, root_layer_pow, size_root_layer_pow, cudaMemcpyHostToDevice), "cudaMemcpy(d_root_layer_pow, root_layer_pow, size_root_layer_pow, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 994); 
#line 995
free(root_layer_pow); 
#line 997
unsigned size_packet_product = (LEN_PACKET_PRODUCT * sizeof(unsigned)); 
#line 998
unsigned *packet_product = (unsigned *)malloc(size_packet_product); 
#line 999
check(cudaMalloc(&d_packet_product, size_packet_product), "cudaMalloc(&d_packet_product, size_packet_product)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 999); 
#line 1001
for (unsigned i = (0); i < NUM_OF_PACKET; i++) 
#line 1002
{ 
#line 1003
unsigned st = i << (LOG_SYMBOL + (1)); 
#line 1004
for (unsigned j = (0); j < SEG_PER_PACKET; j++) 
#line 1005
{ 
#line 1006
unsigned k = (i << LOG_SEG) + j; 
#line 1007
(packet_product[st + (j << 1)]) = sub_mod(0, root_pow[k]); 
#line 1008
(packet_product[st + ((j << 1) | (1))]) = (1); 
#line 1009
(packet_product[st + ((j + SEG_PER_PACKET) << 1)]) = sub_mod(0, root_pow[k + SEG_DIFF]); 
#line 1010
(packet_product[st + (((j + SEG_PER_PACKET) << 1) | (1))]) = (1); 
#line 1011
}  
#line 1012
}  
#line 1013
check(cudaMemcpy(d_packet_product, packet_product, size_packet_product, cudaMemcpyHostToDevice), "cudaMemcpy(d_packet_product, packet_product, size_packet_product, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1013); 
#line 1014
free(packet_product); 
#line 1015
unsigned *tmp; 
#line 1016
check(cudaMalloc(&tmp, (LEN_ONE_PACKET_PRODUCT << 1) * sizeof(unsigned)), "cudaMalloc(&tmp, (LEN_ONE_PACKET_PRODUCT << 1) * sizeof(unsigned))", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1016); 
#line 1017
for (unsigned i = (0); i < NUM_OF_PACKET; i++) 
#line 1018
{ 
#line 1019
unsigned st = i << (LOG_SYMBOL + (1)); 
#line 1020
h_build_product(d_packet_product + st, tmp, tmp + LEN_ONE_PACKET_PRODUCT, 1, LOG_SYMBOL + (1), 0); 
#line 1021
}  
#line 1022
check(cudaFree(tmp), "cudaFree(tmp)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1022); 
#line 1023
free(inv); 
#line 1024
free(root_pow); 
#line 1025
free(root_inv_pow); 
#line 1027
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1027); 
#line 1028
(((std::cout << ("Init process completed!"))) << (std::endl)); 
#line 1030
} 
#line 1032
void fin() 
#line 1033
{ 
#line 1036
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1036); 
#line 1038
for (unsigned i = (0); i < MAX_ACTIVE_ENCODE_BATCH; i++) { 
#line 1039
check(cudaFreeHost(h_encode_p_batch_slot[i]), "cudaFreeHost(h_encode_p_batch_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1039); 
#line 1040
check(cudaFreeHost(h_encode_y_batch_slot[i]), "cudaFreeHost(h_encode_y_batch_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1040); 
#line 1041
}  
#line 1043
for (unsigned i = (0); i < MAX_ACTIVE_DECODE_BATCH; i++) { 
#line 1044
check(cudaFreeHost(h_decode_x_batch_slot[i]), "cudaFreeHost(h_decode_x_batch_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1044); 
#line 1045
check(cudaFreeHost(h_decode_y_batch_slot[i]), "cudaFreeHost(h_decode_y_batch_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1045); 
#line 1046
check(cudaFreeHost(h_decode_p_batch_slot[i]), "cudaFreeHost(h_decode_p_batch_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1046); 
#line 1047
}  
#line 1049
free(h_encode_p_batch_slot); 
#line 1050
free(h_encode_y_batch_slot); 
#line 1051
free(h_decode_x_batch_slot); 
#line 1052
free(h_decode_y_batch_slot); 
#line 1053
free(h_decode_p_batch_slot); 
#line 1055
check(cudaGetLastError(), "cudaGetLastError()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1055); 
#line 1057
check(cudaDeviceReset(), "cudaDeviceReset()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1057); 
#line 1058
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1058); 
#line 1060
} 
#line 1062
void test_fnt(); 
#line 1064
void test_poly_mul(); 
#line 1066
void test_build_init_product(); 
#line 1068
void test_encode_decode(); 
#line 1070
void test_encode_decode_batch(); 
#line 1072
void test_fnt_performance(); 
#line 1074
void test_encode_decode_performance(); 
#line 1076
int main() 
#line 1077
{ 
#line 1079
init(); 
#line 1093
test_encode_decode_performance(); 
#line 1095
fin(); 
#line 1097
return 0; 
#line 1098
} 
#line 1100
void test_fnt() { 
#line 1104
unsigned N_test = (32); 
#line 1106
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1107
unsigned log_nc = (15), log_nv = (16), nc = 1 << log_nc, nv = 1 << log_nv; 
#line 1108
unsigned size_nc = nc * sizeof(unsigned), size_nv = nv * sizeof(unsigned); 
#line 1109
std::vector< unsigned>  c1(nc), c2(nc); 
#line 1110
unsigned *d_c1, *d_c2, *d_v; 
#line 1111
cudaMalloc(&d_c1, size_nc); 
#line 1112
cudaMemset(d_c1, 0, size_nc); 
#line 1113
cudaMalloc(&d_c2, size_nv); 
#line 1114
cudaMemset(d_c2, 0, size_nv); 
#line 1115
cudaMalloc(&d_v, size_nv); 
#line 1116
cudaMemset(d_v, 0, size_nv); 
#line 1118
for (unsigned i = (0); i < nc; i++) { 
#line 1119
c1[i] = ((rand()) % (MOD - (1))); }  
#line 1120
shuffle(c1.begin(), c1.end(), ((std::mersenne_twister_engine< unsigned, 32Ui64, 624Ui64, 397Ui64, 31Ui64, 2567483615U, 11Ui64, 4294967295U, 7Ui64, 2636928640U, 15Ui64, 4022730752U, 18Ui64, 1812433253U> )(time(0)))); 
#line 1121
cudaMemcpy(d_c1, c1.data(), size_nc, cudaMemcpyHostToDevice); 
#line 1123
fnt(d_c1, d_v, log_nc, log_nv, 0, d_N_pos, d_root_layer_pow, d_inv, 0); 
#line 1124
fnt(d_v, d_c2, log_nv, log_nv, 3, d_N_pos, d_root_layer_pow, d_inv, 0); 
#line 1126
cudaMemcpy(c2.data(), d_c2, size_nc, cudaMemcpyDeviceToHost); 
#line 1127
for (unsigned i = (0); i < nc; i++) { 
#line 1128
(void)0; }  
#line 1130
cudaFree(d_c1); 
#line 1131
cudaFree(d_c2); 
#line 1132
cudaFree(d_v); 
#line 1136
}  
#line 1138
(((std::cout << ("FNT test passed!"))) << (std::endl)); 
#line 1140
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1140); 
#line 1142
} 
#line 1144
void test_build_init_product() { 
#line 1147
std::vector< unsigned>  a1 = {(64375), (0), (52012), (0), (2347), (0), (23649), (0), (30899), (0)}, b1(10); 
#line 1148
cudaMemcpy(b1.data(), d_packet_product, (10) * sizeof(unsigned), cudaMemcpyDeviceToHost); 
#line 1150
for (unsigned i = (0); i < (10); i++) { 
#line 1151
(void)0; }  
#line 1154
std::vector< unsigned>  a2 = {(64375), (0), (31561), (0), (12153), (0), (31103), (0), (20714), (0)}, b2(10); 
#line 1155
cudaMemcpy(b2.data(), d_packet_product + (1 << (LOG_SYMBOL + (1))), (10) * sizeof(unsigned), cudaMemcpyDeviceToHost); 
#line 1157
for (unsigned i = (0); i < (10); i++) { 
#line 1158
(void)0; }  
#line 1160
(((std::cout << ("Test packet_product passed!"))) << (std::endl)); 
#line 1162
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1162); 
#line 1164
} 
#line 1166
void test_poly_mul() { 
#line 1170
srand(time(0)); 
#line 1172
unsigned N_test = (32); 
#line 1174
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1176
unsigned log_n = (11); 
#line 1177
unsigned n = 1 << log_n, size_n = n * sizeof(unsigned); 
#line 1179
std::vector< unsigned>  a(n), b(n), c1(n << 1, 0), c2(n << 1, 0); 
#line 1181
for (unsigned i = (0); i < n; i++) { 
#line 1182
a[i] = ((rand()) % (MOD - (1))); 
#line 1183
b[i] = ((rand()) % (MOD - (1))); 
#line 1184
}  
#line 1186
unsigned *t1, *t2, *d_c; 
#line 1187
cudaMalloc(&t1, size_n << 1); 
#line 1188
cudaMalloc(&t2, size_n << 1); 
#line 1189
cudaMalloc(&d_c, size_n << 1); 
#line 1190
cudaMemcpy(d_c, a.data(), size_n, cudaMemcpyHostToDevice); 
#line 1191
cudaMemcpy(d_c + n, b.data(), size_n, cudaMemcpyHostToDevice); 
#line 1192
h_poly_mul(d_c, d_c + n, t1, t2, d_c, log_n, d_N_pos, d_root_layer_pow, d_inv, 0); 
#line 1194
for (unsigned i = (0); i < n; i++) { 
#line 1195
for (unsigned j = (0); j < n; j++) { 
#line 1196
c1[i + j] = add_mod(c1[i + j], mul_mod(a[i], b[j])); }  }  
#line 1205
cudaMemcpy(c2.data(), d_c, size_n << 1, cudaMemcpyDeviceToHost); 
#line 1207
for (unsigned i = (0); i < (n << 1); i++) { 
#line 1208
(void)0; }  
#line 1212
cudaFree(t1); 
#line 1213
cudaFree(t2); 
#line 1214
cudaFree(d_c); 
#line 1216
}  
#line 1218
(((std::cout << ("Poly mul test passed!"))) << (std::endl)); 
#line 1220
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1220); 
#line 1222
} 
#line 1224
void test_encode_decode() { 
#line 1228
srand(time(0)); 
#line 1230
unsigned N_test = (32); 
#line 1232
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1233
std::vector< unsigned>  a(NUM_OF_NEED_SYMBOL), b(NUM_OF_NEED_SYMBOL << 1), c(NUM_OF_NEED_SYMBOL); 
#line 1235
for (unsigned i = (0); i < NUM_OF_NEED_SYMBOL; i++) { 
#line 1236
a[i] = ((rand()) % (MOD - (1))); }  
#line 1238
h_encode(a.data(), b.data()); 
#line 1240
std::vector< unsigned>  x(NUM_OF_NEED_SYMBOL), y(NUM_OF_NEED_SYMBOL); 
#line 1242
for (unsigned i = (0); i < NUM_OF_NEED_PACKET; i++) { 
#line 1243
unsigned stx = i * SYMBOL_PER_PACKET; 
#line 1244
for (unsigned j = (0); j < SEG_PER_PACKET; j++) { 
#line 1245
x[stx + j] = (stx + j); 
#line 1246
x[(stx + j) + SEG_PER_PACKET] = ((stx + j) + SEG_DIFF); 
#line 1247
y[stx + j] = b[stx + j]; 
#line 1248
y[(stx + j) + SEG_PER_PACKET] = b[(stx + j) + SEG_DIFF]; 
#line 1249
}  
#line 1250
}  
#line 1252
h_decode(x.data(), y.data(), c.data()); 
#line 1253
for (unsigned i = (0); i < NUM_OF_NEED_SYMBOL; i++) { 
#line 1254
(void)0; }  
#line 1256
}  
#line 1258
(((std::cout << ("Encode decode test passed!"))) << (std::endl)); 
#line 1260
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1260); 
#line 1262
} 
#line 1264
void test_encode_decode_batch() { 
#line 1268
using namespace std;
#line 1269
srand(time(0)); 
#line 1271
std::vector< unsigned>  a(LEN_BATCH * NUM_OF_NEED_SYMBOL); 
#line 1272
std::vector< unsigned>  b(LEN_BATCH * (NUM_OF_NEED_SYMBOL << 1)); 
#line 1273
std::vector< unsigned>  c(LEN_BATCH * NUM_OF_NEED_SYMBOL); 
#line 1275
for (unsigned tt = (0); tt < LEN_BATCH; tt++) { 
#line 1276
unsigned offset = NUM_OF_NEED_SYMBOL * tt; 
#line 1277
for (unsigned i = (0); i < NUM_OF_NEED_SYMBOL; i++) { 
#line 1278
a[offset + i] = ((rand()) % (MOD - (1))); }  
#line 1279
}  
#line 1281
h_encode_batch(a.data(), b.data()); 
#line 1282
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1282); 
#line 1284
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1284); 
#line 1299
std::vector< unsigned>  x(LEN_BATCH * NUM_OF_NEED_SYMBOL), y(LEN_BATCH * NUM_OF_NEED_SYMBOL); 
#line 1301
for (unsigned tt = (0); tt < LEN_BATCH; tt++) { 
#line 1302
unsigned os1 = NUM_OF_NEED_SYMBOL * tt; 
#line 1303
unsigned os2 = (NUM_OF_NEED_SYMBOL << 1) * tt; 
#line 1304
for (unsigned i = (0); i < NUM_OF_NEED_PACKET; i++) { 
#line 1305
unsigned stx = i * SYMBOL_PER_PACKET; 
#line 1306
for (unsigned j = (0); j < SEG_PER_PACKET; j++) { 
#line 1307
x[(os1 + stx) + j] = (stx + j); 
#line 1308
x[((os1 + stx) + j) + SEG_PER_PACKET] = ((stx + j) + SEG_DIFF); 
#line 1309
y[(os1 + stx) + j] = b[(os2 + stx) + j]; 
#line 1310
y[((os1 + stx) + j) + SEG_PER_PACKET] = b[((os2 + stx) + j) + SEG_DIFF]; 
#line 1311
}  
#line 1312
}  
#line 1313
}  
#line 1315
h_decode_batch(x.data(), y.data(), c.data()); 
#line 1316
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1316); 
#line 1318
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1318); 
#line 1331
for (unsigned i = (0); i < a.size(); i++) { 
#line 1332
(void)0; }  
#line 1334
(((std::cout << ("Encode decode batch test passed!"))) << (std::endl)); 
#line 1336
} 
#line 1338
void test_fnt_performance() { 
#line 1342
using namespace std;
#line 1344
const unsigned N_test = (1024); 
#line 1346
unsigned log_n = (16), n = 1 << log_n; 
#line 1347
unsigned size_n = n * sizeof(unsigned); 
#line 1348
std::vector< std::vector< unsigned> >  a(N_test, ((std::vector< unsigned> )(n))); 
#line 1349
cudaStream_t stream[(N_test)]; 
#line 1350
std::vector< unsigned *>  d_a(N_test), d_b(N_test); 
#line 1352
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1353
for (unsigned i = (0); i < n; i++) { 
#line 1354
(a[tt])[i] = ((rand()) % (MOD - (1))); }  
#line 1355
check(cudaStreamCreate(&(stream[tt])), "cudaStreamCreate(&stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1355); 
#line 1356
check(cudaMallocAsync(&d_a[tt], size_n, stream[tt]), "cudaMallocAsync(&d_a[tt], size_n, stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1356); 
#line 1357
check(cudaMallocAsync(&d_b[tt], size_n, stream[tt]), "cudaMallocAsync(&d_b[tt], size_n, stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1357); 
#line 1358
check(cudaMemcpyAsync(d_a[tt], a[tt].data(), size_n, cudaMemcpyHostToDevice, stream[tt]), "cudaMemcpyAsync(d_a[tt], a[tt].data(), size_n, cudaMemcpyHostToDevice, stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1358); 
#line 1359
}  
#line 1361
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1361); 
#line 1363
(((cout << ("FNT test start"))) << (endl)); 
#line 1365
auto start = chrono::high_resolution_clock::now(); 
#line 1367
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1372
fnt(d_a[tt], d_b[tt], log_n, log_n, 0, d_N_pos, d_root_layer_pow, d_inv, stream[tt]); 
#line 1373
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1373); 
#line 1377
}  
#line 1379
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1379); 
#line 1380
auto stop = chrono::high_resolution_clock::now(); 
#line 1381
auto duration = chrono::duration_cast< std::chrono::duration< __int64, std::ratio< 1i64, 1000i64> > > ((stop - start)).count(); 
#line 1383
(((((((((((cout << ("FNT "))) << N_test)) << (" chunks in "))) << duration)) << ("ms"))) << (endl)); 
#line 1385
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1386
check(cudaFreeAsync(d_a[tt], stream[tt]), "cudaFreeAsync(d_a[tt], stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1386); 
#line 1387
check(cudaFreeAsync(d_b[tt], stream[tt]), "cudaFreeAsync(d_b[tt], stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1387); 
#line 1388
check(cudaStreamDestroy(stream[tt]), "cudaStreamDestroy(stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1388); 
#line 1389
}  
#line 1391
} 
#line 1393
void test_encode_decode_performance() { 
#line 1397
using namespace std;
#line 1398
srand(time(0)); 
#line 1400
const unsigned N_test = (8); 
#line 1402
const __int64 symbol_bytes = (2); 
#line 1403
const __int64 size_test_gb = ((((symbol_bytes * NUM_OF_NEED_SYMBOL) * N_test) * LEN_BATCH) / ((1024 * 1024) * 1024)); 
#line 1405
std::vector< std::vector< unsigned> >  a(N_test, ((std::vector< unsigned> )(LEN_BATCH * NUM_OF_NEED_SYMBOL))); 
#line 1406
std::vector< std::vector< unsigned> >  b(N_test, ((std::vector< unsigned> )(LEN_BATCH * (NUM_OF_NEED_SYMBOL << 1)))); 
#line 1407
std::vector< std::vector< unsigned> >  c(N_test, ((std::vector< unsigned> )(LEN_BATCH * NUM_OF_NEED_SYMBOL))); 
#line 1409
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1410
for (unsigned j = (0); j < LEN_BATCH; j++) { 
#line 1411
unsigned os = j * NUM_OF_NEED_SYMBOL; 
#line 1412
for (unsigned i = (0); i < NUM_OF_NEED_SYMBOL; i++) { 
#line 1413
(a[tt])[os + i] = ((rand()) % (MOD - (1))); 
#line 1414
}  
#line 1415
}  
#line 1416
}  
#line 1418
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1418); 
#line 1420
(((cout << ("Encode performance test start"))) << (endl)); 
#line 1422
auto start1 = chrono::high_resolution_clock::now(); 
#line 1424
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1425
h_encode_batch(a[tt].data(), b[tt].data()); 
#line 1426
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1426); 
#line 1427
}  
#line 1429
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1429); 
#line 1430
auto stop1 = chrono::high_resolution_clock::now(); 
#line 1431
auto duration1 = chrono::duration_cast< std::chrono::duration< __int64, std::ratio< 1i64, 1000i64> > > ((stop1 - start1)).count(); 
#line 1433
(((((((((((cout << ("Encode "))) << N_test)) << (" batch 32 of 64kb chunks in "))) << duration1)) << ("ms"))) << (endl)); 
#line 1434
(((((((cout << ("Encode "))) << (((1.0) * size_test_gb) / (((1.0) * duration1) / (1000.0))))) << (" GB/s"))) << (endl)); 
#line 1436
std::vector< std::vector< unsigned> >  x(N_test, ((std::vector< unsigned> )(LEN_BATCH * NUM_OF_NEED_SYMBOL))); 
#line 1437
std::vector< std::vector< unsigned> >  y(N_test, ((std::vector< unsigned> )(LEN_BATCH * NUM_OF_NEED_SYMBOL))); 
#line 1439
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1440
for (unsigned k = (0); k < LEN_BATCH; k++) { 
#line 1441
unsigned os1 = k * NUM_OF_NEED_SYMBOL; 
#line 1442
unsigned os2 = k * (NUM_OF_NEED_SYMBOL << 1); 
#line 1443
for (unsigned i = (0); i < NUM_OF_NEED_PACKET; i++) { 
#line 1444
unsigned stx = i * SYMBOL_PER_PACKET; 
#line 1445
for (unsigned j = (0); j < SEG_PER_PACKET; j++) { 
#line 1446
(x[tt])[(os1 + stx) + j] = (stx + j); 
#line 1447
(x[tt])[((os1 + stx) + j) + SEG_PER_PACKET] = ((stx + j) + SEG_DIFF); 
#line 1448
(y[tt])[(os1 + stx) + j] = (b[tt])[(os2 + stx) + j]; 
#line 1449
(y[tt])[((os1 + stx) + j) + SEG_PER_PACKET] = (b[tt])[((os2 + stx) + j) + SEG_DIFF]; 
#line 1450
}  
#line 1451
}  
#line 1452
}  
#line 1453
}  
#line 1455
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1455); 
#line 1457
(((cout << ("Decode performance test start"))) << (endl)); 
#line 1459
auto start2 = chrono::high_resolution_clock::now(); 
#line 1461
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1462
h_decode_batch(x[tt].data(), y[tt].data(), c[tt].data()); 
#line 1463
check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1463); 
#line 1464
}  
#line 1466
check(cudaDeviceSynchronize(), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1466); 
#line 1467
auto stop2 = chrono::high_resolution_clock::now(); 
#line 1468
auto duration2 = chrono::duration_cast< std::chrono::duration< __int64, std::ratio< 1i64, 1000i64> > > ((stop2 - start2)).count(); 
#line 1470
(((((((((((cout << ("Decode "))) << N_test)) << (" batch 32 of 64kb chunks in "))) << duration2)) << ("ms"))) << (endl)); 
#line 1471
(((((((cout << ("Decode "))) << (((1.0) * size_test_gb) / (((1.0) * duration2) / (1000.0))))) << (" GB/s"))) << (endl)); 
#line 1473
for (unsigned tt = (0); tt < N_test; tt++) { 
#line 1474
for (unsigned i = (0); i < c[tt].size(); i++) { 
#line 1475
(void)0; }  
#line 1476
}  
#line 1478
} 
#line 1 "kernel.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__dcb4e26f_9_kernel_cu_9470058a
#ifdef _NV_ANON_NAMESPACE
#endif
#pragma pack()
#line 1 "kernel.cudafe1.stub.c"
#include "kernel.cudafe1.stub.c"
#line 1 "kernel.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
extern "C" {
#pragma data_seg(".nvHRKI")
__declspec(allocate(".nvHRKI")) __declspec(selectany) extern const unsigned char hostRefKernelArrayInternalLinkage[] = {
0x0};
#pragma data_seg()
}
extern "C" {
#pragma data_seg(".nvHRKE")
__declspec(allocate(".nvHRKE")) __declspec(selectany) extern const unsigned char hostRefKernelArrayExternalLinkage[] = {
/* _Z10g_build_n1* */
0x5f,0x5a,0x31,0x30,0x67,0x5f,0x62,0x75,0x69,0x6c,0x64,0x5f,0x6e,0x31,0x2a,0x0,
/* _Z10g_build_n2* */
0x5f,0x5a,0x31,0x30,0x67,0x5f,0x62,0x75,0x69,0x6c,0x64,0x5f,0x6e,0x32,0x2a,0x0,
/* _Z10g_build_n3* */
0x5f,0x5a,0x31,0x30,0x67,0x5f,0x62,0x75,0x69,0x6c,0x64,0x5f,0x6e,0x33,0x2a,0x0,
/* _Z12g_poly_deriv* */
0x5f,0x5a,0x31,0x32,0x67,0x5f,0x70,0x6f,0x6c,0x79,0x5f,0x64,0x65,0x72,0x69,0x76,0x2a,0x0,
/* _Z14g_decode_batch* */
0x5f,0x5a,0x31,0x34,0x67,0x5f,0x64,0x65,0x63,0x6f,0x64,0x65,0x5f,0x62,0x61,0x74,0x63,0x68,0x2a,0x0,
/* _Z14g_encode_batch* */
0x5f,0x5a,0x31,0x34,0x67,0x5f,0x65,0x6e,0x63,0x6f,0x64,0x65,0x5f,0x62,0x61,0x74,0x63,0x68,0x2a,0x0,
/* _Z14g_vector_mul_i* */
0x5f,0x5a,0x31,0x34,0x67,0x5f,0x76,0x65,0x63,0x74,0x6f,0x72,0x5f,0x6d,0x75,0x6c,0x5f,0x69,0x2a,0x0,
/* _Z17g_build_product_i* */
0x5f,0x5a,0x31,0x37,0x67,0x5f,0x62,0x75,0x69,0x6c,0x64,0x5f,0x70,0x72,0x6f,0x64,0x75,0x63,0x74,0x5f,0x69,0x2a,0x0,
/* _Z7g_fnt_i* */
0x5f,0x5a,0x37,0x67,0x5f,0x66,0x6e,0x74,0x5f,0x69,0x2a,0x0,
/* _Z9g_end_fnt* */
0x5f,0x5a,0x39,0x67,0x5f,0x65,0x6e,0x64,0x5f,0x66,0x6e,0x74,0x2a,0x0,
/* _Z9g_pre_fnt* */
0x5f,0x5a,0x39,0x67,0x5f,0x70,0x72,0x65,0x5f,0x66,0x6e,0x74,0x2a,0x0,
};
#pragma data_seg()
}
extern "C" {
#pragma data_seg(".nvHRDI")
__declspec(allocate(".nvHRDI")) __declspec(selectany) extern const unsigned char hostRefDeviceArrayInternalLinkage[] = {
0x0};
#pragma data_seg()
}
extern "C" {
#pragma data_seg(".nvHRDE")
__declspec(allocate(".nvHRDE")) __declspec(selectany) extern const unsigned char hostRefDeviceArrayExternalLinkage[] = {
0x0};
#pragma data_seg()
}
extern "C" {
#pragma data_seg(".nvHRCI")
__declspec(allocate(".nvHRCI")) __declspec(selectany) extern const unsigned char hostRefConstantArrayInternalLinkage[] = {
0x0};
#pragma data_seg()
}
extern "C" {
#pragma data_seg(".nvHRCE")
__declspec(allocate(".nvHRCE")) __declspec(selectany) extern const unsigned char hostRefConstantArrayExternalLinkage[] = {
0x0};
#pragma data_seg()
}
