#line 1 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#line 1 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"























































#line 57 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"









#line 67 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#pragma warning(push)
#pragma warning(disable: 4820)
#line 70 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 71 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"












#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"

















#line 77 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"






#line 84 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"






#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"





#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"



#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"













#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"











#line 127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"




















#line 148 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"







#line 156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"



#line 160 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"

#line 162 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"
#line 163 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"















#line 179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"





#line 185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"





#line 191 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"





#line 197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"






#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"







#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"





#line 218 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"





#line 224 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"





#line 230 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"







#pragma once






















#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"






    
    

#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
        


            
        #line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
    #line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"













#pragma once







































































































































#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"



#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
































#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"

#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"





#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"



#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"






#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"











#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"








#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"






























#line 1586 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
























#line 1611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"












#line 1624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"






































#line 1663 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"















































































































#line 1775 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"






































































































#line 1878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"








































































































































































#line 2047 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"





































































































#line 2149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"



















































































































































































































#line 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
extern "C" {




#line 2367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"



































































































































































































































#line 2595 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"









































































































































































































































#line 2868 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"









#line 2878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"



    
    


#line 2886 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
#line 2887 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"






#line 2894 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
#line 2895 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"






#line 2902 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
#line 2903 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"











#line 2915 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"

































#line 2949 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"






















}
#line 2973 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"











































































































































































































































































#line 292 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"



#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"
















































#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"











































#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"


}
#line 393 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"

#line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\concurrencysal.h"
#pragma external_header(pop)
#line 2975 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\sal.h"
#pragma external_header(pop)
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8)



    


        
    #line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"




    


        
    #line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"



    
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"




    
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C" {
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"



#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"


    


#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"





#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"



#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"
    
    
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"











#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"







#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"











#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"





#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"










#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"










#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"


} 
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } 

    





#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vadefs.h"

#pragma warning(pop) 
#pragma pack(pop)
#pragma external_header(pop)
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )






    



    





















#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
















    

#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
        
    #line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    

#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
        
    #line 138 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"





#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
    
    
#line 148 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"




    
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"








    


#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"



#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
    
#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"




    
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    
        
        
    

#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"



    
#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    
#line 220 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    
#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"








    
        
    

#line 237 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    


#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"



#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"



#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    
        
    



#line 273 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

    


#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


#line 281 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
        
        
    #line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

    
#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"



#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"



    


        
    

#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    


#line 308 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"






#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    
        
    





#line 326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 327 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"



#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    
        
    


#line 339 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    


#line 348 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"


#line 351 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    #line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 363 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime.h"
#pragma external_header(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"







#pragma once












    


        
    #line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



    
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"













    
#line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    











        
    #line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        
    #line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    

#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
        
    #line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"




    
#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    

#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
        
    #line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"





#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"





    
#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"









    
#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"













    


        
    #line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"









extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"










    
        
    #line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"








#line 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



















    

#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
        
    #line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
#line 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


 
  

#line 282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
   
  #line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
 





#line 291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 292 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"







    

















        
    #line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
        
    

#line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

























 void __cdecl _invalid_parameter_noinfo(void);
 __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
 void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    



        
        
        
        
        
        
        
        
        
        
        
        

    #line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"












    


#line 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
        
    



#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"









    






        
    #line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        
    #line 445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"













#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"















#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"





    
#line 487 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 491 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    

#line 496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        


            
        #line 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    #line 508 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 509 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 513 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"





#line 519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        



    #line 529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
        
    



#line 539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

    
        
              
        

#line 556 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    



#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

    
        
    



#line 569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

    
        
    



#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
#line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 622 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 633 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



    
#line 639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        












        












        
















    














#line 813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"












































































    













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1865 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    #line 2056 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 2057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

} __pragma(pack(pop))


#pragma warning(pop) 
#pragma external_header(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"










    

#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
        
    #line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"



    

#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
        
    #line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"



    

#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
        
    #line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"





    


#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"


#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
        
        
    #line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"


    

#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
        

#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
            
        #line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
    #line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"


    

#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"

#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
        
    #line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"
#pragma external_header(pop)
#line 232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"


#line 235 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"



#line 239 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"

#line 241 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"






#line 248 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdarg"





#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"





#pragma once








#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

































































































































































































































































































































































#line 373 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 375 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 376 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 380 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#pragma once

























#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 183 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 189 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 237 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 273 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 279 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"






#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 328 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 334 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 346 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 352 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 370 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 376 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 382 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 388 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 400 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 406 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 412 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 418 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 424 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 430 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 436 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 442 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 448 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 454 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 472 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 478 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 484 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 490 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 496 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 502 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 508 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"






#line 521 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 527 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 539 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"






#line 546 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 552 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 558 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"







#line 566 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 572 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 578 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"





#line 584 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"



#line 588 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"

#line 590 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"
#line 591 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xkeycheck.h"
#pragma external_header(pop)
#line 382 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 387 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 390 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 398 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"










#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"





#line 415 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"











#line 427 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 438 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"







#line 446 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"






#line 453 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 458 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"






































#line 503 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




















#line 524 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 525 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"






#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"











#line 545 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 546 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"







#line 554 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 567 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"












#line 580 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 581 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 585 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 589 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"







#line 597 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 599 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 604 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 606 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 613 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 618 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 623 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 628 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 633 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"







#line 641 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 646 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"













#line 660 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"






#line 668 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"










#line 679 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"










#line 690 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"





#line 696 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"








#line 705 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 706 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"












#line 720 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 722 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"







#line 731 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 733 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 744 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 746 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"










#line 758 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 760 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 771 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 773 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"











#line 786 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 788 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 799 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 801 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"








#line 811 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 813 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"








#line 823 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 825 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 836 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 838 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"













#line 853 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 855 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"








#line 865 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 867 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"














#line 883 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 885 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
















#line 902 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"













#line 917 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 919 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"










#line 931 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 933 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"











#line 945 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"












#line 958 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"










#line 970 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 972 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 983 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 985 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"








#line 994 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 996 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 1007 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1009 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"








#line 1019 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1021 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"








#line 1031 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1033 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"







#line 1042 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1044 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"







#line 1053 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1055 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"








#line 1065 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1067 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"






#line 1074 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1078 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1082 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1086 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1090 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1094 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1098 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1110 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"











#line 1122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"





#line 1128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"


















#line 1147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"























































#line 1203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"














































































































#line 1314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 1319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1321 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 1322 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1328 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 1333 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"


#line 1336 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1340 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1344 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1348 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1354 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"









#line 1364 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"




#line 1369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1371 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

































#line 1405 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"







#line 1413 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"



#line 1421 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"












#line 1434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"


#line 1437 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"


#line 1440 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 1441 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"





#line 1447 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"





#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"





#line 1459 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"

#line 1461 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#line 1462 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals_core.h"
#pragma external_header(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdarg"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdarg.h"







#pragma once




#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {










} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdarg"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
using ::va_list;
}



#pragma warning(pop)
#pragma pack(pop)

#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdarg"
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdarg"
#pragma external_header(pop)
#line 249 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"
#line 250 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"





























#line 280 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"
#line 281 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"

#line 283 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"



#line 287 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"

#line 289 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"




#line 294 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_config.h"
#line 84 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"







#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"























































#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"











































#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"










#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"










































#line 157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"








#line 168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"



#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"








#line 181 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"










#line 198 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
        



#line 208 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"



#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"



#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"



#line 220 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"



#line 224 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"



#line 228 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
        





#line 235 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"








#line 244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"





        



#line 254 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
#line 255 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
        
#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 61 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"







enum __declspec(__device_builtin__) cudaRoundMode
{
    cudaRoundNearest,
    cudaRoundZero,
    cudaRoundPosInf,
    cudaRoundMinInf
};




#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"

#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"























































#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 61 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"























































#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"








#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 67 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"






















#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"







#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"

struct __declspec(__device_builtin__) char1
{
    signed char x;
};

struct __declspec(__device_builtin__) uchar1
{
    unsigned char x;
};


struct __declspec(__device_builtin__) __declspec(align(2)) char2
{
    signed char x, y;
};

struct __declspec(__device_builtin__) __declspec(align(2)) uchar2
{
    unsigned char x, y;
};

struct __declspec(__device_builtin__) char3
{
    signed char x, y, z;
};

struct __declspec(__device_builtin__) uchar3
{
    unsigned char x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(4)) char4
{
    signed char x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(4)) uchar4
{
    unsigned char x, y, z, w;
};

struct __declspec(__device_builtin__) short1
{
    short x;
};

struct __declspec(__device_builtin__) ushort1
{
    unsigned short x;
};

struct __declspec(__device_builtin__) __declspec(align(4)) short2
{
    short x, y;
};

struct __declspec(__device_builtin__) __declspec(align(4)) ushort2
{
    unsigned short x, y;
};

struct __declspec(__device_builtin__) short3
{
    short x, y, z;
};

struct __declspec(__device_builtin__) ushort3
{
    unsigned short x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(8)) short4 { short x; short y; short z; short w; };
struct __declspec(__device_builtin__) __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; };

struct __declspec(__device_builtin__) int1
{
    int x;
};

struct __declspec(__device_builtin__) uint1
{
    unsigned int x;
};

struct __declspec(__device_builtin__) __declspec(align(8)) int2 { int x; int y; };
struct __declspec(__device_builtin__) __declspec(align(8)) uint2 { unsigned int x; unsigned int y; };

struct __declspec(__device_builtin__) int3
{
    int x, y, z;
};

struct __declspec(__device_builtin__) uint3
{
    unsigned int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) int4
{
    int x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) uint4
{
    unsigned int x, y, z, w;
};

struct __declspec(__device_builtin__) long1
{
    long int x;
};

struct __declspec(__device_builtin__) ulong1
{
    unsigned long x;
};


struct __declspec(__device_builtin__) __declspec(align(8)) long2 { long int x; long int y; };
struct __declspec(__device_builtin__) __declspec(align(8)) ulong2 { unsigned long int x; unsigned long int y; };












#line 233 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"

struct __declspec(__device_builtin__) long3
{
    long int x, y, z;
};

struct __declspec(__device_builtin__) ulong3
{
    unsigned long int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) long4
{
    long int x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulong4
{
    unsigned long int x, y, z, w;
};

struct __declspec(__device_builtin__) float1
{
    float x;
};















#line 275 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"

struct __declspec(__device_builtin__) __declspec(align(8)) float2 { float x; float y; };

#line 279 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


struct __declspec(__device_builtin__) float3
{
    float x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) float4
{
    float x, y, z, w;
};

struct __declspec(__device_builtin__) longlong1
{
    long long int x;
};

struct __declspec(__device_builtin__) ulonglong1
{
    unsigned long long int x;
};

struct __declspec(__device_builtin__) __declspec(align(16)) longlong2
{
    long long int x, y;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulonglong2
{
    unsigned long long int x, y;
};

struct __declspec(__device_builtin__) longlong3
{
    long long int x, y, z;
};

struct __declspec(__device_builtin__) ulonglong3
{
    unsigned long long int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) longlong4
{
    long long int x, y, z ,w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulonglong4
{
    unsigned long long int x, y, z, w;
};

struct __declspec(__device_builtin__) double1
{
    double x;
};

struct __declspec(__device_builtin__) __declspec(align(16)) double2
{
    double x, y;
};

struct __declspec(__device_builtin__) double3
{
    double x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) double4
{
    double x, y, z, w;
};





#line 356 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"







typedef __declspec(__device_builtin__) struct char1 char1;
typedef __declspec(__device_builtin__) struct uchar1 uchar1;
typedef __declspec(__device_builtin__) struct char2 char2;
typedef __declspec(__device_builtin__) struct uchar2 uchar2;
typedef __declspec(__device_builtin__) struct char3 char3;
typedef __declspec(__device_builtin__) struct uchar3 uchar3;
typedef __declspec(__device_builtin__) struct char4 char4;
typedef __declspec(__device_builtin__) struct uchar4 uchar4;
typedef __declspec(__device_builtin__) struct short1 short1;
typedef __declspec(__device_builtin__) struct ushort1 ushort1;
typedef __declspec(__device_builtin__) struct short2 short2;
typedef __declspec(__device_builtin__) struct ushort2 ushort2;
typedef __declspec(__device_builtin__) struct short3 short3;
typedef __declspec(__device_builtin__) struct ushort3 ushort3;
typedef __declspec(__device_builtin__) struct short4 short4;
typedef __declspec(__device_builtin__) struct ushort4 ushort4;
typedef __declspec(__device_builtin__) struct int1 int1;
typedef __declspec(__device_builtin__) struct uint1 uint1;
typedef __declspec(__device_builtin__) struct int2 int2;
typedef __declspec(__device_builtin__) struct uint2 uint2;
typedef __declspec(__device_builtin__) struct int3 int3;
typedef __declspec(__device_builtin__) struct uint3 uint3;
typedef __declspec(__device_builtin__) struct int4 int4;
typedef __declspec(__device_builtin__) struct uint4 uint4;
typedef __declspec(__device_builtin__) struct long1 long1;
typedef __declspec(__device_builtin__) struct ulong1 ulong1;
typedef __declspec(__device_builtin__) struct long2 long2;
typedef __declspec(__device_builtin__) struct ulong2 ulong2;
typedef __declspec(__device_builtin__) struct long3 long3;
typedef __declspec(__device_builtin__) struct ulong3 ulong3;
typedef __declspec(__device_builtin__) struct long4 long4;
typedef __declspec(__device_builtin__) struct ulong4 ulong4;
typedef __declspec(__device_builtin__) struct float1 float1;
typedef __declspec(__device_builtin__) struct float2 float2;
typedef __declspec(__device_builtin__) struct float3 float3;
typedef __declspec(__device_builtin__) struct float4 float4;
typedef __declspec(__device_builtin__) struct longlong1 longlong1;
typedef __declspec(__device_builtin__) struct ulonglong1 ulonglong1;
typedef __declspec(__device_builtin__) struct longlong2 longlong2;
typedef __declspec(__device_builtin__) struct ulonglong2 ulonglong2;
typedef __declspec(__device_builtin__) struct longlong3 longlong3;
typedef __declspec(__device_builtin__) struct ulonglong3 ulonglong3;
typedef __declspec(__device_builtin__) struct longlong4 longlong4;
typedef __declspec(__device_builtin__) struct ulonglong4 ulonglong4;
typedef __declspec(__device_builtin__) struct double1 double1;
typedef __declspec(__device_builtin__) struct double2 double2;
typedef __declspec(__device_builtin__) struct double3 double3;
typedef __declspec(__device_builtin__) struct double4 double4;







struct __declspec(__device_builtin__) dim3
{
    unsigned int x, y, z;





#line 427 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
    __declspec(__host__) __declspec(__device__) dim3(unsigned int vx = 1, unsigned int vy = 1, unsigned int vz = 1) : x(vx), y(vy), z(vz) {}
    __declspec(__host__) __declspec(__device__) dim3(uint3 v) : x(v.x), y(v.y), z(v.z) {}
    __declspec(__host__) __declspec(__device__) operator uint3(void) const { uint3 t; t.x = x; t.y = y; t.z = z; return t; }
#line 431 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 432 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
};

typedef __declspec(__device_builtin__) struct dim3 dim3;






#line 442 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"

#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"



















#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits.h"







#pragma once




#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {







    
    



#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits.h"
































    
    
        
    

#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits.h"
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits.h"


    
        
    #line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits.h"
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"





     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);

#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"









#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"
    
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"

 extern unsigned long  __cdecl __threadid(void);

 extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))

#pragma warning(pop) 
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"
#pragma external_header(pop)
#line 83 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 84 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"

















 













































































#line 180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




#line 185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"





#line 191 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"











enum __declspec(__device_builtin__) cudaError
{
    




    cudaSuccess                           =      0,
  
    



    cudaErrorInvalidValue                 =     1,
  
    



    cudaErrorMemoryAllocation             =      2,
  
    



    cudaErrorInitializationError          =      3,
  
    




    cudaErrorCudartUnloading              =     4,

    




    cudaErrorProfilerDisabled             =     5,

    





    cudaErrorProfilerNotInitialized       =     6,

    




    cudaErrorProfilerAlreadyStarted       =     7,

    




     cudaErrorProfilerAlreadyStopped       =    8,
  
    






    cudaErrorInvalidConfiguration         =      9,
  
    



    cudaErrorInvalidPitchValue            =     12,
  
    



    cudaErrorInvalidSymbol                =     13,
  
    





    cudaErrorInvalidHostPointer           =     16,
  
    





    cudaErrorInvalidDevicePointer         =     17,
  
    



    cudaErrorInvalidTexture               =     18,
  
    



    cudaErrorInvalidTextureBinding        =     19,
  
    




    cudaErrorInvalidChannelDescriptor     =     20,
  
    



    cudaErrorInvalidMemcpyDirection       =     21,
  
    







    cudaErrorAddressOfConstant            =     22,
  
    






    cudaErrorTextureFetchFailed           =     23,
  
    






    cudaErrorTextureNotBound              =     24,
  
    






    cudaErrorSynchronizationError         =     25,
  
    



    cudaErrorInvalidFilterSetting         =     26,
  
    



    cudaErrorInvalidNormSetting           =     27,
  
    





    cudaErrorMixedDeviceExecution         =     28,

    





    cudaErrorNotYetImplemented            =     31,
  
    






    cudaErrorMemoryValueTooLarge          =     32,
  
    




    cudaErrorStubLibrary                  =     34,

    




    cudaErrorInsufficientDriver           =     35,

    




    cudaErrorCallRequiresNewerDriver      =     36,
  
    



    cudaErrorInvalidSurface               =     37,
  
    



    cudaErrorDuplicateVariableName        =     43,
  
    



    cudaErrorDuplicateTextureName         =     44,
  
    



    cudaErrorDuplicateSurfaceName         =     45,
  
    







    cudaErrorDevicesUnavailable           =     46,
  
    










    cudaErrorIncompatibleDriverContext    =     49,
    
    



    cudaErrorMissingConfiguration         =      52,
  
    






    cudaErrorPriorLaunchFailure           =      53,

    




    cudaErrorLaunchMaxDepthExceeded       =     65,

    





    cudaErrorLaunchFileScopedTex          =     66,

    





    cudaErrorLaunchFileScopedSurf         =     67,

    












    cudaErrorSyncDepthExceeded            =     68,

    









    cudaErrorLaunchPendingCountExceeded   =     69,
  
    



    cudaErrorInvalidDeviceFunction        =      98,
  
    



    cudaErrorNoDevice                     =     100,
  
    




    cudaErrorInvalidDevice                =     101,

    


    cudaErrorDeviceNotLicensed            =     102,

   






   cudaErrorSoftwareValidityNotEstablished  =     103,

    


    cudaErrorStartupFailure               =    127,
  
    


    cudaErrorInvalidKernelImage           =     200,

    







    cudaErrorDeviceUninitialized          =     201,

    


    cudaErrorMapBufferObjectFailed        =     205,
  
    


    cudaErrorUnmapBufferObjectFailed      =     206,

    



    cudaErrorArrayIsMapped                =     207,

    


    cudaErrorAlreadyMapped                =     208,
  
    





    cudaErrorNoKernelImageForDevice       =     209,

    


    cudaErrorAlreadyAcquired              =     210,

    


    cudaErrorNotMapped                    =     211,

    



    cudaErrorNotMappedAsArray             =     212,

    



    cudaErrorNotMappedAsPointer           =     213,
  
    



    cudaErrorECCUncorrectable             =     214,
  
    



    cudaErrorUnsupportedLimit             =     215,
    
    



    cudaErrorDeviceAlreadyInUse           =     216,

    



    cudaErrorPeerAccessUnsupported        =     217,

    



    cudaErrorInvalidPtx                   =     218,

    


    cudaErrorInvalidGraphicsContext       =     219,

    



    cudaErrorNvlinkUncorrectable          =     220,

    




    cudaErrorJitCompilerNotFound          =     221,

    




    cudaErrorUnsupportedPtxVersion        =     222,

    




    cudaErrorJitCompilationDisabled       =     223,

    


    cudaErrorUnsupportedExecAffinity      =     224,

    


    cudaErrorInvalidSource                =     300,

    


    cudaErrorFileNotFound                 =     301,
  
    


    cudaErrorSharedObjectSymbolNotFound   =     302,
  
    


    cudaErrorSharedObjectInitFailed       =     303,

    


    cudaErrorOperatingSystem              =     304,
  
    




    cudaErrorInvalidResourceHandle        =     400,

    



    cudaErrorIllegalState                 =     401,

    




    cudaErrorSymbolNotFound               =     500,
  
    





    cudaErrorNotReady                     =     600,

    





    cudaErrorIllegalAddress               =     700,
  
    






    cudaErrorLaunchOutOfResources         =      701,
  
    








    cudaErrorLaunchTimeout                =      702,

    



    cudaErrorLaunchIncompatibleTexturing  =     703,
      
    




    cudaErrorPeerAccessAlreadyEnabled     =     704,
    
    




    cudaErrorPeerAccessNotEnabled         =     705,
  
    










    cudaErrorSetOnActiveProcess           =     708,

    




    cudaErrorContextIsDestroyed           =     709,

    




    cudaErrorAssert                        =    710,
  
    




    cudaErrorTooManyPeers                 =     711,
  
    



    cudaErrorHostMemoryAlreadyRegistered  =     712,
        
    



    cudaErrorHostMemoryNotRegistered      =     713,

    






    cudaErrorHardwareStackError           =     714,

    





    cudaErrorIllegalInstruction           =     715,

    






    cudaErrorMisalignedAddress            =     716,

    








    cudaErrorInvalidAddressSpace          =     717,

    





    cudaErrorInvalidPc                    =     718,
  
    








    cudaErrorLaunchFailure                =      719,

    






    cudaErrorCooperativeLaunchTooLarge    =     720,
    
    


    cudaErrorNotPermitted                 =     800,

    



    cudaErrorNotSupported                 =     801,

    






    cudaErrorSystemNotReady               =     802,

    




    cudaErrorSystemDriverMismatch         =     803,

    






    cudaErrorCompatNotSupportedOnDevice   =     804,

    


    cudaErrorMpsConnectionFailed          =     805,

    


    cudaErrorMpsRpcFailure                =     806,

    



    cudaErrorMpsServerNotReady            =     807,

    


    cudaErrorMpsMaxClientsReached         =     808,

    


    cudaErrorMpsMaxConnectionsReached     =     809,

    


    cudaErrorMpsClientTerminated          =     810,

    


    cudaErrorStreamCaptureUnsupported     =    900,

    



    cudaErrorStreamCaptureInvalidated     =    901,

    



    cudaErrorStreamCaptureMerge           =    902,

    


    cudaErrorStreamCaptureUnmatched       =    903,

    



    cudaErrorStreamCaptureUnjoined        =    904,

    




    cudaErrorStreamCaptureIsolation       =    905,

    



    cudaErrorStreamCaptureImplicit        =    906,

    



    cudaErrorCapturedEvent                =    907,
  
    




    cudaErrorStreamCaptureWrongThread     =    908,

    


    cudaErrorTimeout                      =    909,

    



    cudaErrorGraphExecUpdateFailure       =    910,

    







    cudaErrorExternalDevice               =    911,

    



    cudaErrorInvalidClusterSize           =    912,

    


    cudaErrorUnknown                      =    999,

    





    cudaErrorApiFailureBase               =  10000
};




enum __declspec(__device_builtin__) cudaChannelFormatKind
{
    cudaChannelFormatKindSigned                         =   0,      
    cudaChannelFormatKindUnsigned                       =   1,      
    cudaChannelFormatKindFloat                          =   2,      
    cudaChannelFormatKindNone                           =   3,      
    cudaChannelFormatKindNV12                           =   4,      
    cudaChannelFormatKindUnsignedNormalized8X1          =   5,      
    cudaChannelFormatKindUnsignedNormalized8X2          =   6,      
    cudaChannelFormatKindUnsignedNormalized8X4          =   7,      
    cudaChannelFormatKindUnsignedNormalized16X1         =   8,      
    cudaChannelFormatKindUnsignedNormalized16X2         =   9,      
    cudaChannelFormatKindUnsignedNormalized16X4         =   10,     
    cudaChannelFormatKindSignedNormalized8X1            =   11,     
    cudaChannelFormatKindSignedNormalized8X2            =   12,     
    cudaChannelFormatKindSignedNormalized8X4            =   13,     
    cudaChannelFormatKindSignedNormalized16X1           =   14,     
    cudaChannelFormatKindSignedNormalized16X2           =   15,     
    cudaChannelFormatKindSignedNormalized16X4           =   16,     
    cudaChannelFormatKindUnsignedBlockCompressed1       =   17,     
    cudaChannelFormatKindUnsignedBlockCompressed1SRGB   =   18,     
    cudaChannelFormatKindUnsignedBlockCompressed2       =   19,     
    cudaChannelFormatKindUnsignedBlockCompressed2SRGB   =   20,     
    cudaChannelFormatKindUnsignedBlockCompressed3       =   21,     
    cudaChannelFormatKindUnsignedBlockCompressed3SRGB   =   22,     
    cudaChannelFormatKindUnsignedBlockCompressed4       =   23,     
    cudaChannelFormatKindSignedBlockCompressed4         =   24,     
    cudaChannelFormatKindUnsignedBlockCompressed5       =   25,     
    cudaChannelFormatKindSignedBlockCompressed5         =   26,     
    cudaChannelFormatKindUnsignedBlockCompressed6H      =   27,     
    cudaChannelFormatKindSignedBlockCompressed6H        =   28,     
    cudaChannelFormatKindUnsignedBlockCompressed7       =   29,     
    cudaChannelFormatKindUnsignedBlockCompressed7SRGB   =   30      
};




struct __declspec(__device_builtin__) cudaChannelFormatDesc
{
    int                        x; 
    int                        y; 
    int                        z; 
    int                        w; 
    enum cudaChannelFormatKind f; 
};




typedef struct cudaArray *cudaArray_t;




typedef const struct cudaArray *cudaArray_const_t;

struct cudaArray;




typedef struct cudaMipmappedArray *cudaMipmappedArray_t;




typedef const struct cudaMipmappedArray *cudaMipmappedArray_const_t;

struct cudaMipmappedArray;









struct __declspec(__device_builtin__) cudaArraySparseProperties {
    struct {
        unsigned int width;             
        unsigned int height;            
        unsigned int depth;             
    } tileExtent;
    unsigned int miptailFirstLevel;        
    unsigned long long miptailSize;     
    unsigned int flags;                 
    unsigned int reserved[4];
};




struct __declspec(__device_builtin__) cudaArrayMemoryRequirements {
    size_t size;                    
    size_t alignment;               
    unsigned int reserved[4];
};




enum __declspec(__device_builtin__) cudaMemoryType
{
    cudaMemoryTypeUnregistered = 0, 
    cudaMemoryTypeHost         = 1, 
    cudaMemoryTypeDevice       = 2, 
    cudaMemoryTypeManaged      = 3  
};




enum __declspec(__device_builtin__) cudaMemcpyKind
{
    cudaMemcpyHostToHost          =   0,      
    cudaMemcpyHostToDevice        =   1,      
    cudaMemcpyDeviceToHost        =   2,      
    cudaMemcpyDeviceToDevice      =   3,      
    cudaMemcpyDefault             =   4       
};






struct __declspec(__device_builtin__) cudaPitchedPtr
{
    void   *ptr;      
    size_t  pitch;    
    size_t  xsize;    
    size_t  ysize;    
};






struct __declspec(__device_builtin__) cudaExtent
{
    size_t width;     
    size_t height;    
    size_t depth;     
};






struct __declspec(__device_builtin__) cudaPos
{
    size_t x;     
    size_t y;     
    size_t z;     
};




struct __declspec(__device_builtin__) cudaMemcpy3DParms
{
    cudaArray_t            srcArray;  
    struct cudaPos         srcPos;    
    struct cudaPitchedPtr  srcPtr;    
  
    cudaArray_t            dstArray;  
    struct cudaPos         dstPos;    
    struct cudaPitchedPtr  dstPtr;    
  
    struct cudaExtent      extent;    
    enum cudaMemcpyKind    kind;      
};




struct __declspec(__device_builtin__) cudaMemcpy3DPeerParms
{
    cudaArray_t            srcArray;  
    struct cudaPos         srcPos;    
    struct cudaPitchedPtr  srcPtr;    
    int                    srcDevice; 
  
    cudaArray_t            dstArray;  
    struct cudaPos         dstPos;    
    struct cudaPitchedPtr  dstPtr;    
    int                    dstDevice; 
  
    struct cudaExtent      extent;    
};




struct __declspec(__device_builtin__)  cudaMemsetParams {
    void *dst;                              
    size_t pitch;                           
    unsigned int value;                     
    unsigned int elementSize;               
    size_t width;                           
    size_t height;                          
};




enum __declspec(__device_builtin__)  cudaAccessProperty {
    cudaAccessPropertyNormal = 0,       
    cudaAccessPropertyStreaming = 1,    
    cudaAccessPropertyPersisting = 2    
};












struct __declspec(__device_builtin__) cudaAccessPolicyWindow {
    void *base_ptr;                     
    size_t num_bytes;                   
    float hitRatio;                     
    enum cudaAccessProperty hitProp;    
    enum cudaAccessProperty missProp;   
};





#line 1322 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"





typedef void (__stdcall *cudaHostFn_t)(void *userData);




struct __declspec(__device_builtin__) cudaHostNodeParams {
    cudaHostFn_t fn;    
    void* userData; 
};




enum __declspec(__device_builtin__) cudaStreamCaptureStatus {
    cudaStreamCaptureStatusNone        = 0, 
    cudaStreamCaptureStatusActive      = 1, 
    cudaStreamCaptureStatusInvalidated = 2  

};





enum __declspec(__device_builtin__) cudaStreamCaptureMode {
    cudaStreamCaptureModeGlobal      = 0,
    cudaStreamCaptureModeThreadLocal = 1,
    cudaStreamCaptureModeRelaxed     = 2
};

enum __declspec(__device_builtin__) cudaSynchronizationPolicy {
    cudaSyncPolicyAuto = 1,
    cudaSyncPolicySpin = 2,
    cudaSyncPolicyYield = 3,
    cudaSyncPolicyBlockingSync = 4
};




enum __declspec(__device_builtin__) cudaClusterSchedulingPolicy {
    cudaClusterSchedulingPolicyDefault       = 0, 
    cudaClusterSchedulingPolicySpread        = 1, 
    cudaClusterSchedulingPolicyLoadBalancing = 2  
};




enum __declspec(__device_builtin__) cudaStreamUpdateCaptureDependenciesFlags {
    cudaStreamAddCaptureDependencies = 0x0, 
    cudaStreamSetCaptureDependencies = 0x1  
};




enum __declspec(__device_builtin__) cudaUserObjectFlags {
    cudaUserObjectNoDestructorSync = 0x1  
};




enum __declspec(__device_builtin__) cudaUserObjectRetainFlags {
    cudaGraphUserObjectMove = 0x1  
};




struct cudaGraphicsResource;




enum __declspec(__device_builtin__) cudaGraphicsRegisterFlags
{
    cudaGraphicsRegisterFlagsNone             = 0,  
    cudaGraphicsRegisterFlagsReadOnly         = 1,   
    cudaGraphicsRegisterFlagsWriteDiscard     = 2,  
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,  
    cudaGraphicsRegisterFlagsTextureGather    = 8   
};




enum __declspec(__device_builtin__) cudaGraphicsMapFlags
{
    cudaGraphicsMapFlagsNone         = 0,  
    cudaGraphicsMapFlagsReadOnly     = 1,  
    cudaGraphicsMapFlagsWriteDiscard = 2   
};




enum __declspec(__device_builtin__) cudaGraphicsCubeFace 
{
    cudaGraphicsCubeFacePositiveX = 0x00, 
    cudaGraphicsCubeFaceNegativeX = 0x01, 
    cudaGraphicsCubeFacePositiveY = 0x02, 
    cudaGraphicsCubeFaceNegativeY = 0x03, 
    cudaGraphicsCubeFacePositiveZ = 0x04, 
    cudaGraphicsCubeFaceNegativeZ = 0x05  
};




enum __declspec(__device_builtin__) cudaResourceType
{
    cudaResourceTypeArray          = 0x00, 
    cudaResourceTypeMipmappedArray = 0x01, 
    cudaResourceTypeLinear         = 0x02, 
    cudaResourceTypePitch2D        = 0x03  
};




enum __declspec(__device_builtin__) cudaResourceViewFormat
{
    cudaResViewFormatNone                      = 0x00, 
    cudaResViewFormatUnsignedChar1             = 0x01, 
    cudaResViewFormatUnsignedChar2             = 0x02, 
    cudaResViewFormatUnsignedChar4             = 0x03, 
    cudaResViewFormatSignedChar1               = 0x04, 
    cudaResViewFormatSignedChar2               = 0x05, 
    cudaResViewFormatSignedChar4               = 0x06, 
    cudaResViewFormatUnsignedShort1            = 0x07, 
    cudaResViewFormatUnsignedShort2            = 0x08, 
    cudaResViewFormatUnsignedShort4            = 0x09, 
    cudaResViewFormatSignedShort1              = 0x0a, 
    cudaResViewFormatSignedShort2              = 0x0b, 
    cudaResViewFormatSignedShort4              = 0x0c, 
    cudaResViewFormatUnsignedInt1              = 0x0d, 
    cudaResViewFormatUnsignedInt2              = 0x0e, 
    cudaResViewFormatUnsignedInt4              = 0x0f, 
    cudaResViewFormatSignedInt1                = 0x10, 
    cudaResViewFormatSignedInt2                = 0x11, 
    cudaResViewFormatSignedInt4                = 0x12, 
    cudaResViewFormatHalf1                     = 0x13, 
    cudaResViewFormatHalf2                     = 0x14, 
    cudaResViewFormatHalf4                     = 0x15, 
    cudaResViewFormatFloat1                    = 0x16, 
    cudaResViewFormatFloat2                    = 0x17, 
    cudaResViewFormatFloat4                    = 0x18, 
    cudaResViewFormatUnsignedBlockCompressed1  = 0x19, 
    cudaResViewFormatUnsignedBlockCompressed2  = 0x1a, 
    cudaResViewFormatUnsignedBlockCompressed3  = 0x1b, 
    cudaResViewFormatUnsignedBlockCompressed4  = 0x1c, 
    cudaResViewFormatSignedBlockCompressed4    = 0x1d, 
    cudaResViewFormatUnsignedBlockCompressed5  = 0x1e, 
    cudaResViewFormatSignedBlockCompressed5    = 0x1f, 
    cudaResViewFormatUnsignedBlockCompressed6H = 0x20, 
    cudaResViewFormatSignedBlockCompressed6H   = 0x21, 
    cudaResViewFormatUnsignedBlockCompressed7  = 0x22  
};




struct __declspec(__device_builtin__) cudaResourceDesc {
    enum cudaResourceType resType;             
    
    union {
        struct {
            cudaArray_t array;                 
        } array;
        struct {
            cudaMipmappedArray_t mipmap;       
        } mipmap;
        struct {
            void *devPtr;                      
            struct cudaChannelFormatDesc desc; 
            size_t sizeInBytes;                
        } linear;
        struct {
            void *devPtr;                      
            struct cudaChannelFormatDesc desc; 
            size_t width;                      
            size_t height;                     
            size_t pitchInBytes;               
        } pitch2D;
    } res;
};




struct __declspec(__device_builtin__) cudaResourceViewDesc
{
    enum cudaResourceViewFormat format;           
    size_t                      width;            
    size_t                      height;           
    size_t                      depth;            
    unsigned int                firstMipmapLevel; 
    unsigned int                lastMipmapLevel;  
    unsigned int                firstLayer;       
    unsigned int                lastLayer;        
};




struct __declspec(__device_builtin__) cudaPointerAttributes
{
    



    enum cudaMemoryType type;

    








    int device;

    



    void *devicePointer;

    






    void *hostPointer;
};




struct __declspec(__device_builtin__) cudaFuncAttributes
{
   




   size_t sharedSizeBytes;

   



   size_t constSizeBytes;

   


   size_t localSizeBytes;

   




   int maxThreadsPerBlock;

   


   int numRegs;

   




   int ptxVersion;

   




   int binaryVersion;

   



   int cacheModeCA;

   




   int maxDynamicSharedSizeBytes;

   






   int preferredShmemCarveout;
};




enum __declspec(__device_builtin__) cudaFuncAttribute
{
    cudaFuncAttributeMaxDynamicSharedMemorySize = 8, 
    cudaFuncAttributePreferredSharedMemoryCarveout = 9, 
    cudaFuncAttributeClusterDimMustBeSet = 10, 
    cudaFuncAttributeRequiredClusterWidth = 11, 
    cudaFuncAttributeRequiredClusterHeight = 12, 
    cudaFuncAttributeRequiredClusterDepth = 13, 
    cudaFuncAttributeNonPortableClusterSizeAllowed = 14, 
    cudaFuncAttributeClusterSchedulingPolicyPreference = 15, 
    cudaFuncAttributeMax
};




enum __declspec(__device_builtin__) cudaFuncCache
{
    cudaFuncCachePreferNone   = 0,    
    cudaFuncCachePreferShared = 1,    
    cudaFuncCachePreferL1     = 2,    
    cudaFuncCachePreferEqual  = 3     
};





enum __declspec(__device_builtin__) cudaSharedMemConfig
{
    cudaSharedMemBankSizeDefault   = 0,
    cudaSharedMemBankSizeFourByte  = 1,
    cudaSharedMemBankSizeEightByte = 2
};




enum __declspec(__device_builtin__) cudaSharedCarveout {
    cudaSharedmemCarveoutDefault      = -1,  
    cudaSharedmemCarveoutMaxShared    = 100, 
    cudaSharedmemCarveoutMaxL1        = 0    
};




enum __declspec(__device_builtin__) cudaComputeMode
{
    cudaComputeModeDefault          = 0,  
    cudaComputeModeExclusive        = 1,  
    cudaComputeModeProhibited       = 2,  
    cudaComputeModeExclusiveProcess = 3   
};




enum __declspec(__device_builtin__) cudaLimit
{
    cudaLimitStackSize                    = 0x00, 
    cudaLimitPrintfFifoSize               = 0x01, 
    cudaLimitMallocHeapSize               = 0x02, 
    cudaLimitDevRuntimeSyncDepth          = 0x03, 
    cudaLimitDevRuntimePendingLaunchCount = 0x04, 
    cudaLimitMaxL2FetchGranularity        = 0x05, 
    cudaLimitPersistingL2CacheSize        = 0x06  
};




enum __declspec(__device_builtin__) cudaMemoryAdvise
{
    cudaMemAdviseSetReadMostly          = 1, 
    cudaMemAdviseUnsetReadMostly        = 2, 
    cudaMemAdviseSetPreferredLocation   = 3, 
    cudaMemAdviseUnsetPreferredLocation = 4, 
    cudaMemAdviseSetAccessedBy          = 5, 
    cudaMemAdviseUnsetAccessedBy        = 6  
};




enum __declspec(__device_builtin__) cudaMemRangeAttribute
{
    cudaMemRangeAttributeReadMostly           = 1, 
    cudaMemRangeAttributePreferredLocation    = 2, 
    cudaMemRangeAttributeAccessedBy           = 3, 
    cudaMemRangeAttributeLastPrefetchLocation = 4  
};




enum __declspec(__device_builtin__) cudaOutputMode
{
    cudaKeyValuePair    = 0x00, 
    cudaCSV             = 0x01  
};




enum __declspec(__device_builtin__) cudaFlushGPUDirectRDMAWritesOptions {
    cudaFlushGPUDirectRDMAWritesOptionHost   = 1<<0, 
    cudaFlushGPUDirectRDMAWritesOptionMemOps = 1<<1  
};




enum __declspec(__device_builtin__) cudaGPUDirectRDMAWritesOrdering {
    cudaGPUDirectRDMAWritesOrderingNone       = 0,   
    cudaGPUDirectRDMAWritesOrderingOwner      = 100, 
    cudaGPUDirectRDMAWritesOrderingAllDevices = 200  
};




enum __declspec(__device_builtin__) cudaFlushGPUDirectRDMAWritesScope {
    cudaFlushGPUDirectRDMAWritesToOwner      = 100, 
    cudaFlushGPUDirectRDMAWritesToAllDevices = 200  
};




enum __declspec(__device_builtin__) cudaFlushGPUDirectRDMAWritesTarget {
    cudaFlushGPUDirectRDMAWritesTargetCurrentDevice 
};





enum __declspec(__device_builtin__) cudaDeviceAttr
{
    cudaDevAttrMaxThreadsPerBlock             = 1,  
    cudaDevAttrMaxBlockDimX                   = 2,  
    cudaDevAttrMaxBlockDimY                   = 3,  
    cudaDevAttrMaxBlockDimZ                   = 4,  
    cudaDevAttrMaxGridDimX                    = 5,  
    cudaDevAttrMaxGridDimY                    = 6,  
    cudaDevAttrMaxGridDimZ                    = 7,  
    cudaDevAttrMaxSharedMemoryPerBlock        = 8,  
    cudaDevAttrTotalConstantMemory            = 9,  
    cudaDevAttrWarpSize                       = 10, 
    cudaDevAttrMaxPitch                       = 11, 
    cudaDevAttrMaxRegistersPerBlock           = 12, 
    cudaDevAttrClockRate                      = 13, 
    cudaDevAttrTextureAlignment               = 14, 
    cudaDevAttrGpuOverlap                     = 15, 
    cudaDevAttrMultiProcessorCount            = 16, 
    cudaDevAttrKernelExecTimeout              = 17, 
    cudaDevAttrIntegrated                     = 18, 
    cudaDevAttrCanMapHostMemory               = 19, 
    cudaDevAttrComputeMode                    = 20, 
    cudaDevAttrMaxTexture1DWidth              = 21, 
    cudaDevAttrMaxTexture2DWidth              = 22, 
    cudaDevAttrMaxTexture2DHeight             = 23, 
    cudaDevAttrMaxTexture3DWidth              = 24, 
    cudaDevAttrMaxTexture3DHeight             = 25, 
    cudaDevAttrMaxTexture3DDepth              = 26, 
    cudaDevAttrMaxTexture2DLayeredWidth       = 27, 
    cudaDevAttrMaxTexture2DLayeredHeight      = 28, 
    cudaDevAttrMaxTexture2DLayeredLayers      = 29, 
    cudaDevAttrSurfaceAlignment               = 30, 
    cudaDevAttrConcurrentKernels              = 31, 
    cudaDevAttrEccEnabled                     = 32, 
    cudaDevAttrPciBusId                       = 33, 
    cudaDevAttrPciDeviceId                    = 34, 
    cudaDevAttrTccDriver                      = 35, 
    cudaDevAttrMemoryClockRate                = 36, 
    cudaDevAttrGlobalMemoryBusWidth           = 37, 
    cudaDevAttrL2CacheSize                    = 38, 
    cudaDevAttrMaxThreadsPerMultiProcessor    = 39, 
    cudaDevAttrAsyncEngineCount               = 40, 
    cudaDevAttrUnifiedAddressing              = 41,     
    cudaDevAttrMaxTexture1DLayeredWidth       = 42, 
    cudaDevAttrMaxTexture1DLayeredLayers      = 43, 
    cudaDevAttrMaxTexture2DGatherWidth        = 45, 
    cudaDevAttrMaxTexture2DGatherHeight       = 46, 
    cudaDevAttrMaxTexture3DWidthAlt           = 47, 
    cudaDevAttrMaxTexture3DHeightAlt          = 48, 
    cudaDevAttrMaxTexture3DDepthAlt           = 49, 
    cudaDevAttrPciDomainId                    = 50, 
    cudaDevAttrTexturePitchAlignment          = 51, 
    cudaDevAttrMaxTextureCubemapWidth         = 52, 
    cudaDevAttrMaxTextureCubemapLayeredWidth  = 53, 
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54, 
    cudaDevAttrMaxSurface1DWidth              = 55, 
    cudaDevAttrMaxSurface2DWidth              = 56, 
    cudaDevAttrMaxSurface2DHeight             = 57, 
    cudaDevAttrMaxSurface3DWidth              = 58, 
    cudaDevAttrMaxSurface3DHeight             = 59, 
    cudaDevAttrMaxSurface3DDepth              = 60, 
    cudaDevAttrMaxSurface1DLayeredWidth       = 61, 
    cudaDevAttrMaxSurface1DLayeredLayers      = 62, 
    cudaDevAttrMaxSurface2DLayeredWidth       = 63, 
    cudaDevAttrMaxSurface2DLayeredHeight      = 64, 
    cudaDevAttrMaxSurface2DLayeredLayers      = 65, 
    cudaDevAttrMaxSurfaceCubemapWidth         = 66, 
    cudaDevAttrMaxSurfaceCubemapLayeredWidth  = 67, 
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68, 
    cudaDevAttrMaxTexture1DLinearWidth        = 69, 
    cudaDevAttrMaxTexture2DLinearWidth        = 70, 
    cudaDevAttrMaxTexture2DLinearHeight       = 71, 
    cudaDevAttrMaxTexture2DLinearPitch        = 72, 
    cudaDevAttrMaxTexture2DMipmappedWidth     = 73, 
    cudaDevAttrMaxTexture2DMipmappedHeight    = 74, 
    cudaDevAttrComputeCapabilityMajor         = 75,  
    cudaDevAttrComputeCapabilityMinor         = 76, 
    cudaDevAttrMaxTexture1DMipmappedWidth     = 77, 
    cudaDevAttrStreamPrioritiesSupported      = 78, 
    cudaDevAttrGlobalL1CacheSupported         = 79, 
    cudaDevAttrLocalL1CacheSupported          = 80, 
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81, 
    cudaDevAttrMaxRegistersPerMultiprocessor  = 82, 
    cudaDevAttrManagedMemory                  = 83, 
    cudaDevAttrIsMultiGpuBoard                = 84, 
    cudaDevAttrMultiGpuBoardGroupID           = 85, 
    cudaDevAttrHostNativeAtomicSupported      = 86, 
    cudaDevAttrSingleToDoublePrecisionPerfRatio = 87, 
    cudaDevAttrPageableMemoryAccess           = 88, 
    cudaDevAttrConcurrentManagedAccess        = 89, 
    cudaDevAttrComputePreemptionSupported     = 90, 
    cudaDevAttrCanUseHostPointerForRegisteredMem = 91, 
    cudaDevAttrReserved92                     = 92,
    cudaDevAttrReserved93                     = 93,
    cudaDevAttrReserved94                     = 94,
    cudaDevAttrCooperativeLaunch              = 95, 
    cudaDevAttrCooperativeMultiDeviceLaunch   = 96, 
    cudaDevAttrMaxSharedMemoryPerBlockOptin   = 97, 
    cudaDevAttrCanFlushRemoteWrites           = 98, 
    cudaDevAttrHostRegisterSupported          = 99, 
    cudaDevAttrPageableMemoryAccessUsesHostPageTables = 100, 
    cudaDevAttrDirectManagedMemAccessFromHost = 101, 
    cudaDevAttrMaxBlocksPerMultiprocessor     = 106, 
    cudaDevAttrMaxPersistingL2CacheSize       = 108, 
    cudaDevAttrMaxAccessPolicyWindowSize      = 109, 
    cudaDevAttrReservedSharedMemoryPerBlock   = 111, 
    cudaDevAttrSparseCudaArraySupported       = 112, 
    cudaDevAttrHostRegisterReadOnlySupported  = 113,  
    cudaDevAttrTimelineSemaphoreInteropSupported = 114,  
    cudaDevAttrMaxTimelineSemaphoreInteropSupported = 114,  
    cudaDevAttrMemoryPoolsSupported           = 115, 
    cudaDevAttrGPUDirectRDMASupported         = 116, 
    cudaDevAttrGPUDirectRDMAFlushWritesOptions = 117, 
    cudaDevAttrGPUDirectRDMAWritesOrdering    = 118, 
    cudaDevAttrMemoryPoolSupportedHandleTypes = 119, 
    cudaDevAttrClusterLaunch                  = 120, 
    cudaDevAttrDeferredMappingCudaArraySupported = 121, 
    cudaDevAttrMax
};




enum __declspec(__device_builtin__) cudaMemPoolAttr
{
    







    cudaMemPoolReuseFollowEventDependencies   = 0x1,

    




    cudaMemPoolReuseAllowOpportunistic        = 0x2,

    





    cudaMemPoolReuseAllowInternalDependencies = 0x3,


    







    cudaMemPoolAttrReleaseThreshold           = 0x4,

    



    cudaMemPoolAttrReservedMemCurrent         = 0x5,

    




    cudaMemPoolAttrReservedMemHigh            = 0x6,

    



    cudaMemPoolAttrUsedMemCurrent             = 0x7,

    




    cudaMemPoolAttrUsedMemHigh                = 0x8
};




enum __declspec(__device_builtin__) cudaMemLocationType {
    cudaMemLocationTypeInvalid = 0,
    cudaMemLocationTypeDevice = 1  
};






struct __declspec(__device_builtin__) cudaMemLocation {
    enum cudaMemLocationType type;  
    int id;                         
};




enum __declspec(__device_builtin__) cudaMemAccessFlags {
    cudaMemAccessFlagsProtNone      = 0,  
    cudaMemAccessFlagsProtRead      = 1,  
    cudaMemAccessFlagsProtReadWrite = 3   
};




struct __declspec(__device_builtin__) cudaMemAccessDesc {
    struct cudaMemLocation  location; 
    enum cudaMemAccessFlags flags;    
};




enum __declspec(__device_builtin__) cudaMemAllocationType {
    cudaMemAllocationTypeInvalid = 0x0,
    


    cudaMemAllocationTypePinned  = 0x1,
    cudaMemAllocationTypeMax     = 0x7FFFFFFF 
};




enum __declspec(__device_builtin__) cudaMemAllocationHandleType {
    cudaMemHandleTypeNone                    = 0x0,  
    cudaMemHandleTypePosixFileDescriptor     = 0x1,  
    cudaMemHandleTypeWin32                   = 0x2,  
    cudaMemHandleTypeWin32Kmt                = 0x4   
};




struct __declspec(__device_builtin__) cudaMemPoolProps {
    enum cudaMemAllocationType         allocType;   
    enum cudaMemAllocationHandleType   handleTypes; 
    struct cudaMemLocation             location;    
    





    void                              *win32SecurityAttributes;
    unsigned char                      reserved[64]; 
};




struct __declspec(__device_builtin__) cudaMemPoolPtrExportData {
    unsigned char reserved[64];
};




struct __declspec(__device_builtin__) cudaMemAllocNodeParams {
    



    struct cudaMemPoolProps         poolProps;       
    const struct cudaMemAccessDesc *accessDescs;     
    size_t                          accessDescCount; 
    size_t                          bytesize;        
    void                           *dptr;            
};




enum __declspec(__device_builtin__) cudaGraphMemAttributeType {
    



    cudaGraphMemAttrUsedMemCurrent      = 0x0,

    




    cudaGraphMemAttrUsedMemHigh         = 0x1,

    




    cudaGraphMemAttrReservedMemCurrent  = 0x2,

    




    cudaGraphMemAttrReservedMemHigh     = 0x3
};





enum __declspec(__device_builtin__) cudaDeviceP2PAttr {
    cudaDevP2PAttrPerformanceRank              = 1, 
    cudaDevP2PAttrAccessSupported              = 2, 
    cudaDevP2PAttrNativeAtomicSupported        = 3, 
    cudaDevP2PAttrCudaArrayAccessSupported     = 4  
};






struct __declspec(__device_builtin__) CUuuid_st {     
    char bytes[16];
};
typedef __declspec(__device_builtin__) struct CUuuid_st CUuuid;
#line 2119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
typedef __declspec(__device_builtin__) struct CUuuid_st cudaUUID_t;




struct __declspec(__device_builtin__) cudaDeviceProp
{
    char         name[256];                  
    cudaUUID_t   uuid;                       
    char         luid[8];                    
    unsigned int luidDeviceNodeMask;         
    size_t       totalGlobalMem;             
    size_t       sharedMemPerBlock;          
    int          regsPerBlock;               
    int          warpSize;                   
    size_t       memPitch;                   
    int          maxThreadsPerBlock;         
    int          maxThreadsDim[3];           
    int          maxGridSize[3];             
    int          clockRate;                  
    size_t       totalConstMem;              
    int          major;                      
    int          minor;                      
    size_t       textureAlignment;           
    size_t       texturePitchAlignment;      
    int          deviceOverlap;              
    int          multiProcessorCount;        
    int          kernelExecTimeoutEnabled;   
    int          integrated;                 
    int          canMapHostMemory;           
    int          computeMode;                
    int          maxTexture1D;               
    int          maxTexture1DMipmap;         
    int          maxTexture1DLinear;         
    int          maxTexture2D[2];            
    int          maxTexture2DMipmap[2];      
    int          maxTexture2DLinear[3];      
    int          maxTexture2DGather[2];      
    int          maxTexture3D[3];            
    int          maxTexture3DAlt[3];         
    int          maxTextureCubemap;          
    int          maxTexture1DLayered[2];     
    int          maxTexture2DLayered[3];     
    int          maxTextureCubemapLayered[2];
    int          maxSurface1D;               
    int          maxSurface2D[2];            
    int          maxSurface3D[3];            
    int          maxSurface1DLayered[2];     
    int          maxSurface2DLayered[3];     
    int          maxSurfaceCubemap;          
    int          maxSurfaceCubemapLayered[2];
    size_t       surfaceAlignment;           
    int          concurrentKernels;          
    int          ECCEnabled;                 
    int          pciBusID;                   
    int          pciDeviceID;                
    int          pciDomainID;                
    int          tccDriver;                  
    int          asyncEngineCount;           
    int          unifiedAddressing;          
    int          memoryClockRate;            
    int          memoryBusWidth;             
    int          l2CacheSize;                
    int          persistingL2CacheMaxSize;   
    int          maxThreadsPerMultiProcessor;
    int          streamPrioritiesSupported;  
    int          globalL1CacheSupported;     
    int          localL1CacheSupported;      
    size_t       sharedMemPerMultiprocessor; 
    int          regsPerMultiprocessor;      
    int          managedMemory;              
    int          isMultiGpuBoard;            
    int          multiGpuBoardGroupID;       
    int          hostNativeAtomicSupported;  
    int          singleToDoublePrecisionPerfRatio; 
    int          pageableMemoryAccess;       
    int          concurrentManagedAccess;    
    int          computePreemptionSupported; 
    int          canUseHostPointerForRegisteredMem; 
    int          cooperativeLaunch;          
    int          cooperativeMultiDeviceLaunch; 
    size_t       sharedMemPerBlockOptin;     
    int          pageableMemoryAccessUsesHostPageTables; 
    int          directManagedMemAccessFromHost; 
    int          maxBlocksPerMultiProcessor; 
    int          accessPolicyMaxWindowSize;  
    size_t       reservedSharedMemPerBlock;  
};




























































































typedef __declspec(__device_builtin__) struct __declspec(__device_builtin__) cudaIpcEventHandle_st
{
    char reserved[64];
}cudaIpcEventHandle_t;




typedef __declspec(__device_builtin__) struct __declspec(__device_builtin__) cudaIpcMemHandle_st 
{
    char reserved[64];
}cudaIpcMemHandle_t;




enum __declspec(__device_builtin__) cudaExternalMemoryHandleType {
    


    cudaExternalMemoryHandleTypeOpaqueFd         = 1,
    


    cudaExternalMemoryHandleTypeOpaqueWin32      = 2,
    


    cudaExternalMemoryHandleTypeOpaqueWin32Kmt   = 3,
    


    cudaExternalMemoryHandleTypeD3D12Heap        = 4,
    


    cudaExternalMemoryHandleTypeD3D12Resource    = 5,
    


    cudaExternalMemoryHandleTypeD3D11Resource    = 6,
    


    cudaExternalMemoryHandleTypeD3D11ResourceKmt = 7,
    


    cudaExternalMemoryHandleTypeNvSciBuf         = 8
};









































struct __declspec(__device_builtin__) cudaExternalMemoryHandleDesc {
    


    enum cudaExternalMemoryHandleType type;
    union {
        




        int fd;
        














        struct {
            


            void *handle;
            



            const void *name;
        } win32;
        



        const void *nvSciBufObject;
    } handle;
    


    unsigned long long size;
    


    unsigned int flags;
};




struct __declspec(__device_builtin__) cudaExternalMemoryBufferDesc {
    


    unsigned long long offset;
    


    unsigned long long size;
    


    unsigned int flags;
};
 



struct __declspec(__device_builtin__) cudaExternalMemoryMipmappedArrayDesc {
    



    unsigned long long offset;
    


    struct cudaChannelFormatDesc formatDesc;
    


    struct cudaExtent extent;
    



    unsigned int flags;
    


    unsigned int numLevels;
};
 



enum __declspec(__device_builtin__) cudaExternalSemaphoreHandleType {
    


    cudaExternalSemaphoreHandleTypeOpaqueFd       = 1,
    


    cudaExternalSemaphoreHandleTypeOpaqueWin32    = 2,
    


    cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,
    


    cudaExternalSemaphoreHandleTypeD3D12Fence     = 4,
    


    cudaExternalSemaphoreHandleTypeD3D11Fence     = 5,
    


     cudaExternalSemaphoreHandleTypeNvSciSync     = 6,
    


    cudaExternalSemaphoreHandleTypeKeyedMutex     = 7,
    


    cudaExternalSemaphoreHandleTypeKeyedMutexKmt  = 8,
    


    cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd  = 9,
    


    cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32  = 10
};




struct __declspec(__device_builtin__) cudaExternalSemaphoreHandleDesc {
    


    enum cudaExternalSemaphoreHandleType type;
    union {
        





        int fd;
        














        struct {
            


            void *handle;
            



            const void *name;
        } win32;
        


        const void* nvSciSyncObj;
    } handle;
    


    unsigned int flags;
};




struct __declspec(__device_builtin__) cudaExternalSemaphoreSignalParams_v1 {
    struct {
        


        struct {
            


            unsigned long long value;
        } fence;
        union {
            



            void *fence;
            unsigned long long reserved;
        } nvSciSync;
        


        struct {
            


            unsigned long long key;
        } keyedMutex;
    } params;
    









    unsigned int flags;
};




struct __declspec(__device_builtin__) cudaExternalSemaphoreWaitParams_v1 {
    struct {
        


        struct {
            


            unsigned long long value;
        } fence;
        union {
            



            void *fence;
            unsigned long long reserved;
        } nvSciSync;
        


        struct {
            


            unsigned long long key;
            


            unsigned int timeoutMs;
        } keyedMutex;
    } params;
    









    unsigned int flags;
};




struct __declspec(__device_builtin__) cudaExternalSemaphoreSignalParams{
    struct {
        


        struct {
            


            unsigned long long value;
        } fence;
        union {
            



            void *fence;
            unsigned long long reserved;
        } nvSciSync;
        


        struct {
            


            unsigned long long key;
        } keyedMutex;
        unsigned int reserved[12];
    } params;
    









    unsigned int flags;
    unsigned int reserved[16];
};




struct __declspec(__device_builtin__) cudaExternalSemaphoreWaitParams {
    struct {
        


        struct {
            


            unsigned long long value;
        } fence;
        union {
            



            void *fence;
            unsigned long long reserved;
        } nvSciSync;
        


        struct {
            


            unsigned long long key;
            


            unsigned int timeoutMs;
        } keyedMutex;
        unsigned int reserved[10];
    } params;
    









    unsigned int flags;
    unsigned int reserved[16];
};










typedef __declspec(__device_builtin__) enum cudaError cudaError_t;




typedef __declspec(__device_builtin__) struct CUstream_st *cudaStream_t;




typedef __declspec(__device_builtin__) struct CUevent_st *cudaEvent_t;




typedef __declspec(__device_builtin__) struct cudaGraphicsResource *cudaGraphicsResource_t;




typedef __declspec(__device_builtin__) enum cudaOutputMode cudaOutputMode_t;




typedef __declspec(__device_builtin__) struct CUexternalMemory_st *cudaExternalMemory_t;




typedef __declspec(__device_builtin__) struct CUexternalSemaphore_st *cudaExternalSemaphore_t;




typedef __declspec(__device_builtin__) struct CUgraph_st *cudaGraph_t;




typedef __declspec(__device_builtin__) struct CUgraphNode_st *cudaGraphNode_t;




typedef __declspec(__device_builtin__) struct CUuserObject_st *cudaUserObject_t;




typedef __declspec(__device_builtin__) struct CUfunc_st *cudaFunction_t;




typedef __declspec(__device_builtin__) struct CUmemPoolHandle_st *cudaMemPool_t;




enum __declspec(__device_builtin__) cudaCGScope {
    cudaCGScopeInvalid   = 0, 
    cudaCGScopeGrid      = 1, 
    cudaCGScopeMultiGrid = 2  
};




struct __declspec(__device_builtin__) cudaLaunchParams
{
    void *func;          
    dim3 gridDim;        
    dim3 blockDim;       
    void **args;         
    size_t sharedMem;    
    cudaStream_t stream; 
};




struct __declspec(__device_builtin__) cudaKernelNodeParams {
    void* func;                     
    dim3 gridDim;                   
    dim3 blockDim;                  
    unsigned int sharedMemBytes;    
    void **kernelParams;            
    void **extra;                   
};




struct __declspec(__device_builtin__) cudaExternalSemaphoreSignalNodeParams {
    cudaExternalSemaphore_t* extSemArray;                        
    const struct cudaExternalSemaphoreSignalParams* paramsArray; 
    unsigned int numExtSems;                                     
};




struct __declspec(__device_builtin__) cudaExternalSemaphoreWaitNodeParams {
    cudaExternalSemaphore_t* extSemArray;                      
    const struct cudaExternalSemaphoreWaitParams* paramsArray; 
    unsigned int numExtSems;                                   
};




enum __declspec(__device_builtin__) cudaGraphNodeType {
    cudaGraphNodeTypeKernel      = 0x00, 
    cudaGraphNodeTypeMemcpy      = 0x01, 
    cudaGraphNodeTypeMemset      = 0x02, 
    cudaGraphNodeTypeHost        = 0x03, 
    cudaGraphNodeTypeGraph       = 0x04, 
    cudaGraphNodeTypeEmpty       = 0x05, 
    cudaGraphNodeTypeWaitEvent   = 0x06, 
    cudaGraphNodeTypeEventRecord = 0x07, 
    cudaGraphNodeTypeExtSemaphoreSignal = 0x08, 
    cudaGraphNodeTypeExtSemaphoreWait = 0x09, 
    cudaGraphNodeTypeMemAlloc    = 0x0a, 
    cudaGraphNodeTypeMemFree     = 0x0b, 
    cudaGraphNodeTypeCount
};




typedef struct CUgraphExec_st* cudaGraphExec_t;




enum __declspec(__device_builtin__) cudaGraphExecUpdateResult {
    cudaGraphExecUpdateSuccess                = 0x0, 
    cudaGraphExecUpdateError                  = 0x1, 
    cudaGraphExecUpdateErrorTopologyChanged   = 0x2, 
    cudaGraphExecUpdateErrorNodeTypeChanged   = 0x3, 
    cudaGraphExecUpdateErrorFunctionChanged   = 0x4, 
    cudaGraphExecUpdateErrorParametersChanged = 0x5, 
    cudaGraphExecUpdateErrorNotSupported      = 0x6, 
    cudaGraphExecUpdateErrorUnsupportedFunctionChange = 0x7, 
    cudaGraphExecUpdateErrorAttributesChanged = 0x8 
};




 
enum __declspec(__device_builtin__) cudaGetDriverEntryPointFlags {
    cudaEnableDefault                = 0x0, 
    cudaEnableLegacyStream           = 0x1, 
    cudaEnablePerThreadDefaultStream = 0x2  
};




enum __declspec(__device_builtin__) cudaGraphDebugDotFlags {
    cudaGraphDebugDotFlagsVerbose                  = 1<<0,  
    cudaGraphDebugDotFlagsKernelNodeParams         = 1<<2,  
    cudaGraphDebugDotFlagsMemcpyNodeParams         = 1<<3,  
    cudaGraphDebugDotFlagsMemsetNodeParams         = 1<<4,  
    cudaGraphDebugDotFlagsHostNodeParams           = 1<<5,  
    cudaGraphDebugDotFlagsEventNodeParams          = 1<<6,  
    cudaGraphDebugDotFlagsExtSemasSignalNodeParams = 1<<7,  
    cudaGraphDebugDotFlagsExtSemasWaitNodeParams   = 1<<8,  
    cudaGraphDebugDotFlagsKernelNodeAttributes     = 1<<9,  
    cudaGraphDebugDotFlagsHandles                  = 1<<10  
};




enum __declspec(__device_builtin__) cudaGraphInstantiateFlags {
    cudaGraphInstantiateFlagAutoFreeOnLaunch = 1 
  , cudaGraphInstantiateFlagUseNodePriority  = 8 

};




typedef __declspec(__device_builtin__) enum cudaLaunchAttributeID {
    cudaLaunchAttributeIgnore                = 0 
  , cudaLaunchAttributeAccessPolicyWindow    = 1 
  , cudaLaunchAttributeCooperative           = 2 
  , cudaLaunchAttributeSynchronizationPolicy = 3 
  , cudaLaunchAttributeClusterDimension                  = 4 
  , cudaLaunchAttributeClusterSchedulingPolicyPreference = 5 
  , cudaLaunchAttributeProgrammaticStreamSerialization   = 6 







  , cudaLaunchAttributeProgrammaticEvent                 = 7 

















  , cudaLaunchAttributePriority              = 8 
} cudaLaunchAttributeID;




typedef __declspec(__device_builtin__) union cudaLaunchAttributeValue {
    char pad[64]; 
    struct cudaAccessPolicyWindow accessPolicyWindow;
    int cooperative;
    enum cudaSynchronizationPolicy syncPolicy;
    struct {
        unsigned int x;
        unsigned int y;
        unsigned int z;
    } clusterDim;
    enum cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference;
    int programmaticStreamSerializationAllowed;
    struct {
        cudaEvent_t event;
        int flags;
        int triggerAtBlockStart;
    } programmaticEvent;
    int priority;
} cudaLaunchAttributeValue;




typedef __declspec(__device_builtin__) struct cudaLaunchAttribute_st {
    cudaLaunchAttributeID id;
    char pad[8 - sizeof(cudaLaunchAttributeID)];
    cudaLaunchAttributeValue val;
} cudaLaunchAttribute;




typedef __declspec(__device_builtin__) struct cudaLaunchConfig_st {
    dim3 gridDim;               
    dim3 blockDim;              
    size_t dynamicSmemBytes;    
    cudaStream_t stream;        
    cudaLaunchAttribute *attrs; 
    unsigned int numAttrs;      
} cudaLaunchConfig_t;





























 




#line 3090 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"



#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"


























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
























enum __declspec(__device_builtin__) cudaSurfaceBoundaryMode
{
    cudaBoundaryModeZero  = 0,    
    cudaBoundaryModeClamp = 1,    
    cudaBoundaryModeTrap  = 2     
};




enum __declspec(__device_builtin__)  cudaSurfaceFormatMode
{
    cudaFormatModeForced = 0,     
    cudaFormatModeAuto = 1        
};




struct __declspec(__device_builtin__) surfaceReference
{
    


    struct cudaChannelFormatDesc channelDesc;
};




typedef __declspec(__device_builtin__) unsigned long long cudaSurfaceObject_t;


 

#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"


























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























enum __declspec(__device_builtin__) cudaTextureAddressMode
{
    cudaAddressModeWrap   = 0,    
    cudaAddressModeClamp  = 1,    
    cudaAddressModeMirror = 2,    
    cudaAddressModeBorder = 3     
};




enum __declspec(__device_builtin__) cudaTextureFilterMode
{
    cudaFilterModePoint  = 0,     
    cudaFilterModeLinear = 1      
};




enum __declspec(__device_builtin__) cudaTextureReadMode
{
    cudaReadModeElementType     = 0,  
    cudaReadModeNormalizedFloat = 1   
};




struct __declspec(__device_builtin__) textureReference
{
    


    int                          normalized;
    


    enum cudaTextureFilterMode   filterMode;
    


    enum cudaTextureAddressMode  addressMode[3];
    


    struct cudaChannelFormatDesc channelDesc;
    


    int                          sRGB;
    


    unsigned int                 maxAnisotropy;
    


    enum cudaTextureFilterMode   mipmapFilterMode;
    


    float                        mipmapLevelBias;
    


    float                        minMipmapLevelClamp;
    


    float                        maxMipmapLevelClamp;
    


    int                          disableTrilinearOptimization;
    int                          __cudaReserved[14];
};




struct __declspec(__device_builtin__) cudaTextureDesc
{
    


    enum cudaTextureAddressMode addressMode[3];
    


    enum cudaTextureFilterMode  filterMode;
    


    enum cudaTextureReadMode    readMode;
    


    int                         sRGB;
    


    float                       borderColor[4];
    


    int                         normalizedCoords;
    


    unsigned int                maxAnisotropy;
    


    enum cudaTextureFilterMode  mipmapFilterMode;
    


    float                       mipmapLevelBias;
    


    float                       minMipmapLevelClamp;
    


    float                       maxMipmapLevelClamp;
    


    int                         disableTrilinearOptimization;
};

struct __declspec(__device_builtin__) cudaTextureDesc_v2
{
    


    enum cudaTextureAddressMode addressMode[3];
    


    enum cudaTextureFilterMode  filterMode;
    


    enum cudaTextureReadMode    readMode;
    


    int                         sRGB;
    


    float                       borderColor[4];
    


    int                         normalizedCoords;
    


    unsigned int                maxAnisotropy;
    


    enum cudaTextureFilterMode  mipmapFilterMode;
    


    float                       mipmapLevelBias;
    


    float                       minMipmapLevelClamp;
    


    float                       maxMipmapLevelClamp;
    


    int                         disableTrilinearOptimization;
    


    int                         seamlessCubemap;
};




typedef __declspec(__device_builtin__) unsigned long long cudaTextureObject_t;


 

#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 92 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\library_types.h"






















































typedef enum cudaDataType_t
{
    CUDA_R_16F  =  2, 
    CUDA_C_16F  =  6, 
    CUDA_R_16BF = 14, 
    CUDA_C_16BF = 15, 
    CUDA_R_32F  =  0, 
    CUDA_C_32F  =  4, 
    CUDA_R_64F  =  1, 
    CUDA_C_64F  =  5, 
    CUDA_R_4I   = 16, 
    CUDA_C_4I   = 17, 
    CUDA_R_4U   = 18, 
    CUDA_C_4U   = 19, 
    CUDA_R_8I   =  3, 
    CUDA_C_8I   =  7, 
    CUDA_R_8U   =  8, 
    CUDA_C_8U   =  9, 
    CUDA_R_16I  = 20, 
    CUDA_C_16I  = 21, 
    CUDA_R_16U  = 22, 
    CUDA_C_16U  = 23, 
    CUDA_R_32I  = 10, 
    CUDA_C_32I  = 11, 
    CUDA_R_32U  = 12, 
    CUDA_C_32U  = 13, 
    CUDA_R_64I  = 24, 
    CUDA_C_64I  = 25, 
    CUDA_R_64U  = 26, 
    CUDA_C_64U  = 27, 
    CUDA_R_8F_E4M3 = 28, 
    CUDA_R_8F_E5M2 = 29, 
} cudaDataType;


typedef enum libraryPropertyType_t
{
    MAJOR_VERSION,
    MINOR_VERSION,
    PATCH_LEVEL
} libraryPropertyType;







#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\library_types.h"
#line 93 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"




























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"





















































































#line 145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
#line 148 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 150 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"








































































































#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"

#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"



#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"





#line 118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"





#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"




#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"

extern "C"
{
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);


extern __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("Use of ""cudaDeviceSynchronize"" from device code is deprecated. Moreover, such use will cause this module to fail to load on sm_90+ devices. If calls to ""cudaDeviceSynchronize"" from device code cannot be removed for older devices at this time, you may guard them with __CUDA_ARCH__ macros to remove them only for sm_90+ devices, making sure to generate code for compute_90 for the macros to take effect. Note that this mitigation will no longer work when support for ""cudaDeviceSynchronize"" from device code is eventually dropped for all devices. Disable this warning with -D__CDPRT_SUPPRESS_SYNC_DEPRECATION_WARNING.")) cudaError_t __stdcall cudaDeviceSynchronize(void);
#line 141 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall __cudaDeviceSynchronizeDeprecationAvoidance(void);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetLastError(void);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaPeekAtLastError(void);
extern __declspec(__device__) __declspec(__cudart_builtin__) const char* __stdcall cudaGetErrorString(cudaError_t error);
extern __declspec(__device__) __declspec(__cudart_builtin__) const char* __stdcall cudaGetErrorName(cudaError_t error);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDeviceCount(int *count);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDevice(int *device);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecordWithFlags_ptsz(cudaEvent_t event, cudaStream_t stream, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFree(void *devPtr);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMalloc(void **devPtr, size_t size);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpyAsync_ptsz(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy2DAsync_ptsz(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy3DAsync_ptsz(const struct cudaMemcpy3DParms *p, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemsetAsync_ptsz(void *devPtr, int value, size_t count, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset2DAsync_ptsz(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset3DAsync_ptsz(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaRuntimeGetVersion(int *runtimeVersion);




















extern __declspec(__device__) __declspec(__cudart_builtin__) void * __stdcall cudaGetParameterBuffer(size_t alignment, size_t size);



























extern __declspec(__device__) __declspec(__cudart_builtin__) void * __stdcall cudaGetParameterBufferV2(void *func, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaLaunchDevice_ptsz(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaLaunchDeviceV2_ptsz(void *parameterBuffer, cudaStream_t stream);
















#line 242 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
    extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaLaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);
    extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaLaunchDeviceV2(void *parameterBuffer, cudaStream_t stream);
#line 245 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"

extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize, unsigned int flags);

extern __declspec(__device__) __declspec(__cudart_builtin__) unsigned long long __stdcall cudaCGGetIntrinsicHandle(enum cudaCGScope scope);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaCGSynchronize(unsigned long long handle, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaCGSynchronizeGrid(unsigned long long handle, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaCGGetSize(unsigned int *numThreads, unsigned int *numGrids, unsigned long long handle);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaCGGetRank(unsigned int *threadRank, unsigned int *gridRank, unsigned long long handle);
}

template <typename T> static __inline __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t cudaMalloc(T **devPtr, size_t size);
template <typename T> static __inline __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, T *entry);
template <typename T> static __inline __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, T func, int blockSize, size_t dynamicSmemSize);
template <typename T> static __inline __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned int flags);


#line 263 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
#line 264 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"




#line 269 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_device_runtime_api.h"
#line 152 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"





#line 158 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
    
    
#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"





























































#line 223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"













#line 237 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

#line 239 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"










#line 250 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"







#line 258 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"





#line 264 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



extern "C" {
#line 269 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"






































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceReset(void);





















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceSynchronize(void);






















































































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetLimit(enum cudaLimit limit, size_t value);
































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);






















 extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetTexture1DLinearMaxWidth(size_t *maxWidthInElements, const struct cudaChannelFormatDesc *fmtDesc, int device);
#line 474 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);




































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int *leastPriority, int *greatestPriority);











































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetCacheConfig(enum cudaFuncCache cacheConfig);






























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);











































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetSharedMemConfig(enum cudaSharedMemConfig config);


























extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetByPCIBusId(int *device, const char *pciBusId);





























extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetPCIBusId(char *pciBusId, int len, int device);















































extern __declspec(__host__) cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t *handle, cudaEvent_t event);








































extern __declspec(__host__) cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t *event, cudaIpcEventHandle_t handle);










































extern __declspec(__host__) cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t *handle, void *devPtr);































































extern __declspec(__host__) cudaError_t __stdcall cudaIpcOpenMemHandle(void **devPtr, cudaIpcMemHandle_t handle, unsigned int flags);



































extern __declspec(__host__) cudaError_t __stdcall cudaIpcCloseMemHandle(void *devPtr);































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceFlushGPUDirectRDMAWrites(enum cudaFlushGPUDirectRDMAWritesTarget target, enum cudaFlushGPUDirectRDMAWritesScope scope);
#line 985 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

 







































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaThreadExit(void);

























extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaThreadSynchronize(void);
















































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaThreadSetLimit(enum cudaLimit limit, size_t value);
































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaThreadGetLimit(size_t *pValue, enum cudaLimit limit);



































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaThreadGetCacheConfig(enum cudaFuncCache *pCacheConfig);














































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaThreadSetCacheConfig(enum cudaFuncCache cacheConfig);

 


























































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetLastError(void);















































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaPeekAtLastError(void);















extern __declspec(__host__) __declspec(__cudart_builtin__) const char* __stdcall cudaGetErrorName(cudaError_t error);















extern __declspec(__host__) __declspec(__cudart_builtin__) const char* __stdcall cudaGetErrorString(cudaError_t error);
 


























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDeviceCount(int *count);
















































































































































































































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDeviceProperties(struct cudaDeviceProp *prop, int device);







































































































































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);

















extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetDefaultMemPool(cudaMemPool_t *memPool, int device);























extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetMemPool(int device, cudaMemPool_t memPool);



















extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetMemPool(cudaMemPool_t *memPool, int device);















































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetNvSciSyncAttributes(void *nvSciSyncAttrList, int device, int flags);







































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetP2PAttribute(int *value, enum cudaDeviceP2PAttr attr, int srcDevice, int dstDevice);




















extern __declspec(__host__) cudaError_t __stdcall cudaChooseDevice(int *device, const struct cudaDeviceProp *prop);











































extern __declspec(__host__) cudaError_t __stdcall cudaSetDevice(int device);




















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDevice(int *device);






























extern __declspec(__host__) cudaError_t __stdcall cudaSetValidDevices(int *device_arr, int len);
































































extern __declspec(__host__) cudaError_t __stdcall cudaSetDeviceFlags( unsigned int flags );











































extern __declspec(__host__) cudaError_t __stdcall cudaGetDeviceFlags( unsigned int *flags );
 






































extern __declspec(__host__) cudaError_t __stdcall cudaStreamCreate(cudaStream_t *pStream);































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);













































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t *pStream, unsigned int flags, int priority);


























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t hStream, int *priority);
























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t hStream, unsigned int *flags);














extern __declspec(__host__) cudaError_t __stdcall cudaCtxResetPersistingL2Cache(void);



















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCopyAttributes(cudaStream_t dst, cudaStream_t src);

 


















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamGetAttribute(
        cudaStream_t hStream, cudaLaunchAttributeID attr,
        cudaLaunchAttributeValue *value_out);

 



















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamSetAttribute(
        cudaStream_t hStream, cudaLaunchAttributeID attr,
        const cudaLaunchAttributeValue *value);

 





























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream);






























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags = 0);







typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void *userData);


































































extern __declspec(__host__) cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t stream,
        cudaStreamCallback_t callback, void *userData, unsigned int flags);






















extern __declspec(__host__) cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream);
























extern __declspec(__host__) cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream);



















































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamAttachMemAsync(cudaStream_t stream, void *devPtr, size_t length = 0, unsigned int flags = 0x04);


#line 2762 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































extern __declspec(__host__) cudaError_t __stdcall cudaStreamBeginCapture(cudaStream_t stream, enum cudaStreamCaptureMode mode);


















































extern __declspec(__host__) cudaError_t __stdcall cudaThreadExchangeStreamCaptureMode(enum cudaStreamCaptureMode *mode);



























extern __declspec(__host__) cudaError_t __stdcall cudaStreamEndCapture(cudaStream_t stream, cudaGraph_t *pGraph);





































extern __declspec(__host__) cudaError_t __stdcall cudaStreamIsCapturing(cudaStream_t stream, enum cudaStreamCaptureStatus *pCaptureStatus);































extern __declspec(__host__) cudaError_t __stdcall cudaStreamGetCaptureInfo(cudaStream_t stream, enum cudaStreamCaptureStatus *pCaptureStatus, unsigned long long *pId);






















































extern __declspec(__host__) cudaError_t __stdcall cudaStreamGetCaptureInfo_v2(cudaStream_t stream, enum cudaStreamCaptureStatus *captureStatus_out, unsigned long long *id_out = 0, cudaGraph_t *graph_out = 0, const cudaGraphNode_t **dependencies_out = 0, size_t *numDependencies_out = 0);
































extern __declspec(__host__) cudaError_t __stdcall cudaStreamUpdateCaptureDependencies(cudaStream_t stream, cudaGraphNode_t *dependencies, size_t numDependencies, unsigned int flags = 0);
 



































extern __declspec(__host__) cudaError_t __stdcall cudaEventCreate(cudaEvent_t *event);




































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);







































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);














































 extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream = 0, unsigned int flags = 0);
#line 3197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"






























extern __declspec(__host__) cudaError_t __stdcall cudaEventQuery(cudaEvent_t event);





























extern __declspec(__host__) cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event);











































extern __declspec(__host__) cudaError_t __stdcall cudaEventElapsedTime(float *ms, cudaEvent_t start, cudaEvent_t end);

 

















































































































































































extern __declspec(__host__) cudaError_t __stdcall cudaImportExternalMemory(cudaExternalMemory_t *extMem_out, const struct cudaExternalMemoryHandleDesc *memHandleDesc);






















































extern __declspec(__host__) cudaError_t __stdcall cudaExternalMemoryGetMappedBuffer(void **devPtr, cudaExternalMemory_t extMem, const struct cudaExternalMemoryBufferDesc *bufferDesc);





























































extern __declspec(__host__) cudaError_t __stdcall cudaExternalMemoryGetMappedMipmappedArray(cudaMipmappedArray_t *mipmap, cudaExternalMemory_t extMem, const struct cudaExternalMemoryMipmappedArrayDesc *mipmapDesc);























extern __declspec(__host__) cudaError_t __stdcall cudaDestroyExternalMemory(cudaExternalMemory_t extMem);
























































































































































extern __declspec(__host__) cudaError_t __stdcall cudaImportExternalSemaphore(cudaExternalSemaphore_t *extSem_out, const struct cudaExternalSemaphoreHandleDesc *semHandleDesc);


































































extern __declspec(__host__) cudaError_t __stdcall cudaSignalExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t *extSemArray, const struct cudaExternalSemaphoreSignalParams *paramsArray, unsigned int numExtSems, cudaStream_t stream = 0);











































































extern __declspec(__host__) cudaError_t __stdcall cudaWaitExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t *extSemArray, const struct cudaExternalSemaphoreWaitParams *paramsArray, unsigned int numExtSems, cudaStream_t stream = 0);






















extern __declspec(__host__) cudaError_t __stdcall cudaDestroyExternalSemaphore(cudaExternalSemaphore_t extSem);

 
































































extern __declspec(__host__) cudaError_t __stdcall cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream);





























































extern __declspec(__host__) cudaError_t __stdcall cudaLaunchKernelExC(const cudaLaunchConfig_t *config, const void *func, void **args);
























































extern __declspec(__host__) cudaError_t __stdcall cudaLaunchCooperativeKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream);




































































































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaLaunchCooperativeKernelMultiDevice(struct cudaLaunchParams *launchParamsList, unsigned int numDevices, unsigned int flags  = 0);














































extern __declspec(__host__) cudaError_t __stdcall cudaFuncSetCacheConfig(const void *func, enum cudaFuncCache cacheConfig);






















































extern __declspec(__host__) cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void *func, enum cudaSharedMemConfig config);
































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);




































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFuncSetAttribute(const void *func, enum cudaFuncAttribute attr, int value);























extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaSetDoubleForDevice(double *d);























extern __declspec(deprecated)  __declspec(__host__) cudaError_t __stdcall cudaSetDoubleForHost(double *d);

































































extern __declspec(__host__) cudaError_t __stdcall cudaLaunchHostFunc(cudaStream_t stream, cudaHostFn_t fn, void *userData);

 






















































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaOccupancyAvailableDynamicSMemPerBlock(size_t *dynamicSmemSize, const void *func, int numBlocks, int blockSize);












































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize, unsigned int flags);


































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaOccupancyMaxPotentialClusterSize(int *clusterSize, const void *func, const cudaLaunchConfig_t *launchConfig);






































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaOccupancyMaxActiveClusters(int *numClusters, const void *func, const cudaLaunchConfig_t *launchConfig);
 






















































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMallocManaged(void **devPtr, size_t size, unsigned int flags = 0x01);


#line 4872 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"





























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMalloc(void **devPtr, size_t size);
































extern __declspec(__host__) cudaError_t __stdcall cudaMallocHost(void **ptr, size_t size);










































extern __declspec(__host__) cudaError_t __stdcall cudaMallocPitch(void **devPtr, size_t *pitch, size_t width, size_t height);



















































extern __declspec(__host__) cudaError_t __stdcall cudaMallocArray(cudaArray_t *array, const struct cudaChannelFormatDesc *desc, size_t width, size_t height = 0, unsigned int flags = 0);





































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFree(void *devPtr);






















extern __declspec(__host__) cudaError_t __stdcall cudaFreeHost(void *ptr);






















extern __declspec(__host__) cudaError_t __stdcall cudaFreeArray(cudaArray_t array);






















extern __declspec(__host__) cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray);

































































extern __declspec(__host__) cudaError_t __stdcall cudaHostAlloc(void **pHost, size_t size, unsigned int flags);




























































































extern __declspec(__host__) cudaError_t __stdcall cudaHostRegister(void *ptr, size_t size, unsigned int flags);






















extern __declspec(__host__) cudaError_t __stdcall cudaHostUnregister(void *ptr);












































extern __declspec(__host__) cudaError_t __stdcall cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);





















extern __declspec(__host__) cudaError_t __stdcall cudaHostGetFlags(unsigned int *pFlags, void *pHost);






































extern __declspec(__host__) cudaError_t __stdcall cudaMalloc3D(struct cudaPitchedPtr* pitchedDevPtr, struct cudaExtent extent);
















































































































































extern __declspec(__host__) cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t *array, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int flags = 0);
















































































































































extern __declspec(__host__) cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t *mipmappedArray, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int numLevels, unsigned int flags = 0);
































extern __declspec(__host__) cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t *levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned int level);








































































































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3D(const struct cudaMemcpy3DParms *p);






























extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3DPeer(const struct cudaMemcpy3DPeerParms *p);





















































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream = 0);

























extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3DPeerAsync(const struct cudaMemcpy3DPeerParms *p, cudaStream_t stream = 0);

































extern __declspec(__host__) cudaError_t __stdcall cudaMemGetInfo(size_t *free, size_t *total);

























extern __declspec(__host__) cudaError_t __stdcall cudaArrayGetInfo(struct cudaChannelFormatDesc *desc, struct cudaExtent *extent, unsigned int *flags, cudaArray_t array);




























extern __declspec(__host__) cudaError_t __stdcall cudaArrayGetPlane(cudaArray_t *pPlaneArray, cudaArray_t hArray, unsigned int planeIdx);






















extern __declspec(__host__) cudaError_t __stdcall cudaArrayGetMemoryRequirements(struct cudaArrayMemoryRequirements  *memoryRequirements, cudaArray_t array, int device);























extern __declspec(__host__) cudaError_t __stdcall cudaMipmappedArrayGetMemoryRequirements(struct cudaArrayMemoryRequirements *memoryRequirements, cudaMipmappedArray_t mipmap, int device);



























 extern __declspec(__host__) cudaError_t __stdcall cudaArrayGetSparseProperties(struct cudaArraySparseProperties *sparseProperties, cudaArray_t array);
#line 6193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"




























 extern __declspec(__host__) cudaError_t __stdcall cudaMipmappedArrayGetSparseProperties(struct cudaArraySparseProperties *sparseProperties, cudaMipmappedArray_t mipmap);
#line 6223 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"











































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyPeer(void *dst, int dstDevice, const void *src, int srcDevice, size_t count);
















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2D(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);

















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);

















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DFromArray(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind);














































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);










































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToSymbol(const void *symbol, const void *src, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyHostToDevice);










































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromSymbol(void *dst, const void *symbol, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost);
























































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyPeerAsync(void *dst, int dstDevice, const void *src, int srcDevice, size_t count, cudaStream_t stream = 0);






























































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);

























































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
























































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);


















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void *symbol, const void *src, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);


















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void *dst, const void *symbol, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);




























extern __declspec(__host__) cudaError_t __stdcall cudaMemset(void *devPtr, int value, size_t count);

































extern __declspec(__host__) cudaError_t __stdcall cudaMemset2D(void *devPtr, size_t pitch, int value, size_t width, size_t height);













































extern __declspec(__host__) cudaError_t __stdcall cudaMemset3D(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent);



































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream = 0);








































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0);




















































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream = 0);



























extern __declspec(__host__) cudaError_t __stdcall cudaGetSymbolAddress(void **devPtr, const void *symbol);


























extern __declspec(__host__) cudaError_t __stdcall cudaGetSymbolSize(size_t *size, const void *symbol);





































































extern __declspec(__host__) cudaError_t __stdcall cudaMemPrefetchAsync(const void *devPtr, size_t count, int dstDevice, cudaStream_t stream = 0);



















































































































extern __declspec(__host__) cudaError_t __stdcall cudaMemAdvise(const void *devPtr, size_t count, enum cudaMemoryAdvise advice, int device);


























































extern __declspec(__host__) cudaError_t __stdcall cudaMemRangeGetAttribute(void *data, size_t dataSize, enum cudaMemRangeAttribute attribute, const void *devPtr, size_t count);






































extern __declspec(__host__) cudaError_t __stdcall cudaMemRangeGetAttributes(void **data, size_t *dataSizes, enum cudaMemRangeAttribute *attributes, size_t numAttributes, const void *devPtr, size_t count);

 

























































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind);









































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromArray(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind);










































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);


















































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);

















































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromArrayAsync(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);

 


































































extern __declspec(__host__) cudaError_t __stdcall cudaMallocAsync(void **devPtr, size_t size, cudaStream_t hStream);

























extern __declspec(__host__) cudaError_t __stdcall cudaFreeAsync(void *devPtr, cudaStream_t hStream);
























extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolTrimTo(cudaMemPool_t memPool, size_t minBytesToKeep);











































extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolSetAttribute(cudaMemPool_t memPool, enum cudaMemPoolAttr attr, void *value );















































extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolGetAttribute(cudaMemPool_t memPool, enum cudaMemPoolAttr attr, void *value );














extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolSetAccess(cudaMemPool_t memPool, const struct cudaMemAccessDesc *descList, size_t count);












extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolGetAccess(enum cudaMemAccessFlags *flags, cudaMemPool_t memPool, struct cudaMemLocation *location);



















extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolCreate(cudaMemPool_t *memPool, const struct cudaMemPoolProps *poolProps);





















extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolDestroy(cudaMemPool_t memPool);



































extern __declspec(__host__) cudaError_t __stdcall cudaMallocFromPoolAsync(void **ptr, size_t size, cudaMemPool_t memPool, cudaStream_t stream);
























extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolExportToShareableHandle(
    void                            *shareableHandle,
    cudaMemPool_t                    memPool,
    enum cudaMemAllocationHandleType handleType,
    unsigned int                     flags);






















extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolImportFromShareableHandle(
    cudaMemPool_t                   *memPool,
    void                            *shareableHandle,
    enum cudaMemAllocationHandleType handleType,
    unsigned int                     flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolExportPointer(struct cudaMemPoolPtrExportData *exportData, void *ptr);




























extern __declspec(__host__) cudaError_t __stdcall cudaMemPoolImportPointer(void **ptr, cudaMemPool_t memPool, struct cudaMemPoolPtrExportData *exportData);

 





















































































































































extern __declspec(__host__) cudaError_t __stdcall cudaPointerGetAttributes(struct cudaPointerAttributes *attributes, const void *ptr);

 






































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceCanAccessPeer(int *canAccessPeer, int device, int peerDevice);









































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceEnablePeerAccess(int peerDevice, unsigned int flags);





















extern __declspec(__host__) cudaError_t __stdcall cudaDeviceDisablePeerAccess(int peerDevice);

 





























































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource);


































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned int flags);






































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsMapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);


































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void **devPtr, size_t *size, cudaGraphicsResource_t resource);





































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t *array, cudaGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel);




























extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t *mipmappedArray, cudaGraphicsResource_t resource);

 




































































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaBindTexture(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t size = 0xffffffff);


























































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaBindTexture2D(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t width, size_t height, size_t pitch);





































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaBindTextureToArray(const struct textureReference *texref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);







































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaBindTextureToMipmappedArray(const struct textureReference *texref, cudaMipmappedArray_const_t mipmappedArray, const struct cudaChannelFormatDesc *desc);

























extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaUnbindTexture(const struct textureReference *texref);




























extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t *offset, const struct textureReference *texref);





























extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaGetTextureReference(const struct textureReference **texref, const void *symbol);

 










































extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaBindSurfaceToArray(const struct surfaceReference *surfref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);
























extern __declspec(deprecated) __declspec(__host__) cudaError_t __stdcall cudaGetSurfaceReference(const struct surfaceReference **surfref, const void *symbol);

 
































extern __declspec(__host__) cudaError_t __stdcall cudaGetChannelDesc(struct cudaChannelFormatDesc *desc, cudaArray_const_t array);





























extern __declspec(__host__) struct cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);
























































































































































































































extern __declspec(__host__) cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t *pTexObject, const struct cudaResourceDesc *pResDesc, const struct cudaTextureDesc *pTexDesc, const struct cudaResourceViewDesc *pResViewDesc);































































































































































































































extern __declspec(__host__) cudaError_t __stdcall cudaCreateTextureObject_v2(cudaTextureObject_t *pTexObject, const struct cudaResourceDesc *pResDesc, const struct cudaTextureDesc_v2 *pTexDesc, const struct cudaResourceViewDesc *pResViewDesc);



















extern __declspec(__host__) cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t texObject);



















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaTextureObject_t texObject);



















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectTextureDesc(struct cudaTextureDesc *pTexDesc, cudaTextureObject_t texObject);



















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectTextureDesc_v2(struct cudaTextureDesc_v2 *pTexDesc, cudaTextureObject_t texObject);




















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(struct cudaResourceViewDesc *pResViewDesc, cudaTextureObject_t texObject);

 










































extern __declspec(__host__) cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t *pSurfObject, const struct cudaResourceDesc *pResDesc);



















extern __declspec(__host__) cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject);


















extern __declspec(__host__) cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaSurfaceObject_t surfObject);

 































extern __declspec(__host__) cudaError_t __stdcall cudaDriverGetVersion(int *driverVersion);
























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaRuntimeGetVersion(int *runtimeVersion);

 












































extern __declspec(__host__) cudaError_t __stdcall cudaGraphCreate(cudaGraph_t *pGraph, unsigned int flags);
































































































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddKernelNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaKernelNodeParams *pNodeParams);
































extern __declspec(__host__) cudaError_t __stdcall cudaGraphKernelNodeGetParams(cudaGraphNode_t node, struct cudaKernelNodeParams *pNodeParams);
























extern __declspec(__host__) cudaError_t __stdcall cudaGraphKernelNodeSetParams(cudaGraphNode_t node, const struct cudaKernelNodeParams *pNodeParams);



















extern __declspec(__host__) cudaError_t __stdcall cudaGraphKernelNodeCopyAttributes(
        cudaGraphNode_t hSrc,
        cudaGraphNode_t hDst);




















extern __declspec(__host__) cudaError_t __stdcall cudaGraphKernelNodeGetAttribute(
    cudaGraphNode_t hNode,
    cudaLaunchAttributeID attr,
    cudaLaunchAttributeValue *value_out);




















extern __declspec(__host__) cudaError_t __stdcall cudaGraphKernelNodeSetAttribute(
    cudaGraphNode_t hNode,
    cudaLaunchAttributeID attr,
    const cudaLaunchAttributeValue *value);














































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddMemcpyNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaMemcpy3DParms *pCopyParams);


























































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddMemcpyNodeToSymbol(
    cudaGraphNode_t *pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t *pDependencies,
    size_t numDependencies,
    const void* symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
#line 10232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"


























































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddMemcpyNodeFromSymbol(
    cudaGraphNode_t* pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t* pDependencies,
    size_t numDependencies,
    void* dst,
    const void* symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
#line 10301 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddMemcpyNode1D(
    cudaGraphNode_t *pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t *pDependencies,
    size_t numDependencies,
    void* dst,
    const void* src,
    size_t count,
    enum cudaMemcpyKind kind);
#line 10368 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"






















extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemcpyNodeGetParams(cudaGraphNode_t node, struct cudaMemcpy3DParms *pNodeParams);

























extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemcpyNodeSetParams(cudaGraphNode_t node, const struct cudaMemcpy3DParms *pNodeParams);






































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemcpyNodeSetParamsToSymbol(
    cudaGraphNode_t node,
    const void* symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
#line 10463 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"






































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemcpyNodeSetParamsFromSymbol(
    cudaGraphNode_t node,
    void* dst,
    const void* symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
#line 10509 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"






































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemcpyNodeSetParams1D(
    cudaGraphNode_t node,
    void* dst,
    const void* src,
    size_t count,
    enum cudaMemcpyKind kind);
#line 10554 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"








































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddMemsetNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaMemsetParams *pMemsetParams);






















extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemsetNodeGetParams(cudaGraphNode_t node, struct cudaMemsetParams *pNodeParams);






















extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemsetNodeSetParams(cudaGraphNode_t node, const struct cudaMemsetParams *pNodeParams);








































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddHostNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaHostNodeParams *pNodeParams);






















extern __declspec(__host__) cudaError_t __stdcall cudaGraphHostNodeGetParams(cudaGraphNode_t node, struct cudaHostNodeParams *pNodeParams);






















extern __declspec(__host__) cudaError_t __stdcall cudaGraphHostNodeSetParams(cudaGraphNode_t node, const struct cudaHostNodeParams *pNodeParams);







































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddChildGraphNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, cudaGraph_t childGraph);


























extern __declspec(__host__) cudaError_t __stdcall cudaGraphChildGraphNodeGetGraph(cudaGraphNode_t node, cudaGraph_t *pGraph);




































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddEmptyNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies);










































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddEventRecordNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, cudaEvent_t event);
#line 10876 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























 extern __declspec(__host__) cudaError_t __stdcall cudaGraphEventRecordNodeGetEvent(cudaGraphNode_t node, cudaEvent_t *event_out);
#line 10903 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























 extern __declspec(__host__) cudaError_t __stdcall cudaGraphEventRecordNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event);
#line 10930 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"












































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddEventWaitNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, cudaEvent_t event);
#line 10976 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























 extern __declspec(__host__) cudaError_t __stdcall cudaGraphEventWaitNodeGetEvent(cudaGraphNode_t node, cudaEvent_t *event_out);
#line 11003 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























 extern __declspec(__host__) cudaError_t __stdcall cudaGraphEventWaitNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event);
#line 11030 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"















































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddExternalSemaphoresSignalNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaExternalSemaphoreSignalNodeParams *nodeParams);
#line 11079 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExternalSemaphoresSignalNodeGetParams(cudaGraphNode_t hNode, struct cudaExternalSemaphoreSignalNodeParams *params_out);
#line 11112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























extern __declspec(__host__) cudaError_t __stdcall cudaGraphExternalSemaphoresSignalNodeSetParams(cudaGraphNode_t hNode, const struct cudaExternalSemaphoreSignalNodeParams *nodeParams);
#line 11139 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"















































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddExternalSemaphoresWaitNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaExternalSemaphoreWaitNodeParams *nodeParams);
#line 11188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExternalSemaphoresWaitNodeGetParams(cudaGraphNode_t hNode, struct cudaExternalSemaphoreWaitNodeParams *params_out);
#line 11221 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























extern __declspec(__host__) cudaError_t __stdcall cudaGraphExternalSemaphoresWaitNodeSetParams(cudaGraphNode_t hNode, const struct cudaExternalSemaphoreWaitNodeParams *nodeParams);
#line 11248 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"











































































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddMemAllocNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, struct cudaMemAllocNodeParams *nodeParams);
#line 11325 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

























extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemAllocNodeGetParams(cudaGraphNode_t node, struct cudaMemAllocNodeParams *params_out);
#line 11352 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"


























































extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddMemFreeNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, void *dptr);
#line 11412 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"






















extern __declspec(__host__) cudaError_t __stdcall cudaGraphMemFreeNodeGetParams(cudaGraphNode_t node, void *dptr_out);
#line 11436 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"


























extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGraphMemTrim(int device);
#line 11464 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetGraphMemAttribute(int device, enum cudaGraphMemAttributeType attr, void* value);
#line 11501 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetGraphMemAttribute(int device, enum cudaGraphMemAttributeType attr, void* value);
#line 11535 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"


























extern __declspec(__host__) cudaError_t __stdcall cudaGraphClone(cudaGraph_t *pGraphClone, cudaGraph_t originalGraph);



























extern __declspec(__host__) cudaError_t __stdcall cudaGraphNodeFindInClone(cudaGraphNode_t *pNode, cudaGraphNode_t originalNode, cudaGraph_t clonedGraph);






























extern __declspec(__host__) cudaError_t __stdcall cudaGraphNodeGetType(cudaGraphNode_t node, enum cudaGraphNodeType *pType);






























extern __declspec(__host__) cudaError_t __stdcall cudaGraphGetNodes(cudaGraph_t graph, cudaGraphNode_t *nodes, size_t *numNodes);






























extern __declspec(__host__) cudaError_t __stdcall cudaGraphGetRootNodes(cudaGraph_t graph, cudaGraphNode_t *pRootNodes, size_t *pNumRootNodes);

































extern __declspec(__host__) cudaError_t __stdcall cudaGraphGetEdges(cudaGraph_t graph, cudaGraphNode_t *from, cudaGraphNode_t *to, size_t *numEdges);






























extern __declspec(__host__) cudaError_t __stdcall cudaGraphNodeGetDependencies(cudaGraphNode_t node, cudaGraphNode_t *pDependencies, size_t *pNumDependencies);































extern __declspec(__host__) cudaError_t __stdcall cudaGraphNodeGetDependentNodes(cudaGraphNode_t node, cudaGraphNode_t *pDependentNodes, size_t *pNumDependentNodes);






























extern __declspec(__host__) cudaError_t __stdcall cudaGraphAddDependencies(cudaGraph_t graph, const cudaGraphNode_t *from, const cudaGraphNode_t *to, size_t numDependencies);






























extern __declspec(__host__) cudaError_t __stdcall cudaGraphRemoveDependencies(cudaGraph_t graph, const cudaGraphNode_t *from, const cudaGraphNode_t *to, size_t numDependencies);





























extern __declspec(__host__) cudaError_t __stdcall cudaGraphDestroyNode(cudaGraphNode_t node);





































extern __declspec(__host__) cudaError_t __stdcall cudaGraphInstantiate(cudaGraphExec_t *pGraphExec, cudaGraph_t graph, cudaGraphNode_t *pErrorNode, char *pLogBuffer, size_t bufferSize);















































extern __declspec(__host__) cudaError_t __stdcall cudaGraphInstantiateWithFlags(cudaGraphExec_t *pGraphExec, cudaGraph_t graph, unsigned long long flags);
#line 11959 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"










































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecKernelNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const struct cudaKernelNodeParams *pNodeParams);

















































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const struct cudaMemcpy3DParms *pNodeParams);






















































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParamsToSymbol(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    const void* symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
#line 12115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"






















































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParamsFromSymbol(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    void* dst,
    const void* symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
#line 12178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"




















































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecMemcpyNodeSetParams1D(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    void* dst,
    const void* src,
    size_t count,
    enum cudaMemcpyKind kind);
#line 12238 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"














































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecMemsetNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const struct cudaMemsetParams *pNodeParams);






































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecHostNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const struct cudaHostNodeParams *pNodeParams);













































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecChildGraphNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, cudaGraph_t childGraph);
#line 12371 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"










































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecEventRecordNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event);
#line 12415 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"










































 extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecEventWaitNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event);
#line 12459 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"













































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecExternalSemaphoresSignalNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const struct cudaExternalSemaphoreSignalNodeParams *nodeParams);
#line 12506 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"













































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecExternalSemaphoresWaitNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const struct cudaExternalSemaphoreWaitNodeParams *nodeParams);
#line 12553 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"






































extern __declspec(__host__) cudaError_t __stdcall cudaGraphNodeSetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned int isEnabled);
#line 12593 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
































extern __declspec(__host__) cudaError_t __stdcall cudaGraphNodeGetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned int *isEnabled);
#line 12627 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"















































































extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecUpdate(cudaGraphExec_t hGraphExec, cudaGraph_t hGraph, cudaGraphNode_t *hErrorNode_out, enum cudaGraphExecUpdateResult *updateResult_out);
























 extern __declspec(__host__) cudaError_t __stdcall cudaGraphUpload(cudaGraphExec_t graphExec, cudaStream_t stream);
#line 12733 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"





























extern __declspec(__host__) cudaError_t __stdcall cudaGraphLaunch(cudaGraphExec_t graphExec, cudaStream_t stream);






















extern __declspec(__host__) cudaError_t __stdcall cudaGraphExecDestroy(cudaGraphExec_t graphExec);




















extern __declspec(__host__) cudaError_t __stdcall cudaGraphDestroy(cudaGraph_t graph);


















extern __declspec(__host__) cudaError_t __stdcall cudaGraphDebugDotPrint(cudaGraph_t graph, const char *path, unsigned int flags);



































extern __declspec(__host__) cudaError_t __stdcall cudaUserObjectCreate(cudaUserObject_t *object_out, void *ptr, cudaHostFn_t destroy, unsigned int initialRefcount, unsigned int flags);























extern __declspec(__host__) cudaError_t __stdcall cudaUserObjectRetain(cudaUserObject_t object, unsigned int count = 1);



























extern __declspec(__host__) cudaError_t __stdcall cudaUserObjectRelease(cudaUserObject_t object, unsigned int count = 1);



























extern __declspec(__host__) cudaError_t __stdcall cudaGraphRetainUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned int count = 1, unsigned int flags = 0);
























extern __declspec(__host__) cudaError_t __stdcall cudaGraphReleaseUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned int count = 1);

 































































extern __declspec(__host__) cudaError_t __stdcall cudaGetDriverEntryPoint(const char *symbol, void **funcPtr, unsigned long long flags);

 


extern __declspec(__host__) cudaError_t __stdcall cudaGetExportTable(const void **ppExportTable, const cudaUUID_t *pExportTableId);



































































































































































 











extern __declspec(__host__) cudaError_t __cdecl cudaGetFuncBySymbol(cudaFunction_t* functionPtr, const void* symbolPtr);

 






























































































































#line 13343 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



















#line 13363 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"


}

#line 13368 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"


#line 13371 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"







#line 13379 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"

#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"






























































template<class T> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
  return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf1(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf2(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf4(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char>(void)
{
  int e = (int)sizeof(char) * 8;



#line 164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
#line 166 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<signed char>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned char>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char1>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar1>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char2>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar2>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char4>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar4>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned short>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short1>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort1>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short2>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort2>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short4>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort4>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned int>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int1>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint1>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int2>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint2>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int4>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint4>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}



template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned long>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long1>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong1>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long2>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong2>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long4>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong4>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

#line 395 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float1>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float2>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float4>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescNV12(void)
{
    int e = (int)sizeof(char) * 8;

    return cudaCreateChannelDesc(e, e, e, 0, cudaChannelFormatKindNV12);
}

template<cudaChannelFormatKind> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
    return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X1>(void)
{
    return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedNormalized8X1);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X2>(void)
{
    return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedNormalized8X2);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X4>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindSignedNormalized8X4);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X1>(void)
{
    return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized8X1);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X2>(void)
{
    return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedNormalized8X2);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X4>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedNormalized8X4);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X1>(void)
{
    return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindSignedNormalized16X1);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X2>(void)
{
    return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindSignedNormalized16X2);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X4>(void)
{
    return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindSignedNormalized16X4);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X1>(void)
{
    return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized16X1);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X2>(void)
{
    return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindUnsignedNormalized16X2);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X4>(void)
{
    return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindUnsignedNormalized16X4);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindNV12>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 0, cudaChannelFormatKindNV12);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed1>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed1SRGB>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1SRGB);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed2>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed2SRGB>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2SRGB);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed3>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed3SRGB>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3SRGB);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed4>(void)
{
    return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed4);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed4>(void)
{
    return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedBlockCompressed4);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed5>(void)
{
    return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed5);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed5>(void)
{
    return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedBlockCompressed5);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed6H>(void)
{
    return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindUnsignedBlockCompressed6H);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed6H>(void)
{
    return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindSignedBlockCompressed6H);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed7>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7);
}


template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed7SRGB>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7SRGB);
}

#line 591 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"


 

#line 596 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
#line 96 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 97 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_functions.h"




















































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 54 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
#line 55 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_functions.h"























static __inline __declspec(__host__) struct cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
{
  struct cudaPitchedPtr s;

  s.ptr   = d;
  s.pitch = p;
  s.xsize = xsz;
  s.ysize = ysz;

  return s;
}
















static __inline __declspec(__host__) struct cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
{
  struct cudaPos p;

  p.x = x;
  p.y = y;
  p.z = z;

  return p;
}
















static __inline __declspec(__host__) struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
{
  struct cudaExtent e;

  e.width  = w;
  e.height = h;
  e.depth  = d;

  return e;
}

 

#line 146 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_functions.h"
#line 98 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"

#line 100 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/host_defines.h"
#line 101 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.h"


























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.h"



#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.h"

#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.h"







static __inline __declspec(__host__) __declspec(__device__) char1 make_char1(signed char x);

static __inline __declspec(__host__) __declspec(__device__) uchar1 make_uchar1(unsigned char x);

static __inline __declspec(__host__) __declspec(__device__) char2 make_char2(signed char x, signed char y);

static __inline __declspec(__host__) __declspec(__device__) uchar2 make_uchar2(unsigned char x, unsigned char y);

static __inline __declspec(__host__) __declspec(__device__) char3 make_char3(signed char x, signed char y, signed char z);

static __inline __declspec(__host__) __declspec(__device__) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z);

static __inline __declspec(__host__) __declspec(__device__) char4 make_char4(signed char x, signed char y, signed char z, signed char w);

static __inline __declspec(__host__) __declspec(__device__) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w);

static __inline __declspec(__host__) __declspec(__device__) short1 make_short1(short x);

static __inline __declspec(__host__) __declspec(__device__) ushort1 make_ushort1(unsigned short x);

static __inline __declspec(__host__) __declspec(__device__) short2 make_short2(short x, short y);

static __inline __declspec(__host__) __declspec(__device__) ushort2 make_ushort2(unsigned short x, unsigned short y);

static __inline __declspec(__host__) __declspec(__device__) short3 make_short3(short x,short y, short z);

static __inline __declspec(__host__) __declspec(__device__) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z);

static __inline __declspec(__host__) __declspec(__device__) short4 make_short4(short x, short y, short z, short w);

static __inline __declspec(__host__) __declspec(__device__) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w);

static __inline __declspec(__host__) __declspec(__device__) int1 make_int1(int x);

static __inline __declspec(__host__) __declspec(__device__) uint1 make_uint1(unsigned int x);

static __inline __declspec(__host__) __declspec(__device__) int2 make_int2(int x, int y);

static __inline __declspec(__host__) __declspec(__device__) uint2 make_uint2(unsigned int x, unsigned int y);

static __inline __declspec(__host__) __declspec(__device__) int3 make_int3(int x, int y, int z);

static __inline __declspec(__host__) __declspec(__device__) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z);

static __inline __declspec(__host__) __declspec(__device__) int4 make_int4(int x, int y, int z, int w);

static __inline __declspec(__host__) __declspec(__device__) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w);

static __inline __declspec(__host__) __declspec(__device__) long1 make_long1(long int x);

static __inline __declspec(__host__) __declspec(__device__) ulong1 make_ulong1(unsigned long int x);

static __inline __declspec(__host__) __declspec(__device__) long2 make_long2(long int x, long int y);

static __inline __declspec(__host__) __declspec(__device__) ulong2 make_ulong2(unsigned long int x, unsigned long int y);

static __inline __declspec(__host__) __declspec(__device__) long3 make_long3(long int x, long int y, long int z);

static __inline __declspec(__host__) __declspec(__device__) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z);

static __inline __declspec(__host__) __declspec(__device__) long4 make_long4(long int x, long int y, long int z, long int w);

static __inline __declspec(__host__) __declspec(__device__) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w);

static __inline __declspec(__host__) __declspec(__device__) float1 make_float1(float x);

static __inline __declspec(__host__) __declspec(__device__) float2 make_float2(float x, float y);

static __inline __declspec(__host__) __declspec(__device__) float3 make_float3(float x, float y, float z);

static __inline __declspec(__host__) __declspec(__device__) float4 make_float4(float x, float y, float z, float w);

static __inline __declspec(__host__) __declspec(__device__) longlong1 make_longlong1(long long int x);

static __inline __declspec(__host__) __declspec(__device__) ulonglong1 make_ulonglong1(unsigned long long int x);

static __inline __declspec(__host__) __declspec(__device__) longlong2 make_longlong2(long long int x, long long int y);

static __inline __declspec(__host__) __declspec(__device__) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y);

static __inline __declspec(__host__) __declspec(__device__) longlong3 make_longlong3(long long int x, long long int y, long long int z);

static __inline __declspec(__host__) __declspec(__device__) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z);

static __inline __declspec(__host__) __declspec(__device__) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w);

static __inline __declspec(__host__) __declspec(__device__) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w);

static __inline __declspec(__host__) __declspec(__device__) double1 make_double1(double x);

static __inline __declspec(__host__) __declspec(__device__) double2 make_double2(double x, double y);

static __inline __declspec(__host__) __declspec(__device__) double3 make_double3(double x, double y, double z);

static __inline __declspec(__host__) __declspec(__device__) double4 make_double4(double x, double y, double z, double w);




#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.hpp"


























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.hpp"



#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.hpp"

#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.hpp"







static __inline __declspec(__host__) __declspec(__device__) char1 make_char1(signed char x)
{
  char1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar1 make_uchar1(unsigned char x)
{
  uchar1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char2 make_char2(signed char x, signed char y)
{
  char2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar2 make_uchar2(unsigned char x, unsigned char y)
{
  uchar2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char3 make_char3(signed char x, signed char y, signed char z)
{
  char3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z)
{
  uchar3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char4 make_char4(signed char x, signed char y, signed char z, signed char w)
{
  char4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w)
{
  uchar4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short1 make_short1(short x)
{
  short1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort1 make_ushort1(unsigned short x)
{
  ushort1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short2 make_short2(short x, short y)
{
  short2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort2 make_ushort2(unsigned short x, unsigned short y)
{
  ushort2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short3 make_short3(short x,short y, short z)
{ 
  short3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z)
{
  ushort3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short4 make_short4(short x, short y, short z, short w)
{
  short4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w)
{
  ushort4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int1 make_int1(int x)
{
  int1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint1 make_uint1(unsigned int x)
{
  uint1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int2 make_int2(int x, int y)
{
  int2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint2 make_uint2(unsigned int x, unsigned int y)
{
  uint2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int3 make_int3(int x, int y, int z)
{
  int3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z)
{
  uint3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int4 make_int4(int x, int y, int z, int w)
{
  int4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w)
{
  uint4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long1 make_long1(long int x)
{
  long1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong1 make_ulong1(unsigned long int x)
{
  ulong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long2 make_long2(long int x, long int y)
{
  long2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong2 make_ulong2(unsigned long int x, unsigned long int y)
{
  ulong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long3 make_long3(long int x, long int y, long int z)
{
  long3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z)
{
  ulong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long4 make_long4(long int x, long int y, long int z, long int w)
{
  long4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w)
{
  ulong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float1 make_float1(float x)
{
  float1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float2 make_float2(float x, float y)
{
  float2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float3 make_float3(float x, float y, float z)
{
  float3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float4 make_float4(float x, float y, float z, float w)
{
  float4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong1 make_longlong1(long long int x)
{
  longlong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong1 make_ulonglong1(unsigned long long int x)
{
  ulonglong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong2 make_longlong2(long long int x, long long int y)
{
  longlong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y)
{
  ulonglong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong3 make_longlong3(long long int x, long long int y, long long int z)
{
  longlong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z)
{
  ulonglong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w)
{
  longlong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w)
{
  ulonglong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double1 make_double1(double x)
{
  double1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double2 make_double2(double x, double y)
{
  double2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double3 make_double3(double x, double y, double z)
{
  double3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double4 make_double4(double x, double y, double z, double w)
{
  double4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}



#line 316 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.hpp"

#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.h"
#line 174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.h"

#line 176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_functions.h"
#line 102 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"











#line 114 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"

#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"












#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 72 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 73 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"












#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"










#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);

     unsigned long* __cdecl __doserrno(void);
    

     errno_t __cdecl _set_doserrno(  unsigned long _Value);
     errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_string.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )



__pragma(pack(push, 8)) extern "C" {



[[nodiscard]]  
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

[[nodiscard]]  
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

[[nodiscard]]  
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

[[nodiscard]]  
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

[[nodiscard]]    
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

[[nodiscard]]  

 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]  
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]    

 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_string.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"




#pragma warning(pop) 
} __pragma(pack(pop))
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"


#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



 
 int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
 int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"

    












#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"

#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"





    
     void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      
     int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"





    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {










    
     errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
     errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
     errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
     errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
     wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"











#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
 __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"


      wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
 int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
 size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
 size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
 size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
    
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
 int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
 wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
 size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  
 wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
        



    #line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

      
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"



 
  
 wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


 errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
 
  
 wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

  errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

   int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

   int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

   int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

   int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

  errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

  errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 436 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 

 size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

 size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
 int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
 int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
 int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
 int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
 int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
 int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
 int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
 int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"









    


#line 568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

      
     wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

    
    

      
     int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      
     int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    
     
     wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    
     
     wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    
     
     wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    
     
     wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    
     
     wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      
     int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
     errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
     errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
     errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
     errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
     errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
     char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"



      char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
 int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
 size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
 __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
 
  
 char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


 errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
  
 char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
 int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
 int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


 errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl _strlwr( char *_String);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"


 errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
 int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
 int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
 int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 

#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
 size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
    
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"


 errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
 char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

 char* __cdecl _strrev(
      char* _Str
    );


 errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl _strset( char *_Destination,  int _Value);
#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
 size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  
 char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


 errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl _strupr( char *_String);
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"


 errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

  char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 

 size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

 size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"





    
    
      
     char* __cdecl strdup(
          char const* _String
        );
    

    
      
     int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      
     int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    
     char* __cdecl strlwr(
          char* _String
        );

      
     int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    
     char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    
     char* __cdecl strrev(
          char* _String
        );

    
    char* __cdecl strset(
          char* _String,
               int   _Value);

    
     char* __cdecl strupr(
          char* _String
        );

#line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#pragma external_header(pop)
#line 86 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  
 
 
 wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

 errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

 

 size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

 size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  
 wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

 
 
  
 wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"


 errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

   wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"


 errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

   wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"









    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  
        long   tv_nsec; 
    };
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
















  
 int* __cdecl __daylight(void);




  
 long* __cdecl __dstbias(void);




  
 long* __cdecl __timezone(void);




    
 char** __cdecl __tzname(void);



  
 errno_t __cdecl _get_daylight(
      int* _Daylight
    );

 
 errno_t __cdecl _get_dstbias(
      long* _DaylightSavingsBias
    );

  
 errno_t __cdecl _get_timezone(
      long* _TimeZone
    );

 
 errno_t __cdecl _get_tzname(
                             size_t* _ReturnValue,
      char*   _Buffer,
                              size_t  _SizeInBytes,
                              int     _Index
    );








 
 
  
 char* __cdecl asctime(
      struct tm const* _Tm
    );


     
    
     errno_t __cdecl asctime_s(
            char*            _Buffer,
                                            size_t           _SizeInBytes,
                                                         struct tm const* _Tm
        );
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

 
 clock_t __cdecl clock(void);

 
 
  
 char* __cdecl _ctime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _ctime32_s(
        char*             _Buffer,
                                        size_t            _SizeInBytes,
                                                     __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

 
 
  
 char* __cdecl _ctime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _ctime64_s(
        char*             _Buffer,
                                          size_t            _SizeInBytes,
                                                       __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(  char (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

 
 double __cdecl _difftime32(
      __time32_t _Time1,
      __time32_t _Time2
    );

 
 double __cdecl _difftime64(
      __time64_t _Time1,
      __time64_t _Time2
    );

 
  
 struct tm* __cdecl _gmtime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _gmtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  
 struct tm* __cdecl _gmtime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _gmtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
  
 struct tm* __cdecl _localtime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _localtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  
 struct tm* __cdecl _localtime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _localtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
 __time32_t __cdecl _mkgmtime32(
      struct tm* _Tm
    );

 
 __time64_t __cdecl _mkgmtime64(
      struct tm* _Tm
    );


 __time32_t __cdecl _mktime32(
      struct tm* _Tm
    );


 __time64_t __cdecl _mktime64(
      struct tm* _Tm
    );

 

 size_t __cdecl strftime(
       char*            _Buffer,
                               size_t           _SizeInBytes,
        char const*      _Format,
                               struct tm const* _Tm
    );

 

 size_t __cdecl _strftime_l(
           char*            _Buffer,
                               size_t           _MaxSize,
        char const*      _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );


 errno_t __cdecl _strdate_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }
#line 293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

   char* __cdecl _strdate( char *_Buffer);
#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"


 errno_t __cdecl _strtime_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

  char* __cdecl _strtime( char *_Buffer);
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

 __time32_t __cdecl _time32(
      __time32_t* _Time
    );

 __time64_t __cdecl _time64(
      __time64_t* _Time
    );

 
 
 int __cdecl _timespec32_get(
      struct _timespec32* _Ts,
       int                 _Base
    );

 
 
 int __cdecl _timespec64_get(
      struct _timespec64* _Ts,
       int                 _Base
    );










     void __cdecl _tzset(void);

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
     unsigned __cdecl _getsystime(
          struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
     unsigned __cdecl _setsystime(
          struct tm* _Tm,
          unsigned   _Milliseconds
        );

#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"










    


































































































          
        static __inline char* __cdecl ctime(
              time_t const* const _Time
            )
        {
            return _ctime64(_Time);
        }

         
        static __inline double __cdecl difftime(
              time_t const _Time1,
              time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

          
        static __inline struct tm* __cdecl gmtime(
              time_t const* const _Time)
        {
            return _gmtime64(_Time);
        }

        
        static __inline struct tm* __cdecl localtime(
              time_t const* const _Time
            )
        {
            return _localtime64(_Time);
        }

         
        static __inline time_t __cdecl _mkgmtime(
              struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
              struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
              time_t* const _Time
            )
        {
            return _time64(_Time);
        }

         
        static __inline int __cdecl timespec_get(
              struct timespec* const _Ts,
               int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                    char*         const _Buffer,
                                                    size_t        const _SizeInBytes,
                                                                 time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        #line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

    #line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

#line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"










    

    
          void __cdecl tzset(void);
    #line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
#pragma external_header(pop)
#line 87 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

extern "C"
{
#line 91 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) clock_t __cdecl clock(void)


#line 95 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
;
extern         __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void*   __cdecl memset(void*, int, size_t) ;
extern         __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void*   __cdecl memcpy(void*, const void*, size_t) ;

}
#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"








#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"





#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new_debug.h"







#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )
#pragma warning(disable: 4985) 


extern "C++" {

#pragma pack(push, 8)













    namespace std
    {
        struct nothrow_t {
            explicit nothrow_t() = default;
        };

        


            extern nothrow_t const nothrow;
        #line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"
    }
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"

[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new(
    size_t _Size
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new(
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void* _Block
    ) noexcept;

void __cdecl operator delete(
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void* _Block
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;
































































#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
    [[nodiscard]]      
    inline void* __cdecl operator new(size_t _Size,   void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"


    
    [[nodiscard]]      
    inline void* __cdecl operator new[](size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"
#pragma warning(pop)



#pragma pack(pop)

} 
#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new_debug.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C++" {

#pragma pack(push, 8)






    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_new_debug.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;



    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
























































































#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"










    
    
    
    
    
    
    

    
    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

















































































































































































































































































































#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"











    
    
    
    
    
    
    

















































































#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"











    

    
        
    #line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"

    
        
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"

    
        
    #line 714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"

    
    

    
    

    
    

    
    












































#line 771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"













    
#line 786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#pragma warning(pop) 
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\crtdefs.h"


















































































#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )












#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"















#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"






















































#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"









#line 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 119 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 120 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"




#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"



#pragma detect_mismatch("_MSC_VER", "1900")
#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"


#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"



#pragma detect_mismatch("RuntimeLibrary", "MT_StaticRelease")






#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"






#line 160 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"



#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"






#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"





























#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"





#line 209 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"





#line 215 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"






#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 223 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"



#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"





#pragma once








#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"
















#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"



#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"




#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"




#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"

#pragma comment(lib, "libcpmt" "" "")






#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"

#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\use_ansi.h"
#pragma external_header(pop)
#line 232 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"



















#line 252 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"






#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"



#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"






#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"












#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"






#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 298 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"






#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"




#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
















#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

#line 333 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 334 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"



#line 338 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"



#line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"


namespace std {
enum _Uninitialized { 
    _Noinit
};

class  _Lockit { 
public:














    __thiscall _Lockit() noexcept;
    explicit __thiscall _Lockit(int) noexcept; 
    __thiscall ~_Lockit() noexcept; 
#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

    static void __cdecl _Lockit_ctor(int) noexcept;
    static void __cdecl _Lockit_dtor(int) noexcept;

private:
    static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
    static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
    static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

public:
     _Lockit(const _Lockit&) = delete;
    _Lockit&  operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};








































































#line 458 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

class  _Init_locks { 
public:










    __thiscall _Init_locks() noexcept;
    __thiscall ~_Init_locks() noexcept;
#line 474 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"

private:
    static void __cdecl _Init_locks_ctor(_Init_locks*) noexcept;
    static void __cdecl _Init_locks_dtor(_Init_locks*) noexcept;
};




































#line 516 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
}
#line 518 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"







#pragma warning(pop)
#pragma pack(pop)
#line 528 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#line 529 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\yvals.h"
#pragma external_header(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdint.h"







#pragma once






#pragma warning(push)
#pragma warning(disable:   4514 4820 )

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;










































    
    
    




#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdint.h"







































#pragma warning(pop) 

#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdint.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
using :: int8_t;
using :: int16_t;
using :: int32_t;
using :: int64_t;
using :: uint8_t;
using :: uint16_t;
using :: uint32_t;
using :: uint64_t;

using :: int_least8_t;
using :: int_least16_t;
using :: int_least32_t;
using :: int_least64_t;
using :: uint_least8_t;
using :: uint_least16_t;
using :: uint_least32_t;
using :: uint_least64_t;

using :: int_fast8_t;
using :: int_fast16_t;
using :: int_fast32_t;
using :: int_fast64_t;
using :: uint_fast8_t;
using :: uint_fast16_t;
using :: uint_fast32_t;
using :: uint_fast64_t;

using :: intmax_t;
using :: intptr_t;
using :: uintmax_t;
using :: uintptr_t;


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using :: int8_t;
    using :: int16_t;
    using :: int32_t;
    using :: int64_t;
    using :: uint8_t;
    using :: uint16_t;
    using :: uint32_t;
    using :: uint64_t;

    using :: int_least8_t;
    using :: int_least16_t;
    using :: int_least32_t;
    using :: int_least64_t;
    using :: uint_least8_t;
    using :: uint_least16_t;
    using :: uint_least32_t;
    using :: uint_least64_t;

    using :: int_fast8_t;
    using :: int_fast16_t;
    using :: int_fast32_t;
    using :: int_fast64_t;
    using :: uint_fast8_t;
    using :: uint_fast16_t;
    using :: uint_fast32_t;
    using :: uint_fast64_t;

    using :: intmax_t;
    using :: intptr_t;
    using :: uintmax_t;
    using :: uintptr_t;
} 
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"
}



#pragma warning(pop)
#pragma pack(pop)

#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdint"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstddef"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"





#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

    [[nodiscard]] constexpr value_type operator()() const noexcept {
        return value;
    }
};

template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

using true_type  = bool_constant<true>;
using false_type = bool_constant<false>;

template <bool _Test, class _Ty = void>
struct enable_if {}; 

template <class _Ty>
struct enable_if<true, _Ty> { 
    using type = _Ty;
};

template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

template <bool _Test, class _Ty1, class _Ty2>
struct conditional { 
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;








template <class, class>
 constexpr bool is_same_v = false; 
template <class _Ty>
 constexpr bool is_same_v<_Ty, _Ty> = true;

template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"

template <class _Ty>
struct remove_const { 
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

template <class _Ty>
struct remove_volatile { 
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

template <class _Ty>
struct remove_cv { 
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; 
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { 
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { 
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};

template <class... _Traits>
struct disjunction : false_type {}; 

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    
};

template <class... _Traits>
 constexpr bool disjunction_v = disjunction<_Traits...>::value;

template <class _Ty, class... _Types>
 constexpr bool _Is_any_of_v = 
    disjunction_v<is_same<_Ty, _Types>...>;





#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"

template <class _Ty>
 constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,



    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_arithmetic_v = 
    is_integral_v<_Ty> || is_floating_point_v<_Ty>;

template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};

template <class _Ty>
struct remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t = remove_cv_t<remove_reference_t<_Ty>>;









#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"

}


#pragma warning(pop)
#pragma pack(pop)
#line 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"
#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtr1common"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstddef"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
using :: ptrdiff_t;
using :: size_t;
using max_align_t = double; 


































































}

using ::std:: max_align_t; 



#pragma warning(pop)
#pragma pack(pop)

#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstddef"
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstddef"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
    #line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"










#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"


    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"


















































































void __cdecl _fperrraise(  int _Except);

   short __cdecl _dclass(  double _X);
   short __cdecl _ldclass(  long double _X);
   short __cdecl _fdclass(  float _X);

   int __cdecl _dsign(  double _X);
   int __cdecl _ldsign(  long double _X);
   int __cdecl _fdsign(  float _X);

   int __cdecl _dpcomp(  double _X,   double _Y);
   int __cdecl _ldpcomp(  long double _X,   long double _Y);
   int __cdecl _fdpcomp(  float _X,   float _Y);

   short __cdecl _dtest(  double* _Px);
   short __cdecl _ldtest(  long double* _Px);
   short __cdecl _fdtest(  float* _Px);

 short __cdecl _d_int(  double* _Px,   short _Xexp);
 short __cdecl _ld_int(  long double* _Px,   short _Xexp);
 short __cdecl _fd_int(  float* _Px,   short _Xexp);

 short __cdecl _dscale(  double* _Px,   long _Lexp);
 short __cdecl _ldscale(  long double* _Px,   long _Lexp);
 short __cdecl _fdscale(  float* _Px,   long _Lexp);

 short __cdecl _dunscale(  short* _Pex,   double* _Px);
 short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
 short __cdecl _fdunscale(  short* _Pex,   float* _Px);

   short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
   short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
   short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

   short __cdecl _dnorm(  unsigned short* _Ps);
   short __cdecl _fdnorm(  unsigned short* _Ps);

   double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
   long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
   float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

   double __cdecl _dlog(  double _X,   int _Baseflag);
   long double __cdecl _ldlog(  long double _X,   int _Baseflag);
   float __cdecl _fdlog(  float _X,   int _Baseflag);

   double __cdecl _dsin(  double _X,   unsigned int _Qoff);
   long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
   float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"





      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

       double    __cdecl acosh(  double _X);
       double    __cdecl asinh(  double _X);
       double    __cdecl atanh(  double _X);
        double    __cdecl atof(  char const* _String);
        double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
       double    __cdecl _cabs(  struct _complex _Complex_value);
       double    __cdecl cbrt(  double _X);
       double    __cdecl ceil(  double _X);
       double    __cdecl _chgsign(  double _X);
       double    __cdecl copysign(  double _Number,   double _Sign);
       double    __cdecl _copysign(  double _Number,   double _Sign);
       double    __cdecl erf(  double _X);
       double    __cdecl erfc(  double _X);
       double    __cdecl exp2(  double _X);
       double    __cdecl expm1(  double _X);
       double    __cdecl fdim(  double _X,   double _Y);
       double    __cdecl floor(  double _X);
       double    __cdecl fma(  double _X,   double _Y,   double _Z);
       double    __cdecl fmax(  double _X,   double _Y);
       double    __cdecl fmin(  double _X,   double _Y);
       double    __cdecl frexp(  double _X,   int* _Y);
       double    __cdecl hypot(  double _X,   double _Y);
       double    __cdecl _hypot(  double _X,   double _Y);
       int       __cdecl ilogb(  double _X);
       double    __cdecl ldexp(  double _X,   int _Y);
       double    __cdecl lgamma(  double _X);
       long long __cdecl llrint(  double _X);
       long long __cdecl llround(  double _X);
       double    __cdecl log1p(  double _X);
       double    __cdecl log2(  double _X);
       double    __cdecl logb(  double _X);
       long      __cdecl lrint(  double _X);
       long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

       double __cdecl modf(  double _X,   double* _Y);
       double __cdecl nan(  char const* _X);
       double __cdecl nearbyint(  double _X);
       double __cdecl nextafter(  double _X,   double _Y);
       double __cdecl nexttoward(  double _X,   long double _Y);
       double __cdecl remainder(  double _X,   double _Y);
       double __cdecl remquo(  double _X,   double _Y,   int* _Z);
       double __cdecl rint(  double _X);
       double __cdecl round(  double _X);
       double __cdecl scalbln(  double _X,   long _Y);
       double __cdecl scalbn(  double _X,   int _Y);
       double __cdecl tgamma(  double _X);
       double __cdecl trunc(  double _X);
       double __cdecl _j0(  double _X );
       double __cdecl _j1(  double _X );
       double __cdecl _jn(int _X,   double _Y);
       double __cdecl _y0(  double _X);
       double __cdecl _y1(  double _X);
       double __cdecl _yn(  int _X,   double _Y);

       float     __cdecl acoshf(  float _X);
       float     __cdecl asinhf(  float _X);
       float     __cdecl atanhf(  float _X);
       float     __cdecl cbrtf(  float _X);
       float     __cdecl _chgsignf(  float _X);
       float     __cdecl copysignf(  float _Number,   float _Sign);
       float     __cdecl _copysignf(  float _Number,   float _Sign);
       float     __cdecl erff(  float _X);
       float     __cdecl erfcf(  float _X);
       float     __cdecl expm1f(  float _X);
       float     __cdecl exp2f(  float _X);
       float     __cdecl fdimf(  float _X,   float _Y);
       float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
       float     __cdecl fmaxf(  float _X,   float _Y);
       float     __cdecl fminf(  float _X,   float _Y);
       float     __cdecl _hypotf(  float _X,   float _Y);
       int       __cdecl ilogbf(  float _X);
       float     __cdecl lgammaf(  float _X);
       long long __cdecl llrintf(  float _X);
       long long __cdecl llroundf(  float _X);
       float     __cdecl log1pf(  float _X);
       float     __cdecl log2f(  float _X);
       float     __cdecl logbf(  float _X);
       long      __cdecl lrintf(  float _X);
       long      __cdecl lroundf(  float _X);
       float     __cdecl nanf(  char const* _X);
       float     __cdecl nearbyintf(  float _X);
       float     __cdecl nextafterf(  float _X,   float _Y);
       float     __cdecl nexttowardf(  float _X,   long double _Y);
       float     __cdecl remainderf(  float _X,   float _Y);
       float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
       float     __cdecl rintf(  float _X);
       float     __cdecl roundf(  float _X);
       float     __cdecl scalblnf(  float _X,   long _Y);
       float     __cdecl scalbnf(  float _X,   int _Y);
       float     __cdecl tgammaf(  float _X);
       float     __cdecl truncf(  float _X);

    



#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

    

           float __cdecl _logbf(  float _X);
           float __cdecl _nextafterf(  float _X,   float _Y);
           int   __cdecl _finitef(  float _X);
           int   __cdecl _isnanf(  float _X);
           int   __cdecl _fpclassf(  float _X);

           int   __cdecl _set_FMA3_enable(  int _Flag);
           int   __cdecl _get_FMA3_enable(void);

    




#line 604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"



    

           float __cdecl acosf(  float _X);
           float __cdecl asinf(  float _X);
           float __cdecl atan2f(  float _Y,   float _X);
           float __cdecl atanf(  float _X);
           float __cdecl ceilf(  float _X);
           float __cdecl cosf(  float _X);
           float __cdecl coshf(  float _X);
           float __cdecl expf(  float _X);

    









































#line 661 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

    



#line 667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    #line 674 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

    

           float __cdecl floorf(  float _X);
           float __cdecl fmodf(  float _X,   float _Y);

    











#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

           float  __cdecl log10f(  float _X);
           float  __cdecl logf(  float _X);
           float  __cdecl modff(  float _X,   float *_Y);
           float  __cdecl powf(  float _X,   float _Y);
           float  __cdecl sinf(  float _X);
           float  __cdecl sinhf(  float _X);
           float  __cdecl sqrtf(  float _X);
           float  __cdecl tanf(  float _X);
           float  __cdecl tanhf(  float _X);

    

















































#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

       long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

       long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

       long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

       long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

       long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

       long double __cdecl erfl(  long double _X);
       long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

       long double __cdecl exp2l(  long double _X);
       long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

       long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

       long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
       long double __cdecl fmaxl(  long double _X,   long double _Y);
       long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

       int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

       long double __cdecl lgammal(  long double _X);
       long long __cdecl llrintl(  long double _X);
       long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

       long double __cdecl log1pl(  long double _X);
       long double __cdecl log2l(  long double _X);
       long double __cdecl logbl(  long double _X);
       long __cdecl lrintl(  long double _X);
       long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

       long double __cdecl nanl(  char const* _X);
       long double __cdecl nearbyintl(  long double _X);
       long double __cdecl nextafterl(  long double _X,   long double _Y);
       long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

       long double __cdecl remainderl(  long double _X,   long double _Y);
       long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
       long double __cdecl rintl(  long double _X);
       long double __cdecl roundl(  long double _X);
       long double __cdecl scalblnl(  long double _X,   long _Y);
       long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

       long double __cdecl tgammal(  long double _X);
       long double __cdecl truncl(  long double _X);

    



#line 960 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

            double __cdecl j0(  double _X);
            double __cdecl j1(  double _X);
            double __cdecl jn(  int _X,   double _Y);
            double __cdecl y0(  double _X);
            double __cdecl y1(  double _X);
            double __cdecl yn(  int _X,   double _Y);
    #line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

#line 988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"




#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





































#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
       size_t _Count,
       size_t _Size
    );

 
 int __cdecl _callnewh(
      size_t _Size
    );

     
 __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
       size_t _Size
    );


void __cdecl _free_base(
        void* _Block
    );

 
void __cdecl free(
        void* _Block
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
 __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
       size_t _Size
    );

 

size_t __cdecl _msize_base(
      void* _Block
    );

 
 
size_t __cdecl _msize(
      void* _Block
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
              size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size
    );


void __cdecl _aligned_free(
        void* _Block
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
       size_t _Size,
                         size_t _Alignment
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
       size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 

size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment
    );


















#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"










#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
     void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

     void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );

#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"



 
 void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
 void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
 void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
 void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
 void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"





      
     void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      
     void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


































     
    
     errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

      wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

     
    
     errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

      wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

    
     errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

      wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

     
     double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     double __cdecl _wtof(
          wchar_t const* _String
        );

     
     double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     int __cdecl _wtoi(
          wchar_t const* _String
        );

     
     int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     long __cdecl _wtol(
          wchar_t const* _String
        );

     
     long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
     long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
     errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    
     wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
     errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    
     wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
     __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
     __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
     __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
     errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

  void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

     void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    
     void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

     errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

        
        

        
         errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          
         wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
         errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

         
         int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
         errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

         errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

          void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

         int __cdecl _wsystem(
              wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"









 void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );













     __declspec(noreturn) void __cdecl exit(  int _Code);
     __declspec(noreturn) void __cdecl _exit(  int _Code);
     __declspec(noreturn) void __cdecl _Exit(  int _Code);
     __declspec(noreturn) void __cdecl quick_exit(  int _Code);
     __declspec(noreturn) void __cdecl abort(void);
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"





 unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    


#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


    
    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
     _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

     _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"












#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"









  int __cdecl _set_error_mode(  int _Mode);




     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);

     unsigned long* __cdecl __doserrno(void);
    

     errno_t __cdecl _set_doserrno(  unsigned long _Value);
     errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    
      char** __cdecl __sys_errlist(void);
    

      int * __cdecl __sys_nerr(void);
    

     void __cdecl perror(  char const* _ErrMsg);
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




  char**    __cdecl __p__pgmptr (void);
  wchar_t** __cdecl __p__wpgmptr(void);
  int*      __cdecl __p__fmode  (void);








    
    
    
#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 
 errno_t __cdecl _get_pgmptr (  char**    _Value);

 
 errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

 errno_t __cdecl _set_fmode  (               int       _Mode );

 errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

   div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
   ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
   lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning(pop)






 void __cdecl srand(  unsigned int _Seed);

   int __cdecl rand(void);



#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                      double    __cdecl atof   (  char const* _String);
    int       __cdecl atoi   (  char const* _String);
                      long      __cdecl atol   (  char const* _String);
                      long long __cdecl atoll  (  char const* _String);
                      __int64   __cdecl _atoi64(  char const* _String);

   double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
   int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
   long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
   long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
   __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

   int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
   int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
   int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
 int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
 int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
 int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
 float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
 float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
 double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
 long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

 errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 

 errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 

 errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 

 errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 

 char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

 errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );


 char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

 errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  
 char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

 errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 
  
 char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
 errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


 char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
        
    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    


        
    #line 841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

     
     int __cdecl ___mb_cur_max_func(void);

     
     int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"



 
 int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
 int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
 size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
 size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
 size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
 size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
 int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
 int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


 errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 923 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


 errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"





 int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );


 int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
     errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


 errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


 errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


 errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




















 
 
 __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




 errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


 void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


 errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




 
 errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );

#line 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




 int*       __cdecl __p___argc (void);
 char***    __cdecl __p___argv (void);
 wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 char***    __cdecl __p__environ (void);
 wchar_t*** __cdecl __p__wenviron(void);


    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"







    
    
#line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"









      
     char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    


#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    
     errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    

#line 1210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

     int __cdecl system(
          char const* _Command
        );

    
    
    #pragma warning(push)
    #pragma warning(disable: 6540)

     
     int __cdecl _putenv(
          char const* _EnvString
        );

    
     errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning(pop)

     errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

      void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
     void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
     void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
     void __cdecl _sleep(
          unsigned long _Duration
        );

#line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"









    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

       
     char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

       
     char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

     
     char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

     
     char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

     
     char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    
     void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

     
     char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

      
     int __cdecl putenv(
          char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )





[[nodiscard]]   inline double abs(  double _Xx) noexcept  {
    return :: fabs(_Xx);
}

[[nodiscard]]   inline float abs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline long double abs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}

namespace std {
using :: size_t;
using :: div_t;
using :: ldiv_t;
using :: abort;
using :: abs;
using :: atexit;
using :: atof;
using :: atoi;
using :: atol;
using :: bsearch;
using :: calloc;
using :: div;
using :: exit;
using :: free;
using :: labs;
using :: ldiv;
using :: malloc;
using :: mblen;
using :: mbstowcs;
using :: mbtowc;
using :: qsort;
using :: rand;
using :: realloc;
using :: srand;
using :: strtod;
using :: strtol;
using :: strtoul;
using :: wcstombs;
using :: wctomb;

using :: lldiv_t;


using :: getenv;
using :: system;
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"

using :: atoll;
using :: llabs;
using :: lldiv;
using :: strtof;
using :: strtold;
using :: strtoll;
using :: strtoull;

using :: _Exit;
using :: at_quick_exit;
using :: quick_exit;
}



#pragma warning(pop)
#pragma pack(pop)

#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdlib"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\initializer_list"





#pragma once






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Elem>
class initializer_list {
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;

    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

    [[nodiscard]] constexpr const _Elem* begin() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr const _Elem* end() const noexcept {
        return _Last;
    }

    [[nodiscard]] constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};

template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\initializer_list"
#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\initializer_list"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class>

 constexpr bool _Always_false = false;



template <class _Arg, class _Result>
struct unary_function { 
    using argument_type = _Arg;
    using result_type   = _Result;
};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function { 
    using first_argument_type  = _Arg1;
    using second_argument_type = _Arg2;
    using result_type          = _Result;
};
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"

template <class _Ty = void>
struct plus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left + _Right;
    }
};

template <class _Ty = void>
struct minus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left - _Right;
    }
};

template <class _Ty = void>
struct multiplies {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left * _Right;
    }
};

template <class _Ty = void>
struct equal_to {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left == _Right;
    }
};

template <class _Ty = void>
struct not_equal_to {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left != _Right;
    }
};

template <class _Ty = void>
struct greater {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left > _Right;
    }
};

template <class _Ty = void>
struct less {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left < _Right;
    }
};

template <class _Ty = void>
struct greater_equal {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left >= _Right;
    }
};

template <class _Ty = void>
struct less_equal {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left <= _Right;
    }
};

template <>
struct plus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct minus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct multiplies<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct not_equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept {
    return __builtin_addressof(_Val);
}

template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;

template <class _Ptrty>
[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept { 
    return ::std:: addressof(*_Ptr);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { 
    return _Ptr;
}
}








#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"




#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"

#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"








#line 294 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"






#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"

























#line 327 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"


























#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"









































#line 396 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"



#pragma warning(pop)
#pragma pack(pop)
#line 402 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#line 403 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstddef"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Ty, _Ty... _Vals>
struct integer_sequence { 
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

    [[nodiscard]] static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { 
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { 
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};

template <class... _Traits>
struct conjunction : true_type {}; 

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
    
};

template <class... _Traits>
 constexpr bool conjunction_v = conjunction<_Traits...>::value;

template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; 

template <class _Trait>
 constexpr bool negation_v = negation<_Trait>::value;

template <class _Ty>
 constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};

template <class... _Types>
using void_t = void;


template <class _Ty>
struct add_const { 
    using type = const _Ty;
};

template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;

template <class _Ty>
struct add_volatile { 
    using type = volatile _Ty;
};

template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;

template <class _Ty>
struct add_cv { 
    using type = const volatile _Ty;
};

template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;

template <class _Ty, class = void>
struct _Add_reference { 
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { 
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};

template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept;

template <class _Ty>
struct remove_extent { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;

template <class _Ty>
struct remove_all_extents { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;

template <class _Ty, class = void>
struct _Add_pointer { 
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { 
    using type = remove_reference_t<_Ty>*;
};

template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;

template <class>
 constexpr bool is_array_v = false; 

template <class _Ty, size_t _Nx>
 constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
 constexpr bool is_array_v<_Ty[]> = true;

template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};



















#line 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class>
 constexpr bool is_lvalue_reference_v = false; 

template <class _Ty>
 constexpr bool is_lvalue_reference_v<_Ty&> = true;

template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};

template <class>
 constexpr bool is_rvalue_reference_v = false; 

template <class _Ty>
 constexpr bool is_rvalue_reference_v<_Ty&&> = true;

template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};

template <class>
 constexpr bool is_reference_v = false; 

template <class _Ty>
 constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
 constexpr bool is_reference_v<_Ty&&> = true;

template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};

template <class>
 constexpr bool is_pointer_v = false; 

template <class _Ty>
 constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* const volatile> = true;

template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_null_pointer_v =
    is_same_v<remove_cv_t<_Ty>, nullptr_t>; 

template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};

template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_union_v = __is_union(_Ty);

template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_class_v = __is_class(_Ty);

template <class _Ty>
 constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; 

template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    
};

template <class _From, class _To>
 constexpr bool is_convertible_v = __is_convertible_to(_From, _To);


template <class _Ty>
struct is_convertible<_Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<_Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
 constexpr bool is_convertible_v<_Ty&, volatile _Ty&> = true;

template <class _Ty>
 constexpr bool is_convertible_v<volatile _Ty&, volatile _Ty&> = true;

template <class _Ty>
 constexpr bool is_convertible_v<_Ty&, const volatile _Ty&> = true;

template <class _Ty>
 constexpr bool is_convertible_v<volatile _Ty&, const volatile _Ty&> = true;
#line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_enum_v = __is_enum(_Ty);

template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; 

template <class _Ty>
 constexpr bool is_compound_v = !is_fundamental_v<_Ty>;

template <class... _Types>
struct _Arg_types {}; 

template <class _Ty1>
struct _Arg_types<_Ty1> {
     typedef _Ty1 argument_type;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
     typedef _Ty1 first_argument_type;
     typedef _Ty2 second_argument_type;
};

template <class _Ty>
struct _Is_memfunptr { 
    using _Bool_type = false_type; 
};











template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };












template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };






template <class _Ty>
 constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
#line 422 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};

template <class>
 constexpr bool is_const_v = false; 

template <class _Ty>
 constexpr bool is_const_v<const _Ty> = true;

template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};

template <class>
 constexpr bool is_volatile_v = false; 

template <class _Ty>
 constexpr bool is_volatile_v<volatile _Ty> = true;

template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_function_v = 
    !is_const_v<const _Ty> && !is_reference_v<_Ty>;

template <class _Ty>
struct is_function : bool_constant<is_function_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_object_v = 
    is_const_v<const _Ty> && !is_void_v<_Ty>;

template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {};

template <class>
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*> {
    static constexpr bool value = !is_function_v<_Ty1>;
    using _Class_type           = _Ty2;
};





template <class _Ty>
 constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
#line 476 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};





template <class _Ty>
 constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
#line 487 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; 

template <class _Ty>
 constexpr bool is_scalar_v = 
    is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};

template <class _Ty>
struct  is_pod : bool_constant<__is_pod(_Ty)> {}; 

template <class _Ty>
  constexpr bool is_pod_v = __is_pod(_Ty);

template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_empty_v = __is_empty(_Ty);

template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_abstract_v = __is_abstract(_Ty);

template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_final_v = __is_final(_Ty);

template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);


template <class _Ty>
struct  is_literal_type : bool_constant<__is_literal_type(_Ty)> {
    
};

template <class _Ty>
  constexpr bool is_literal_type_v = __is_literal_type(_Ty);
#line 543 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"


template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);






#line 559 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    
};

template <class _Ty>
 constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);















#line 591 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_default_constructible_v = __is_constructible(_Ty);

template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};

template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; 

template <class _To, class _From>
 constexpr bool is_assignable_v = __is_assignable(_To, _From);

template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_copy_assignable_v = __is_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);










#line 662 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template <class _Ty>
using _Is_copy_assignable_no_precondition_check = is_copy_assignable<_Ty>;

template <class _Ty>
 constexpr bool _Is_copy_assignable_unchecked_v = is_copy_assignable_v<_Ty>;
#line 668 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);









#line 686 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template <class _Ty>
using _Is_move_assignable_no_precondition_check = is_move_assignable<_Ty>;

template <class _Ty>
 constexpr bool _Is_move_assignable_unchecked_v = is_move_assignable_v<_Ty>;
#line 692 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_destructible_v = __is_destructible(_Ty);

template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    
};

template <class _To, class _From>
 constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
    
};

template <class _Ty>
 constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    
};

template <class _To, class _From>
 constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    
    
};

template <class _Ty>
 constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { 
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed   = static_cast<_Uty>(-1) < static_cast<_Uty>(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { 
                                
    static constexpr bool _Signed   = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; 

template <class _Ty>
 constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; 

template <class _Ty>
 constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

template <class _Ty>
 constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

template <bool>
struct _Select { 
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; 

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = 
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

template <class _Ty>
struct make_signed { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;

template <size_t>
struct _Make_unsigned2; 

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = 
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

template <class _Ty>
struct make_unsigned { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;

template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { 
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}

template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; 

template <class _Ty>
 constexpr size_t alignment_of_v = alignof(_Ty);

template <class _Ty, size_t _Len>
union _Align_type { 
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; 

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {






    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "Please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
        "that you actually want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conforming "
        "behavior.");
#line 1015 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 1017 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using _Next                 = double;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using _Next                 = int;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using _Next                 = short;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct aligned_storage { 
    using _Next                 = char;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; 

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; 

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    
};

template <size_t _Len, class... _Types>
struct aligned_union { 
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; 
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = aligned_storage_t<_Max_len, alignment_value>;
};

template <size_t _Len, class... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template <class _Ty, bool = is_enum_v<_Ty>>
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};

template <class _Ty>
struct _Underlying_type<_Ty, false> {};

template <class _Ty>
struct underlying_type : _Underlying_type<_Ty> {}; 

template <class _Ty>
using underlying_type_t = typename _Underlying_type<_Ty>::type;

template <class _Ty>
 constexpr size_t rank_v = 0; 

template <class _Ty, size_t _Nx>
 constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

template <class _Ty>
 constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};

template <class _Ty, unsigned int _Ix = 0>
 constexpr size_t extent_v = 0; 

template <class _Ty, size_t _Nx>
 constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
 constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
 constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};

template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    
};

template <class _Base, class _Derived>
 constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

template <class _Ty>
struct decay { 
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

template <class _Ty>
using decay_t = typename decay<_Ty>::type;

template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>());














#line 1151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper {};
#line 1154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

template <class... _Ty>
struct common_type;

template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};







































































































































































#line 1358 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t = typename _Identity<_Ty>::type;








#line 1374 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Type, template <class...> class _Template>
 constexpr bool _Is_specialization_v = false; 
template <template <class...> class _Template, class... _Types>
 constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};

template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(
    remove_reference_t<_Ty>& _Arg) noexcept { 
    return static_cast<_Ty&&>(_Arg);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept { 
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}

template <class _Ty>
[[nodiscard]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { 
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}

template <class _Ty>
[[nodiscard]] constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&,
    _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept { 
    return ::std:: move(_Arg);
}

template <class _Ty>
class reference_wrapper;





#pragma warning(push) 
#pragma warning(disable : 28278) 
enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};

struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

    template <class _Callable, class... _Types>
    static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(
        noexcept(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)))
        -> decltype(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...);
    }
};

struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

    template <class _Decayed, class _Refwrap, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&&... _Args2) noexcept(
        noexcept((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept -> decltype(static_cast<_Ty1&&>(_Arg1).*_Pmd) {
        return static_cast<_Ty1&&>(_Arg1).*_Pmd;
    }
};

struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

    template <class _Decayed, class _Refwrap>
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd) {
        return _Rw.get().*_Pmd;
    }
};

struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*static_cast<_Ty1&&>(_Arg1)).*_Pmd))
        -> decltype((*static_cast<_Ty1&&>(_Arg1)).*_Pmd) {
        return (*static_cast<_Ty1&&>(_Arg1)).*_Pmd;
    }
};

template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
    bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>,
    bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
struct _Invoker1;

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmf_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap,
              _Invoker_pmf_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<
          is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmd_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap,
              _Invoker_pmd_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor {};

template <class _Callable>
inline auto invoke(_Callable&& _Obj) noexcept(noexcept(static_cast<_Callable&&>(_Obj)()))
    -> decltype(static_cast<_Callable&&>(_Obj)()) {
    return static_cast<_Callable&&>(_Obj)();
}

template <class _Callable, class _Ty1, class... _Types2>
inline auto invoke(_Callable&& _Obj, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
    noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)))
    -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {
    if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast<_Ty1&&>(_Arg1).*_Obj;
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
        return _Arg1.get().*_Obj;
    } else {
        static_assert(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer, "bug in invoke");
        return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
    }
}
#pragma warning(pop) 

#pragma warning(push)
#pragma warning(disable : 4242) 
#pragma warning(disable : 4244) 
#pragma warning(disable : 4365) 
#pragma warning(disable : 5215) 






template <class _To>
void _Implicitly_convert_to(_To) noexcept; 

template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
 constexpr bool _Is_nothrow_convertible_v = noexcept(_Implicitly_convert_to<_To>(::std:: declval<_From>()));





#pragma warning(pop)

template <class _From, class _To, bool _IsVoid>
 constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
 constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    
};







#line 1593 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
_Ty _Returns_exactly() noexcept; 

template <class _From, class _To, class = void>
struct _Invoke_convertible : false_type {};

template <class _From, class _To>
struct _Invoke_convertible<_From, _To, void_t<decltype(_Implicitly_convert_to<_To>(_Returns_exactly<_From>()))>>
    : true_type {};

template <class _From, class _To>
struct _Invoke_nothrow_convertible : bool_constant<noexcept(_Implicitly_convert_to<_To>(_Returns_exactly<_From>()))> {};

template <class _Result, bool _Nothrow>
struct _Invoke_traits_common {
    using type                  = _Result;
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<_Nothrow>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, _Invoke_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<conjunction_v<_Is_nothrow_invocable,
        disjunction<is_void<_Rx>,
            conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>>>;
};

template <class _Void, class _Callable>
struct _Invoke_traits_zero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable>
using _Decltype_invoke_zero = decltype(::std:: declval<_Callable>()());

template <class _Callable>
struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
    : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(::std:: declval<_Callable>()())> {};

template <class _Void, class... _Types>
struct _Invoke_traits_nonzero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable, class _Ty1, class... _Types2>
using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
    ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...));

template <class _Callable, class _Ty1, class... _Types2>
struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
    _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
                      noexcept(_Invoker1<_Callable, _Ty1>::_Call(
                          ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...))> {};

template <class _Callable, class... _Args>
using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
    _Invoke_traits_nonzero<void, _Callable, _Args...>>;


template <class _Fty>
struct  result_of { 
    static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use "
                                       "result_of<CallableType(zero or more argument types)> instead.");
};







template <class _Callable, class... _Args> struct  result_of<_Callable __cdecl(_Args...)> : _Select_invoke_traits<_Callable, _Args...> { };    template <class _Callable, class... _Args> struct  result_of<_Callable __vectorcall(_Args...)> : _Select_invoke_traits<_Callable, _Args...> { };


__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
using result_of_t  = typename result_of<_Ty>::type;
__pragma(warning(pop))
#line 1684 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};










































#line 1738 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"



























#line 1766 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct _Function_args {}; 







template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)   > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)   > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const  > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const  > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile  > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile  > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile  > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile  > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  & > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  & > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const & > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const & > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile & > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile & > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile & > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile & > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  && > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  && > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const && > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const && > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile && > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile && > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile && > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile && > : _Arg_types<_Types...> {  typedef _Ret result_type; };








template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) > {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&&> {  typedef _Ret result_type; };


template <class _Ty, class = void>
struct _Weak_result_type {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { 
     typedef typename _Ty::result_type result_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty> {
    
     typedef typename _Ty::argument_type argument_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { 
     typedef typename _Ty::first_argument_type first_argument_type;
     typedef typename _Ty::second_argument_type second_argument_type;
};
__pragma(warning(pop))

template <class _Ty>
using _Weak_types = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Function_args<remove_pointer_t<_Ty>>,
    conditional_t<is_member_function_pointer_v<_Ty>, _Is_memfunptr<remove_cv_t<_Ty>>, _Weak_binary_args<_Ty>>>;

template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept;
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>> : true_type {};

template <class _Ty>
class reference_wrapper

    : public _Weak_types<_Ty>
#line 1842 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
{
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    inline reference_wrapper(_Uty&& _Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) {
        _Ty& _Ref = static_cast<_Uty&&>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }

    inline operator _Ty&() const noexcept {
        return *_Ptr;
    }

    [[nodiscard]] inline _Ty& get() const noexcept {
        return *_Ptr;
    }

private:
    _Ty* _Ptr{};

public:
    template <class... _Types>
    inline auto operator()(_Types&&... _Args) const
        noexcept(noexcept(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...))) 
        -> decltype(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)) {
        return ::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...);
    }
};




#line 1881 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

template <class _Ty>
void ref(const _Ty&&) = delete;

template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return ::std:: ref(_Val.get());
}

template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

template <class _Ty>
void cref(const _Ty&&) = delete;

template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return ::std:: cref(_Val.get());
}



















#line 1927 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

template <class _Ty>
struct _Is_swappable;

template <class _Ty>
struct _Is_nothrow_swappable;



#line 1937 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
template <class _Ty, int _Enabled = 0>
#line 1939 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
inline void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
inline void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; 

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type {}; 

template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    
};

template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};

template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>())) 
                                    && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> {
    
    
};

template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    
    
};

template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};


































#line 2016 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

namespace _Has_ADL_swap_detail {
    void swap(); 

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} 
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
 constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;






template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    
};















































 constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
 constexpr size_t _FNV_prime        = 1099511628211ULL;



#line 2093 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { 
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
[[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { 
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
[[nodiscard]] size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}

template <class _Kty>
[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept { 
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

template <class _Kty>
[[nodiscard]] size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}

template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { 
     typedef _Kty argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const _Kty& _Keyval) const
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))  {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { 
    _Conditionally_enabled_hash()                                   = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)      = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
};

template <class _Kty>
struct hash
    : _Conditionally_enabled_hash<_Kty,
          !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    
    static size_t _Do_hash(const _Kty& _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
     typedef float argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const float _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); 
    }
};

template <>
struct hash<double> {
     typedef double argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); 
    }
};

template <>
struct hash<long double> {
     typedef long double argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const long double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); 
    }
};

template <>
struct hash<nullptr_t> {
     typedef nullptr_t argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(nullptr_t) const noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; 

template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> {};



template <class _FloatingType>
struct _Floating_type_traits;

template <>
struct _Floating_type_traits<float> {
    static constexpr int32_t _Mantissa_bits           = 24; 
    static constexpr int32_t _Exponent_bits           = 8; 
    static constexpr int32_t _Maximum_binary_exponent = 127; 
    static constexpr int32_t _Minimum_binary_exponent = -126; 
    static constexpr int32_t _Exponent_bias           = 127;
    static constexpr int32_t _Sign_shift              = 31; 
    static constexpr int32_t _Exponent_shift          = 23; 

    using _Uint_type = uint32_t;

    static constexpr uint32_t _Exponent_mask             = 0x000000FFu; 
    static constexpr uint32_t _Normal_mantissa_mask      = 0x00FFFFFFu; 
    static constexpr uint32_t _Denormal_mantissa_mask    = 0x007FFFFFu; 
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u; 
    static constexpr uint32_t _Shifted_sign_mask         = 0x80000000u; 
    static constexpr uint32_t _Shifted_exponent_mask     = 0x7F800000u; 
};

template <>
struct _Floating_type_traits<double> {
    static constexpr int32_t _Mantissa_bits           = 53; 
    static constexpr int32_t _Exponent_bits           = 11; 
    static constexpr int32_t _Maximum_binary_exponent = 1023; 
    static constexpr int32_t _Minimum_binary_exponent = -1022; 
    static constexpr int32_t _Exponent_bias           = 1023;
    static constexpr int32_t _Sign_shift              = 63; 
    static constexpr int32_t _Exponent_shift          = 52; 

    using _Uint_type = uint64_t;

    static constexpr uint64_t _Exponent_mask             = 0x00000000000007FFu; 
    static constexpr uint64_t _Normal_mantissa_mask      = 0x001FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Denormal_mantissa_mask    = 0x000FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u; 
    static constexpr uint64_t _Shifted_sign_mask         = 0x8000000000000000u; 
    static constexpr uint64_t _Shifted_exponent_mask     = 0x7FF0000000000000u; 
};

template <>
struct _Floating_type_traits<long double> : _Floating_type_traits<double> {};




__pragma(warning(push)) __pragma(warning(disable : 4996))
namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: add_const;
    using ::std:: add_cv;
    using ::std:: add_pointer;
    using ::std:: add_volatile;
    using ::std:: aligned_storage;
    using ::std:: alignment_of;
    using ::std:: conditional;
    using ::std:: decay;
    using ::std:: enable_if;
    using ::std:: extent;
    using ::std:: false_type;
    using ::std:: has_virtual_destructor;
    using ::std:: integral_constant;
    using ::std:: is_abstract;
    using ::std:: is_arithmetic;
    using ::std:: is_array;
    using ::std:: is_base_of;
    using ::std:: is_class;
    using ::std:: is_compound;
    using ::std:: is_const;
    using ::std:: is_convertible;
    using ::std:: is_empty;
    using ::std:: is_enum;
    using ::std:: is_floating_point;
    using ::std:: is_function;
    using ::std:: is_fundamental;
    using ::std:: is_integral;
    using ::std:: is_member_function_pointer;
    using ::std:: is_member_object_pointer;
    using ::std:: is_member_pointer;
    using ::std:: is_object;
    using ::std:: is_pod;
    using ::std:: is_pointer;
    using ::std:: is_polymorphic;
    using ::std:: is_reference;
    using ::std:: is_same;
    using ::std:: is_scalar;
    using ::std:: is_signed;
    using ::std:: is_union;
    using ::std:: is_unsigned;
    using ::std:: is_void;
    using ::std:: is_volatile;
    using ::std:: make_signed;
    using ::std:: make_unsigned;
    using ::std:: rank;
    using ::std:: remove_all_extents;
    using ::std:: remove_const;
    using ::std:: remove_cv;
    using ::std:: remove_extent;
    using ::std:: remove_pointer;
    using ::std:: remove_reference;
    using ::std:: remove_volatile;
    using ::std:: true_type;
    using ::std:: cref;
    using ::std:: ref;
    using ::std:: reference_wrapper;

    using ::std:: result_of;
#line 2322 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
    using ::std:: hash;
} 
__pragma(warning(pop))
#line 2326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"

}



#pragma warning(pop)
#pragma pack(pop)

#line 2335 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
#line 2336 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {


  bool __cdecl uncaught_exception() noexcept;
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
 int __cdecl uncaught_exceptions() noexcept;

}



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





    


#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"













typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;






   
void* __cdecl _alloca(  size_t _Size);





     intptr_t __cdecl _get_heap_handle(void);

     
     int __cdecl _heapmin(void);

    
         int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

    
           int __cdecl _heapchk(void);
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

     int __cdecl _resetstkoflw(void);

    
    
    

    
        
    

#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

    static_assert((sizeof(unsigned int) <= 16), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE");


    #pragma warning(push)
    #pragma warning(disable: 6540) 
                                   

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

















    
    







#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"




#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014) 
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC)
            {
                ((void)0);
            }
            #line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)

#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"




    
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
#pragma external_header(pop)
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_exception.h"







#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* terminate_handler )(void);
typedef void (__cdecl* terminate_function)(void);








     __declspec(noreturn) void __cdecl abort();
     __declspec(noreturn) void __cdecl terminate() throw();

    

         terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

         terminate_handler __cdecl _get_terminate();

    #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"

#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"



#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* unexpected_handler )(void);
typedef void (__cdecl* unexpected_function)(void);






struct _EXCEPTION_POINTERS;



     __declspec(noreturn) void __cdecl unexpected() noexcept(false);

    

         unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) noexcept;

         unexpected_handler __cdecl _get_unexpected() noexcept;

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

         _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );

    #line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"

    class type_info;

     int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();

#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\eh.h"
#pragma external_header(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_exception.h"







#pragma warning(push)
#pragma warning(disable:   4514 4820 )

#pragma pack(push, 8)

__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

 void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );

 void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class exception
{
public:

    exception() noexcept
        : _Data()
    {
    }

    explicit exception(char const* const _Message) noexcept
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) noexcept
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) noexcept
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) noexcept
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() noexcept
    {
        __std_exception_destroy(&_Data);
    }

    [[nodiscard]] virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() noexcept
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() noexcept
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() noexcept
        : bad_alloc("bad array new length")
    {
    }
};

#pragma warning(pop)

} 

#pragma pack(pop)

#pragma warning(pop) 
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_exception.h"
#pragma external_header(pop)
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"

namespace std {

using ::terminate;


using ::set_terminate;
using ::terminate_handler;

[[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept { 
    return _get_terminate();
}
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"


using ::unexpected;


using ::set_unexpected;
using ::unexpected_handler;

[[nodiscard]] inline unexpected_handler __cdecl get_unexpected() noexcept { 
    return _get_unexpected();
}
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"

}




































































































































#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"

 void __cdecl __ExceptionPtrCreate(  void*) noexcept;
 void __cdecl __ExceptionPtrDestroy(  void*) noexcept;
 void __cdecl __ExceptionPtrCopy(  void*,   const void*) noexcept;
 void __cdecl __ExceptionPtrAssign(  void*,   const void*) noexcept;
 bool __cdecl __ExceptionPtrCompare(  const void*,   const void*) noexcept;
 bool __cdecl __ExceptionPtrToBool(  const void*) noexcept;
 void __cdecl __ExceptionPtrSwap(  void*,   void*) noexcept;
 void __cdecl __ExceptionPtrCurrentException(void*) noexcept;
[[noreturn]]  void __cdecl __ExceptionPtrRethrow(  const void*);
 void __cdecl __ExceptionPtrCopyException(
      void*,   const void*,   const void*) noexcept;

namespace std {

class exception_ptr {
public:
    exception_ptr() noexcept {
        __ExceptionPtrCreate(this);
    }

    exception_ptr(nullptr_t) noexcept {
        __ExceptionPtrCreate(this);
    }

    ~exception_ptr() noexcept {
        __ExceptionPtrDestroy(this);
    }

    exception_ptr(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrCopy(this, &_Rhs);
    }

    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }

    exception_ptr& operator=(nullptr_t) noexcept {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }

    explicit operator bool() const noexcept {
        return __ExceptionPtrToBool(this);
    }

    static exception_ptr _Current_exception() noexcept {
        exception_ptr _Retval;
        __ExceptionPtrCurrentException(&_Retval);
        return _Retval;
    }

    static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr) {
        exception_ptr _Retval;
        if (!_Ptr) {
            
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }

    friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }

    friend bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }

    friend bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept {
        return !_Rhs;
    }

    friend bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept {
        return !_Lhs;
    }

    friend bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return !(_Lhs == _Rhs);
    }

    friend bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) noexcept {
        return !(_Lhs == _Rhs);
    }

    friend bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) noexcept {
        return !(_Lhs == _Rhs);
    }

private:




    void* _Data1;
    void* _Data2;



};

[[nodiscard]] inline exception_ptr current_exception() noexcept {
    return exception_ptr::_Current_exception();
}

[[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr) {
    __ExceptionPtrRethrow(&_Ptr);
}

template <class _Ex>
void* __GetExceptionInfo(_Ex);

template <class _Ex>
[[nodiscard]] exception_ptr make_exception_ptr(_Ex _Except) noexcept {
    return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
}

[[noreturn]] inline void _Throw_bad_array_new_length() {
    throw bad_array_new_length{};
}

class nested_exception { 
public:
    nested_exception() noexcept : _Exc(::std:: current_exception()) {}

    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept {}

    [[noreturn]] void rethrow_nested() const { 
        if (_Exc) {
            ::std:: rethrow_exception(_Exc);
        } else {
            ::std:: terminate();
        }
    }

    [[nodiscard]] exception_ptr nested_ptr() const noexcept { 
        return _Exc;
    }

private:
    exception_ptr _Exc;
};

template <class _Ty, class _Uty>
struct _With_nested : _Uty, nested_exception { 
    explicit _With_nested(_Ty&& _Arg)
        : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception() {} 
};

template <class _Ty>
[[noreturn]] void throw_with_nested(_Ty&& _Arg) { 
    using _Uty = decay_t<_Ty>;

    if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
        
        using _Glued = _With_nested<_Ty, _Uty>;
        throw _Glued(::std:: forward<_Ty>(_Arg));
    } else {
        
        throw ::std:: forward<_Ty>(_Arg);
    }
}


template <class _Ty>
void _Rethrow_if_nested(const _Ty* _Ptr, true_type) { 
    const auto _Nested = dynamic_cast<const nested_exception*>(_Ptr);

    if (_Nested) {
        _Nested->rethrow_nested();
    }
}

template <class _Ty>
void _Rethrow_if_nested(const _Ty*, false_type) {} 

template <class _Ty>
void rethrow_if_nested(const _Ty& _Arg) { 
    bool_constant<
        is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>)>
        _Tag;

    _Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
}



#line 388 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"

}



#pragma warning(pop)
#pragma pack(pop)

#line 397 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
#line 398 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\exception"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {






















#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"



using new_handler = void(__cdecl*)();
#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"

 new_handler __cdecl set_new_handler(  new_handler) noexcept;
[[nodiscard]]  new_handler __cdecl get_new_handler() noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\new"
#pragma external_header(pop)
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"






#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"



#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl operator new( size_t, void*) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl operator new[]( size_t, void*) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete(void*, void*) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete[](void*, void*) throw();

extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete(void*,  size_t) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete[](void*,  size_t) throw();
#line 133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
#line 134 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"









#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"




#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
    
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"


    

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"














    








#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"




#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
    #line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"






#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"


    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"



#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"




















} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

 FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
     wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
     wint_t __cdecl _fgetwchar(void);

    
     wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
     wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
     wint_t __cdecl getwc(
          FILE* _Stream
        );

     
     wint_t __cdecl getwchar(void);


    
     
     wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
     int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
     wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
     wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
     int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
     wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
     FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      
     FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
     errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    
     FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
     errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
     FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

     void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
         FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    #line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
     __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
     errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

       wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
     wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
     wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
     wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    



#line 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
     int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 540 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    

#line 614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 632 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    

#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
     int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 760 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

      
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 911 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 913 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 931 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

      
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    

#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
     int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...);  __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 1283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    

#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...);  __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...);  __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    

#line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1562 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    

#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    

#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1719 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    

#line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"


    
        
        
        #pragma warning(push)
        #pragma warning(disable: 4141 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    




#line 1863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
     
     int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 1949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1995 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    

#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
      
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    

#line 2025 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2034 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 2077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    

#line 2111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    

#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    


#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {































    
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"















    
    
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
     errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    
    
    
    
    
    

        
         errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
         
         errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                     char const* _FileName,
                                     char const* _Mode
            );

        
         
         size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
         errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
         char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
         errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
         errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    #line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     void __cdecl clearerr(
          FILE* _Stream
        );

     
    
     int __cdecl fclose(
          FILE* _Stream
        );

    
     int __cdecl _fcloseall(void);

     
     FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
     int __cdecl feof(
          FILE* _Stream
        );

     
     int __cdecl ferror(
          FILE* _Stream
        );

    
     int __cdecl fflush(
          FILE* _Stream
        );

     
    
     int __cdecl fgetc(
          FILE* _Stream
        );

    
     int __cdecl _fgetchar(void);

     
    
     int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
     char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
     int __cdecl _fileno(
          FILE* _Stream
        );

    
     int __cdecl _flushall(void);

      
     FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
     int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl _fputchar(
          int _Character
        );

     
    
     int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
     size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      
     FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
     FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
     int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
     int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
     int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
     long __cdecl ftell(
          FILE* _Stream
        );

     
     
     __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
     size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
     int __cdecl getc(
          FILE* _Stream
        );

     
     int __cdecl getchar(void);

     
     int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     int __cdecl _getw(
          FILE* _Stream
        );

     void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
         int __cdecl _pclose(
              FILE* _Stream
            );

         
         FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    #line 344 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
     int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl putchar(
          int _Character
        );

    
     int __cdecl puts(
          char const* _Buffer
        );

     
    
     int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

     int __cdecl remove(
          char const* _FileName
        );

     
     int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

     int __cdecl _unlink(
          char const* _FileName
        );

    

        
         int __cdecl unlink(
              char const* _FileName
            );

    #line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     void __cdecl rewind(
          FILE* _Stream
        );

    
     int __cdecl _rmtmp(void);

    
     void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
     int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
     int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    


#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    

#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

      
     FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

   char* __cdecl tmpnam(  char *_Buffer);
#line 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
     int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    
    
    
    
    
     void __cdecl _lock_file(
          FILE* _Stream
        );

     void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
     int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
     size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
     size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
     int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
     int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
     __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
     size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
     int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
     int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    














#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



     int* __cdecl __p__commode(void);

    


        
    #line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



    
    

#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    
    
    
    
     int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     int __cdecl _set_printf_count_output(
          int _Value
        );

     int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    

#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    

#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    

#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"


    
    
    
    
    
     int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

      
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 1245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

      
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    

#line 1282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    

#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



    
    
    
    
    
     
     int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    








#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    

#line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

       int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...);    int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    

#line 1823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    

#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    








#line 1916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    

#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    

#line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...);     int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    

#line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    

#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    

#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 2057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    

#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2092 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    

#line 2118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    
    
    
    
     int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable: 6530) 

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        #pragma warning(pop)

    #line 2219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

      
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    

#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    

#line 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

            _Result = vsscanf_s(_Buffer, _Format, _ArgList);

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 2299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 6530) 

     
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    

#line 2336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        
         char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

           int   __cdecl fcloseall(void);
                   FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
            int   __cdecl fgetchar(void);
                   int   __cdecl fileno(  FILE* _Stream);
            int   __cdecl flushall(void);
            int   __cdecl fputchar(  int _Ch);
                     int   __cdecl getw(  FILE* _Stream);
                int   __cdecl putw(  int _Ch,   FILE* _Stream);
                    int   __cdecl rmtmp(void);

    #line 2441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#line 2442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma external_header(pop)
#line 137 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

#line 139 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"



#line 143 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
extern "C"
{
extern


#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
            


#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
__declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) int     __cdecl printf(const char*, ...);
#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"


extern  __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl malloc(size_t) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl free(void*) ;


extern  __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl _alloca(size_t);
#line 163 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"




#line 168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
}


#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    














#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
#line 176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

extern "C"
{






#line 186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"



#line 190 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"


#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"








#line 202 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"


#line 205 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"



#line 209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__)  void __cdecl _wassert(
  const wchar_t *, const wchar_t *, unsigned);
#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
}






























#line 244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

















#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"



#line 266 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl operator new( size_t) throw(...);
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl operator new[]( size_t) throw(...);
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete(void*) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete[](void*) throw();

extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete(void*,  size_t) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete[](void*,  size_t) throw();
#line 275 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"








#line 284 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"



#line 288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

#line 290 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

#line 292 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"









#line 302 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"








#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"












































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"







extern "C"
{









































































#line 197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 200 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

#line 202 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





#line 209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"







extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) int            __cdecl abs(int a) ;







extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) long int       __cdecl labs(long int a) ;







extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) long long int          llabs(long long int a) ;


#line 239 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#line 240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




#line 245 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl fabs(double x) ;










































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fabsf(float x) ;


#line 332 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"






extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    min(const int a, const int b);






extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned int           umin(const unsigned int a, const unsigned int b);






extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llmin(const long long int a, const long long int b);






extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned long long int ullmin(const unsigned long long int a, const unsigned long long int b);



#line 364 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

















#line 382 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl fminf(float x, float y);
#line 384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

















#line 402 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl fmin(double x, double y);
#line 404 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 407 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"






extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    max(const int a, const int b);







extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned int           umax(const unsigned int a, const unsigned int b);






extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llmax(const long long int a, const long long int b);






extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned long long int ullmax(const unsigned long long int a, const unsigned long long int b);



#line 440 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

















#line 458 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl fmaxf(float x, float y);
#line 460 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

















#line 478 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl fmax(double, double);
#line 480 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sin(double x) ;
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl cos(double x) ;


#line 557 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincos(double x, double *sptr, double *cptr) ;















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincosf(float x, float *sptr, float *cptr) ;



#line 593 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl tan(double x) ;




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sqrt(double x) ;


#line 706 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 rsqrt(double x);





































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  rsqrtf(float x);



#line 849 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




















































#line 902 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl log2(double x);
#line 904 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"






























































#line 967 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl exp2(double x);
#line 969 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"






























































#line 1032 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl exp2f(float x);
#line 1034 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 1037 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



























































         
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 exp10(double x) ;






























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  exp10f(float x) ;



#line 1165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

























































































#line 1255 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl expm1(double x);
#line 1257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

























































































#line 1347 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl expm1f(float x);
#line 1349 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





















































#line 1403 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl log2f(float x);
#line 1405 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl log10(double x) ;





































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl log(double x) ;
































































































#line 1623 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl log1p(double x);
#line 1625 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
































































































#line 1722 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl log1pf(float x);
#line 1724 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl floor(double x) ;














































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl exp(double x) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl cosh(double x) ;

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sinh(double x) ;

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl tanh(double x) ;























































#line 2061 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl acosh(double x);
#line 2063 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"























































#line 2119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl acoshf(float x);
#line 2121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































#line 2172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl asinh(double x);
#line 2174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































#line 2225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl asinhf(float x);
#line 2227 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















































#line 2279 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl atanh(double x);
#line 2281 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















































#line 2333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl atanhf(float x);
#line 2335 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"













































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl ldexp(double x, int exp) ;













































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  ldexpf(float x, int exp) ;




















































#line 2480 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl logb(double x);
#line 2482 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




















































#line 2535 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl logbf(float x);
#line 2537 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





































#line 2575 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  int    __cdecl ilogb(double x);
#line 2577 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





































#line 2615 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  int    __cdecl ilogbf(float x);
#line 2617 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"









































































#line 2691 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl scalbn(double x, int n);
#line 2693 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"









































































#line 2767 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl scalbnf(float x, int n);
#line 2769 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"









































































#line 2843 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl scalbln(double x, long int n);
#line 2845 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"









































































#line 2919 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl scalblnf(float x, long int n);
#line 2921 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"









































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl frexp(double x, int *nptr) ;









































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  frexpf(float x, int *nptr) ;




















































#line 3122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl round(double x);
#line 3124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




















































#line 3177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl roundf(float x);
#line 3179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















#line 3195 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  long int __cdecl lround(double x);
#line 3197 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















#line 3213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  long int __cdecl lroundf(float x);
#line 3215 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















#line 3231 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  long long int __cdecl llround(double x);
#line 3233 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















#line 3249 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  long long int __cdecl llroundf(float x);
#line 3251 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"







































































#line 3323 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl rint(double x);
#line 3325 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#line 3326 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































#line 3377 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl rintf(float x);
#line 3379 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














#line 3394 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  long int __cdecl lrint(double x);
#line 3396 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














#line 3411 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  long int __cdecl lrintf(float x);
#line 3413 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














#line 3428 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  long long int __cdecl llrint(double x);
#line 3430 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














#line 3445 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  long long int __cdecl llrintf(float x);
#line 3447 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































#line 3498 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl nearbyint(double x);
#line 3500 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































#line 3551 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl nearbyintf(float x);
#line 3553 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl ceil(double x) ;


















































#line 3663 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl trunc(double x);
#line 3665 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































#line 3716 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl truncf(float x);
#line 3718 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"























#line 3742 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl fdim(double x, double y);
#line 3744 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"























#line 3768 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl fdimf(float x, float y);
#line 3770 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"








































































































































































































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl atan2(double y, double x) ;






































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl atan(double x) ;






















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl acos(double x) ;


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl asin(double x) ;































































#line 4276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double __cdecl hypot(double x, double y);
#line 4278 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 4281 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



#line 4285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

















































extern __declspec(__device__) __declspec(__device_builtin__) double                rhypot(double x, double y) ;



#line 4339 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





























































static __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl hypotf(float x, float y);


#line 4404 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



#line 4408 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

















































extern __declspec(__device__) __declspec(__device_builtin__) float                 rhypotf(float x, float y) ;











































extern __declspec(__device__) __declspec(__device_builtin__)  double __cdecl norm3d(double a, double b, double c) ;


















































extern __declspec(__device__) __declspec(__device_builtin__) double                rnorm3d(double a, double b, double c) ;
















































extern __declspec(__device__) __declspec(__device_builtin__)  double __cdecl norm4d(double a, double b, double c, double d) ;























































extern __declspec(__device__) __declspec(__device_builtin__) double rnorm4d(double a, double b, double c, double d) ;
























































extern "C++"  __declspec(__device__) __declspec(__device_builtin__)  double norm(int dim, double const * p) ;































































extern __declspec(__device__) __declspec(__device_builtin__) double rnorm(int dim, double const * p) ;
































































extern __declspec(__device__) __declspec(__device_builtin__) float rnormf(int dim, float const * p) ;
























































extern "C++"  __declspec(__device__) __declspec(__device_builtin__)  float normf(int dim, float const * p) ;












































extern __declspec(__device__) __declspec(__device_builtin__) float norm3df(float a, float b, float c) ;


















































extern __declspec(__device__) __declspec(__device_builtin__) float rnorm3df(float a, float b, float c) ;
















































extern __declspec(__device__) __declspec(__device_builtin__) float norm4df(float a, float b, float c, float d) ;























































extern __declspec(__device__) __declspec(__device_builtin__) float rnorm4df(float a, float b, float c, float d) ;



#line 5106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















































































#line 5190 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl cbrt(double x);
#line 5192 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















































































#line 5276 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl cbrtf(float x);
#line 5278 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 5281 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 rcbrt(double x);

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  rcbrtf(float x);



























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 sinpi(double x);



























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sinpif(float x);



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 cospi(double x);



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cospif(float x);





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincospi(double x, double *sptr, double *cptr);





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincospif(float x, float *sptr, float *cptr);



#line 5668 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"








































































































































































































































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl pow(double x, double y) ;























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl modf(double x, double *iptr) ;


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl fmod(double x, double y) ;
































































































#line 6209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl remainder(double x, double y);
#line 6211 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
































































































#line 6308 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl remainderf(float x, float y);
#line 6310 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





































































#line 6380 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl remquo(double x, double y, int *quo);
#line 6382 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





































































#line 6452 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl remquof(float x, float y, int *quo);
#line 6454 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl j0(double x) ;


#line 6495 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"






































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  j0f(float x) ;



#line 6538 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl j1(double x) ;


#line 6606 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  j1f(float x) ;



#line 6676 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"






































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl jn(int n, double x) ;


#line 6718 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"







































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  jnf(int n, float x) ;



#line 6762 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl y0(double x) ;


#line 6822 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  y0f(float x) ;



#line 6884 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl y1(double x) ;


#line 6944 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  y1f(float x) ;



#line 7006 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl yn(int n, double x) ;


#line 7068 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  ynf(int n, float x) ;


























extern __declspec(__device__) __declspec(__device_builtin__)  double __cdecl cyl_bessel_i0(double x) ;

























extern __declspec(__device__) __declspec(__device_builtin__) float                  cyl_bessel_i0f(float x) ;


























extern __declspec(__device__) __declspec(__device_builtin__)  double __cdecl cyl_bessel_i1(double x) ;

























extern __declspec(__device__) __declspec(__device_builtin__) float                  cyl_bessel_i1f(float x) ;



#line 7238 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















































































#line 7318 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl erf(double x);
#line 7320 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















































































#line 7400 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl erff(float x);
#line 7402 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 7405 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfinv(double x);
































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfinvf(float x);



#line 7540 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



































#line 7576 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl erfc(double x);
#line 7578 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



































#line 7614 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl erfcf(float x);
#line 7616 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































































































#line 7731 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl lgamma(double x);
#line 7733 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 7736 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfcinv(double x);






















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfcinvf(float x);



































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 normcdfinv(double x);



































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  normcdfinvf(float x);










































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 normcdf(double x);










































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  normcdff(float x);































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfcx(double x);































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfcxf(float x);



#line 8201 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















































































































#line 8317 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl lgammaf(float x);
#line 8319 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"































































































#line 8415 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl tgamma(double x);
#line 8417 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"































































































#line 8513 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl tgammaf(float x);
#line 8515 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"










#line 8526 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl copysign(double x, double y);
#line 8528 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"










#line 8539 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl copysignf(float x, float y);
#line 8541 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
















#line 8558 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl nextafter(double x, double y);
#line 8560 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
















#line 8577 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl nextafterf(float x, float y);
#line 8579 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"













#line 8593 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl nan(const char *tagp);
#line 8595 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"













#line 8609 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl nanf(const char *tagp);
#line 8611 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 8614 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinff(float) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnanf(float) ;








#line 8625 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finite(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finitef(float) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbit(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnan(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinf(double) ;
#line 8631 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbitf(float) ;



#line 8637 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



























































































































































#line 8793 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  double __cdecl fma(double x, double y, double z);
#line 8795 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



























































































































































#line 8951 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__)  float  __cdecl fmaf(float x, float y, float z);
#line 8953 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 8956 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbitl(long double) ;




#line 8966 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finitel(long double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinfl(long double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnanl(long double) ;
#line 8970 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl acosf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl asinf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl atanf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl atan2f(float, float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl cosf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl sinf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl tanf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl coshf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl sinhf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl tanhf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl expf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl logf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl log10f(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl modff(float, float*) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl powf(float, float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl sqrtf(float) ;         
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl ceilf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl floorf(float) ;
extern  __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float __cdecl fmodf(float, float) ;















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 10543 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

}


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"















#pragma external_header(pop)
#line 10548 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"





#pragma once










#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"



#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"



#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




[[nodiscard]]   inline float acos(  float _Xx) noexcept  {
    return :: acosf(_Xx);
}

[[nodiscard]]   inline float acosh(  float _Xx) noexcept  {
    return :: acoshf(_Xx);
}

[[nodiscard]]   inline float asin(  float _Xx) noexcept  {
    return :: asinf(_Xx);
}

[[nodiscard]]   inline float asinh(  float _Xx) noexcept  {
    return :: asinhf(_Xx);
}

[[nodiscard]]   inline float atan(  float _Xx) noexcept  {
    return :: atanf(_Xx);
}

[[nodiscard]]   inline float atanh(  float _Xx) noexcept  {
    return :: atanhf(_Xx);
}

[[nodiscard]]   inline float atan2(  float _Yx,   float _Xx) noexcept  {
    return :: atan2f(_Yx, _Xx);
}

[[nodiscard]]   inline float cbrt(  float _Xx) noexcept  {
    return :: cbrtf(_Xx);
}

[[nodiscard]]   inline float ceil(  float _Xx) noexcept  {


#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: ceilf(_Xx);
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline float copysign(  float _Number,   float _Sign) noexcept  {


#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: copysignf(_Number, _Sign);
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline float cos(  float _Xx) noexcept  {
    return :: cosf(_Xx);
}

[[nodiscard]]   inline float cosh(  float _Xx) noexcept  {
    return :: coshf(_Xx);
}

[[nodiscard]]   inline float erf(  float _Xx) noexcept  {
    return :: erff(_Xx);
}

[[nodiscard]]   inline float erfc(  float _Xx) noexcept  {
    return :: erfcf(_Xx);
}

[[nodiscard]]   inline float exp(  float _Xx) noexcept  {
    return :: expf(_Xx);
}

[[nodiscard]]   inline float exp2(  float _Xx) noexcept  {
    return :: exp2f(_Xx);
}

[[nodiscard]]   inline float expm1(  float _Xx) noexcept  {
    return :: expm1f(_Xx);
}

[[nodiscard]]   inline float fabs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline float fdim(  float _Xx,   float _Yx) noexcept  {
    return :: fdimf(_Xx, _Yx);
}

[[nodiscard]]   inline float floor(  float _Xx) noexcept  {


#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: floorf(_Xx);
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline float fma(  float _Xx,   float _Yx,   float _Zx) noexcept  {
    return :: fmaf(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline float fmax(  float _Xx,   float _Yx) noexcept  {
    return :: fmaxf(_Xx, _Yx);
}

[[nodiscard]]   inline float fmin(  float _Xx,   float _Yx) noexcept  {
    return :: fminf(_Xx, _Yx);
}

[[nodiscard]]   inline float fmod(  float _Xx,   float _Yx) noexcept  {
    return :: fmodf(_Xx, _Yx);
}

inline float frexp(  float _Xx,   int* _Yx) noexcept  {
    return :: frexpf(_Xx, _Yx);
}

[[nodiscard]]   inline float hypot(  float _Xx,   float _Yx) noexcept  {
    return :: hypotf(_Xx, _Yx);
}

[[nodiscard]]   inline int ilogb(  float _Xx) noexcept  {
    return :: ilogbf(_Xx);
}

[[nodiscard]]   inline float ldexp(  float _Xx,   int _Yx) noexcept  {
    return :: ldexpf(_Xx, _Yx);
}

[[nodiscard]]   inline float lgamma(  float _Xx) noexcept  {
    return :: lgammaf(_Xx);
}

[[nodiscard]]   inline long long llrint(  float _Xx) noexcept  {
    return :: llrintf(_Xx);
}

[[nodiscard]]   inline long long llround(  float _Xx) noexcept  {
    return :: llroundf(_Xx);
}

[[nodiscard]]   inline float log(  float _Xx) noexcept  {
    return :: logf(_Xx);
}

[[nodiscard]]   inline float log10(  float _Xx) noexcept  {
    return :: log10f(_Xx);
}

[[nodiscard]]   inline float log1p(  float _Xx) noexcept  {
    return :: log1pf(_Xx);
}

[[nodiscard]]   inline float log2(  float _Xx) noexcept  {
    return :: log2f(_Xx);
}

[[nodiscard]]   inline float logb(  float _Xx) noexcept  {
    return :: logbf(_Xx);
}

[[nodiscard]]   inline long lrint(  float _Xx) noexcept  {
    return :: lrintf(_Xx);
}

[[nodiscard]]   inline long lround(  float _Xx) noexcept  {
    return :: lroundf(_Xx);
}

inline float modf(  float _Xx,   float* _Yx) noexcept  {
    return :: modff(_Xx, _Yx);
}

[[nodiscard]]   inline float nearbyint(  float _Xx) noexcept  {
    return :: nearbyintf(_Xx);
}

[[nodiscard]]   inline float nextafter(  float _Xx,   float _Yx) noexcept  {
    return :: nextafterf(_Xx, _Yx);
}

[[nodiscard]]   inline float nexttoward(  float _Xx,   long double _Yx) noexcept  {
    return :: nexttowardf(_Xx, _Yx);
}

[[nodiscard]]   inline float pow(  float _Xx,   float _Yx) noexcept  {
    return :: powf(_Xx, _Yx);
}

[[nodiscard]]   inline float remainder(  float _Xx,   float _Yx) noexcept  {
    return :: remainderf(_Xx, _Yx);
}

inline float remquo(  float _Xx,   float _Yx,   int* _Zx) noexcept  {
    return :: remquof(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline float rint(  float _Xx) noexcept  {
    return :: rintf(_Xx);
}

[[nodiscard]]   inline float round(  float _Xx) noexcept  {


#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: roundf(_Xx);
#line 246 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline float scalbln(  float _Xx,   long _Yx) noexcept  {
    return :: scalblnf(_Xx, _Yx);
}

[[nodiscard]]   inline float scalbn(  float _Xx,   int _Yx) noexcept  {
    return :: scalbnf(_Xx, _Yx);
}

[[nodiscard]]   inline float sin(  float _Xx) noexcept  {
    return :: sinf(_Xx);
}

[[nodiscard]]   inline float sinh(  float _Xx) noexcept  {
    return :: sinhf(_Xx);
}

[[nodiscard]]   inline float sqrt(  float _Xx) noexcept  {
    return :: sqrtf(_Xx);
}

[[nodiscard]]   inline float tan(  float _Xx) noexcept  {
    return :: tanf(_Xx);
}

[[nodiscard]]   inline float tanh(  float _Xx) noexcept  {
    return :: tanhf(_Xx);
}

[[nodiscard]]   inline float tgamma(  float _Xx) noexcept  {
    return :: tgammaf(_Xx);
}

[[nodiscard]]   inline float trunc(  float _Xx) noexcept  {


#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: truncf(_Xx);
#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline long double acos(  long double _Xx) noexcept  {
    return :: acosl(_Xx);
}

[[nodiscard]]   inline long double acosh(  long double _Xx) noexcept  {
    return :: acoshl(_Xx);
}

[[nodiscard]]   inline long double asin(  long double _Xx) noexcept  {
    return :: asinl(_Xx);
}

[[nodiscard]]   inline long double asinh(  long double _Xx) noexcept  {
    return :: asinhl(_Xx);
}

[[nodiscard]]   inline long double atan(  long double _Xx) noexcept  {
    return :: atanl(_Xx);
}

[[nodiscard]]   inline long double atanh(  long double _Xx) noexcept  {
    return :: atanhl(_Xx);
}

[[nodiscard]]   inline long double atan2(  long double _Yx,   long double _Xx) noexcept
 {
    return :: atan2l(_Yx, _Xx);
}

[[nodiscard]]   inline long double cbrt(  long double _Xx) noexcept  {
    return :: cbrtl(_Xx);
}

[[nodiscard]]   inline long double ceil(  long double _Xx) noexcept  {


#line 327 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: ceill(_Xx);
#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline long double copysign(  long double _Number,   long double _Sign) noexcept
 {


#line 338 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: copysignl(_Number, _Sign);
#line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline long double cos(  long double _Xx) noexcept  {
    return :: cosl(_Xx);
}

[[nodiscard]]   inline long double cosh(  long double _Xx) noexcept  {
    return :: coshl(_Xx);
}

[[nodiscard]]   inline long double erf(  long double _Xx) noexcept  {
    return :: erfl(_Xx);
}

[[nodiscard]]   inline long double erfc(  long double _Xx) noexcept  {
    return :: erfcl(_Xx);
}

[[nodiscard]]   inline long double exp(  long double _Xx) noexcept  {
    return :: expl(_Xx);
}

[[nodiscard]]   inline long double exp2(  long double _Xx) noexcept  {
    return :: exp2l(_Xx);
}

[[nodiscard]]   inline long double expm1(  long double _Xx) noexcept  {
    return :: expm1l(_Xx);
}

[[nodiscard]]   inline long double fabs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}

[[nodiscard]]   inline long double fdim(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fdiml(_Xx, _Yx);
}

[[nodiscard]]   inline long double floor(  long double _Xx) noexcept  {


#line 385 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 387 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: floorl(_Xx);
#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline long double fma(
      long double _Xx,   long double _Yx,   long double _Zx) noexcept  {
    return :: fmal(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline long double fmax(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fmaxl(_Xx, _Yx);
}

[[nodiscard]]   inline long double fmin(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fminl(_Xx, _Yx);
}

[[nodiscard]]   inline long double fmod(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fmodl(_Xx, _Yx);
}

inline long double frexp(  long double _Xx,   int* _Yx) noexcept  {
    return :: frexpl(_Xx, _Yx);
}

[[nodiscard]]   inline long double hypot(  long double _Xx,   long double _Yx) noexcept
 {
    return :: hypotl(_Xx, _Yx);
}

[[nodiscard]]   inline int ilogb(  long double _Xx) noexcept  {
    return :: ilogbl(_Xx);
}

[[nodiscard]]   inline long double ldexp(  long double _Xx,   int _Yx) noexcept  {
    return :: ldexpl(_Xx, _Yx);
}

[[nodiscard]]   inline long double lgamma(  long double _Xx) noexcept  {
    return :: lgammal(_Xx);
}

[[nodiscard]]   inline long long llrint(  long double _Xx) noexcept  {
    return :: llrintl(_Xx);
}

[[nodiscard]]   inline long long llround(  long double _Xx) noexcept  {
    return :: llroundl(_Xx);
}

[[nodiscard]]   inline long double log(  long double _Xx) noexcept  {
    return :: logl(_Xx);
}

[[nodiscard]]   inline long double log10(  long double _Xx) noexcept  {
    return :: log10l(_Xx);
}

[[nodiscard]]   inline long double log1p(  long double _Xx) noexcept  {
    return :: log1pl(_Xx);
}

[[nodiscard]]   inline long double log2(  long double _Xx) noexcept  {
    return :: log2l(_Xx);
}

[[nodiscard]]   inline long double logb(  long double _Xx) noexcept  {
    return :: logbl(_Xx);
}

[[nodiscard]]   inline long lrint(  long double _Xx) noexcept  {
    return :: lrintl(_Xx);
}

[[nodiscard]]   inline long lround(  long double _Xx) noexcept  {
    return :: lroundl(_Xx);
}

inline long double modf(  long double _Xx,   long double* _Yx) noexcept  {
    return :: modfl(_Xx, _Yx);
}

[[nodiscard]]   inline long double nearbyint(  long double _Xx) noexcept  {
    return :: nearbyintl(_Xx);
}

[[nodiscard]]   inline long double nextafter(  long double _Xx,   long double _Yx) noexcept
 {
    return :: nextafterl(_Xx, _Yx);
}

[[nodiscard]]   inline long double nexttoward(  long double _Xx,   long double _Yx) noexcept
 {
    return :: nexttowardl(_Xx, _Yx);
}

[[nodiscard]]   inline long double pow(  long double _Xx,   long double _Yx) noexcept
 {
    return :: powl(_Xx, _Yx);
}

[[nodiscard]]   inline long double remainder(  long double _Xx,   long double _Yx) noexcept
 {
    return :: remainderl(_Xx, _Yx);
}

inline long double remquo(  long double _Xx,   long double _Yx,   int* _Zx) noexcept  {
    return :: remquol(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline long double rint(  long double _Xx) noexcept  {
    return :: rintl(_Xx);
}

[[nodiscard]]   inline long double round(  long double _Xx) noexcept  {


#line 508 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 510 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: roundl(_Xx);
#line 512 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}

[[nodiscard]]   inline long double scalbln(  long double _Xx,   long _Yx) noexcept  {
    return :: scalblnl(_Xx, _Yx);
}

[[nodiscard]]   inline long double scalbn(  long double _Xx,   int _Yx) noexcept  {
    return :: scalbnl(_Xx, _Yx);
}

[[nodiscard]]   inline long double sin(  long double _Xx) noexcept  {
    return :: sinl(_Xx);
}

[[nodiscard]]   inline long double sinh(  long double _Xx) noexcept  {
    return :: sinhl(_Xx);
}

[[nodiscard]]   inline long double sqrt(  long double _Xx) noexcept  {
    return :: sqrtl(_Xx);
}

[[nodiscard]]   inline long double tan(  long double _Xx) noexcept  {
    return :: tanl(_Xx);
}

[[nodiscard]]   inline long double tanh(  long double _Xx) noexcept  {
    return :: tanhl(_Xx);
}

[[nodiscard]]   inline long double tgamma(  long double _Xx) noexcept  {
    return :: tgammal(_Xx);
}

[[nodiscard]]   inline long double trunc(  long double _Xx) noexcept  {


#line 550 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 552 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
    return :: truncl(_Xx);
#line 554 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
}


namespace std {
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
        double>>; 
}

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0>
double frexp(_Ty _Value,   int* const _Exp) noexcept  {
    return :: frexp(static_cast<double>(_Value), _Exp);
}

template <class _Ty1, class _Ty2, class _Ty3,
    ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2> && ::std:: is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else {
        return :: fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
}

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0>
::std:: _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else {
        return :: remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
}












#line 607 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 609 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"



















#line 631 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 633 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"

#line 635 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"


template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acos(_Ty _Left) noexcept { return :: acos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asin(_Ty _Left) noexcept { return :: asin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atan(_Ty _Left) noexcept { return :: atan(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: atan2(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cos(_Ty _Left) noexcept { return :: cos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sin(_Ty _Left) noexcept { return :: sin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tan(_Ty _Left) noexcept { return :: tan(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acosh(_Ty _Left) noexcept { return :: acosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asinh(_Ty _Left) noexcept { return :: asinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atanh(_Ty _Left) noexcept { return :: atanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cosh(_Ty _Left) noexcept { return :: cosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sinh(_Ty _Left) noexcept { return :: sinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tanh(_Ty _Left) noexcept { return :: tanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp(_Ty _Left) noexcept { return :: exp(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp2(_Ty _Left) noexcept { return :: exp2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double expm1(_Ty _Left) noexcept { return :: expm1(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] int ilogb(_Ty _Left) noexcept { return :: ilogb(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ldexp(_Ty _Left, int _Arg2) noexcept { return :: ldexp(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log(_Ty _Left) noexcept { return :: log(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log10(_Ty _Left) noexcept { return :: log10(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log1p(_Ty _Left) noexcept { return :: log1p(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log2(_Ty _Left) noexcept { return :: log2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double logb(_Ty _Left) noexcept { return :: logb(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbn(_Ty _Left, int _Arg2) noexcept { return :: scalbn(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbln(_Ty _Left, long _Arg2) noexcept { return :: scalbln(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cbrt(_Ty _Left) noexcept { return :: cbrt(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double fabs(_Ty _Left) noexcept { return :: fabs(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: hypot(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> pow(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: pow(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sqrt(_Ty _Left) noexcept { return :: sqrt(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erf(_Ty _Left) noexcept { return :: erf(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erfc(_Ty _Left) noexcept { return :: erfc(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double lgamma(_Ty _Left) noexcept { return :: lgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tgamma(_Ty _Left) noexcept { return :: tgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ceil(_Ty _Left) noexcept { return :: ceil(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double floor(_Ty _Left) noexcept { return :: floor(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nearbyint(_Ty _Left) noexcept { return :: nearbyint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double rint(_Ty _Left) noexcept { return :: rint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lrint(_Ty _Left) noexcept { return :: lrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llrint(_Ty _Left) noexcept { return :: llrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double round(_Ty _Left) noexcept { return :: round(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lround(_Ty _Left) noexcept { return :: lround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llround(_Ty _Left) noexcept { return :: llround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double trunc(_Ty _Left) noexcept { return :: trunc(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmod(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: remainder(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: copysign(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: nextafter(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nexttoward(_Ty _Left, long double _Arg2) noexcept { return :: nexttoward(static_cast<double>(_Left), _Arg2); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fdim(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmax(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmin(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
















namespace std {
using :: abs;
using :: acos;
using :: asin;
using :: atan;
using :: atan2;
using :: ceil;
using :: cos;
using :: cosh;
using :: exp;
using :: fabs;
using :: floor;
using :: fmod;
using :: frexp;
using :: ldexp;
using :: log;
using :: log10;
using :: modf;
using :: pow;
using :: sin;
using :: sinh;
using :: sqrt;
using :: tan;
using :: tanh;

using :: acosf;
using :: asinf;
using :: atanf;
using :: atan2f;
using :: ceilf;
using :: cosf;
using :: coshf;
using :: expf;
using :: fabsf;
using :: floorf;
using :: fmodf;
using :: frexpf;
using :: ldexpf;
using :: logf;
using :: log10f;
using :: modff;
using :: powf;
using :: sinf;
using :: sinhf;
using :: sqrtf;
using :: tanf;
using :: tanhf;

using :: acosl;
using :: asinl;
using :: atanl;
using :: atan2l;
using :: ceill;
using :: cosl;
using :: coshl;
using :: expl;
using :: fabsl;
using :: floorl;
using :: fmodl;
using :: frexpl;
using :: ldexpl;
using :: logl;
using :: log10l;
using :: modfl;
using :: powl;
using :: sinl;
using :: sinhl;
using :: sqrtl;
using :: tanl;
using :: tanhl;

using :: float_t;
using :: double_t;

using :: acosh;
using :: asinh;
using :: atanh;
using :: cbrt;
using :: erf;
using :: erfc;
using :: expm1;
using :: exp2;
using :: hypot;
using :: ilogb;
using :: lgamma;
using :: log1p;
using :: log2;
using :: logb;
using :: llrint;
using :: lrint;
using :: nearbyint;
using :: rint;
using :: llround;
using :: lround;
using :: fdim;
using :: fma;
using :: fmax;
using :: fmin;
using :: round;
using :: trunc;
using :: remainder;
using :: remquo;
using :: copysign;
using :: nan;
using :: nextafter;
using :: scalbn;
using :: scalbln;
using :: nexttoward;
using :: tgamma;

using :: acoshf;
using :: asinhf;
using :: atanhf;
using :: cbrtf;
using :: erff;
using :: erfcf;
using :: expm1f;
using :: exp2f;
using :: hypotf;
using :: ilogbf;
using :: lgammaf;
using :: log1pf;
using :: log2f;
using :: logbf;
using :: llrintf;
using :: lrintf;
using :: nearbyintf;
using :: rintf;
using :: llroundf;
using :: lroundf;
using :: fdimf;
using :: fmaf;
using :: fmaxf;
using :: fminf;
using :: roundf;
using :: truncf;
using :: remainderf;
using :: remquof;
using :: copysignf;
using :: nanf;
using :: nextafterf;
using :: scalbnf;
using :: scalblnf;
using :: nexttowardf;
using :: tgammaf;

using :: acoshl;
using :: asinhl;
using :: atanhl;
using :: cbrtl;
using :: erfl;
using :: erfcl;
using :: expm1l;
using :: exp2l;
using :: hypotl;
using :: ilogbl;
using :: lgammal;
using :: log1pl;
using :: log2l;
using :: logbl;
using :: llrintl;
using :: lrintl;
using :: nearbyintl;
using :: rintl;
using :: llroundl;
using :: lroundl;
using :: fdiml;
using :: fmal;
using :: fmaxl;
using :: fminl;
using :: roundl;
using :: truncl;
using :: remainderl;
using :: remquol;
using :: copysignl;
using :: nanl;
using :: nextafterl;
using :: scalbnl;
using :: scalblnl;
using :: nexttowardl;
using :: tgammal;

using :: fpclassify;
using :: signbit;
using :: isfinite;
using :: isinf;
using :: isnan;
using :: isnormal;
using :: isgreater;
using :: isgreaterequal;
using :: isless;
using :: islessequal;
using :: islessgreater;
using :: isunordered;
}






































































































































































































































































































































































































































#line 1329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"



#pragma warning(pop)
#pragma pack(pop)

#line 1336 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
#line 1337 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cmath"
#pragma external_header(pop)
#line 10552 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

#line 10554 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#line 10555 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

























#line 10581 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

























































































































































































































































#line 10831 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__)  double __cdecl _hypot(double x, double y);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__)  float  __cdecl _hypotf(float x, float y);



#line 10838 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




#line 10843 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool signbit(long double) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__)  int _ldsign(long double);

#line 10847 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















#line 10867 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





#line 10873 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool signbit(double) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__)  int _dsign(double);


#line 10892 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















#line 10912 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"





#line 10918 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool signbit(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__)  int _fdsign(float);


#line 10937 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



#line 10941 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline __declspec(__host__) __declspec(__device__) bool isinf(long double a);
#line 10943 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















#line 10962 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














static __inline __declspec(__host__) __declspec(__device__) bool isinf(double a);

#line 10979 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















#line 10999 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















static __inline __declspec(__host__) __declspec(__device__) bool isinf(float a);

#line 11017 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



#line 11021 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline __declspec(__host__) __declspec(__device__) bool isnan(long double a);
#line 11023 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

















#line 11041 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"













static __inline __declspec(__host__) __declspec(__device__) bool isnan(double a);

#line 11057 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















#line 11076 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














static __inline __declspec(__host__) __declspec(__device__) bool isnan(float a);

#line 11093 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



#line 11097 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
static __inline __declspec(__host__) __declspec(__device__) bool isfinite(long double a);
#line 11099 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



















#line 11119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"















static __inline __declspec(__host__) __declspec(__device__) bool isfinite(double a);

#line 11137 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















#line 11156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"














static __inline __declspec(__host__) __declspec(__device__) bool isfinite(float a);

#line 11173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




#line 11178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
template<class T> extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) T _Pow_int(T, int) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long long int abs(long long int) throw();
#line 11181 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

#line 11183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



#line 11187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

#line 11189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"









#line 11199 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 11202 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"











#line 11214 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"











































#line 11260 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long int __cdecl abs(long int) throw();


#line 11264 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl abs(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double   __cdecl abs(double) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl fabs(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl ceil(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl floor(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sqrt(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl pow(float, float) throw();

























#line 11297 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


template <class _Ty1, class _Ty2, ::std:: enable_if_t< ::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> > [[nodiscard]] __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) ::std:: _Common_float_type_t<_Ty1, _Ty2> __cdecl pow(_Ty1 _Left, _Ty2 _Right) noexcept;



#line 11304 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#line 11305 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#line 11306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl log(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl log10(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl fmod(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl modf(float, float*) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl exp(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl frexp(float, int*) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl ldexp(float, int) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl asin(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sin(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sinh(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl acos(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl cos(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl cosh(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl atan(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl atan2(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl tan(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl tanh(float) throw();
#line 11324 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"










#line 11335 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 11338 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"







#line 11346 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


#line 11349 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



































































































































































































#line 11545 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl logb(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) int   __cdecl ilogb(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl scalbn(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl scalbln(float, long int) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl exp2(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl expm1(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl log2(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl log1p(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl acosh(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl asinh(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl atanh(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl hypot(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl cbrt(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl erf(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl erfc(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl lgamma(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl tgamma(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl copysign(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl nextafter(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl remainder(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl remquo(float, float, int *) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float __cdecl round(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long int      __cdecl lround(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long long int __cdecl llround(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float         __cdecl trunc(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float         __cdecl rint(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long int      __cdecl lrint(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long long int __cdecl llrint(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float         __cdecl nearbyint(float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float         __cdecl fdim(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float         __cdecl fma(float, float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float         __cdecl fmax(float, float) throw();
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float         __cdecl fmin(float, float) throw();
#line 11579 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float exp10(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float rsqrt(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float rcbrt(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float sinpi(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float cospi(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void sincospi(const float a, float *const sptr, float *const cptr);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void sincos(const float a, float *const sptr, float *const cptr);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float j0(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float j1(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float jn(const int n, const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float y0(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float y1(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float yn(const int n, const float a);

static inline __declspec(__device__) __declspec(__cudart_builtin__) float cyl_bessel_i0(const float a);

static inline __declspec(__device__) __declspec(__cudart_builtin__) float cyl_bessel_i1(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float erfinv(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float erfcinv(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float normcdfinv(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float normcdf(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float erfcx(const float a);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double copysign(const double a, const float b);

static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double copysign(const float a, const double b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned int min(const unsigned int a, const unsigned int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned int min(const int a, const unsigned int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned int min(const unsigned int a, const int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long int min(const long int a, const long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long int min(const unsigned long int a, const unsigned long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long int min(const long int a, const unsigned long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long int min(const unsigned long int a, const long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long long int min(const long long int a, const long long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long long int min(const unsigned long long int a, const unsigned long long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long long int min(const long long int a, const unsigned long long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long long int min(const unsigned long long int a, const long long int b);










static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float min(const float a, const float b);










static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double min(const double a, const double b);









static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double min(const float a, const double b);









static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double min(const double a, const float b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned int max(const unsigned int a, const unsigned int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned int max(const int a, const unsigned int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned int max(const unsigned int a, const int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long int max(const long int a, const long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long int max(const unsigned long int a, const unsigned long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long int max(const long int a, const unsigned long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long int max(const unsigned long int a, const long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long long int max(const long long int a, const long long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long long int max(const unsigned long long int a, const unsigned long long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long long int max(const long long int a, const unsigned long long int b);







static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) unsigned long long int max(const unsigned long long int a, const long long int b);










static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float max(const float a, const float b);










static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double max(const double a, const double b);









static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double max(const float a, const double b);









static inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double max(const double a, const float b);










extern "C"{
inline __declspec(__device__) void *__nv_aligned_device_malloc(size_t size, size_t align)
{
  __declspec(__device__) void *__nv_aligned_device_malloc_impl(size_t, size_t);
  return __nv_aligned_device_malloc_impl(size, align);
}
}
#line 11901 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"


















































































































































































































































































#line 12176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"



#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"


















#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 78 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 79 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"

























































#line 137 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"















































































































































































































































































#line 409 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
















#line 426 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 433 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool isinf(const long double a)
{

  return (__isinfl(a) != 0);


#line 440 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 442 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 449 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool isinf(const double a)
{

  return (__isinf(a) != 0);


#line 456 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 458 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 465 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) bool isinf(const float a)
{

  return (__isinff(a) != 0);


#line 472 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 474 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 481 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool isnan(const long double a)
{

  return (__isnanl(a) != 0);


#line 488 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 490 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 497 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool isnan(const double a)
{

  return (__isnan(a) != 0);


#line 504 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 506 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 513 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool isnan(const float a)
{

  return (__isnanf(a) != 0);


#line 520 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 522 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 529 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool isfinite(const long double a)
{

  return (__finitel(a) != 0);


#line 536 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 538 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 545 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool isfinite(const double a)
{

  return (__finite(a) != 0);


#line 552 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 554 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






#line 561 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
static __inline __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) bool isfinite(const float a)
{

  return (__finitef(a) != 0);


#line 568 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
}
#line 570 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"

#line 572 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"




#line 577 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"


#line 580 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
















































































































































































#line 757 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"

static inline __declspec(__host__) __declspec(__device__) float exp10(const float a)
{
  return exp10f(a);
}

static inline __declspec(__host__) __declspec(__device__) float rsqrt(const float a)
{
  return rsqrtf(a);
}

static inline __declspec(__host__) __declspec(__device__) float rcbrt(const float a)
{
  return rcbrtf(a);
}

static inline __declspec(__host__) __declspec(__device__) float sinpi(const float a)
{
  return sinpif(a);
}

static inline __declspec(__host__) __declspec(__device__) float cospi(const float a)
{
  return cospif(a);
}

static inline __declspec(__host__) __declspec(__device__) void sincospi(const float a, float *const sptr, float *const cptr)
{
  sincospif(a, sptr, cptr);
}

static inline __declspec(__host__) __declspec(__device__) void sincos(const float a, float *const sptr, float *const cptr)
{
  sincosf(a, sptr, cptr);
}

static inline __declspec(__host__) __declspec(__device__) float j0(const float a)
{
  return j0f(a);
}

static inline __declspec(__host__) __declspec(__device__) float j1(const float a)
{
  return j1f(a);
}

static inline __declspec(__host__) __declspec(__device__) float jn(const int n, const float a)
{
  return jnf(n, a);
}

static inline __declspec(__host__) __declspec(__device__) float y0(const float a)
{
  return y0f(a);
}

static inline __declspec(__host__) __declspec(__device__) float y1(const float a)
{
  return y1f(a);
}

static inline __declspec(__host__) __declspec(__device__) float yn(const int n, const float a)
{ 
  return ynf(n, a);
}

static inline __declspec(__device__) float cyl_bessel_i0(const float a)
{
  return cyl_bessel_i0f(a);
}

static inline __declspec(__device__) float cyl_bessel_i1(const float a)
{
  return cyl_bessel_i1f(a);
}

static inline __declspec(__host__) __declspec(__device__) float erfinv(const float a)
{
  return erfinvf(a);
}

static inline __declspec(__host__) __declspec(__device__) float erfcinv(const float a)
{
  return erfcinvf(a);
}

static inline __declspec(__host__) __declspec(__device__) float normcdfinv(const float a)
{
  return normcdfinvf(a);
}

static inline __declspec(__host__) __declspec(__device__) float normcdf(const float a)
{
  return normcdff(a);
}

static inline __declspec(__host__) __declspec(__device__) float erfcx(const float a)
{
  return erfcxf(a);
}

static inline __declspec(__host__) __declspec(__device__) double copysign(const double a, const float b)
{
  return copysign(a, static_cast<double>(b));
}

static inline __declspec(__host__) __declspec(__device__) double copysign(const float a, const double b)
{
  return copysign(static_cast<double>(a), b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned int min(const unsigned int a, const unsigned int b)
{
  return umin(a, b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned int min(const int a, const unsigned int b)
{
  return umin(static_cast<unsigned int>(a), b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned int min(const unsigned int a, const int b)
{
  return umin(a, static_cast<unsigned int>(b));
}

static inline __declspec(__host__) __declspec(__device__) long int min(const long int a, const long int b)
{
  long int retval;
  


#line 890 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
  
  if (sizeof(long int) == sizeof(int)) {


#line 895 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
    retval = static_cast<long int>(min(static_cast<int>(a), static_cast<int>(b)));
  } else {
    retval = static_cast<long int>(llmin(static_cast<long long int>(a), static_cast<long long int>(b)));
  }
  return retval;
}

static inline __declspec(__host__) __declspec(__device__) unsigned long int min(const unsigned long int a, const unsigned long int b)
{
  unsigned long int retval;


#line 908 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
  if (sizeof(unsigned long int) == sizeof(unsigned int)) {


#line 912 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
    retval = static_cast<unsigned long int>(umin(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmin(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __declspec(__host__) __declspec(__device__) unsigned long int min(const long int a, const unsigned long int b)
{
  unsigned long int retval;


#line 925 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
  if (sizeof(unsigned long int) == sizeof(unsigned int)) {


#line 929 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
    retval = static_cast<unsigned long int>(umin(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmin(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __declspec(__host__) __declspec(__device__) unsigned long int min(const unsigned long int a, const long int b)
{
  unsigned long int retval;


#line 942 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
  if (sizeof(unsigned long int) == sizeof(unsigned int)) {


#line 946 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
    retval = static_cast<unsigned long int>(umin(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmin(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __declspec(__host__) __declspec(__device__) long long int min(const long long int a, const long long int b)
{
  return llmin(a, b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned long long int min(const unsigned long long int a, const unsigned long long int b)
{
  return ullmin(a, b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned long long int min(const long long int a, const unsigned long long int b)
{
  return ullmin(static_cast<unsigned long long int>(a), b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned long long int min(const unsigned long long int a, const long long int b)
{
  return ullmin(a, static_cast<unsigned long long int>(b));
}

static inline __declspec(__host__) __declspec(__device__) float min(const float a, const float b)
{
  return fminf(a, b);
}

static inline __declspec(__host__) __declspec(__device__) double min(const double a, const double b)
{
  return fmin(a, b);
}

static inline __declspec(__host__) __declspec(__device__) double min(const float a, const double b)
{
  return fmin(static_cast<double>(a), b);
}

static inline __declspec(__host__) __declspec(__device__) double min(const double a, const float b)
{
  return fmin(a, static_cast<double>(b));
}

static inline __declspec(__host__) __declspec(__device__) unsigned int max(const unsigned int a, const unsigned int b)
{
  return umax(a, b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned int max(const int a, const unsigned int b)
{
  return umax(static_cast<unsigned int>(a), b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned int max(const unsigned int a, const int b)
{
  return umax(a, static_cast<unsigned int>(b));
}

static inline __declspec(__host__) __declspec(__device__) long int max(const long int a, const long int b)
{
  long int retval;
  


#line 1015 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
  if (sizeof(long int) == sizeof(int)) {


#line 1019 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
    retval = static_cast<long int>(max(static_cast<int>(a), static_cast<int>(b)));
  } else {
    retval = static_cast<long int>(llmax(static_cast<long long int>(a), static_cast<long long int>(b)));
  }
  return retval;
}

static inline __declspec(__host__) __declspec(__device__) unsigned long int max(const unsigned long int a, const unsigned long int b)
{
  unsigned long int retval;


#line 1032 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
  if (sizeof(unsigned long int) == sizeof(unsigned int)) {


#line 1036 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
    retval = static_cast<unsigned long int>(umax(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmax(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __declspec(__host__) __declspec(__device__) unsigned long int max(const long int a, const unsigned long int b)
{
  unsigned long int retval;


#line 1049 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
  if (sizeof(unsigned long int) == sizeof(unsigned int)) {


#line 1053 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
    retval = static_cast<unsigned long int>(umax(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmax(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __declspec(__host__) __declspec(__device__) unsigned long int max(const unsigned long int a, const long int b)
{
  unsigned long int retval;


#line 1066 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
  if (sizeof(unsigned long int) == sizeof(unsigned int)) {


#line 1070 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
    retval = static_cast<unsigned long int>(umax(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmax(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __declspec(__host__) __declspec(__device__) long long int max(const long long int a, const long long int b)
{
  return llmax(a, b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned long long int max(const unsigned long long int a, const unsigned long long int b)
{
  return ullmax(a, b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned long long int max(const long long int a, const unsigned long long int b)
{
  return ullmax(static_cast<unsigned long long int>(a), b);
}

static inline __declspec(__host__) __declspec(__device__) unsigned long long int max(const unsigned long long int a, const long long int b)
{
  return ullmax(a, static_cast<unsigned long long int>(b));
}

static inline __declspec(__host__) __declspec(__device__) float max(const float a, const float b)
{
  return fmaxf(a, b);
}

static inline __declspec(__host__) __declspec(__device__) double max(const double a, const double b)
{
  return fmax(a, b);
}

static inline __declspec(__host__) __declspec(__device__) double max(const float a, const double b)
{
  return fmax(static_cast<double>(a), b);
}

static inline __declspec(__host__) __declspec(__device__) double max(const double a, const float b)
{
  return fmax(a, static_cast<double>(b));
}


























































#line 1175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"










#line 1186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3385 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"

#line 3387 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"




#line 3392 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.hpp"
#line 12180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

#line 12182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"

#line 12184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"




#line 12189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\math_functions.h"
#line 304 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"

#line 306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"




#line 311 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/common_functions.h"
#line 116 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"






























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"


















































































































































































































































































































































































































































































































































































































#line 596 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"

#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 67 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"







template<class T, int dim = 1>
struct __declspec(__device_builtin_surface_type__) surface : public surfaceReference
{

  __declspec(__host__) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<T>();
  }

  __declspec(__host__) surface(struct cudaChannelFormatDesc desc)
  {
    channelDesc = desc;
  }
#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"
};

template<int dim>
struct  __declspec(__device_builtin_surface_type__)  surface<void, dim> : public surfaceReference
{

  __declspec(__host__) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<void>();
  }
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"
};

#line 102 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"

#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"
#line 117 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"






























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"


















































































































































































































































































































































































































































































































































































































#line 596 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\channel_descriptor.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"

#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 67 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"







template<class T, int texType = 0x01, enum cudaTextureReadMode mode = cudaReadModeElementType>
struct __declspec(__device_builtin_texture_type__) texture : public textureReference
{

  __declspec(__host__) texture(int                         norm  = 0,
                   enum cudaTextureFilterMode  fMode = cudaFilterModePoint,
                   enum cudaTextureAddressMode aMode = cudaAddressModeClamp)
  {
    normalized     = norm;
    filterMode     = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc    = cudaCreateChannelDesc<T>();
    sRGB           = 0;
  }

  __declspec(__host__) texture(int                          norm,
                   enum cudaTextureFilterMode   fMode,
                   enum cudaTextureAddressMode  aMode,
                   struct cudaChannelFormatDesc desc)
  {
    normalized     = norm;
    filterMode     = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc    = desc;
    sRGB           = 0;
  }
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"
};

#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"

#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"
#line 118 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"















#line 75 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"


#line 78 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"

#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"







extern "C"
{









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __mulhi(int x, int y);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __umulhi(unsigned int x, unsigned int y);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) long long int          __mul64hi(long long int x, long long int y);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned long long int __umul64hi(unsigned long long int x, unsigned long long int y);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __int_as_float(int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __float_as_int(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __uint_as_float(unsigned int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __float_as_uint(float x);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) void                   __syncthreads(void);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) void                   __prof_trigger(int);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) void                   __threadfence(void);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) void                   __threadfence_block(void);
__declspec(__device__) __declspec(__cudart_builtin__) 


#line 175 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
__declspec(noreturn)
#line 177 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
__declspec(__device_builtin__) void                   __trap(void);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) void                   __brkpt();






















__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __saturatef(float x);




































































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __sad(int x, int y, unsigned int z);



































































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __usad(unsigned int x, unsigned int y, unsigned int z);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __mul24(int x, int y);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __umul24(unsigned int x, unsigned int y);












__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  fdividef(float x, float y);








































































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fdividef(float x, float y);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) double                 fdivide(double x, double y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __sinf(float x) ;










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __cosf(float x) ;












__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __tanf(float x) ;














__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void                   __sincosf(float x, float *sptr, float *cptr) ;
















































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __expf(float x) ;






























__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __exp10f(float x) ;
























__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __log2f(float x) ;


























__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __log10f(float x) ;










































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __logf(float x) ;









































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __powf(float x, float y) ;








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __float2int_rn(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __float2int_rz(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __float2int_ru(float);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __float2int_rd(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __float2uint_rn(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __float2uint_rz(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __float2uint_ru(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __float2uint_rd(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __int2float_rn(int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __int2float_rz(int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __int2float_ru(int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __int2float_rd(int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __uint2float_rn(unsigned int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __uint2float_rz(unsigned int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __uint2float_ru(unsigned int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __uint2float_rd(unsigned int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) long long int          __float2ll_rn(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) long long int          __float2ll_rz(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) long long int          __float2ll_ru(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) long long int          __float2ll_rd(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned long long int __float2ull_rn(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned long long int __float2ull_rz(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned long long int __float2ull_ru(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned long long int __float2ull_rd(float x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __ll2float_rn(long long int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __ll2float_rz(long long int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __ll2float_ru(long long int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __ll2float_rd(long long int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __ull2float_rn(unsigned long long int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __ull2float_rz(unsigned long long int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __ull2float_ru(unsigned long long int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __ull2float_rd(unsigned long long int x);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fadd_rn(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fadd_rz(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fadd_ru(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fadd_rd(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fsub_rn(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fsub_rz(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fsub_ru(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fsub_rd(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fmul_rn(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fmul_rz(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fmul_ru(float x, float y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fmul_rd(float x, float y);
























































































































































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fmaf_rn(float x, float y, float z);
























































































































































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fmaf_rz(float x, float y, float z);
























































































































































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fmaf_ru(float x, float y, float z);
























































































































































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fmaf_rd(float x, float y, float z);
































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __frcp_rn(float x);
































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __frcp_rz(float x);
































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __frcp_ru(float x);
































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __frcp_rd(float x);






























__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fsqrt_rn(float x);






























__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fsqrt_rz(float x);






























__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fsqrt_ru(float x);






























__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fsqrt_rd(float x);






































__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __frsqrt_rn(float x);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fdiv_rn(float x, float y);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fdiv_rz(float x, float y);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fdiv_ru(float x, float y);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) float                  __fdiv_rd(float x, float y);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __clz(int x);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __ffs(int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __popc(unsigned int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __brev(unsigned int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __clzll(long long int x);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __ffsll(long long int x);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __popcll(unsigned long long int x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned long long int __brevll(unsigned long long int x);























__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __byte_perm(unsigned int x, unsigned int y, unsigned int s);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __hadd(int x, int y);












__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __rhadd(int x, int y);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __uhadd(unsigned int x, unsigned int y);












__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __urhadd(unsigned int x, unsigned int y);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) int                    __double2int_rz(double x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __double2uint_rz(double x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) long long int          __double2ll_rz(double x);








__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned long long int __double2ull_rz(double x);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __pm0(void);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __pm1(void);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __pm2(void);
__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int           __pm3(void);







 

















__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vabs2(unsigned int a);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vabsss2(unsigned int a);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vadd2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vaddss2 (unsigned int a, unsigned int b);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vaddus2 (unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vavgs2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vavgu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vhaddu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpeq2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpges2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpgeu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpgts2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpgtu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmples2(unsigned int a, unsigned int b);











__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpleu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmplts2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpltu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpne2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vabsdiffu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vmaxs2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vmaxu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vmins2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vminu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vseteq2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetges2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetgeu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetgts2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetgtu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetles2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetleu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetlts2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetltu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetne2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsadu2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsub2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsubss2 (unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsubus2 (unsigned int a, unsigned int b);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vneg2(unsigned int a);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vnegss2(unsigned int a);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vabsdiffs2(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsads2(unsigned int a, unsigned int b);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vabs4(unsigned int a);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vabsss4(unsigned int a);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vadd4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vaddss4 (unsigned int a, unsigned int b);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vaddus4 (unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vavgs4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vavgu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vhaddu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpeq4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpges4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpgeu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpgts4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpgtu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmples4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpleu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmplts4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpltu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vcmpne4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vabsdiffu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vmaxs4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vmaxu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vmins4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vminu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vseteq4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetles4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetleu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetlts4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetltu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetges4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetgeu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetgts4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetgtu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsetne4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsadu4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsub4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsubss4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsubus4(unsigned int a, unsigned int b);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vneg4(unsigned int a);









__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vnegss4(unsigned int a);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vabsdiffs4(unsigned int a, unsigned int b);










__declspec(__device__) __declspec(__cudart_builtin__) __declspec(__device_builtin__) unsigned int __vsads4(unsigned int a, unsigned int b);






}













#line 3222 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"







static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mulhi" "() is deprecated in favor of __" "mulhi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) int mulhi(const int a, const int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mulhi" "() is deprecated in favor of __" "mulhi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned int mulhi(const unsigned int a, const unsigned int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mulhi" "() is deprecated in favor of __" "mulhi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned int mulhi(const int a, const unsigned int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mulhi" "() is deprecated in favor of __" "mulhi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned int mulhi(const unsigned int a, const int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mul64hi" "() is deprecated in favor of __" "mul64hi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) long long int mul64hi(const long long int a, const long long int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mul64hi" "() is deprecated in favor of __" "mul64hi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned long long int mul64hi(const unsigned long long int a, const unsigned long long int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mul64hi" "() is deprecated in favor of __" "mul64hi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned long long int mul64hi(const long long int a, const unsigned long long int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mul64hi" "() is deprecated in favor of __" "mul64hi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned long long int mul64hi(const unsigned long long int a, const long long int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("float_as_int" "() is deprecated in favor of __" "float_as_int" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) int float_as_int(const float a);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("int_as_float" "() is deprecated in favor of __" "int_as_float" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) float int_as_float(const int a);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("float_as_uint" "() is deprecated in favor of __" "float_as_uint" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned int float_as_uint(const float a);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("uint_as_float" "() is deprecated in favor of __" "uint_as_float" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) float uint_as_float(const unsigned int a);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("saturate" "() is deprecated in favor of __" "saturate" "f" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) float saturate(const float a);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("mul24" "() is deprecated in favor of __" "mul24" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) int mul24(const int a, const int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("umul24" "() is deprecated in favor of __" "umul24" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned int umul24(const unsigned int a, const unsigned int b);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("float2int" "() is deprecated in favor of __" "float2int" "_ru|_rd|_rn|_rz" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) int float2int(const float a, const enum cudaRoundMode mode = cudaRoundZero);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("float2uint" "() is deprecated in favor of __" "float2uint" "_ru|_rd|_rn|_rz" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) unsigned int float2uint(const float a, const enum cudaRoundMode mode = cudaRoundZero);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("int2float" "() is deprecated in favor of __" "int2float" "_ru|_rd|_rn|_rz" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) float int2float(const int a, const enum cudaRoundMode mode = cudaRoundNearest);

static __inline __declspec(__device__) __declspec(__cudart_builtin__) __declspec(deprecated("uint2float" "() is deprecated in favor of __" "uint2float" "_ru|_rd|_rn|_rz" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning).")) float uint2float(const unsigned int a, const enum cudaRoundMode mode = cudaRoundNearest);










#line 3277 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"








#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"















#line 75 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"


#line 78 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"

#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"








static __inline __declspec(__device__) int mulhi(const int a, const int b)
{
  return __mulhi(a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(const unsigned int a, const unsigned int b)
{
  return __umulhi(a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(const int a, const unsigned int b)
{
  return __umulhi(static_cast<unsigned int>(a), b);
}

static __inline __declspec(__device__) unsigned int mulhi(const unsigned int a, const int b)
{
  return __umulhi(a, static_cast<unsigned int>(b));
}

static __inline __declspec(__device__) long long int mul64hi(const long long int a, const long long int b)
{
  return __mul64hi(a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(const unsigned long long int a, const unsigned long long int b)
{
  return __umul64hi(a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(const long long int a, const unsigned long long int b)
{
  return __umul64hi(static_cast<unsigned long long int>(a), b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(const unsigned long long int a, const long long int b)
{
  return __umul64hi(a, static_cast<unsigned long long int>(b));
}

static __inline __declspec(__device__) int float_as_int(const float a)
{
  return __float_as_int(a);
}

static __inline __declspec(__device__) float int_as_float(const int a)
{
  return __int_as_float(a);
}

static __inline __declspec(__device__) unsigned int float_as_uint(const float a)
{
  return __float_as_uint(a);
}

static __inline __declspec(__device__) float uint_as_float(const unsigned int a)
{
  return __uint_as_float(a);
}
static __inline __declspec(__device__) float saturate(const float a)
{
  return __saturatef(a);
}

static __inline __declspec(__device__) int mul24(const int a, const int b)
{
  return __mul24(a, b);
}

static __inline __declspec(__device__) unsigned int umul24(const unsigned int a, const unsigned int b)
{
  return __umul24(a, b);
}

static __inline __declspec(__device__) int float2int(const float a, const enum cudaRoundMode mode)
{
  return (mode == cudaRoundNearest) ? __float2int_rn(a) :
         (mode == cudaRoundPosInf ) ? __float2int_ru(a) :
         (mode == cudaRoundMinInf ) ? __float2int_rd(a) :
                                      __float2int_rz(a);
}

static __inline __declspec(__device__) unsigned int float2uint(const float a, const enum cudaRoundMode mode)
{
  return (mode == cudaRoundNearest) ? __float2uint_rn(a) :
         (mode == cudaRoundPosInf ) ? __float2uint_ru(a) :
         (mode == cudaRoundMinInf ) ? __float2uint_rd(a) :
                                      __float2uint_rz(a);
}

static __inline __declspec(__device__) float int2float(const int a, const enum cudaRoundMode mode)
{
  return (mode == cudaRoundZero  ) ? __int2float_rz(a) :
         (mode == cudaRoundPosInf) ? __int2float_ru(a) :
         (mode == cudaRoundMinInf) ? __int2float_rd(a) :
                                     __int2float_rn(a);
}

static __inline __declspec(__device__) float uint2float(const unsigned int a, const enum cudaRoundMode mode)
{
  return (mode == cudaRoundZero  ) ? __uint2float_rz(a) :
         (mode == cudaRoundPosInf) ? __uint2float_ru(a) :
         (mode == cudaRoundMinInf) ? __uint2float_rd(a) :
                                     __uint2float_rn(a);
}




#line 200 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"







#line 208 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"




#line 213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_functions.hpp"
#line 3286 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 3287 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"

#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"









#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"





#line 74 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"


extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicAdd(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicAdd(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicExch(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicExch(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) float        __fAtomicExch(float *address, float val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicMin(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicMin(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicMax(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicMax(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicInc(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicDec(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicAnd(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicAnd(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicOr(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicOr(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicXor(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicXor(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicCAS(int *address, int compare, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicCAS(unsigned int *address, unsigned int compare, unsigned int val);
}
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"







static __inline __declspec(__device__) int atomicAdd(int *address, int val) ;

static __inline __declspec(__device__) unsigned int atomicAdd(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) int atomicSub(int *address, int val) ;

static __inline __declspec(__device__) unsigned int atomicSub(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) int atomicExch(int *address, int val) ;

static __inline __declspec(__device__) unsigned int atomicExch(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) float atomicExch(float *address, float val) ;

static __inline __declspec(__device__) int atomicMin(int *address, int val) ;

static __inline __declspec(__device__) unsigned int atomicMin(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) int atomicMax(int *address, int val) ;

static __inline __declspec(__device__) unsigned int atomicMax(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) unsigned int atomicInc(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) unsigned int atomicDec(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) int atomicAnd(int *address, int val) ;

static __inline __declspec(__device__) unsigned int atomicAnd(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) int atomicOr(int *address, int val) ;

static __inline __declspec(__device__) unsigned int atomicOr(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) int atomicXor(int *address, int val) ;

static __inline __declspec(__device__) unsigned int atomicXor(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__) int atomicCAS(int *address, int compare, int val) ;

static __inline __declspec(__device__) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val) ;







#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"







#line 163 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"






#line 170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"

extern "C"
{

extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicAdd(unsigned long long int *address, unsigned long long int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicExch(unsigned long long int *address, unsigned long long int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val);
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
extern __declspec(__device__) __declspec(__device_builtin__) __declspec(deprecated("__any""() is not valid on compute_70 and above, and should be replaced with ""__any""_sync()." "To continue using ""__any""(), specify virtual architecture compute_60 when targeting sm_70 and above, for example, using the pair of compiler options: -arch=compute_60 -code=sm_70.")) int __any(int cond);
extern __declspec(__device__) __declspec(__device_builtin__) __declspec(deprecated("__all""() is not valid on compute_70 and above, and should be replaced with ""__all""_sync()." "To continue using ""__all""(), specify virtual architecture compute_60 when targeting sm_70 and above, for example, using the pair of compiler options: -arch=compute_60 -code=sm_70.")) int __all(int cond);
}








static __inline __declspec(__device__) unsigned long long int atomicAdd(unsigned long long int *address, unsigned long long int val) ;

static __inline __declspec(__device__) unsigned long long int atomicExch(unsigned long long int *address, unsigned long long int val) ;

static __inline __declspec(__device__) unsigned long long int atomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val) ;

static __inline __declspec(__device__) __declspec(deprecated("__any""() is not valid on compute_70 and above, and should be replaced with ""__any""_sync()." "To continue using ""__any""(), specify virtual architecture compute_60 when targeting sm_70 and above, for example, using the pair of compiler options: -arch=compute_60 -code=sm_70.")) bool any(bool cond) ;

static __inline __declspec(__device__) __declspec(deprecated("__all""() is not valid on compute_70 and above, and should be replaced with ""__all""_sync()." "To continue using ""__all""(), specify virtual architecture compute_60 when targeting sm_70 and above, for example, using the pair of compiler options: -arch=compute_60 -code=sm_70.")) bool all(bool cond) ;




#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.hpp"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.hpp"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.hpp"









#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.hpp"







static __inline __declspec(__device__) int atomicAdd(int *address, int val)
{
  return __iAtomicAdd(address, val);
}

static __inline __declspec(__device__) unsigned int atomicAdd(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, val);
}

static __inline __declspec(__device__) int atomicSub(int *address, int val)
{
  return __iAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__) unsigned int atomicSub(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__) int atomicExch(int *address, int val)
{
  return __iAtomicExch(address, val);
}

static __inline __declspec(__device__) unsigned int atomicExch(unsigned int *address, unsigned int val)
{
  return __uAtomicExch(address, val);
}

static __inline __declspec(__device__) float atomicExch(float *address, float val)
{
  return __fAtomicExch(address, val);
}

static __inline __declspec(__device__) int atomicMin(int *address, int val)
{
  return __iAtomicMin(address, val);
}

static __inline __declspec(__device__) unsigned int atomicMin(unsigned int *address, unsigned int val)
{
  return __uAtomicMin(address, val);
}

static __inline __declspec(__device__) int atomicMax(int *address, int val)
{
  return __iAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned int atomicMax(unsigned int *address, unsigned int val)
{
  return __uAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned int atomicInc(unsigned int *address, unsigned int val)
{
  return __uAtomicInc(address, val);
}

static __inline __declspec(__device__) unsigned int atomicDec(unsigned int *address, unsigned int val)
{
  return __uAtomicDec(address, val);
}

static __inline __declspec(__device__) int atomicAnd(int *address, int val)
{
  return __iAtomicAnd(address, val);
}

static __inline __declspec(__device__) unsigned int atomicAnd(unsigned int *address, unsigned int val)
{
  return __uAtomicAnd(address, val);
}

static __inline __declspec(__device__) int atomicOr(int *address, int val)
{
  return __iAtomicOr(address, val);
}

static __inline __declspec(__device__) unsigned int atomicOr(unsigned int *address, unsigned int val)
{
  return __uAtomicOr(address, val);
}

static __inline __declspec(__device__) int atomicXor(int *address, int val)
{
  return __iAtomicXor(address, val);
}

static __inline __declspec(__device__) unsigned int atomicXor(unsigned int *address, unsigned int val)
{
  return __uAtomicXor(address, val);
}

static __inline __declspec(__device__) int atomicCAS(int *address, int compare, int val)
{
  return __iAtomicCAS(address, compare, val);
}

static __inline __declspec(__device__) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val)
{
  return __uAtomicCAS(address, compare, val);
}







#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.hpp"







static __inline __declspec(__device__) unsigned long long int atomicAdd(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicAdd(address, val);
}

static __inline __declspec(__device__) unsigned long long int atomicExch(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicExch(address, val);
}

static __inline __declspec(__device__) unsigned long long int atomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val)
{
  return __ullAtomicCAS(address, compare, val);
}

static __inline __declspec(__device__) bool any(bool cond)
{
  return (bool)__any((int)cond);
}

static __inline __declspec(__device__) bool all(bool cond)
{
  return (bool)__all((int)cond);
}

#line 220 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.hpp"



#line 224 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.hpp"

#line 209 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
#line 210 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"

#line 212 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_atomic_functions.h"
#line 3289 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"




















#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"

#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"

#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 84 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 85 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 86 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"

extern "C"
{








extern __declspec(__device__) __declspec(__device_builtin__) long long int         __double_as_longlong(double x);








extern __declspec(__device__) __declspec(__device_builtin__) double                __longlong_as_double(long long int x);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rn(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rz(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_ru(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rd(double x, double y, double z);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rz(double x, double y);










 
extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rd(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rz(double x, double y);










 
extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rd(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rz(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rd(double x, double y);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rz(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rd(double x);







extern __declspec(__device__) __declspec(__device_builtin__) double                 __int2double_rn(int x);







extern __declspec(__device__) __declspec(__device_builtin__) double                 __uint2double_rn(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rn(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rz(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_ru(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rd(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rn(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rz(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_ru(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rd(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2hiint(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2loint(double x);









extern __declspec(__device__) __declspec(__device_builtin__) double                 __hiloint2double(int hi, int lo);
}







static __inline __declspec(__device__) double fma(double a, double b, double c, enum cudaRoundMode mode);

static __inline __declspec(__device__) double dmul(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline __declspec(__device__) double dadd(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline __declspec(__device__) double dsub(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline __declspec(__device__) int double2int(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline __declspec(__device__) unsigned int double2uint(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline __declspec(__device__) long long int double2ll(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline __declspec(__device__) unsigned long long int double2ull(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline __declspec(__device__) double ll2double(long long int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline __declspec(__device__) double ull2double(unsigned long long int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline __declspec(__device__) double int2double(int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline __declspec(__device__) double uint2double(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline __declspec(__device__) double float2double(float a, enum cudaRoundMode mode = cudaRoundNearest);



#line 1176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"




















#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"

#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"

#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 84 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 85 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 86 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"







static __inline __declspec(__device__) double fma(double a, double b, double c, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero   ? __fma_rz(a, b, c) :
         mode == cudaRoundPosInf ? __fma_ru(a, b, c) :
         mode == cudaRoundMinInf ? __fma_rd(a, b, c) :
                                   __fma_rn(a, b, c);
}

static __inline __declspec(__device__) double dmul(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero   ? __dmul_rz(a, b) :
         mode == cudaRoundPosInf ? __dmul_ru(a, b) :
         mode == cudaRoundMinInf ? __dmul_rd(a, b) :
                                   __dmul_rn(a, b);
}

static __inline __declspec(__device__) double dadd(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero   ? __dadd_rz(a, b) :
         mode == cudaRoundPosInf ? __dadd_ru(a, b) :
         mode == cudaRoundMinInf ? __dadd_rd(a, b) :
                                   __dadd_rn(a, b);
}

static __inline __declspec(__device__) double dsub(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero   ? __dsub_rz(a, b) :
         mode == cudaRoundPosInf ? __dsub_ru(a, b) :
         mode == cudaRoundMinInf ? __dsub_rd(a, b) :
                                   __dsub_rn(a, b);
}

static __inline __declspec(__device__) int double2int(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2int_rn(a) :
         mode == cudaRoundPosInf  ? __double2int_ru(a) :
         mode == cudaRoundMinInf  ? __double2int_rd(a) :
                                    __double2int_rz(a);
}

static __inline __declspec(__device__) unsigned int double2uint(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2uint_rn(a) :
         mode == cudaRoundPosInf  ? __double2uint_ru(a) :
         mode == cudaRoundMinInf  ? __double2uint_rd(a) :
                                    __double2uint_rz(a);
}

static __inline __declspec(__device__) long long int double2ll(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2ll_rn(a) :
         mode == cudaRoundPosInf  ? __double2ll_ru(a) :
         mode == cudaRoundMinInf  ? __double2ll_rd(a) :
                                    __double2ll_rz(a);
}

static __inline __declspec(__device__) unsigned long long int double2ull(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2ull_rn(a) :
         mode == cudaRoundPosInf  ? __double2ull_ru(a) :
         mode == cudaRoundMinInf  ? __double2ull_rd(a) :
                                    __double2ull_rz(a);
}

static __inline __declspec(__device__) double ll2double(long long int a, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero   ? __ll2double_rz(a) :
         mode == cudaRoundPosInf ? __ll2double_ru(a) :
         mode == cudaRoundMinInf ? __ll2double_rd(a) :
                                   __ll2double_rn(a);
}

static __inline __declspec(__device__) double ull2double(unsigned long long int a, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero   ? __ull2double_rz(a) :
         mode == cudaRoundPosInf ? __ull2double_ru(a) :
         mode == cudaRoundMinInf ? __ull2double_rd(a) :
                                   __ull2double_rn(a);
}

static __inline __declspec(__device__) double int2double(int a, enum cudaRoundMode mode)
{
  return (double)a;
}

static __inline __declspec(__device__) double uint2double(unsigned int a, enum cudaRoundMode mode)
{
  return (double)a;
}

static __inline __declspec(__device__) double float2double(float a, enum cudaRoundMode mode)
{
  return (double)a;
}



#line 191 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"

#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"




#line 198 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.hpp"
#line 1179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"
#line 1180 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"

#line 1182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"




#line 1187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\device_double_functions.h"
#line 3290 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"









#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"





#line 74 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"



extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) float __fAtomicAdd(float *address, float val);
}
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"







static __inline __declspec(__device__) float atomicAdd(float *address, float val) ;

#line 92 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.hpp"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.hpp"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.hpp"









#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.hpp"







static __inline __declspec(__device__) float atomicAdd(float *address, float val)
{
  return __fAtomicAdd(address, val);
}

#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.hpp"



#line 85 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.hpp"

#line 98 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"
#line 99 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"

#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_atomic_functions.h"
#line 3291 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"





#line 76 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"



extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) long long __illAtomicMin(long long *address, long long val);
extern __declspec(__device__) __declspec(__device_builtin__) long long __illAtomicMax(long long *address, long long val);
extern __declspec(__device__) __declspec(__device_builtin__) long long __llAtomicAnd(long long *address, long long val);
extern __declspec(__device__) __declspec(__device_builtin__) long long __llAtomicOr(long long *address, long long val);
extern __declspec(__device__) __declspec(__device_builtin__) long long __llAtomicXor(long long *address, long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicMin(unsigned long long *address, unsigned long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicMax(unsigned long long *address, unsigned long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicAnd(unsigned long long *address, unsigned long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicOr (unsigned long long *address, unsigned long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicXor(unsigned long long *address, unsigned long long val);
}
#line 93 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"







static __inline __declspec(__device__) long long atomicMin(long long *address, long long val) ;

static __inline __declspec(__device__) long long atomicMax(long long *address, long long val) ;

static __inline __declspec(__device__) long long atomicAnd(long long *address, long long val) ;

static __inline __declspec(__device__) long long atomicOr(long long *address, long long val) ;

static __inline __declspec(__device__) long long atomicXor(long long *address, long long val) ;

static __inline __declspec(__device__) unsigned long long atomicMin(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__) unsigned long long atomicMax(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__) unsigned long long atomicAnd(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__) unsigned long long atomicOr(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__) unsigned long long atomicXor(unsigned long long *address, unsigned long long val) ;

#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"

#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.hpp"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.hpp"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.hpp"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.hpp"







static __inline __declspec(__device__) long long atomicMin(long long *address, long long val)
{
    return __illAtomicMin(address, val);
}

static __inline __declspec(__device__) long long atomicMax(long long *address, long long val)
{
    return __illAtomicMax(address, val);
}

static __inline __declspec(__device__) long long atomicAnd(long long *address, long long val)
{
    return __llAtomicAnd(address, val);
}

static __inline __declspec(__device__) long long atomicOr(long long *address, long long val)
{
    return __llAtomicOr(address, val);
}

static __inline __declspec(__device__) long long atomicXor(long long *address, long long val)
{
    return __llAtomicXor(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicMin(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicMin(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicMax(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicAnd(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicAnd(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicOr(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicOr(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicXor(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicXor(address, val);
}

#line 128 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.hpp"

#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.hpp"



#line 134 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.hpp"

#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"

#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
#line 3292 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_35_atomic_functions.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"


































































































































#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_atomic_functions.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_35_atomic_functions.h"

#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_35_atomic_functions.h"
#line 3293 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"























































#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"

#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 71 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"





#line 77 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"




extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) double __dAtomicAdd(double *address, double val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicAdd_block(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicAdd_system(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicAdd_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicAdd_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicAdd_block(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicAdd_system(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
float __fAtomicAdd_block(float *address, float val);

extern __declspec(__device__) __declspec(__device_builtin__)
float __fAtomicAdd_system(float *address, float val);

extern __declspec(__device__) __declspec(__device_builtin__)
double __dAtomicAdd_block(double *address, double val);

extern __declspec(__device__) __declspec(__device_builtin__)
double __dAtomicAdd_system(double *address, double val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicExch_block(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicExch_system(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicExch_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicExch_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicExch_block(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicExch_system(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
float __fAtomicExch_block(float *address, float val);

extern __declspec(__device__) __declspec(__device_builtin__)
float __fAtomicExch_system(float *address, float val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicMin_block(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicMin_system(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __illAtomicMin_block(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __illAtomicMin_system(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicMin_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicMin_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicMin_block(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicMin_system(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicMax_block(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicMax_system(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __illAtomicMax_block(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __illAtomicMax_system(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicMax_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicMax_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicMax_block(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicMax_system(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicInc_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicInc_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicDec_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicDec_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicCAS_block(int *address, int compare, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicCAS_system(int *address, int compare, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicCAS_block(unsigned int *address, unsigned int compare,
                                unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicCAS_system(unsigned int *address, unsigned int compare,
                                 unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicCAS_block(unsigned long long int *address,
                                        unsigned long long int compare,
                                        unsigned long long int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicCAS_system(unsigned long long int *address,
                                         unsigned long long int compare,
                                         unsigned long long int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicAnd_block(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicAnd_system(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __llAtomicAnd_block(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __llAtomicAnd_system(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicAnd_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicAnd_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicAnd_block(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicAnd_system(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicOr_block(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicOr_system(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __llAtomicOr_block(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __llAtomicOr_system(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicOr_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicOr_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicOr_block(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicOr_system(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicXor_block(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
int __iAtomicXor_system(int *address, int val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __llAtomicXor_block(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
long long __llAtomicXor_system(long long *address, long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicXor_block(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned int __uAtomicXor_system(unsigned int *address, unsigned int val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicXor_block(unsigned long long *address, unsigned long long val);

extern __declspec(__device__) __declspec(__device_builtin__)
unsigned long long __ullAtomicXor_system(unsigned long long *address, unsigned long long val);
}
#line 296 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"







static __inline __declspec(__device__) double atomicAdd(double *address, double val) ;

static __inline __declspec(__device__)
int atomicAdd_block(int *address, int val) ;

static __inline __declspec(__device__)
int atomicAdd_system(int *address, int val) ;

static __inline __declspec(__device__)
unsigned int atomicAdd_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicAdd_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned long long atomicAdd_block(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
unsigned long long atomicAdd_system(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
float atomicAdd_block(float *address, float val) ;

static __inline __declspec(__device__)
float atomicAdd_system(float *address, float val) ;

static __inline __declspec(__device__)
double atomicAdd_block(double *address, double val) ;

static __inline __declspec(__device__)
double atomicAdd_system(double *address, double val) ;

static __inline __declspec(__device__)
int atomicSub_block(int *address, int val) ;

static __inline __declspec(__device__)
int atomicSub_system(int *address, int val) ;

static __inline __declspec(__device__)
unsigned int atomicSub_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicSub_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
int atomicExch_block(int *address, int val) ;

static __inline __declspec(__device__)
int atomicExch_system(int *address, int val) ;

static __inline __declspec(__device__)
unsigned int atomicExch_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicExch_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned long long atomicExch_block(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
unsigned long long atomicExch_system(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
float atomicExch_block(float *address, float val) ;

static __inline __declspec(__device__)
float atomicExch_system(float *address, float val) ;

static __inline __declspec(__device__)
int atomicMin_block(int *address, int val) ;

static __inline __declspec(__device__)
int atomicMin_system(int *address, int val) ;

static __inline __declspec(__device__)
long long atomicMin_block(long long *address, long long val) ;

static __inline __declspec(__device__)
long long atomicMin_system(long long *address, long long val) ;

static __inline __declspec(__device__)
unsigned int atomicMin_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicMin_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned long long atomicMin_block(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
unsigned long long atomicMin_system(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
int atomicMax_block(int *address, int val) ;

static __inline __declspec(__device__)
int atomicMax_system(int *address, int val) ;

static __inline __declspec(__device__)
long long atomicMax_block(long long *address, long long val) ;

static __inline __declspec(__device__)
long long atomicMax_system(long long *address, long long val) ;

static __inline __declspec(__device__)
unsigned int atomicMax_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicMax_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned long long atomicMax_block(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
unsigned long long atomicMax_system(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
unsigned int atomicInc_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicInc_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicDec_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicDec_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
int atomicCAS_block(int *address, int compare, int val) ;

static __inline __declspec(__device__)
int atomicCAS_system(int *address, int compare, int val) ;

static __inline __declspec(__device__)
unsigned int atomicCAS_block(unsigned int *address, unsigned int compare,
                             unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicCAS_system(unsigned int *address, unsigned int compare,
                              unsigned int val) ;

static __inline __declspec(__device__)
unsigned long long int atomicCAS_block(unsigned long long int *address,
                                       unsigned long long int compare,
                                       unsigned long long int val) ;

static __inline __declspec(__device__)
unsigned long long int atomicCAS_system(unsigned long long int *address,
                                        unsigned long long int compare,
                                        unsigned long long int val) ;

static __inline __declspec(__device__)
int atomicAnd_block(int *address, int val) ;

static __inline __declspec(__device__)
int atomicAnd_system(int *address, int val) ;

static __inline __declspec(__device__)
long long atomicAnd_block(long long *address, long long val) ;

static __inline __declspec(__device__)
long long atomicAnd_system(long long *address, long long val) ;

static __inline __declspec(__device__)
unsigned int atomicAnd_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicAnd_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned long long atomicAnd_block(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
unsigned long long atomicAnd_system(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
int atomicOr_block(int *address, int val) ;

static __inline __declspec(__device__)
int atomicOr_system(int *address, int val) ;

static __inline __declspec(__device__)
long long atomicOr_block(long long *address, long long val) ;

static __inline __declspec(__device__)
long long atomicOr_system(long long *address, long long val) ;

static __inline __declspec(__device__)
unsigned int atomicOr_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicOr_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned long long atomicOr_block(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
unsigned long long atomicOr_system(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
int atomicXor_block(int *address, int val) ;

static __inline __declspec(__device__)
int atomicXor_system(int *address, int val) ;

static __inline __declspec(__device__)
long long atomicXor_block(long long *address, long long val) ;

static __inline __declspec(__device__)
long long atomicXor_system(long long *address, long long val) ;

static __inline __declspec(__device__)
unsigned int atomicXor_block(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned int atomicXor_system(unsigned int *address, unsigned int val) ;

static __inline __declspec(__device__)
unsigned long long atomicXor_block(unsigned long long *address, unsigned long long val) ;

static __inline __declspec(__device__)
unsigned long long atomicXor_system(unsigned long long *address, unsigned long long val) ;

#line 528 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"

#line 530 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.hpp"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.hpp"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.hpp"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.hpp"







static __inline __declspec(__device__) double atomicAdd(double *address, double val)
{
  return __dAtomicAdd(address, val);
}

static __inline __declspec(__device__)
int atomicAdd_block(int *address, int val)
{
  return __iAtomicAdd_block(address, val);
}

static __inline __declspec(__device__)
int atomicAdd_system(int *address, int val)
{
  return __iAtomicAdd_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicAdd_block(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicAdd_system(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd_system(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicAdd_block(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicAdd_block(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicAdd_system(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicAdd_system(address, val);
}

static __inline __declspec(__device__)
float atomicAdd_block(float *address, float val)
{
  return __fAtomicAdd_block(address, val);
}

static __inline __declspec(__device__)
float atomicAdd_system(float *address, float val)
{
  return __fAtomicAdd_system(address, val);
}

static __inline __declspec(__device__)
double atomicAdd_block(double *address, double val)
{
  return __dAtomicAdd_block(address, val);
}

static __inline __declspec(__device__)
double atomicAdd_system(double *address, double val)
{
  return __dAtomicAdd_system(address, val);
}

static __inline __declspec(__device__)
int atomicSub_block(int *address, int val)
{
  return __iAtomicAdd_block(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__)
int atomicSub_system(int *address, int val)
{
  return __iAtomicAdd_system(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__)
unsigned int atomicSub_block(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd_block(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__)
unsigned int atomicSub_system(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd_system(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__)
int atomicExch_block(int *address, int val)
{
  return __iAtomicExch_block(address, val);
}

static __inline __declspec(__device__)
int atomicExch_system(int *address, int val)
{
  return __iAtomicExch_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicExch_block(unsigned int *address, unsigned int val)
{
  return __uAtomicExch_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicExch_system(unsigned int *address, unsigned int val)
{
  return __uAtomicExch_system(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicExch_block(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicExch_block(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicExch_system(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicExch_system(address, val);
}

static __inline __declspec(__device__)
float atomicExch_block(float *address, float val)
{
  return __fAtomicExch_block(address, val);
}

static __inline __declspec(__device__)
float atomicExch_system(float *address, float val)
{
  return __fAtomicExch_system(address, val);
}

static __inline __declspec(__device__)
int atomicMin_block(int *address, int val)
{
  return __iAtomicMin_block(address, val);
}

static __inline __declspec(__device__)
int atomicMin_system(int *address, int val)
{
  return __iAtomicMin_system(address, val);
}

static __inline __declspec(__device__)
long long atomicMin_block(long long *address, long long val)
{
  return __illAtomicMin_block(address, val);
}

static __inline __declspec(__device__)
long long atomicMin_system(long long *address, long long val)
{
  return __illAtomicMin_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicMin_block(unsigned int *address, unsigned int val)
{
  return __uAtomicMin_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicMin_system(unsigned int *address, unsigned int val)
{
  return __uAtomicMin_system(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicMin_block(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicMin_block(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicMin_system(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicMin_system(address, val);
}

static __inline __declspec(__device__)
int atomicMax_block(int *address, int val)
{
  return __iAtomicMax_block(address, val);
}

static __inline __declspec(__device__)
int atomicMax_system(int *address, int val)
{
  return __iAtomicMax_system(address, val);
}

static __inline __declspec(__device__)
long long atomicMax_block(long long *address, long long val)
{
  return __illAtomicMax_block(address, val);
}

static __inline __declspec(__device__)
long long atomicMax_system(long long *address, long long val)
{
  return __illAtomicMax_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicMax_block(unsigned int *address, unsigned int val)
{
  return __uAtomicMax_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicMax_system(unsigned int *address, unsigned int val)
{
  return __uAtomicMax_system(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicMax_block(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicMax_block(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicMax_system(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicMax_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicInc_block(unsigned int *address, unsigned int val)
{
  return __uAtomicInc_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicInc_system(unsigned int *address, unsigned int val)
{
  return __uAtomicInc_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicDec_block(unsigned int *address, unsigned int val)
{
  return __uAtomicDec_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicDec_system(unsigned int *address, unsigned int val)
{
  return __uAtomicDec_system(address, val);
}

static __inline __declspec(__device__)
int atomicCAS_block(int *address, int compare, int val)
{
  return __iAtomicCAS_block(address, compare, val);
}

static __inline __declspec(__device__)
int atomicCAS_system(int *address, int compare, int val)
{
  return __iAtomicCAS_system(address, compare, val);
}

static __inline __declspec(__device__)
unsigned int atomicCAS_block(unsigned int *address, unsigned int compare,
                             unsigned int val)
{
  return __uAtomicCAS_block(address, compare, val);
}

static __inline __declspec(__device__)
unsigned int atomicCAS_system(unsigned int *address, unsigned int compare,
                              unsigned int val)
{
  return __uAtomicCAS_system(address, compare, val);
}

static __inline __declspec(__device__)
unsigned long long int atomicCAS_block(unsigned long long int *address,
                                       unsigned long long int compare,
                                       unsigned long long int val)
{
  return __ullAtomicCAS_block(address, compare, val);
}

static __inline __declspec(__device__)
unsigned long long int atomicCAS_system(unsigned long long int *address,
                                        unsigned long long int compare,
                                        unsigned long long int val)
{
  return __ullAtomicCAS_system(address, compare, val);
}

static __inline __declspec(__device__)
int atomicAnd_block(int *address, int val)
{
  return __iAtomicAnd_block(address, val);
}

static __inline __declspec(__device__)
int atomicAnd_system(int *address, int val)
{
  return __iAtomicAnd_system(address, val);
}

static __inline __declspec(__device__)
long long atomicAnd_block(long long *address, long long val)
{
  return __llAtomicAnd_block(address, val);
}

static __inline __declspec(__device__)
long long atomicAnd_system(long long *address, long long val)
{
  return __llAtomicAnd_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicAnd_block(unsigned int *address, unsigned int val)
{
  return __uAtomicAnd_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicAnd_system(unsigned int *address, unsigned int val)
{
  return __uAtomicAnd_system(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicAnd_block(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicAnd_block(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicAnd_system(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicAnd_system(address, val);
}

static __inline __declspec(__device__)
int atomicOr_block(int *address, int val)
{
  return __iAtomicOr_block(address, val);
}

static __inline __declspec(__device__)
int atomicOr_system(int *address, int val)
{
  return __iAtomicOr_system(address, val);
}

static __inline __declspec(__device__)
long long atomicOr_block(long long *address, long long val)
{
  return __llAtomicOr_block(address, val);
}

static __inline __declspec(__device__)
long long atomicOr_system(long long *address, long long val)
{
  return __llAtomicOr_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicOr_block(unsigned int *address, unsigned int val)
{
  return __uAtomicOr_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicOr_system(unsigned int *address, unsigned int val)
{
  return __uAtomicOr_system(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicOr_block(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicOr_block(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicOr_system(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicOr_system(address, val);
}

static __inline __declspec(__device__)
int atomicXor_block(int *address, int val)
{
  return __iAtomicXor_block(address, val);
}

static __inline __declspec(__device__)
int atomicXor_system(int *address, int val)
{
  return __iAtomicXor_system(address, val);
}

static __inline __declspec(__device__)
long long atomicXor_block(long long *address, long long val)
{
  return __llAtomicXor_block(address, val);
}

static __inline __declspec(__device__)
long long atomicXor_system(long long *address, long long val)
{
  return __llAtomicXor_system(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicXor_block(unsigned int *address, unsigned int val)
{
  return __uAtomicXor_block(address, val);
}

static __inline __declspec(__device__)
unsigned int atomicXor_system(unsigned int *address, unsigned int val)
{
  return __uAtomicXor_system(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicXor_block(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicXor_block(address, val);
}

static __inline __declspec(__device__)
unsigned long long atomicXor_system(unsigned long long *address, unsigned long long val)
{
  return __ullAtomicXor_system(address, val);
}

#line 521 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.hpp"

#line 523 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.hpp"



#line 527 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.hpp"

#line 536 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"
#line 537 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"

#line 539 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_60_atomic_functions.h"

#line 3294 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"









#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"





#line 74 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"







#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"






#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) void                   __threadfence_system(void);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rz(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rd(double x, double y);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rn(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rz(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_ru(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rd(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rn(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rz(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_ru(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rd(double x);
extern __declspec(__device__) __declspec(__device_builtin__) __declspec(deprecated("__ballot""() is not valid on compute_70 and above, and should be replaced with ""__ballot""_sync()." "To continue using ""__ballot""(), specify virtual architecture compute_60 when targeting sm_70 and above, for example, using the pair of compiler options: -arch=compute_60 -code=sm_70.")) unsigned int __ballot(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_count(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_and(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_or(int);
extern __declspec(__device__) __declspec(__device_builtin__) long long int         clock64(void);









extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_ieee_rn(float x, float y, float z);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_ieee_rd(float x, float y, float z);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_ieee_ru(float x, float y, float z);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_ieee_rz(float x, float y, float z);












extern __declspec(__device__) __declspec(__device_builtin__) long long int         __double_as_longlong(double x);








extern __declspec(__device__) __declspec(__device_builtin__) double                __longlong_as_double(long long int x);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rn(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rz(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_ru(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rd(double x, double y, double z);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rz(double x, double y);










 
extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rd(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rz(double x, double y);










 
extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rd(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rz(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rd(double x, double y);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rz(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rd(double x);







extern __declspec(__device__) __declspec(__device_builtin__) double                 __int2double_rn(int x);







extern __declspec(__device__) __declspec(__device_builtin__) double                 __uint2double_rn(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rn(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rz(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_ru(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rd(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rn(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rz(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_ru(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rd(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2hiint(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2loint(double x);









extern __declspec(__device__) __declspec(__device_builtin__) double                 __hiloint2double(int hi, int lo);


}






static __inline __declspec(__device__) __declspec(deprecated("__ballot""() is not valid on compute_70 and above, and should be replaced with ""__ballot""_sync()." "To continue using ""__ballot""(), specify virtual architecture compute_60 when targeting sm_70 and above, for example, using the pair of compiler options: -arch=compute_60 -code=sm_70.")) unsigned int ballot(bool pred) ;

static __inline __declspec(__device__) int syncthreads_count(bool pred) ;

static __inline __declspec(__device__) bool syncthreads_and(bool pred) ;

static __inline __declspec(__device__) bool syncthreads_or(bool pred) ;




static __inline __declspec(__device__) unsigned int __isGlobal(const void *ptr) ;
static __inline __declspec(__device__) unsigned int __isShared(const void *ptr) ;
static __inline __declspec(__device__) unsigned int __isConstant(const void *ptr) ;
static __inline __declspec(__device__) unsigned int __isLocal(const void *ptr) ;

static __inline __declspec(__device__) unsigned int __isGridConstant(const void *ptr) ;
#line 1528 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
static __inline __declspec(__device__) size_t __cvta_generic_to_global(const void *ptr) ;
static __inline __declspec(__device__) size_t __cvta_generic_to_shared(const void *ptr) ;
static __inline __declspec(__device__) size_t __cvta_generic_to_constant(const void *ptr) ;
static __inline __declspec(__device__) size_t __cvta_generic_to_local(const void *ptr) ;

static __inline __declspec(__device__) size_t __cvta_generic_to_grid_constant(const void *ptr) ;
#line 1535 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"

static __inline __declspec(__device__) void * __cvta_global_to_generic(size_t rawbits) ;
static __inline __declspec(__device__) void * __cvta_shared_to_generic(size_t rawbits) ;
static __inline __declspec(__device__) void * __cvta_constant_to_generic(size_t rawbits) ;
static __inline __declspec(__device__) void * __cvta_local_to_generic(size_t rawbits) ;

static __inline __declspec(__device__) void * __cvta_grid_constant_to_generic(size_t rawbits) ;
#line 1543 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
#line 1544 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"









#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"







static __inline __declspec(__device__) unsigned int ballot(bool pred)
{
  return __ballot((int)pred);
}

static __inline __declspec(__device__) int syncthreads_count(bool pred)
{
  return __syncthreads_count((int)pred);
}

static __inline __declspec(__device__) bool syncthreads_and(bool pred)
{
  return (bool)__syncthreads_and((int)pred);
}

static __inline __declspec(__device__) bool syncthreads_or(bool pred)
{
  return (bool)__syncthreads_or((int)pred);
}


extern "C" {
  __declspec(__device__) unsigned __nv_isGlobal_impl(const void *);
  __declspec(__device__) unsigned __nv_isShared_impl(const void *);
  __declspec(__device__) unsigned __nv_isConstant_impl(const void *);
  __declspec(__device__) unsigned __nv_isLocal_impl(const void *);
  __declspec(__device__) unsigned __nv_isGridConstant_impl(const void *);
}

static __inline __declspec(__device__) unsigned int __isGlobal(const void *ptr)
{
  return __nv_isGlobal_impl(ptr); 
}

static __inline __declspec(__device__) unsigned int __isShared(const void *ptr)
{
  return __nv_isShared_impl(ptr); 
}

static __inline __declspec(__device__) unsigned int __isConstant(const void *ptr)
{
  return __nv_isConstant_impl(ptr); 
}

static __inline __declspec(__device__) unsigned int __isLocal(const void *ptr)
{
  return __nv_isLocal_impl(ptr); 
}


static __inline __declspec(__device__) unsigned int __isGridConstant(const void *ptr)
{
  return __nv_isGridConstant_impl(ptr); 
}
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"

extern "C" {
  __declspec(__device__) size_t __nv_cvta_generic_to_global_impl(const void *);
  __declspec(__device__) size_t __nv_cvta_generic_to_shared_impl(const void *);
  __declspec(__device__) size_t __nv_cvta_generic_to_constant_impl(const void *);
  __declspec(__device__) size_t __nv_cvta_generic_to_local_impl(const void *);
  __declspec(__device__) void * __nv_cvta_global_to_generic_impl(size_t);
  __declspec(__device__) void * __nv_cvta_shared_to_generic_impl(size_t);
  __declspec(__device__) void * __nv_cvta_constant_to_generic_impl(size_t);
  __declspec(__device__) void * __nv_cvta_local_to_generic_impl(size_t);
}

static __inline __declspec(__device__) size_t __cvta_generic_to_global(const void *p)
{
  return __nv_cvta_generic_to_global_impl(p);
}

static __inline __declspec(__device__) size_t __cvta_generic_to_shared(const void *p)
{
  return __nv_cvta_generic_to_shared_impl(p);
}

static __inline __declspec(__device__) size_t __cvta_generic_to_constant(const void *p)
{
  return __nv_cvta_generic_to_constant_impl(p);
}

static __inline __declspec(__device__) size_t __cvta_generic_to_local(const void *p)
{
  return __nv_cvta_generic_to_local_impl(p);
}

static __inline __declspec(__device__) void * __cvta_global_to_generic(size_t rawbits)
{
  return __nv_cvta_global_to_generic_impl(rawbits);
}

static __inline __declspec(__device__) void * __cvta_shared_to_generic(size_t rawbits)
{
  return __nv_cvta_shared_to_generic_impl(rawbits);
}

static __inline __declspec(__device__) void * __cvta_constant_to_generic(size_t rawbits)
{
  return __nv_cvta_constant_to_generic_impl(rawbits);
}

static __inline __declspec(__device__) void * __cvta_local_to_generic(size_t rawbits)
{
  return __nv_cvta_local_to_generic_impl(rawbits);
}




#line 186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"

static __inline __declspec(__device__) size_t __cvta_generic_to_grid_constant(const void *ptr)
{

  unsigned long long ret;
  asm("cvta.to.param.u64 %0, %1;"  : "=l"(ret) : "l"(ptr));



#line 196 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"
  return (size_t)ret;
  
}

static __inline __declspec(__device__) void * __cvta_grid_constant_to_generic(size_t rawbits)
{
  void *ret;

  unsigned long long in = rawbits;
  asm("cvta.param.u64 %0, %1;" : "=l"(ret) : "l"(in));



#line 210 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"
  return ret;
}

#line 214 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"


#line 217 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"



#line 221 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.hpp"

#line 1550 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
#line 1551 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
#line 1552 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_20_intrinsics.h"
#line 3295 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"





#line 76 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"












#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"







#line 97 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"



#line 101 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"

static __declspec(__device__) __inline unsigned  __fns(unsigned mask, unsigned base, int offset) ;
static __declspec(__device__) __inline void  __barrier_sync(unsigned id) ;
static __declspec(__device__) __inline void  __barrier_sync_count(unsigned id, unsigned cnt) ;
static __declspec(__device__) __inline void  __syncwarp(unsigned mask=0xFFFFFFFF) ;
static __declspec(__device__) __inline int __all_sync(unsigned mask, int pred) ;
static __declspec(__device__) __inline int __any_sync(unsigned mask, int pred) ;
static __declspec(__device__) __inline int __uni_sync(unsigned mask, int pred) ;
static __declspec(__device__) __inline unsigned __ballot_sync(unsigned mask, int pred) ;
static __declspec(__device__) __inline unsigned __activemask() ;




















#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"

static __declspec(__device__) __inline int __shfl_sync(unsigned mask, int var, int srcLane, int width=32) ;
static __declspec(__device__) __inline unsigned int __shfl_sync(unsigned mask, unsigned int var, int srcLane, int width=32) ;
static __declspec(__device__) __inline int __shfl_up_sync(unsigned mask, int var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline unsigned int __shfl_up_sync(unsigned mask, unsigned int var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline int __shfl_down_sync(unsigned mask, int var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline unsigned int __shfl_down_sync(unsigned mask, unsigned int var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width=32) ;
static __declspec(__device__) __inline unsigned int __shfl_xor_sync(unsigned mask, unsigned int var, int laneMask, int width=32) ;
static __declspec(__device__) __inline float __shfl_sync(unsigned mask, float var, int srcLane, int width=32) ;
static __declspec(__device__) __inline float __shfl_up_sync(unsigned mask, float var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline float __shfl_down_sync(unsigned mask, float var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width=32) ;















#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"

static __declspec(__device__) __inline long long __shfl_sync(unsigned mask, long long var, int srcLane, int width=32) ;
static __declspec(__device__) __inline unsigned long long __shfl_sync(unsigned mask, unsigned long long var, int srcLane, int width=32) ;
static __declspec(__device__) __inline long long __shfl_up_sync(unsigned mask, long long var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline unsigned long long __shfl_up_sync(unsigned mask, unsigned long long var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline long long __shfl_down_sync(unsigned mask, long long var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline unsigned long long __shfl_down_sync(unsigned mask, unsigned long long var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline long long __shfl_xor_sync(unsigned mask, long long var, int laneMask, int width=32) ;
static __declspec(__device__) __inline unsigned long long __shfl_xor_sync(unsigned mask, unsigned long long var, int laneMask, int width=32) ;
static __declspec(__device__) __inline double __shfl_sync(unsigned mask, double var, int srcLane, int width=32) ;
static __declspec(__device__) __inline double __shfl_up_sync(unsigned mask, double var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline double __shfl_down_sync(unsigned mask, double var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width=32) ;











#line 186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"

static __declspec(__device__) __inline long __shfl_sync(unsigned mask, long var, int srcLane, int width=32) ;
static __declspec(__device__) __inline unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width=32) ;
static __declspec(__device__) __inline long __shfl_up_sync(unsigned mask, long var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline long __shfl_down_sync(unsigned mask, long var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned int delta, int width=32) ;
static __declspec(__device__) __inline long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width=32) ;
static __declspec(__device__) __inline unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width=32) ;







#line 203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"

#line 205 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"

#line 207 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"



extern "C"
{
}











#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"

static __declspec(__device__) __inline
unsigned __fns(unsigned mask, unsigned base, int offset) {
  extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __nvvm_fns(unsigned int mask, unsigned int base, int offset);
  return __nvvm_fns(mask, base, offset);
}

static __declspec(__device__) __inline 
void  __barrier_sync(unsigned id) {
  extern __declspec(__device__) __declspec(__device_builtin__) void __nvvm_barrier_sync(unsigned id);
  return __nvvm_barrier_sync(id);
}

static __declspec(__device__) __inline 
void  __barrier_sync_count(unsigned id, unsigned cnt) {
  extern __declspec(__device__) __declspec(__device_builtin__) void __nvvm_barrier_sync_cnt(unsigned id, unsigned cnt);
  return __nvvm_barrier_sync_cnt(id, cnt);
}

static __declspec(__device__) __inline 
void  __syncwarp(unsigned mask) {
  extern __declspec(__device__) __declspec(__device_builtin__) void __nvvm_bar_warp_sync(unsigned mask);
  return __nvvm_bar_warp_sync(mask);
}

static __declspec(__device__) __inline 
int __all_sync(unsigned mask, int pred) {
  extern __declspec(__device__) __declspec(__device_builtin__) int __nvvm_vote_all_sync(unsigned int mask, int pred); 
  return __nvvm_vote_all_sync(mask, pred);
}

static __declspec(__device__) __inline 
int __any_sync(unsigned mask, int pred) {
  extern __declspec(__device__) __declspec(__device_builtin__) int __nvvm_vote_any_sync(unsigned int mask, int pred); 
  return __nvvm_vote_any_sync(mask, pred);
}

static __declspec(__device__) __inline 
int __uni_sync(unsigned mask, int pred) {
  extern __declspec(__device__) __declspec(__device_builtin__) int __nvvm_vote_uni_sync(unsigned int mask, int pred); 
  return __nvvm_vote_uni_sync(mask, pred);
}

static __declspec(__device__) __inline 
unsigned __ballot_sync(unsigned mask, int pred) {
  extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __nvvm_vote_ballot_sync(unsigned int mask, int pred); 
  return __nvvm_vote_ballot_sync(mask, pred);
}

static __declspec(__device__) __inline
unsigned __activemask() {
    unsigned ret;
    asm volatile ("activemask.b32 %0;" : "=r"(ret));
    return ret;
}


























































































































































































































#line 362 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"







static __declspec(__device__) __inline int __shfl_sync(unsigned mask, int var, int srcLane, int width) {
        extern __declspec(__device__) __declspec(__device_builtin__) unsigned __nvvm_shfl_idx_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
	int ret;
	int c = ((32-width) << 8) | 0x1f;
        ret = __nvvm_shfl_idx_sync(mask, var, srcLane, c);
	return ret;
}

static __declspec(__device__) __inline unsigned int __shfl_sync(unsigned mask, unsigned int var, int srcLane, int width) {
        return (unsigned int) __shfl_sync(mask, (int)var, srcLane, width);
}

static __declspec(__device__) __inline int __shfl_up_sync(unsigned mask, int var, unsigned int delta, int width) {
        extern __declspec(__device__) __declspec(__device_builtin__) unsigned __nvvm_shfl_up_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
	int ret;
	int c = (32-width) << 8;
        ret = __nvvm_shfl_up_sync(mask, var, delta, c);
	return ret;
}

static __declspec(__device__) __inline unsigned int __shfl_up_sync(unsigned mask, unsigned int var, unsigned int delta, int width) {
        return (unsigned int) __shfl_up_sync(mask, (int)var, delta, width);
}

static __declspec(__device__) __inline int __shfl_down_sync(unsigned mask, int var, unsigned int delta, int width) {
        extern __declspec(__device__) __declspec(__device_builtin__) unsigned __nvvm_shfl_down_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
	int ret;
	int c = ((32-width) << 8) | 0x1f;
        ret = __nvvm_shfl_down_sync(mask, var, delta, c);
	return ret;
}

static __declspec(__device__) __inline unsigned int __shfl_down_sync(unsigned mask, unsigned int var, unsigned int delta, int width) {
        return (unsigned int) __shfl_down_sync(mask, (int)var, delta, width);
}

static __declspec(__device__) __inline int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width) {
        extern __declspec(__device__) __declspec(__device_builtin__) unsigned __nvvm_shfl_bfly_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
	int ret;
	int c = ((32-width) << 8) | 0x1f;
        ret = __nvvm_shfl_bfly_sync(mask, var, laneMask, c);
	return ret;
}

static __declspec(__device__) __inline unsigned int __shfl_xor_sync(unsigned mask, unsigned int var, int laneMask, int width) {
	return (unsigned int) __shfl_xor_sync(mask, (int)var, laneMask, width);
}

static __declspec(__device__) __inline float __shfl_sync(unsigned mask, float var, int srcLane, int width) {
        extern __declspec(__device__) __declspec(__device_builtin__) unsigned __nvvm_shfl_idx_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
        int ret;
        int c;
	c = ((32-width) << 8) | 0x1f;
        ret = __nvvm_shfl_idx_sync(mask, __float_as_int(var), srcLane, c);
	return __int_as_float(ret);
}

static __declspec(__device__) __inline float __shfl_up_sync(unsigned mask, float var, unsigned int delta, int width) {
        extern __declspec(__device__) __declspec(__device_builtin__) unsigned __nvvm_shfl_up_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
	int ret;
        int c;
	c = (32-width) << 8;
        ret = __nvvm_shfl_up_sync(mask, __float_as_int(var), delta, c);
	return __int_as_float(ret);
}

static __declspec(__device__) __inline float __shfl_down_sync(unsigned mask, float var, unsigned int delta, int width) {
        extern __declspec(__device__) __declspec(__device_builtin__) unsigned __nvvm_shfl_down_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
	int ret;
        int c;
	c = ((32-width) << 8) | 0x1f;
        ret = __nvvm_shfl_down_sync(mask, __float_as_int(var), delta, c);
	return __int_as_float(ret);
}

static __declspec(__device__) __inline float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width) {
        extern __declspec(__device__) __declspec(__device_builtin__) unsigned __nvvm_shfl_bfly_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
	int ret;
        int c;
	c = ((32-width) << 8) | 0x1f;
        ret = __nvvm_shfl_bfly_sync(mask, __float_as_int(var), laneMask, c);
	return __int_as_float(ret);
}


static __declspec(__device__) __inline long long __shfl_sync(unsigned mask, long long var, int srcLane, int width) {
	int lo, hi;
	asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
	hi = __shfl_sync(mask, hi, srcLane, width);
	lo = __shfl_sync(mask, lo, srcLane, width);
	asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
	return var;
}

static __declspec(__device__) __inline unsigned long long __shfl_sync(unsigned mask, unsigned long long var, int srcLane, int width) {
        return (unsigned long long) __shfl_sync(mask, (long long) var, srcLane, width);
}

static __declspec(__device__) __inline long long __shfl_up_sync(unsigned mask, long long var, unsigned int delta, int width) {
	int lo, hi;
	asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
	hi = __shfl_up_sync(mask, hi, delta, width);
	lo = __shfl_up_sync(mask, lo, delta, width);
	asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
	return var;
}

static __declspec(__device__) __inline unsigned long long __shfl_up_sync(unsigned mask, unsigned long long var, unsigned int delta, int width) {
        return (unsigned long long) __shfl_up_sync(mask, (long long) var, delta, width);
}

static __declspec(__device__) __inline long long __shfl_down_sync(unsigned mask, long long var, unsigned int delta, int width) {
	int lo, hi;
	asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
	hi = __shfl_down_sync(mask, hi, delta, width);
	lo = __shfl_down_sync(mask, lo, delta, width);
	asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
	return var;
}

static __declspec(__device__) __inline unsigned long long __shfl_down_sync(unsigned mask, unsigned long long var, unsigned int delta, int width) {
        return (unsigned long long) __shfl_down_sync(mask, (long long) var, delta, width);
}

static __declspec(__device__) __inline long long __shfl_xor_sync(unsigned mask, long long var, int laneMask, int width) {
	int lo, hi;
	asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
	hi = __shfl_xor_sync(mask, hi, laneMask, width);
	lo = __shfl_xor_sync(mask, lo, laneMask, width);
	asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
	return var;
}

static __declspec(__device__) __inline unsigned long long __shfl_xor_sync(unsigned mask, unsigned long long var, int laneMask, int width) {
        return (unsigned long long) __shfl_xor_sync(mask, (long long) var, laneMask, width);
}

static __declspec(__device__) __inline double __shfl_sync(unsigned mask, double var, int srcLane, int width) {
	unsigned lo, hi;
	asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
	hi = __shfl_sync(mask, hi, srcLane, width);
	lo = __shfl_sync(mask, lo, srcLane, width);
	asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
	return var;
}

static __declspec(__device__) __inline double __shfl_up_sync(unsigned mask, double var, unsigned int delta, int width) {
	unsigned lo, hi;
	asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
	hi = __shfl_up_sync(mask, hi, delta, width);
	lo = __shfl_up_sync(mask, lo, delta, width);
	asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
	return var;
}

static __declspec(__device__) __inline double __shfl_down_sync(unsigned mask, double var, unsigned int delta, int width) {
	unsigned lo, hi;
	asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
	hi = __shfl_down_sync(mask, hi, delta, width);
	lo = __shfl_down_sync(mask, lo, delta, width);
	asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
	return var;
}

static __declspec(__device__) __inline double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width) {
	unsigned lo, hi;
	asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
	hi = __shfl_xor_sync(mask, hi, laneMask, width);
	lo = __shfl_xor_sync(mask, lo, laneMask, width);
	asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
	return var;
}



static __declspec(__device__) __inline long __shfl_sync(unsigned mask, long var, int srcLane, int width) {
	return (sizeof(long) == sizeof(long long)) ?
                __shfl_sync(mask, (long long) var, srcLane, width) :
		__shfl_sync(mask, (int) var, srcLane, width);
}

static __declspec(__device__) __inline unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width) {
	return (sizeof(long) == sizeof(long long)) ?
                __shfl_sync(mask, (unsigned long long) var, srcLane, width) :
		__shfl_sync(mask, (unsigned int) var, srcLane, width);
}

static __declspec(__device__) __inline long __shfl_up_sync(unsigned mask, long var, unsigned int delta, int width) {
	return (sizeof(long) == sizeof(long long)) ?
		__shfl_up_sync(mask, (long long) var, delta, width) :
		__shfl_up_sync(mask, (int) var, delta, width);
}

static __declspec(__device__) __inline unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned int delta, int width) {
	return (sizeof(long) == sizeof(long long)) ?
		__shfl_up_sync(mask, (unsigned long long) var, delta, width) :
		__shfl_up_sync(mask, (unsigned int) var, delta, width);
}

static __declspec(__device__) __inline long __shfl_down_sync(unsigned mask, long var, unsigned int delta, int width) {
	return (sizeof(long) == sizeof(long long)) ?
		__shfl_down_sync(mask, (long long) var, delta, width) :
		__shfl_down_sync(mask, (int) var, delta, width);
}

static __declspec(__device__) __inline unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned int delta, int width) {
	return (sizeof(long) == sizeof(long long)) ?
		__shfl_down_sync(mask, (unsigned long long) var, delta, width) :
		__shfl_down_sync(mask, (unsigned int) var, delta, width);
}

static __declspec(__device__) __inline long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width) {
	return (sizeof(long) == sizeof(long long)) ?
		__shfl_xor_sync(mask, (long long) var, laneMask, width) :
		__shfl_xor_sync(mask, (int) var, laneMask, width);
}

static __declspec(__device__) __inline unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width) {
	return (sizeof(long) == sizeof(long long)) ?
		__shfl_xor_sync(mask, (unsigned long long) var, laneMask, width) :
		__shfl_xor_sync(mask, (unsigned int) var, laneMask, width);
}




#line 596 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"

#line 598 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"

#line 600 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"



#line 604 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.hpp"

#line 213 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
#line 214 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"

#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_30_intrinsics.h"
#line 3296 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"





#line 76 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"











static __declspec(__device__) __inline long __ldg(const long *ptr) ;
static __declspec(__device__) __inline unsigned long __ldg(const unsigned long *ptr) ;

static __declspec(__device__) __inline char __ldg(const char *ptr) ;
static __declspec(__device__) __inline signed char __ldg(const signed char *ptr) ;
static __declspec(__device__) __inline short __ldg(const short *ptr) ;
static __declspec(__device__) __inline int __ldg(const int *ptr) ;
static __declspec(__device__) __inline long long __ldg(const long long *ptr) ;
static __declspec(__device__) __inline char2 __ldg(const char2 *ptr) ;
static __declspec(__device__) __inline char4 __ldg(const char4 *ptr) ;
static __declspec(__device__) __inline short2 __ldg(const short2 *ptr) ;
static __declspec(__device__) __inline short4 __ldg(const short4 *ptr) ;
static __declspec(__device__) __inline int2 __ldg(const int2 *ptr) ;
static __declspec(__device__) __inline int4 __ldg(const int4 *ptr) ;
static __declspec(__device__) __inline longlong2 __ldg(const longlong2 *ptr) ;

static __declspec(__device__) __inline unsigned char __ldg(const unsigned char *ptr) ;
static __declspec(__device__) __inline unsigned short __ldg(const unsigned short *ptr) ;
static __declspec(__device__) __inline unsigned int __ldg(const unsigned int *ptr) ;
static __declspec(__device__) __inline unsigned long long __ldg(const unsigned long long *ptr) ;
static __declspec(__device__) __inline uchar2 __ldg(const uchar2 *ptr) ;
static __declspec(__device__) __inline uchar4 __ldg(const uchar4 *ptr) ;
static __declspec(__device__) __inline ushort2 __ldg(const ushort2 *ptr) ;
static __declspec(__device__) __inline ushort4 __ldg(const ushort4 *ptr) ;
static __declspec(__device__) __inline uint2 __ldg(const uint2 *ptr) ;
static __declspec(__device__) __inline uint4 __ldg(const uint4 *ptr) ;
static __declspec(__device__) __inline ulonglong2 __ldg(const ulonglong2 *ptr) ;

static __declspec(__device__) __inline float __ldg(const float *ptr) ;
static __declspec(__device__) __inline double __ldg(const double *ptr) ;
static __declspec(__device__) __inline float2 __ldg(const float2 *ptr) ;
static __declspec(__device__) __inline float4 __ldg(const float4 *ptr) ;
static __declspec(__device__) __inline double2 __ldg(const double2 *ptr) ;



static __declspec(__device__) __inline long __ldcg(const long *ptr) ;
static __declspec(__device__) __inline unsigned long __ldcg(const unsigned long *ptr) ;

static __declspec(__device__) __inline char __ldcg(const char *ptr) ;
static __declspec(__device__) __inline signed char __ldcg(const signed char *ptr) ;
static __declspec(__device__) __inline short __ldcg(const short *ptr) ;
static __declspec(__device__) __inline int __ldcg(const int *ptr) ;
static __declspec(__device__) __inline long long __ldcg(const long long *ptr) ;
static __declspec(__device__) __inline char2 __ldcg(const char2 *ptr) ;
static __declspec(__device__) __inline char4 __ldcg(const char4 *ptr) ;
static __declspec(__device__) __inline short2 __ldcg(const short2 *ptr) ;
static __declspec(__device__) __inline short4 __ldcg(const short4 *ptr) ;
static __declspec(__device__) __inline int2 __ldcg(const int2 *ptr) ;
static __declspec(__device__) __inline int4 __ldcg(const int4 *ptr) ;
static __declspec(__device__) __inline longlong2 __ldcg(const longlong2 *ptr) ;

static __declspec(__device__) __inline unsigned char __ldcg(const unsigned char *ptr) ;
static __declspec(__device__) __inline unsigned short __ldcg(const unsigned short *ptr) ;
static __declspec(__device__) __inline unsigned int __ldcg(const unsigned int *ptr) ;
static __declspec(__device__) __inline unsigned long long __ldcg(const unsigned long long *ptr) ;
static __declspec(__device__) __inline uchar2 __ldcg(const uchar2 *ptr) ;
static __declspec(__device__) __inline uchar4 __ldcg(const uchar4 *ptr) ;
static __declspec(__device__) __inline ushort2 __ldcg(const ushort2 *ptr) ;
static __declspec(__device__) __inline ushort4 __ldcg(const ushort4 *ptr) ;
static __declspec(__device__) __inline uint2 __ldcg(const uint2 *ptr) ;
static __declspec(__device__) __inline uint4 __ldcg(const uint4 *ptr) ;
static __declspec(__device__) __inline ulonglong2 __ldcg(const ulonglong2 *ptr) ;

static __declspec(__device__) __inline float __ldcg(const float *ptr) ;
static __declspec(__device__) __inline double __ldcg(const double *ptr) ;
static __declspec(__device__) __inline float2 __ldcg(const float2 *ptr) ;
static __declspec(__device__) __inline float4 __ldcg(const float4 *ptr) ;
static __declspec(__device__) __inline double2 __ldcg(const double2 *ptr) ;



static __declspec(__device__) __inline long __ldca(const long *ptr) ;
static __declspec(__device__) __inline unsigned long __ldca(const unsigned long *ptr) ;

static __declspec(__device__) __inline char __ldca(const char *ptr) ;
static __declspec(__device__) __inline signed char __ldca(const signed char *ptr) ;
static __declspec(__device__) __inline short __ldca(const short *ptr) ;
static __declspec(__device__) __inline int __ldca(const int *ptr) ;
static __declspec(__device__) __inline long long __ldca(const long long *ptr) ;
static __declspec(__device__) __inline char2 __ldca(const char2 *ptr) ;
static __declspec(__device__) __inline char4 __ldca(const char4 *ptr) ;
static __declspec(__device__) __inline short2 __ldca(const short2 *ptr) ;
static __declspec(__device__) __inline short4 __ldca(const short4 *ptr) ;
static __declspec(__device__) __inline int2 __ldca(const int2 *ptr) ;
static __declspec(__device__) __inline int4 __ldca(const int4 *ptr) ;
static __declspec(__device__) __inline longlong2 __ldca(const longlong2 *ptr) ;

static __declspec(__device__) __inline unsigned char __ldca(const unsigned char *ptr) ;
static __declspec(__device__) __inline unsigned short __ldca(const unsigned short *ptr) ;
static __declspec(__device__) __inline unsigned int __ldca(const unsigned int *ptr) ;
static __declspec(__device__) __inline unsigned long long __ldca(const unsigned long long *ptr) ;
static __declspec(__device__) __inline uchar2 __ldca(const uchar2 *ptr) ;
static __declspec(__device__) __inline uchar4 __ldca(const uchar4 *ptr) ;
static __declspec(__device__) __inline ushort2 __ldca(const ushort2 *ptr) ;
static __declspec(__device__) __inline ushort4 __ldca(const ushort4 *ptr) ;
static __declspec(__device__) __inline uint2 __ldca(const uint2 *ptr) ;
static __declspec(__device__) __inline uint4 __ldca(const uint4 *ptr) ;
static __declspec(__device__) __inline ulonglong2 __ldca(const ulonglong2 *ptr) ;

static __declspec(__device__) __inline float __ldca(const float *ptr) ;
static __declspec(__device__) __inline double __ldca(const double *ptr) ;
static __declspec(__device__) __inline float2 __ldca(const float2 *ptr) ;
static __declspec(__device__) __inline float4 __ldca(const float4 *ptr) ;
static __declspec(__device__) __inline double2 __ldca(const double2 *ptr) ;



static __declspec(__device__) __inline long __ldcs(const long *ptr) ;
static __declspec(__device__) __inline unsigned long __ldcs(const unsigned long *ptr) ;

static __declspec(__device__) __inline char __ldcs(const char *ptr) ;
static __declspec(__device__) __inline signed char __ldcs(const signed char *ptr) ;
static __declspec(__device__) __inline short __ldcs(const short *ptr) ;
static __declspec(__device__) __inline int __ldcs(const int *ptr) ;
static __declspec(__device__) __inline long long __ldcs(const long long *ptr) ;
static __declspec(__device__) __inline char2 __ldcs(const char2 *ptr) ;
static __declspec(__device__) __inline char4 __ldcs(const char4 *ptr) ;
static __declspec(__device__) __inline short2 __ldcs(const short2 *ptr) ;
static __declspec(__device__) __inline short4 __ldcs(const short4 *ptr) ;
static __declspec(__device__) __inline int2 __ldcs(const int2 *ptr) ;
static __declspec(__device__) __inline int4 __ldcs(const int4 *ptr) ;
static __declspec(__device__) __inline longlong2 __ldcs(const longlong2 *ptr) ;

static __declspec(__device__) __inline unsigned char __ldcs(const unsigned char *ptr) ;
static __declspec(__device__) __inline unsigned short __ldcs(const unsigned short *ptr) ;
static __declspec(__device__) __inline unsigned int __ldcs(const unsigned int *ptr) ;
static __declspec(__device__) __inline unsigned long long __ldcs(const unsigned long long *ptr) ;
static __declspec(__device__) __inline uchar2 __ldcs(const uchar2 *ptr) ;
static __declspec(__device__) __inline uchar4 __ldcs(const uchar4 *ptr) ;
static __declspec(__device__) __inline ushort2 __ldcs(const ushort2 *ptr) ;
static __declspec(__device__) __inline ushort4 __ldcs(const ushort4 *ptr) ;
static __declspec(__device__) __inline uint2 __ldcs(const uint2 *ptr) ;
static __declspec(__device__) __inline uint4 __ldcs(const uint4 *ptr) ;
static __declspec(__device__) __inline ulonglong2 __ldcs(const ulonglong2 *ptr) ;

static __declspec(__device__) __inline float __ldcs(const float *ptr) ;
static __declspec(__device__) __inline double __ldcs(const double *ptr) ;
static __declspec(__device__) __inline float2 __ldcs(const float2 *ptr) ;
static __declspec(__device__) __inline float4 __ldcs(const float4 *ptr) ;
static __declspec(__device__) __inline double2 __ldcs(const double2 *ptr) ;



static __declspec(__device__) __inline long __ldlu(const long *ptr) ;
static __declspec(__device__) __inline unsigned long __ldlu(const unsigned long *ptr) ;

static __declspec(__device__) __inline char __ldlu(const char *ptr) ;
static __declspec(__device__) __inline signed char __ldlu(const signed char *ptr) ;
static __declspec(__device__) __inline short __ldlu(const short *ptr) ;
static __declspec(__device__) __inline int __ldlu(const int *ptr) ;
static __declspec(__device__) __inline long long __ldlu(const long long *ptr) ;
static __declspec(__device__) __inline char2 __ldlu(const char2 *ptr) ;
static __declspec(__device__) __inline char4 __ldlu(const char4 *ptr) ;
static __declspec(__device__) __inline short2 __ldlu(const short2 *ptr) ;
static __declspec(__device__) __inline short4 __ldlu(const short4 *ptr) ;
static __declspec(__device__) __inline int2 __ldlu(const int2 *ptr) ;
static __declspec(__device__) __inline int4 __ldlu(const int4 *ptr) ;
static __declspec(__device__) __inline longlong2 __ldlu(const longlong2 *ptr) ;

static __declspec(__device__) __inline unsigned char __ldlu(const unsigned char *ptr) ;
static __declspec(__device__) __inline unsigned short __ldlu(const unsigned short *ptr) ;
static __declspec(__device__) __inline unsigned int __ldlu(const unsigned int *ptr) ;
static __declspec(__device__) __inline unsigned long long __ldlu(const unsigned long long *ptr) ;
static __declspec(__device__) __inline uchar2 __ldlu(const uchar2 *ptr) ;
static __declspec(__device__) __inline uchar4 __ldlu(const uchar4 *ptr) ;
static __declspec(__device__) __inline ushort2 __ldlu(const ushort2 *ptr) ;
static __declspec(__device__) __inline ushort4 __ldlu(const ushort4 *ptr) ;
static __declspec(__device__) __inline uint2 __ldlu(const uint2 *ptr) ;
static __declspec(__device__) __inline uint4 __ldlu(const uint4 *ptr) ;
static __declspec(__device__) __inline ulonglong2 __ldlu(const ulonglong2 *ptr) ;

static __declspec(__device__) __inline float __ldlu(const float *ptr) ;
static __declspec(__device__) __inline double __ldlu(const double *ptr) ;
static __declspec(__device__) __inline float2 __ldlu(const float2 *ptr) ;
static __declspec(__device__) __inline float4 __ldlu(const float4 *ptr) ;
static __declspec(__device__) __inline double2 __ldlu(const double2 *ptr) ;



static __declspec(__device__) __inline long __ldcv(const long *ptr) ;
static __declspec(__device__) __inline unsigned long __ldcv(const unsigned long *ptr) ;

static __declspec(__device__) __inline char __ldcv(const char *ptr) ;
static __declspec(__device__) __inline signed char __ldcv(const signed char *ptr) ;
static __declspec(__device__) __inline short __ldcv(const short *ptr) ;
static __declspec(__device__) __inline int __ldcv(const int *ptr) ;
static __declspec(__device__) __inline long long __ldcv(const long long *ptr) ;
static __declspec(__device__) __inline char2 __ldcv(const char2 *ptr) ;
static __declspec(__device__) __inline char4 __ldcv(const char4 *ptr) ;
static __declspec(__device__) __inline short2 __ldcv(const short2 *ptr) ;
static __declspec(__device__) __inline short4 __ldcv(const short4 *ptr) ;
static __declspec(__device__) __inline int2 __ldcv(const int2 *ptr) ;
static __declspec(__device__) __inline int4 __ldcv(const int4 *ptr) ;
static __declspec(__device__) __inline longlong2 __ldcv(const longlong2 *ptr) ;

static __declspec(__device__) __inline unsigned char __ldcv(const unsigned char *ptr) ;
static __declspec(__device__) __inline unsigned short __ldcv(const unsigned short *ptr) ;
static __declspec(__device__) __inline unsigned int __ldcv(const unsigned int *ptr) ;
static __declspec(__device__) __inline unsigned long long __ldcv(const unsigned long long *ptr) ;
static __declspec(__device__) __inline uchar2 __ldcv(const uchar2 *ptr) ;
static __declspec(__device__) __inline uchar4 __ldcv(const uchar4 *ptr) ;
static __declspec(__device__) __inline ushort2 __ldcv(const ushort2 *ptr) ;
static __declspec(__device__) __inline ushort4 __ldcv(const ushort4 *ptr) ;
static __declspec(__device__) __inline uint2 __ldcv(const uint2 *ptr) ;
static __declspec(__device__) __inline uint4 __ldcv(const uint4 *ptr) ;
static __declspec(__device__) __inline ulonglong2 __ldcv(const ulonglong2 *ptr) ;

static __declspec(__device__) __inline float __ldcv(const float *ptr) ;
static __declspec(__device__) __inline double __ldcv(const double *ptr) ;
static __declspec(__device__) __inline float2 __ldcv(const float2 *ptr) ;
static __declspec(__device__) __inline float4 __ldcv(const float4 *ptr) ;
static __declspec(__device__) __inline double2 __ldcv(const double2 *ptr) ;



static __declspec(__device__) __inline void __stwb(long *ptr, long value) ;
static __declspec(__device__) __inline void __stwb(unsigned long *ptr, unsigned long value) ;

static __declspec(__device__) __inline void __stwb(char *ptr, char value) ;
static __declspec(__device__) __inline void __stwb(signed char *ptr, signed char value) ;
static __declspec(__device__) __inline void __stwb(short *ptr, short value) ;
static __declspec(__device__) __inline void __stwb(int *ptr, int value) ;
static __declspec(__device__) __inline void __stwb(long long *ptr, long long value) ;
static __declspec(__device__) __inline void __stwb(char2 *ptr, char2 value) ;
static __declspec(__device__) __inline void __stwb(char4 *ptr, char4 value) ;
static __declspec(__device__) __inline void __stwb(short2 *ptr, short2 value) ;
static __declspec(__device__) __inline void __stwb(short4 *ptr, short4 value) ;
static __declspec(__device__) __inline void __stwb(int2 *ptr, int2 value) ;
static __declspec(__device__) __inline void __stwb(int4 *ptr, int4 value) ;
static __declspec(__device__) __inline void __stwb(longlong2 *ptr, longlong2 value) ;

static __declspec(__device__) __inline void __stwb(unsigned char *ptr, unsigned char value) ;
static __declspec(__device__) __inline void __stwb(unsigned short *ptr, unsigned short value) ;
static __declspec(__device__) __inline void __stwb(unsigned int *ptr, unsigned int value) ;
static __declspec(__device__) __inline void __stwb(unsigned long long *ptr, unsigned long long value) ;
static __declspec(__device__) __inline void __stwb(uchar2 *ptr, uchar2 value) ;
static __declspec(__device__) __inline void __stwb(uchar4 *ptr, uchar4 value) ;
static __declspec(__device__) __inline void __stwb(ushort2 *ptr, ushort2 value) ;
static __declspec(__device__) __inline void __stwb(ushort4 *ptr, ushort4 value) ;
static __declspec(__device__) __inline void __stwb(uint2 *ptr, uint2 value) ;
static __declspec(__device__) __inline void __stwb(uint4 *ptr, uint4 value) ;
static __declspec(__device__) __inline void __stwb(ulonglong2 *ptr, ulonglong2 value) ;

static __declspec(__device__) __inline void __stwb(float *ptr, float value) ;
static __declspec(__device__) __inline void __stwb(double *ptr, double value) ;
static __declspec(__device__) __inline void __stwb(float2 *ptr, float2 value) ;
static __declspec(__device__) __inline void __stwb(float4 *ptr, float4 value) ;
static __declspec(__device__) __inline void __stwb(double2 *ptr, double2 value) ;



static __declspec(__device__) __inline void __stcg(long *ptr, long value) ;
static __declspec(__device__) __inline void __stcg(unsigned long *ptr, unsigned long value) ;

static __declspec(__device__) __inline void __stcg(char *ptr, char value) ;
static __declspec(__device__) __inline void __stcg(signed char *ptr, signed char value) ;
static __declspec(__device__) __inline void __stcg(short *ptr, short value) ;
static __declspec(__device__) __inline void __stcg(int *ptr, int value) ;
static __declspec(__device__) __inline void __stcg(long long *ptr, long long value) ;
static __declspec(__device__) __inline void __stcg(char2 *ptr, char2 value) ;
static __declspec(__device__) __inline void __stcg(char4 *ptr, char4 value) ;
static __declspec(__device__) __inline void __stcg(short2 *ptr, short2 value) ;
static __declspec(__device__) __inline void __stcg(short4 *ptr, short4 value) ;
static __declspec(__device__) __inline void __stcg(int2 *ptr, int2 value) ;
static __declspec(__device__) __inline void __stcg(int4 *ptr, int4 value) ;
static __declspec(__device__) __inline void __stcg(longlong2 *ptr, longlong2 value) ;

static __declspec(__device__) __inline void __stcg(unsigned char *ptr, unsigned char value) ;
static __declspec(__device__) __inline void __stcg(unsigned short *ptr, unsigned short value) ;
static __declspec(__device__) __inline void __stcg(unsigned int *ptr, unsigned int value) ;
static __declspec(__device__) __inline void __stcg(unsigned long long *ptr, unsigned long long value) ;
static __declspec(__device__) __inline void __stcg(uchar2 *ptr, uchar2 value) ;
static __declspec(__device__) __inline void __stcg(uchar4 *ptr, uchar4 value) ;
static __declspec(__device__) __inline void __stcg(ushort2 *ptr, ushort2 value) ;
static __declspec(__device__) __inline void __stcg(ushort4 *ptr, ushort4 value) ;
static __declspec(__device__) __inline void __stcg(uint2 *ptr, uint2 value) ;
static __declspec(__device__) __inline void __stcg(uint4 *ptr, uint4 value) ;
static __declspec(__device__) __inline void __stcg(ulonglong2 *ptr, ulonglong2 value) ;

static __declspec(__device__) __inline void __stcg(float *ptr, float value) ;
static __declspec(__device__) __inline void __stcg(double *ptr, double value) ;
static __declspec(__device__) __inline void __stcg(float2 *ptr, float2 value) ;
static __declspec(__device__) __inline void __stcg(float4 *ptr, float4 value) ;
static __declspec(__device__) __inline void __stcg(double2 *ptr, double2 value) ;



static __declspec(__device__) __inline void __stcs(long *ptr, long value) ;
static __declspec(__device__) __inline void __stcs(unsigned long *ptr, unsigned long value) ;

static __declspec(__device__) __inline void __stcs(char *ptr, char value) ;
static __declspec(__device__) __inline void __stcs(signed char *ptr, signed char value) ;
static __declspec(__device__) __inline void __stcs(short *ptr, short value) ;
static __declspec(__device__) __inline void __stcs(int *ptr, int value) ;
static __declspec(__device__) __inline void __stcs(long long *ptr, long long value) ;
static __declspec(__device__) __inline void __stcs(char2 *ptr, char2 value) ;
static __declspec(__device__) __inline void __stcs(char4 *ptr, char4 value) ;
static __declspec(__device__) __inline void __stcs(short2 *ptr, short2 value) ;
static __declspec(__device__) __inline void __stcs(short4 *ptr, short4 value) ;
static __declspec(__device__) __inline void __stcs(int2 *ptr, int2 value) ;
static __declspec(__device__) __inline void __stcs(int4 *ptr, int4 value) ;
static __declspec(__device__) __inline void __stcs(longlong2 *ptr, longlong2 value) ;

static __declspec(__device__) __inline void __stcs(unsigned char *ptr, unsigned char value) ;
static __declspec(__device__) __inline void __stcs(unsigned short *ptr, unsigned short value) ;
static __declspec(__device__) __inline void __stcs(unsigned int *ptr, unsigned int value) ;
static __declspec(__device__) __inline void __stcs(unsigned long long *ptr, unsigned long long value) ;
static __declspec(__device__) __inline void __stcs(uchar2 *ptr, uchar2 value) ;
static __declspec(__device__) __inline void __stcs(uchar4 *ptr, uchar4 value) ;
static __declspec(__device__) __inline void __stcs(ushort2 *ptr, ushort2 value) ;
static __declspec(__device__) __inline void __stcs(ushort4 *ptr, ushort4 value) ;
static __declspec(__device__) __inline void __stcs(uint2 *ptr, uint2 value) ;
static __declspec(__device__) __inline void __stcs(uint4 *ptr, uint4 value) ;
static __declspec(__device__) __inline void __stcs(ulonglong2 *ptr, ulonglong2 value) ;

static __declspec(__device__) __inline void __stcs(float *ptr, float value) ;
static __declspec(__device__) __inline void __stcs(double *ptr, double value) ;
static __declspec(__device__) __inline void __stcs(float2 *ptr, float2 value) ;
static __declspec(__device__) __inline void __stcs(float4 *ptr, float4 value) ;
static __declspec(__device__) __inline void __stcs(double2 *ptr, double2 value) ;



static __declspec(__device__) __inline void __stwt(long *ptr, long value) ;
static __declspec(__device__) __inline void __stwt(unsigned long *ptr, unsigned long value) ;

static __declspec(__device__) __inline void __stwt(char *ptr, char value) ;
static __declspec(__device__) __inline void __stwt(signed char *ptr, signed char value) ;
static __declspec(__device__) __inline void __stwt(short *ptr, short value) ;
static __declspec(__device__) __inline void __stwt(int *ptr, int value) ;
static __declspec(__device__) __inline void __stwt(long long *ptr, long long value) ;
static __declspec(__device__) __inline void __stwt(char2 *ptr, char2 value) ;
static __declspec(__device__) __inline void __stwt(char4 *ptr, char4 value) ;
static __declspec(__device__) __inline void __stwt(short2 *ptr, short2 value) ;
static __declspec(__device__) __inline void __stwt(short4 *ptr, short4 value) ;
static __declspec(__device__) __inline void __stwt(int2 *ptr, int2 value) ;
static __declspec(__device__) __inline void __stwt(int4 *ptr, int4 value) ;
static __declspec(__device__) __inline void __stwt(longlong2 *ptr, longlong2 value) ;

static __declspec(__device__) __inline void __stwt(unsigned char *ptr, unsigned char value) ;
static __declspec(__device__) __inline void __stwt(unsigned short *ptr, unsigned short value) ;
static __declspec(__device__) __inline void __stwt(unsigned int *ptr, unsigned int value) ;
static __declspec(__device__) __inline void __stwt(unsigned long long *ptr, unsigned long long value) ;
static __declspec(__device__) __inline void __stwt(uchar2 *ptr, uchar2 value) ;
static __declspec(__device__) __inline void __stwt(uchar4 *ptr, uchar4 value) ;
static __declspec(__device__) __inline void __stwt(ushort2 *ptr, ushort2 value) ;
static __declspec(__device__) __inline void __stwt(ushort4 *ptr, ushort4 value) ;
static __declspec(__device__) __inline void __stwt(uint2 *ptr, uint2 value) ;
static __declspec(__device__) __inline void __stwt(uint4 *ptr, uint4 value) ;
static __declspec(__device__) __inline void __stwt(ulonglong2 *ptr, ulonglong2 value) ;

static __declspec(__device__) __inline void __stwt(float *ptr, float value) ;
static __declspec(__device__) __inline void __stwt(double *ptr, double value) ;
static __declspec(__device__) __inline void __stwt(float2 *ptr, float2 value) ;
static __declspec(__device__) __inline void __stwt(float4 *ptr, float4 value) ;
static __declspec(__device__) __inline void __stwt(double2 *ptr, double2 value) ;
















static __declspec(__device__) __inline unsigned int __funnelshift_l(unsigned int lo, unsigned int hi, unsigned int shift) ;











static __declspec(__device__) __inline unsigned int __funnelshift_lc(unsigned int lo, unsigned int hi, unsigned int shift) ;












static __declspec(__device__) __inline unsigned int __funnelshift_r(unsigned int lo, unsigned int hi, unsigned int shift) ;











static __declspec(__device__) __inline unsigned int __funnelshift_rc(unsigned int lo, unsigned int hi, unsigned int shift) ;


#line 501 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"

#line 503 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"




#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"



extern "C"
{
    
    
}















#line 94 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"









#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline long __ldg(const long *ptr) { unsigned long ret; asm volatile ("ld.global.nc.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (long)ret; }
static __declspec(__device__) __inline unsigned long __ldg(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.nc.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return ret; }
#line 107 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline char __ldg(const char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __declspec(__device__) __inline signed char __ldg(const signed char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (signed char)ret; }
static __declspec(__device__) __inline short __ldg(const short *ptr) { unsigned short ret; asm volatile ("ld.global.nc.s16 %0, [%1];"  : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __declspec(__device__) __inline int __ldg(const int *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __declspec(__device__) __inline long long __ldg(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.nc.s64 %0, [%1];"  : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __declspec(__device__) __inline char2 __ldg(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.nc.v2.s8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __declspec(__device__) __inline char4 __ldg(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __declspec(__device__) __inline short2 __ldg(const short2 *ptr) { short2 ret; asm volatile ("ld.global.nc.v2.s16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline short4 __ldg(const short4 *ptr) { short4 ret; asm volatile ("ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline int2 __ldg(const int2 *ptr) { int2 ret; asm volatile ("ld.global.nc.v2.s32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline int4 __ldg(const int4 *ptr) { int4 ret; asm volatile ("ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline longlong2 __ldg(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.nc.v2.s64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __declspec(__device__) __inline unsigned char __ldg(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.u8 %0, [%1];"  : "=r"(ret) : "l" (ptr));  return (unsigned char)ret; }
static __declspec(__device__) __inline unsigned short __ldg(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.nc.u16 %0, [%1];"  : "=h"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned int __ldg(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.nc.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned long long __ldg(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.nc.u64 %0, [%1];"  : "=l"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uchar2 __ldg(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.nc.v2.u8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __declspec(__device__) __inline uchar4 __ldg(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __declspec(__device__) __inline ushort2 __ldg(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.nc.v2.u16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline ushort4 __ldg(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uint2 __ldg(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.nc.v2.u32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uint4 __ldg(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline ulonglong2 __ldg(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.nc.v2.u64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __declspec(__device__) __inline float __ldg(const float *ptr) { float ret; asm volatile ("ld.global.nc.f32 %0, [%1];"  : "=f"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline double __ldg(const double *ptr) { double ret; asm volatile ("ld.global.nc.f64 %0, [%1];"  : "=d"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline float2 __ldg(const float2 *ptr) { float2 ret; asm volatile ("ld.global.nc.v2.f32 {%0,%1}, [%2];"  : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline float4 __ldg(const float4 *ptr) { float4 ret; asm volatile ("ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];"  : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline double2 __ldg(const double2 *ptr) { double2 ret; asm volatile ("ld.global.nc.v2.f64 {%0,%1}, [%2];"  : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }










#line 150 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline long __ldcg(const long *ptr) { unsigned long ret; asm volatile ("ld.global.cg.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (long)ret; }
static __declspec(__device__) __inline unsigned long __ldcg(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.cg.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return ret; }
#line 153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline char __ldcg(const char *ptr) { unsigned int ret; asm volatile ("ld.global.cg.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __declspec(__device__) __inline signed char __ldcg(const signed char *ptr) { unsigned int ret; asm volatile ("ld.global.cg.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (signed char)ret; }
static __declspec(__device__) __inline short __ldcg(const short *ptr) { unsigned short ret; asm volatile ("ld.global.cg.s16 %0, [%1];"  : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __declspec(__device__) __inline int __ldcg(const int *ptr) { unsigned int ret; asm volatile ("ld.global.cg.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __declspec(__device__) __inline long long __ldcg(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.cg.s64 %0, [%1];"  : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __declspec(__device__) __inline char2 __ldcg(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.cg.v2.s8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __declspec(__device__) __inline char4 __ldcg(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.cg.v4.s8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __declspec(__device__) __inline short2 __ldcg(const short2 *ptr) { short2 ret; asm volatile ("ld.global.cg.v2.s16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline short4 __ldcg(const short4 *ptr) { short4 ret; asm volatile ("ld.global.cg.v4.s16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline int2 __ldcg(const int2 *ptr) { int2 ret; asm volatile ("ld.global.cg.v2.s32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline int4 __ldcg(const int4 *ptr) { int4 ret; asm volatile ("ld.global.cg.v4.s32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline longlong2 __ldcg(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.cg.v2.s64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __declspec(__device__) __inline unsigned char __ldcg(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.cg.u8 %0, [%1];"  : "=r"(ret) : "l" (ptr));  return (unsigned char)ret; }
static __declspec(__device__) __inline unsigned short __ldcg(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.cg.u16 %0, [%1];"  : "=h"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned int __ldcg(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.cg.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned long long __ldcg(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.cg.u64 %0, [%1];"  : "=l"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uchar2 __ldcg(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.cg.v2.u8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __declspec(__device__) __inline uchar4 __ldcg(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.cg.v4.u8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __declspec(__device__) __inline ushort2 __ldcg(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.cg.v2.u16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline ushort4 __ldcg(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.cg.v4.u16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uint2 __ldcg(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.cg.v2.u32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uint4 __ldcg(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.cg.v4.u32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline ulonglong2 __ldcg(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.cg.v2.u64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __declspec(__device__) __inline float __ldcg(const float *ptr) { float ret; asm volatile ("ld.global.cg.f32 %0, [%1];"  : "=f"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline double __ldcg(const double *ptr) { double ret; asm volatile ("ld.global.cg.f64 %0, [%1];"  : "=d"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline float2 __ldcg(const float2 *ptr) { float2 ret; asm volatile ("ld.global.cg.v2.f32 {%0,%1}, [%2];"  : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline float4 __ldcg(const float4 *ptr) { float4 ret; asm volatile ("ld.global.cg.v4.f32 {%0,%1,%2,%3}, [%4];"  : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline double2 __ldcg(const double2 *ptr) { double2 ret; asm volatile ("ld.global.cg.v2.f64 {%0,%1}, [%2];"  : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }









#line 195 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline long __ldca(const long *ptr) { unsigned long ret; asm volatile ("ld.global.ca.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (long)ret; }
static __declspec(__device__) __inline unsigned long __ldca(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.ca.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return ret; }
#line 198 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline char __ldca(const char *ptr) { unsigned int ret; asm volatile ("ld.global.ca.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __declspec(__device__) __inline signed char __ldca(const signed char *ptr) { unsigned int ret; asm volatile ("ld.global.ca.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (signed char)ret; }
static __declspec(__device__) __inline short __ldca(const short *ptr) { unsigned short ret; asm volatile ("ld.global.ca.s16 %0, [%1];"  : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __declspec(__device__) __inline int __ldca(const int *ptr) { unsigned int ret; asm volatile ("ld.global.ca.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __declspec(__device__) __inline long long __ldca(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.ca.s64 %0, [%1];"  : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __declspec(__device__) __inline char2 __ldca(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.ca.v2.s8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __declspec(__device__) __inline char4 __ldca(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.ca.v4.s8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __declspec(__device__) __inline short2 __ldca(const short2 *ptr) { short2 ret; asm volatile ("ld.global.ca.v2.s16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline short4 __ldca(const short4 *ptr) { short4 ret; asm volatile ("ld.global.ca.v4.s16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline int2 __ldca(const int2 *ptr) { int2 ret; asm volatile ("ld.global.ca.v2.s32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline int4 __ldca(const int4 *ptr) { int4 ret; asm volatile ("ld.global.ca.v4.s32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline longlong2 __ldca(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.ca.v2.s64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __declspec(__device__) __inline unsigned char __ldca(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.ca.u8 %0, [%1];"  : "=r"(ret) : "l" (ptr));  return (unsigned char)ret; }
static __declspec(__device__) __inline unsigned short __ldca(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.ca.u16 %0, [%1];"  : "=h"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned int __ldca(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.ca.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned long long __ldca(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.ca.u64 %0, [%1];"  : "=l"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uchar2 __ldca(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.ca.v2.u8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __declspec(__device__) __inline uchar4 __ldca(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.ca.v4.u8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __declspec(__device__) __inline ushort2 __ldca(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.ca.v2.u16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline ushort4 __ldca(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.ca.v4.u16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uint2 __ldca(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.ca.v2.u32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uint4 __ldca(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.ca.v4.u32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline ulonglong2 __ldca(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.ca.v2.u64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __declspec(__device__) __inline float __ldca(const float *ptr) { float ret; asm volatile ("ld.global.ca.f32 %0, [%1];"  : "=f"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline double __ldca(const double *ptr) { double ret; asm volatile ("ld.global.ca.f64 %0, [%1];"  : "=d"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline float2 __ldca(const float2 *ptr) { float2 ret; asm volatile ("ld.global.ca.v2.f32 {%0,%1}, [%2];"  : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline float4 __ldca(const float4 *ptr) { float4 ret; asm volatile ("ld.global.ca.v4.f32 {%0,%1,%2,%3}, [%4];"  : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline double2 __ldca(const double2 *ptr) { double2 ret; asm volatile ("ld.global.ca.v2.f64 {%0,%1}, [%2];"  : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }









#line 240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline long __ldcs(const long *ptr) { unsigned long ret; asm volatile ("ld.global.cs.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (long)ret; }
static __declspec(__device__) __inline unsigned long __ldcs(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.cs.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return ret; }
#line 243 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline char __ldcs(const char *ptr) { unsigned int ret; asm volatile ("ld.global.cs.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __declspec(__device__) __inline signed char __ldcs(const signed char *ptr) { unsigned int ret; asm volatile ("ld.global.cs.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (signed char)ret; }
static __declspec(__device__) __inline short __ldcs(const short *ptr) { unsigned short ret; asm volatile ("ld.global.cs.s16 %0, [%1];"  : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __declspec(__device__) __inline int __ldcs(const int *ptr) { unsigned int ret; asm volatile ("ld.global.cs.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __declspec(__device__) __inline long long __ldcs(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.cs.s64 %0, [%1];"  : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __declspec(__device__) __inline char2 __ldcs(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.cs.v2.s8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __declspec(__device__) __inline char4 __ldcs(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.cs.v4.s8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __declspec(__device__) __inline short2 __ldcs(const short2 *ptr) { short2 ret; asm volatile ("ld.global.cs.v2.s16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline short4 __ldcs(const short4 *ptr) { short4 ret; asm volatile ("ld.global.cs.v4.s16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline int2 __ldcs(const int2 *ptr) { int2 ret; asm volatile ("ld.global.cs.v2.s32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline int4 __ldcs(const int4 *ptr) { int4 ret; asm volatile ("ld.global.cs.v4.s32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline longlong2 __ldcs(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.cs.v2.s64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __declspec(__device__) __inline unsigned char __ldcs(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.cs.u8 %0, [%1];"  : "=r"(ret) : "l" (ptr));  return (unsigned char)ret; }
static __declspec(__device__) __inline unsigned short __ldcs(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.cs.u16 %0, [%1];"  : "=h"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned int __ldcs(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.cs.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned long long __ldcs(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.cs.u64 %0, [%1];"  : "=l"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uchar2 __ldcs(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.cs.v2.u8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __declspec(__device__) __inline uchar4 __ldcs(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.cs.v4.u8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __declspec(__device__) __inline ushort2 __ldcs(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.cs.v2.u16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline ushort4 __ldcs(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.cs.v4.u16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uint2 __ldcs(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.cs.v2.u32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline uint4 __ldcs(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.cs.v4.u32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline ulonglong2 __ldcs(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.cs.v2.u64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __declspec(__device__) __inline float __ldcs(const float *ptr) { float ret; asm volatile ("ld.global.cs.f32 %0, [%1];"  : "=f"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline double __ldcs(const double *ptr) { double ret; asm volatile ("ld.global.cs.f64 %0, [%1];"  : "=d"(ret) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline float2 __ldcs(const float2 *ptr) { float2 ret; asm volatile ("ld.global.cs.v2.f32 {%0,%1}, [%2];"  : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline float4 __ldcs(const float4 *ptr) { float4 ret; asm volatile ("ld.global.cs.v4.f32 {%0,%1,%2,%3}, [%4];"  : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __declspec(__device__) __inline double2 __ldcs(const double2 *ptr) { double2 ret; asm volatile ("ld.global.cs.v2.f64 {%0,%1}, [%2];"  : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }









#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline long __ldlu(const long *ptr) { unsigned long ret; asm ("ld.global.lu.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return (long)ret; }
static __declspec(__device__) __inline unsigned long __ldlu(const unsigned long *ptr) { unsigned long ret; asm ("ld.global.lu.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return ret; }
#line 288 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline char __ldlu(const char *ptr) { unsigned int ret; asm ("ld.global.lu.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return (char)ret; }
static __declspec(__device__) __inline signed char __ldlu(const signed char *ptr) { unsigned int ret; asm ("ld.global.lu.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return (signed char)ret; }
static __declspec(__device__) __inline short __ldlu(const short *ptr) { unsigned short ret; asm ("ld.global.lu.s16 %0, [%1];"  : "=h"(ret) : "l" (ptr) : "memory"); return (short)ret; }
static __declspec(__device__) __inline int __ldlu(const int *ptr) { unsigned int ret; asm ("ld.global.lu.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return (int)ret; }
static __declspec(__device__) __inline long long __ldlu(const long long *ptr) { unsigned long long ret; asm ("ld.global.lu.s64 %0, [%1];"  : "=l"(ret) : "l" (ptr) : "memory"); return (long long)ret; }
static __declspec(__device__) __inline char2 __ldlu(const char2 *ptr) { char2 ret; int2 tmp; asm ("ld.global.lu.v2.s8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr) : "memory"); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __declspec(__device__) __inline char4 __ldlu(const char4 *ptr) { char4 ret; int4 tmp; asm ("ld.global.lu.v4.s8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr) : "memory"); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __declspec(__device__) __inline short2 __ldlu(const short2 *ptr) { short2 ret; asm ("ld.global.lu.v2.s16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline short4 __ldlu(const short4 *ptr) { short4 ret; asm ("ld.global.lu.v4.s16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline int2 __ldlu(const int2 *ptr) { int2 ret; asm ("ld.global.lu.v2.s32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline int4 __ldlu(const int4 *ptr) { int4 ret; asm ("ld.global.lu.v4.s32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline longlong2 __ldlu(const longlong2 *ptr) { longlong2 ret; asm ("ld.global.lu.v2.s64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr) : "memory"); return ret; }

static __declspec(__device__) __inline unsigned char __ldlu(const unsigned char *ptr) { unsigned int ret; asm ("ld.global.lu.u8 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory");  return (unsigned char)ret; }
static __declspec(__device__) __inline unsigned short __ldlu(const unsigned short *ptr) { unsigned short ret; asm ("ld.global.lu.u16 %0, [%1];"  : "=h"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline unsigned int __ldlu(const unsigned int *ptr) { unsigned int ret; asm ("ld.global.lu.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline unsigned long long __ldlu(const unsigned long long *ptr) { unsigned long long ret; asm ("ld.global.lu.u64 %0, [%1];"  : "=l"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline uchar2 __ldlu(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm ("ld.global.lu.v2.u8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr) : "memory"); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __declspec(__device__) __inline uchar4 __ldlu(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm ("ld.global.lu.v4.u8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr) : "memory"); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __declspec(__device__) __inline ushort2 __ldlu(const ushort2 *ptr) { ushort2 ret; asm ("ld.global.lu.v2.u16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline ushort4 __ldlu(const ushort4 *ptr) { ushort4 ret; asm ("ld.global.lu.v4.u16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline uint2 __ldlu(const uint2 *ptr) { uint2 ret; asm ("ld.global.lu.v2.u32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline uint4 __ldlu(const uint4 *ptr) { uint4 ret; asm ("ld.global.lu.v4.u32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline ulonglong2 __ldlu(const ulonglong2 *ptr) { ulonglong2 ret; asm ("ld.global.lu.v2.u64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr) : "memory"); return ret; }

static __declspec(__device__) __inline float __ldlu(const float *ptr) { float ret; asm ("ld.global.lu.f32 %0, [%1];"  : "=f"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline double __ldlu(const double *ptr) { double ret; asm ("ld.global.lu.f64 %0, [%1];"  : "=d"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline float2 __ldlu(const float2 *ptr) { float2 ret; asm ("ld.global.lu.v2.f32 {%0,%1}, [%2];"  : "=f"(ret.x), "=f"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline float4 __ldlu(const float4 *ptr) { float4 ret; asm ("ld.global.lu.v4.f32 {%0,%1,%2,%3}, [%4];"  : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline double2 __ldlu(const double2 *ptr) { double2 ret; asm ("ld.global.lu.v2.f64 {%0,%1}, [%2];"  : "=d"(ret.x), "=d"(ret.y) : "l" (ptr) : "memory"); return ret; }









#line 330 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline long __ldcv(const long *ptr) { unsigned long ret; asm ("ld.global.cv.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return (long)ret; }
static __declspec(__device__) __inline unsigned long __ldcv(const unsigned long *ptr) { unsigned long ret; asm ("ld.global.cv.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return ret; }
#line 333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline char __ldcv(const char *ptr) { unsigned int ret; asm ("ld.global.cv.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return (char)ret; }
static __declspec(__device__) __inline signed char __ldcv(const signed char *ptr) { unsigned int ret; asm ("ld.global.cv.s8 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return (signed char)ret; }
static __declspec(__device__) __inline short __ldcv(const short *ptr) { unsigned short ret; asm ("ld.global.cv.s16 %0, [%1];"  : "=h"(ret) : "l" (ptr) : "memory"); return (short)ret; }
static __declspec(__device__) __inline int __ldcv(const int *ptr) { unsigned int ret; asm ("ld.global.cv.s32 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return (int)ret; }
static __declspec(__device__) __inline long long __ldcv(const long long *ptr) { unsigned long long ret; asm ("ld.global.cv.s64 %0, [%1];"  : "=l"(ret) : "l" (ptr) : "memory"); return (long long)ret; }
static __declspec(__device__) __inline char2 __ldcv(const char2 *ptr) { char2 ret; int2 tmp; asm ("ld.global.cv.v2.s8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr) : "memory"); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __declspec(__device__) __inline char4 __ldcv(const char4 *ptr) { char4 ret; int4 tmp; asm ("ld.global.cv.v4.s8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr) : "memory"); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __declspec(__device__) __inline short2 __ldcv(const short2 *ptr) { short2 ret; asm ("ld.global.cv.v2.s16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline short4 __ldcv(const short4 *ptr) { short4 ret; asm ("ld.global.cv.v4.s16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline int2 __ldcv(const int2 *ptr) { int2 ret; asm ("ld.global.cv.v2.s32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline int4 __ldcv(const int4 *ptr) { int4 ret; asm ("ld.global.cv.v4.s32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline longlong2 __ldcv(const longlong2 *ptr) { longlong2 ret; asm ("ld.global.cv.v2.s64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr) : "memory"); return ret; }

static __declspec(__device__) __inline unsigned char __ldcv(const unsigned char *ptr) { unsigned int ret; asm ("ld.global.cv.u8 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory");  return (unsigned char)ret; }
static __declspec(__device__) __inline unsigned short __ldcv(const unsigned short *ptr) { unsigned short ret; asm ("ld.global.cv.u16 %0, [%1];"  : "=h"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline unsigned int __ldcv(const unsigned int *ptr) { unsigned int ret; asm ("ld.global.cv.u32 %0, [%1];"  : "=r"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline unsigned long long __ldcv(const unsigned long long *ptr) { unsigned long long ret; asm ("ld.global.cv.u64 %0, [%1];"  : "=l"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline uchar2 __ldcv(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm ("ld.global.cv.v2.u8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr) : "memory"); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __declspec(__device__) __inline uchar4 __ldcv(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm ("ld.global.cv.v4.u8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr) : "memory"); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __declspec(__device__) __inline ushort2 __ldcv(const ushort2 *ptr) { ushort2 ret; asm ("ld.global.cv.v2.u16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline ushort4 __ldcv(const ushort4 *ptr) { ushort4 ret; asm ("ld.global.cv.v4.u16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline uint2 __ldcv(const uint2 *ptr) { uint2 ret; asm ("ld.global.cv.v2.u32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline uint4 __ldcv(const uint4 *ptr) { uint4 ret; asm ("ld.global.cv.v4.u32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline ulonglong2 __ldcv(const ulonglong2 *ptr) { ulonglong2 ret; asm ("ld.global.cv.v2.u64 {%0,%1}, [%2];"  : "=l"(ret.x), "=l"(ret.y) : "l" (ptr) : "memory"); return ret; }

static __declspec(__device__) __inline float __ldcv(const float *ptr) { float ret; asm ("ld.global.cv.f32 %0, [%1];"  : "=f"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline double __ldcv(const double *ptr) { double ret; asm ("ld.global.cv.f64 %0, [%1];"  : "=d"(ret) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline float2 __ldcv(const float2 *ptr) { float2 ret; asm ("ld.global.cv.v2.f32 {%0,%1}, [%2];"  : "=f"(ret.x), "=f"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline float4 __ldcv(const float4 *ptr) { float4 ret; asm ("ld.global.cv.v4.f32 {%0,%1,%2,%3}, [%4];"  : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __declspec(__device__) __inline double2 __ldcv(const double2 *ptr) { double2 ret; asm ("ld.global.cv.v2.f64 {%0,%1}, [%2];"  : "=d"(ret.x), "=d"(ret.y) : "l" (ptr) : "memory"); return ret; }









#line 375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline void __stwb(long *ptr, long value) { asm ("st.global.wb.s32 [%0], %1;"  :: "l" (ptr),  "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(unsigned long *ptr, unsigned long value) { asm ("st.global.wb.u32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
#line 378 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline void __stwb(char *ptr, char value) { asm ("st.global.wb.s8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory"); }
static __declspec(__device__) __inline void __stwb(signed char *ptr, signed char value) { asm ("st.global.wb.s8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory"); }
static __declspec(__device__) __inline void __stwb(short *ptr, short value) { asm ("st.global.wb.s16 [%0], %1;"  :: "l" (ptr), "h"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(int *ptr, int value) { asm ("st.global.wb.s32 [%0], %1;"  :: "l" (ptr), "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(long long *ptr, long long value) { asm ("st.global.wb.s64 [%0], %1;"  :: "l" (ptr), "l"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(char2 *ptr, char2 value) { const int x = value.x, y = value.y; asm ("st.global.wb.v2.s8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __declspec(__device__) __inline void __stwb(char4 *ptr, char4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.wb.v4.s8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __declspec(__device__) __inline void __stwb(short2 *ptr, short2 value) { asm ("st.global.wb.v2.s16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwb(short4 *ptr, short4 value) { asm ("st.global.wb.v4.s16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwb(int2 *ptr, int2 value) { asm ("st.global.wb.v2.s32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwb(int4 *ptr, int4 value) { asm ("st.global.wb.v4.s32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwb(longlong2 *ptr, longlong2 value) { asm ("st.global.wb.v2.s64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __declspec(__device__) __inline void __stwb(unsigned char *ptr, unsigned char value) { asm ("st.global.wb.u8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory");  }
static __declspec(__device__) __inline void __stwb(unsigned short *ptr, unsigned short value) { asm ("st.global.wb.u16 [%0], %1;"  :: "l" (ptr), "h"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(unsigned int *ptr, unsigned int value) { asm ("st.global.wb.u32 [%0], %1;"  :: "l" (ptr), "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(unsigned long long *ptr, unsigned long long value) { asm ("st.global.wb.u64 [%0], %1;"  :: "l" (ptr), "l"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(uchar2 *ptr, uchar2 value) { const int x = value.x, y = value.y; asm ("st.global.wb.v2.u8 [%0], {%1,%2};"  :: "l" (ptr),  "r"(x), "r"(y) : "memory"); }
static __declspec(__device__) __inline void __stwb(uchar4 *ptr, uchar4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.wb.v4.u8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __declspec(__device__) __inline void __stwb(ushort2 *ptr, ushort2 value) { asm ("st.global.wb.v2.u16 [%0], {%1,%2};"  :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwb(ushort4 *ptr, ushort4 value) { asm ("st.global.wb.v4.u16 [%0], {%1,%2,%3,%4};"  :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwb(uint2 *ptr, uint2 value) { asm ("st.global.wb.v2.u32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwb(uint4 *ptr, uint4 value) { asm ("st.global.wb.v4.u32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwb(ulonglong2 *ptr, ulonglong2 value) { asm ("st.global.wb.v2.u64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __declspec(__device__) __inline void __stwb(float *ptr, float value) { asm ("st.global.wb.f32 [%0], %1;"  :: "l" (ptr), "f"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(double *ptr, double value) { asm ("st.global.wb.f64 [%0], %1;"  :: "l" (ptr), "d"(value) : "memory"); }
static __declspec(__device__) __inline void __stwb(float2 *ptr, float2 value) { asm ("st.global.wb.v2.f32 [%0], {%1,%2};"  :: "l" (ptr), "f"(value.x), "f"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwb(float4 *ptr, float4 value) { asm ("st.global.wb.v4.f32 [%0], {%1,%2,%3,%4};"  :: "l" (ptr), "f"(value.x), "f"(value.y), "f"(value.z), "f"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwb(double2 *ptr, double2 value) { asm ("st.global.wb.v2.f64 [%0], {%1,%2};"  :: "l" (ptr), "d"(value.x), "d"(value.y) : "memory"); }









#line 420 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline void __stcg(long *ptr, long value) { asm ("st.global.cg.s32 [%0], %1;"  :: "l" (ptr),  "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(unsigned long *ptr, unsigned long value) { asm ("st.global.cg.u32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
#line 423 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline void __stcg(char *ptr, char value) { asm ("st.global.cg.s8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory"); }
static __declspec(__device__) __inline void __stcg(signed char *ptr, signed char value) { asm ("st.global.cg.s8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory"); }
static __declspec(__device__) __inline void __stcg(short *ptr, short value) { asm ("st.global.cg.s16 [%0], %1;"  :: "l" (ptr), "h"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(int *ptr, int value) { asm ("st.global.cg.s32 [%0], %1;"  :: "l" (ptr), "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(long long *ptr, long long value) { asm ("st.global.cg.s64 [%0], %1;"  :: "l" (ptr), "l"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(char2 *ptr, char2 value) { const int x = value.x, y = value.y; asm ("st.global.cg.v2.s8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __declspec(__device__) __inline void __stcg(char4 *ptr, char4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.cg.v4.s8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __declspec(__device__) __inline void __stcg(short2 *ptr, short2 value) { asm ("st.global.cg.v2.s16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcg(short4 *ptr, short4 value) { asm ("st.global.cg.v4.s16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcg(int2 *ptr, int2 value) { asm ("st.global.cg.v2.s32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcg(int4 *ptr, int4 value) { asm ("st.global.cg.v4.s32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcg(longlong2 *ptr, longlong2 value) { asm ("st.global.cg.v2.s64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __declspec(__device__) __inline void __stcg(unsigned char *ptr, unsigned char value) { asm ("st.global.cg.u8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory");  }
static __declspec(__device__) __inline void __stcg(unsigned short *ptr, unsigned short value) { asm ("st.global.cg.u16 [%0], %1;"  :: "l" (ptr), "h"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(unsigned int *ptr, unsigned int value) { asm ("st.global.cg.u32 [%0], %1;"  :: "l" (ptr), "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(unsigned long long *ptr, unsigned long long value) { asm ("st.global.cg.u64 [%0], %1;"  :: "l" (ptr), "l"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(uchar2 *ptr, uchar2 value) { const int x = value.x, y = value.y; asm ("st.global.cg.v2.u8 [%0], {%1,%2};"  :: "l" (ptr),  "r"(x), "r"(y) : "memory"); }
static __declspec(__device__) __inline void __stcg(uchar4 *ptr, uchar4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.cg.v4.u8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __declspec(__device__) __inline void __stcg(ushort2 *ptr, ushort2 value) { asm ("st.global.cg.v2.u16 [%0], {%1,%2};"  :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcg(ushort4 *ptr, ushort4 value) { asm ("st.global.cg.v4.u16 [%0], {%1,%2,%3,%4};"  :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcg(uint2 *ptr, uint2 value) { asm ("st.global.cg.v2.u32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcg(uint4 *ptr, uint4 value) { asm ("st.global.cg.v4.u32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcg(ulonglong2 *ptr, ulonglong2 value) { asm ("st.global.cg.v2.u64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __declspec(__device__) __inline void __stcg(float *ptr, float value) { asm ("st.global.cg.f32 [%0], %1;"  :: "l" (ptr), "f"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(double *ptr, double value) { asm ("st.global.cg.f64 [%0], %1;"  :: "l" (ptr), "d"(value) : "memory"); }
static __declspec(__device__) __inline void __stcg(float2 *ptr, float2 value) { asm ("st.global.cg.v2.f32 [%0], {%1,%2};"  :: "l" (ptr), "f"(value.x), "f"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcg(float4 *ptr, float4 value) { asm ("st.global.cg.v4.f32 [%0], {%1,%2,%3,%4};"  :: "l" (ptr), "f"(value.x), "f"(value.y), "f"(value.z), "f"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcg(double2 *ptr, double2 value) { asm ("st.global.cg.v2.f64 [%0], {%1,%2};"  :: "l" (ptr), "d"(value.x), "d"(value.y) : "memory"); }









#line 465 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline void __stcs(long *ptr, long value) { asm ("st.global.cs.s32 [%0], %1;"  :: "l" (ptr),  "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(unsigned long *ptr, unsigned long value) { asm ("st.global.cs.u32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
#line 468 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline void __stcs(char *ptr, char value) { asm ("st.global.cs.s8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory"); }
static __declspec(__device__) __inline void __stcs(signed char *ptr, signed char value) { asm ("st.global.cs.s8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory"); }
static __declspec(__device__) __inline void __stcs(short *ptr, short value) { asm ("st.global.cs.s16 [%0], %1;"  :: "l" (ptr), "h"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(int *ptr, int value) { asm ("st.global.cs.s32 [%0], %1;"  :: "l" (ptr), "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(long long *ptr, long long value) { asm ("st.global.cs.s64 [%0], %1;"  :: "l" (ptr), "l"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(char2 *ptr, char2 value) { const int x = value.x, y = value.y; asm ("st.global.cs.v2.s8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __declspec(__device__) __inline void __stcs(char4 *ptr, char4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.cs.v4.s8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __declspec(__device__) __inline void __stcs(short2 *ptr, short2 value) { asm ("st.global.cs.v2.s16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcs(short4 *ptr, short4 value) { asm ("st.global.cs.v4.s16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcs(int2 *ptr, int2 value) { asm ("st.global.cs.v2.s32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcs(int4 *ptr, int4 value) { asm ("st.global.cs.v4.s32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcs(longlong2 *ptr, longlong2 value) { asm ("st.global.cs.v2.s64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __declspec(__device__) __inline void __stcs(unsigned char *ptr, unsigned char value) { asm ("st.global.cs.u8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory");  }
static __declspec(__device__) __inline void __stcs(unsigned short *ptr, unsigned short value) { asm ("st.global.cs.u16 [%0], %1;"  :: "l" (ptr), "h"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(unsigned int *ptr, unsigned int value) { asm ("st.global.cs.u32 [%0], %1;"  :: "l" (ptr), "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(unsigned long long *ptr, unsigned long long value) { asm ("st.global.cs.u64 [%0], %1;"  :: "l" (ptr), "l"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(uchar2 *ptr, uchar2 value) { const int x = value.x, y = value.y; asm ("st.global.cs.v2.u8 [%0], {%1,%2};"  :: "l" (ptr),  "r"(x), "r"(y) : "memory"); }
static __declspec(__device__) __inline void __stcs(uchar4 *ptr, uchar4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.cs.v4.u8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __declspec(__device__) __inline void __stcs(ushort2 *ptr, ushort2 value) { asm ("st.global.cs.v2.u16 [%0], {%1,%2};"  :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcs(ushort4 *ptr, ushort4 value) { asm ("st.global.cs.v4.u16 [%0], {%1,%2,%3,%4};"  :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcs(uint2 *ptr, uint2 value) { asm ("st.global.cs.v2.u32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcs(uint4 *ptr, uint4 value) { asm ("st.global.cs.v4.u32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcs(ulonglong2 *ptr, ulonglong2 value) { asm ("st.global.cs.v2.u64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __declspec(__device__) __inline void __stcs(float *ptr, float value) { asm ("st.global.cs.f32 [%0], %1;"  :: "l" (ptr), "f"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(double *ptr, double value) { asm ("st.global.cs.f64 [%0], %1;"  :: "l" (ptr), "d"(value) : "memory"); }
static __declspec(__device__) __inline void __stcs(float2 *ptr, float2 value) { asm ("st.global.cs.v2.f32 [%0], {%1,%2};"  :: "l" (ptr), "f"(value.x), "f"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stcs(float4 *ptr, float4 value) { asm ("st.global.cs.v4.f32 [%0], {%1,%2,%3,%4};"  :: "l" (ptr), "f"(value.x), "f"(value.y), "f"(value.z), "f"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stcs(double2 *ptr, double2 value) { asm ("st.global.cs.v2.f64 [%0], {%1,%2};"  :: "l" (ptr), "d"(value.x), "d"(value.y) : "memory"); }









#line 510 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"
static __declspec(__device__) __inline void __stwt(long *ptr, long value) { asm ("st.global.wt.s32 [%0], %1;"  :: "l" (ptr),  "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(unsigned long *ptr, unsigned long value) { asm ("st.global.wt.u32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
#line 513 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"


static __declspec(__device__) __inline void __stwt(char *ptr, char value) { asm ("st.global.wt.s8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory"); }
static __declspec(__device__) __inline void __stwt(signed char *ptr, signed char value) { asm ("st.global.wt.s8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory"); }
static __declspec(__device__) __inline void __stwt(short *ptr, short value) { asm ("st.global.wt.s16 [%0], %1;"  :: "l" (ptr), "h"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(int *ptr, int value) { asm ("st.global.wt.s32 [%0], %1;"  :: "l" (ptr), "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(long long *ptr, long long value) { asm ("st.global.wt.s64 [%0], %1;"  :: "l" (ptr), "l"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(char2 *ptr, char2 value) { const int x = value.x, y = value.y; asm ("st.global.wt.v2.s8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __declspec(__device__) __inline void __stwt(char4 *ptr, char4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.wt.v4.s8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __declspec(__device__) __inline void __stwt(short2 *ptr, short2 value) { asm ("st.global.wt.v2.s16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwt(short4 *ptr, short4 value) { asm ("st.global.wt.v4.s16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwt(int2 *ptr, int2 value) { asm ("st.global.wt.v2.s32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwt(int4 *ptr, int4 value) { asm ("st.global.wt.v4.s32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwt(longlong2 *ptr, longlong2 value) { asm ("st.global.wt.v2.s64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __declspec(__device__) __inline void __stwt(unsigned char *ptr, unsigned char value) { asm ("st.global.wt.u8 [%0], %1;"  :: "l" (ptr), "r"((int)value) : "memory");  }
static __declspec(__device__) __inline void __stwt(unsigned short *ptr, unsigned short value) { asm ("st.global.wt.u16 [%0], %1;"  :: "l" (ptr), "h"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(unsigned int *ptr, unsigned int value) { asm ("st.global.wt.u32 [%0], %1;"  :: "l" (ptr), "r"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(unsigned long long *ptr, unsigned long long value) { asm ("st.global.wt.u64 [%0], %1;"  :: "l" (ptr), "l"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(uchar2 *ptr, uchar2 value) { const int x = value.x, y = value.y; asm ("st.global.wt.v2.u8 [%0], {%1,%2};"  :: "l" (ptr),  "r"(x), "r"(y) : "memory"); }
static __declspec(__device__) __inline void __stwt(uchar4 *ptr, uchar4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.wt.v4.u8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __declspec(__device__) __inline void __stwt(ushort2 *ptr, ushort2 value) { asm ("st.global.wt.v2.u16 [%0], {%1,%2};"  :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwt(ushort4 *ptr, ushort4 value) { asm ("st.global.wt.v4.u16 [%0], {%1,%2,%3,%4};"  :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwt(uint2 *ptr, uint2 value) { asm ("st.global.wt.v2.u32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwt(uint4 *ptr, uint4 value) { asm ("st.global.wt.v4.u32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwt(ulonglong2 *ptr, ulonglong2 value) { asm ("st.global.wt.v2.u64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __declspec(__device__) __inline void __stwt(float *ptr, float value) { asm ("st.global.wt.f32 [%0], %1;"  :: "l" (ptr), "f"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(double *ptr, double value) { asm ("st.global.wt.f64 [%0], %1;"  :: "l" (ptr), "d"(value) : "memory"); }
static __declspec(__device__) __inline void __stwt(float2 *ptr, float2 value) { asm ("st.global.wt.v2.f32 [%0], {%1,%2};"  :: "l" (ptr), "f"(value.x), "f"(value.y) : "memory"); }
static __declspec(__device__) __inline void __stwt(float4 *ptr, float4 value) { asm ("st.global.wt.v4.f32 [%0], {%1,%2,%3,%4};"  :: "l" (ptr), "f"(value.x), "f"(value.y), "f"(value.z), "f"(value.w) : "memory"); }
static __declspec(__device__) __inline void __stwt(double2 *ptr, double2 value) { asm ("st.global.wt.v2.f64 [%0], {%1,%2};"  :: "l" (ptr), "d"(value.x), "d"(value.y) : "memory"); }








static __declspec(__device__) __inline unsigned int __funnelshift_l(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
static __declspec(__device__) __inline unsigned int __funnelshift_lc(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.l.clamp.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}


static __declspec(__device__) __inline unsigned int __funnelshift_r(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.r.wrap.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
static __declspec(__device__) __inline unsigned int __funnelshift_rc(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.r.clamp.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}


#line 582 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"

#line 584 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"



#line 588 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.hpp"

#line 508 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
#line 509 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"

#line 511 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
#line 3297 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_35_intrinsics.h"














































































































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"





























































































































































































































































































































































































































































































































#line 511 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_32_intrinsics.h"
#line 112 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_35_intrinsics.h"



#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_35_intrinsics.h"

#line 3298 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"





#line 76 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"













static __declspec(__device__) __inline int __dp2a_lo(int srcA, int srcB, int c) ;
static __declspec(__device__) __inline unsigned int __dp2a_lo(unsigned int srcA, unsigned int srcB, unsigned int c) ;

static __declspec(__device__) __inline int __dp2a_lo(short2 srcA, char4 srcB, int c) ;
static __declspec(__device__) __inline unsigned int __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned int c) ;

static __declspec(__device__) __inline int __dp2a_hi(int srcA, int srcB, int c) ;
static __declspec(__device__) __inline unsigned int __dp2a_hi(unsigned int srcA, unsigned int srcB, unsigned int c) ;

static __declspec(__device__) __inline int __dp2a_hi(short2 srcA, char4 srcB, int c) ;
static __declspec(__device__) __inline unsigned int __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned int c) ;






static __declspec(__device__) __inline int __dp4a(int srcA, int srcB, int c) ;
static __declspec(__device__) __inline unsigned int __dp4a(unsigned int srcA, unsigned int srcB, unsigned int c) ;

static __declspec(__device__) __inline int __dp4a(char4 srcA, char4 srcB, int c) ;
static __declspec(__device__) __inline unsigned int __dp4a(uchar4 srcA, uchar4 srcB, unsigned int c) ;

#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"

#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.hpp"






















































#line 56 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.hpp"

#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.hpp"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.hpp"









static __declspec(__device__) __inline int __dp4a(int srcA, int srcB, int c) {
    int ret;
    asm volatile ("dp4a.s32.s32 %0, %1, %2, %3;" : "=r"(ret) : "r"(srcA), "r"(srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline unsigned int __dp4a(unsigned int srcA, unsigned int srcB, unsigned int c) {
    unsigned int ret;
    asm volatile ("dp4a.u32.u32 %0, %1, %2, %3;" : "=r"(ret) : "r"(srcA), "r"(srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline int __dp4a(char4 srcA, char4 srcB, int c) {
    int ret;
    asm volatile ("dp4a.s32.s32 %0, %1, %2, %3;" : "=r"(ret) : "r"(*(int *)&srcA), "r"(*(int *)&srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline unsigned int __dp4a(uchar4 srcA, uchar4 srcB, unsigned int c) {
    unsigned int ret;
    asm volatile ("dp4a.u32.u32 %0, %1, %2, %3;" : "=r"(ret) : "r"(*(unsigned int *)&srcA), "r"(*(unsigned int *)&srcB), "r"(c));
    return ret;
}


static __declspec(__device__) __inline int __dp2a_lo(int srcA, int srcB, int c) {
    int ret;
    asm volatile ("dp2a.lo.s32.s32 %0, %1, %2, %3;" : "=r"(ret) : "r"(srcA), "r"(srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline unsigned int __dp2a_lo(unsigned int srcA, unsigned int srcB, unsigned int c) {
    unsigned int ret;
    asm volatile ("dp2a.lo.u32.u32 %0, %1, %2, %3;" : "=r"(ret) : "r"(srcA), "r"(srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline int __dp2a_lo(short2 srcA, char4 srcB, int c) {
    int ret;
    asm volatile ("dp2a.lo.s32.s32 %0, %1, %2, %3;" : "=r"(ret) : "r"(*(int *)&srcA), "r"(*(int *)&srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline unsigned int __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned int c) {
    unsigned int ret;
    asm volatile ("dp2a.lo.u32.u32 %0, %1, %2, %3;" : "=r"(ret) : "r"(*(unsigned int *)&srcA), "r"(*(unsigned int *)&srcB), "r"(c));
    return ret;
}


static __declspec(__device__) __inline int __dp2a_hi(int srcA, int srcB, int c) {
    int ret;
    asm volatile ("dp2a.hi.s32.s32 %0, %1, %2, %3;" : "=r"(ret) : "r"(srcA), "r"(srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline unsigned int __dp2a_hi(unsigned int srcA, unsigned int srcB, unsigned int c) {
    unsigned int ret;
    asm volatile ("dp2a.hi.u32.u32 %0, %1, %2, %3;" : "=r"(ret) : "r"(srcA), "r"(srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline int __dp2a_hi(short2 srcA, char4 srcB, int c) {
    int ret;
    asm volatile ("dp2a.hi.s32.s32 %0, %1, %2, %3;" : "=r"(ret) : "r"(*(int *)&srcA), "r"(*(int *)&srcB), "r"(c));
    return ret;
}

static __declspec(__device__) __inline unsigned int __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned int c) {
    unsigned int ret;
    asm volatile ("dp2a.hi.u32.u32 %0, %1, %2, %3;" : "=r"(ret) : "r"(*(unsigned int *)&srcA), "r"(*(unsigned int *)&srcB), "r"(c));
    return ret;
}


#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.hpp"

#line 157 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.hpp"



#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.hpp"

#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
#line 122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"

#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\sm_61_intrinsics.h"
#line 3299 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"






#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"

#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"





#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"





static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, unsigned value) ;
static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, int value) ;
static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, unsigned long value) ;
static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, long value) ;
static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, unsigned long long value) ;
static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, long long value) ;
static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, float value) ;
static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, double value) ;

static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, unsigned value, int *pred) ;
static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, int value, int *pred) ;
static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, unsigned long value, int *pred) ;
static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, long value, int *pred) ;
static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, unsigned long long value, int *pred) ;
static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, long long value, int *pred) ;
static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, float value, int *pred) ;
static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, double value, int *pred) ;

static __declspec(__device__) __inline void __nanosleep(unsigned int ns) ;

static __declspec(__device__) __inline unsigned short int atomicCAS(unsigned short int *address, unsigned short int compare, unsigned short int val) ;

#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"

#line 118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"






#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"

#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"











static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, unsigned value) {
  return __match32_any_sync(mask, value);
}

static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, int value) {
  return __match32_any_sync(mask, value);
}

static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, unsigned long value) {
  return (sizeof(long) == sizeof(long long)) ?
    __match64_any_sync(mask, (unsigned long long)value):
    __match32_any_sync(mask, (unsigned)value);
}

static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, long value) {
  return (sizeof(long) == sizeof(long long)) ?
    __match64_any_sync(mask, (unsigned long long)value):
    __match32_any_sync(mask, (unsigned)value);
}

static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, unsigned long long value) {
  return __match64_any_sync(mask, value);
}

static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, long long value) {
  return __match64_any_sync(mask, value);
}

static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, float value) {
  return __match32_any_sync(mask, __float_as_uint(value));
}

static __declspec(__device__) __inline unsigned int __match_any_sync(unsigned mask, double value) {
  return __match64_any_sync(mask, __double_as_longlong(value));
}




static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, unsigned value, int *pred) {
  return __match32_all_sync(mask, value, pred);
}

static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, int value, int *pred) {
  return __match32_all_sync(mask, value, pred);
}

static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, unsigned long value, int *pred) {
  return (sizeof(long) == sizeof(long long)) ?
    __match64_all_sync(mask, (unsigned long long)value, pred):
    __match32_all_sync(mask, (unsigned)value, pred);
}

static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, long value, int *pred) {
  return (sizeof(long) == sizeof(long long)) ?
    __match64_all_sync(mask, (unsigned long long)value, pred):
    __match32_all_sync(mask, (unsigned)value, pred);
}

static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, unsigned long long value, int *pred) {
  return __match64_all_sync(mask, value, pred);
}

static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, long long value, int *pred) {
  return __match64_all_sync(mask, value, pred);
}

static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, float value, int *pred) {
  return __match32_all_sync(mask, __float_as_uint(value), pred);
}

static __declspec(__device__) __inline unsigned int __match_all_sync(unsigned mask, double value, int *pred) {
  return __match64_all_sync(mask, __double_as_longlong(value), pred);
}

static __declspec(__device__) __inline void __nanosleep(unsigned int ns) {
    asm volatile("nanosleep.u32 %0;" :: "r"(ns));
}


extern "C" __declspec(__device__) __declspec(__device_builtin__)
unsigned short __usAtomicCAS(unsigned short *, unsigned short, unsigned short);

static __declspec(__device__) __inline unsigned short int atomicCAS(unsigned short int *address, unsigned short int compare, unsigned short int val) {
  return __usAtomicCAS(address, compare, val);
}


#line 182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"

#line 184 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"



#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"




#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.hpp"
#line 124 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
#line 125 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"

#line 127 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"




#line 132 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_70_rt.h"
#line 3300 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"






#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"

#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"





#line 88 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"





static __declspec(__device__) __inline unsigned __reduce_add_sync(unsigned mask, unsigned value) ;
static __declspec(__device__) __inline unsigned __reduce_min_sync(unsigned mask, unsigned value) ;
static __declspec(__device__) __inline unsigned __reduce_max_sync(unsigned mask, unsigned value) ;

static __declspec(__device__) __inline int __reduce_add_sync(unsigned mask, int value) ;
static __declspec(__device__) __inline int __reduce_min_sync(unsigned mask, int value) ;
static __declspec(__device__) __inline int __reduce_max_sync(unsigned mask, int value) ;

static __declspec(__device__) __inline unsigned __reduce_and_sync(unsigned mask, unsigned value) ;
static __declspec(__device__) __inline unsigned __reduce_or_sync(unsigned mask, unsigned value) ;
static __declspec(__device__) __inline unsigned __reduce_xor_sync(unsigned mask, unsigned value) ;


extern "C" {
inline __declspec(__device__) void *__nv_associate_access_property(const void *ptr, 
                                                       unsigned long long property) {
  extern __declspec(__device__) void *__nv_associate_access_property_impl(const void *,
                                                              unsigned long long);
  return __nv_associate_access_property_impl(ptr, property);
}

inline __declspec(__device__)  void __nv_memcpy_async_shared_global_4(void *dst, 
                                                          const void *src, 
                                                          unsigned src_size) {
  extern __declspec(__device__) void __nv_memcpy_async_shared_global_4_impl(void *, 
                                                                const void *, 
                                                                unsigned);
  __nv_memcpy_async_shared_global_4_impl(dst, src, src_size);
}

inline __declspec(__device__)  void __nv_memcpy_async_shared_global_8(void *dst, 
                                                          const void *src, 
                                                          unsigned src_size) {
  extern __declspec(__device__) void __nv_memcpy_async_shared_global_8_impl(void *, 
                                                                const void *, 
                                                                unsigned);
  __nv_memcpy_async_shared_global_8_impl(dst, src, src_size);
}

inline __declspec(__device__)  void __nv_memcpy_async_shared_global_16(void *dst, 
                                                          const void *src, 
                                                          unsigned src_size) {
  extern __declspec(__device__) void __nv_memcpy_async_shared_global_16_impl(void *, 
                                                                const void *, 
                                                                unsigned);
  __nv_memcpy_async_shared_global_16_impl(dst, src, src_size);
}

}
#line 143 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"

#line 145 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"






#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"

#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"











#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 57 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"


#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3094 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\driver_types.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"

#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"






















































































































#line 120 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
























































































































































































































































































#line 282 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\builtin_types.h"
#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
















































































#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_types.h"
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"





































































































































































































#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"




#line 262 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\host_defines.h"
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"








extern "C" { 
  __declspec(__device_builtin__) __declspec(__device__) unsigned __reduce_add_sync_unsigned_impl(unsigned, unsigned);
  __declspec(__device_builtin__) __declspec(__device__) unsigned __reduce_min_sync_unsigned_impl(unsigned, unsigned);
  __declspec(__device_builtin__) __declspec(__device__) unsigned __reduce_max_sync_unsigned_impl(unsigned, unsigned);
  __declspec(__device_builtin__) __declspec(__device__) int __reduce_add_sync_signed_impl(unsigned, int);
  __declspec(__device_builtin__) __declspec(__device__) int __reduce_min_sync_signed_impl(unsigned, int);
  __declspec(__device_builtin__) __declspec(__device__) int __reduce_max_sync_signed_impl(unsigned, int);
  __declspec(__device_builtin__) __declspec(__device__) unsigned __reduce_or_sync_unsigned_impl(unsigned, unsigned);
  __declspec(__device_builtin__) __declspec(__device__) unsigned __reduce_and_sync_unsigned_impl(unsigned, unsigned);
  __declspec(__device_builtin__) __declspec(__device__) unsigned __reduce_xor_sync_unsigned_impl(unsigned, unsigned);
}

static __declspec(__device__) __inline unsigned __reduce_add_sync(unsigned mask, unsigned value) {
  return __reduce_add_sync_unsigned_impl(mask, value);
}

static __declspec(__device__) __inline unsigned __reduce_min_sync(unsigned mask, unsigned value) {
  return __reduce_min_sync_unsigned_impl(mask, value);
}

static __declspec(__device__) __inline unsigned __reduce_max_sync(unsigned mask, unsigned value) {
  return __reduce_max_sync_unsigned_impl(mask, value);
}

static __declspec(__device__) __inline int __reduce_add_sync(unsigned mask, int value) {
  return __reduce_add_sync_signed_impl(mask, value);
}
  
static __declspec(__device__) __inline int __reduce_min_sync(unsigned mask, int value) {
  return __reduce_min_sync_signed_impl(mask, value);
}

static __declspec(__device__) __inline int __reduce_max_sync(unsigned mask, int value) {
  return __reduce_max_sync_signed_impl(mask, value);
}

static __declspec(__device__) __inline unsigned __reduce_and_sync(unsigned mask, unsigned value) {
  return __reduce_and_sync_unsigned_impl(mask, value);
}

static __declspec(__device__) __inline unsigned __reduce_or_sync(unsigned mask, unsigned value) {
  return __reduce_or_sync_unsigned_impl(mask, value);
}

static __declspec(__device__) __inline unsigned __reduce_xor_sync(unsigned mask, unsigned value) {
  return __reduce_xor_sync_unsigned_impl(mask, value);
}
#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"

#line 140 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"



#line 144 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"




#line 149 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.hpp"
#line 151 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
#line 152 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"

#line 154 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"




#line 159 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_80_rt.h"
#line 3301 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"






#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"

#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"





































#line 106 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"

#line 108 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"





#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.hpp"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.hpp"






#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.hpp"

#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.hpp"




























































































































#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.hpp"

#line 195 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.hpp"



#line 199 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.hpp"




#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.hpp"
#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"

#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"




#line 122 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\sm_90_rt.h"
#line 3302 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"




























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"






































































































#line 104 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_surface_types.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"





#line 69 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"




template <typename T> struct __nv_surf_trait {  typedef void * cast_type; };

template<> struct __nv_surf_trait<char> {  typedef char * cast_type; };
template<> struct __nv_surf_trait<signed char> {  typedef signed char * cast_type; };
template<> struct __nv_surf_trait<unsigned char> {  typedef unsigned char * cast_type; };
template<> struct __nv_surf_trait<char1> {  typedef char1 * cast_type; };
template<> struct __nv_surf_trait<uchar1> {  typedef uchar1 * cast_type; };
template<> struct __nv_surf_trait<char2> {  typedef char2 * cast_type; };
template<> struct __nv_surf_trait<uchar2> {  typedef uchar2 * cast_type; };
template<> struct __nv_surf_trait<char4> {  typedef char4 * cast_type; };
template<> struct __nv_surf_trait<uchar4> {  typedef uchar4 * cast_type; };
template<> struct __nv_surf_trait<short> {  typedef short * cast_type; };
template<> struct __nv_surf_trait<unsigned short> {  typedef unsigned short * cast_type; };
template<> struct __nv_surf_trait<short1> {  typedef short1 * cast_type; };
template<> struct __nv_surf_trait<ushort1> {  typedef ushort1 * cast_type; };
template<> struct __nv_surf_trait<short2> {  typedef short2 * cast_type; };
template<> struct __nv_surf_trait<ushort2> {  typedef ushort2 * cast_type; };
template<> struct __nv_surf_trait<short4> {  typedef short4 * cast_type; };
template<> struct __nv_surf_trait<ushort4> {  typedef ushort4 * cast_type; };
template<> struct __nv_surf_trait<int> {  typedef int * cast_type; };
template<> struct __nv_surf_trait<unsigned int> {  typedef unsigned int * cast_type; };
template<> struct __nv_surf_trait<int1> {  typedef int1 * cast_type; };
template<> struct __nv_surf_trait<uint1> {  typedef uint1 * cast_type; };
template<> struct __nv_surf_trait<int2> {  typedef int2 * cast_type; };
template<> struct __nv_surf_trait<uint2> {  typedef uint2 * cast_type; };
template<> struct __nv_surf_trait<int4> {  typedef int4 * cast_type; };
template<> struct __nv_surf_trait<uint4> {  typedef uint4 * cast_type; };
template<> struct __nv_surf_trait<long long> {  typedef long long * cast_type; };
template<> struct __nv_surf_trait<unsigned long long> {  typedef unsigned long long * cast_type; };
template<> struct __nv_surf_trait<longlong1> {  typedef longlong1 * cast_type; };
template<> struct __nv_surf_trait<ulonglong1> {  typedef ulonglong1 * cast_type; };
template<> struct __nv_surf_trait<longlong2> {  typedef longlong2 * cast_type; };
template<> struct __nv_surf_trait<ulonglong2> {  typedef ulonglong2 * cast_type; };

template<> struct __nv_surf_trait<long> {  typedef int * cast_type; };
template<> struct __nv_surf_trait<unsigned long> {  typedef unsigned int * cast_type; };
template<> struct __nv_surf_trait<long1> {  typedef int1 * cast_type; };
template<> struct __nv_surf_trait<ulong1> {  typedef uint1 * cast_type; };
template<> struct __nv_surf_trait<long2> {  typedef int2 * cast_type; };
template<> struct __nv_surf_trait<ulong2> {  typedef uint2 * cast_type; };
template<> struct __nv_surf_trait<long4> {  typedef uint4 * cast_type; };
template<> struct __nv_surf_trait<ulong4> {  typedef int4 * cast_type; };
#line 116 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
template<> struct __nv_surf_trait<float> {  typedef float * cast_type; };
template<> struct __nv_surf_trait<float1> {  typedef float1 * cast_type; };
template<> struct __nv_surf_trait<float2> {  typedef float2 * cast_type; };
template<> struct __nv_surf_trait<float4> {  typedef float4 * cast_type; };
#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"

template <typename T>
static __declspec(deprecated) __declspec(__device__)  __forceinline void surf1Dread(T *res, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1Dread_v2", (void *)res, s, surf, x, mode);
#line 128 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline  T surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf1Dread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, mode);
  return temp;
#line 138 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}
  
template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf1Dread(T *res, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf1Dread<T>(surf, x, mode);
#line 146 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template <typename T>
static __declspec(deprecated) __declspec(__device__)  __forceinline void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2Dread_v2", (void *)res, s, surf, x, y, mode);
#line 155 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline  T surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf2Dread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, mode);
  return temp;
#line 165 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf2Dread<T>(surf, x, y, mode);
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template <typename T>
static __declspec(deprecated) __declspec(__device__)  __forceinline void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf3Dread_v2", (void *)res, s, surf, x, y, z, mode);
#line 182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline  T surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf3Dread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, z, mode);
  return temp;
#line 192 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf3Dread<T>(surf, x, y, z, mode);
#line 200 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}



template <typename T>
static __declspec(deprecated) __declspec(__device__)  __forceinline void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int  layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1DLayeredread_v2", (void *)res, s, surf, x,  layer, mode);
#line 210 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline  T surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf1DLayeredread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, layer, mode);
  return temp;
#line 220 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf1DLayeredread<T>(surf, x, layer, mode);
#line 229 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template <typename T>
static __declspec(deprecated) __declspec(__device__)  __forceinline void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x,  int y, int  layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2DLayeredread_v2", (void *)res, s, surf, x, y, layer, mode);
#line 238 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline  T surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf2DLayeredread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, layer, mode);
  return temp;
#line 248 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf2DLayeredread<T>(surf, x, y, layer, mode);
#line 257 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template <typename T>
static __declspec(__device__)  __forceinline void surfCubemapread(T *res, surface<void, 0x0C> surf, int x,  int y, int  face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapread_v2", (void *)res, s, surf, x, y, face, mode);
#line 266 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline  T surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;

  __nv_tex_surf_handler("__surfCubemapread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, face, mode);
  return temp;
#line 277 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surfCubemapread<T>(surf, x, y, face, mode);
#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template <typename T>
static __declspec(deprecated) __declspec(__device__)  __forceinline void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x,  int y, int  layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapLayeredread_v2", (void *)res, s, surf, x, y, layerFace, mode);
#line 294 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline  T surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surfCubemapLayeredread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, layerFace, mode);
  return temp;
#line 304 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surfCubemapLayeredread<T>(surf, x, y, layerFace, mode);
#line 312 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf1Dwrite(T val, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1Dwrite_v2", (void *)&val, s, surf, x, mode);
#line 321 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf1Dwrite(T val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1Dwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x,  mode);
#line 329 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}



template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2Dwrite_v2", (void *)&val,  s, surf, x, y, mode);
#line 339 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2Dwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y,  mode);
#line 347 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf3Dwrite_v2", (void *)&val,  s, surf, x, y, z,mode);
#line 356 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf3Dwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y, z,  mode);
#line 364 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1DLayeredwrite_v2", (void *)&val,  s, surf, x, layer,mode);
#line 373 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1DLayeredwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val,  (int)sizeof(T), surf, x, layer, mode);
#line 381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2DLayeredwrite_v2", (void *)&val, s, surf, x, y, layer,mode);
#line 390 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2DLayeredwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val,  (int)sizeof(T), surf, x, y, layer, mode);
#line 398 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}


template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapwrite_v2", (void *)&val, s, surf, x, y, face, mode);
#line 407 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y, face,  mode);
#line 415 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}



template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapLayeredwrite_v2", (void *)&val, s, surf, x, y, layerFace,  mode);
#line 425 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}

template<class T>
static __declspec(deprecated) __declspec(__device__) __forceinline void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapLayeredwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y, layerFace,  mode);
#line 433 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
}




#line 439 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
#line 440 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_functions.h"
#line 3303 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"





























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"












































































































#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_texture_types.h"
#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"





#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"


template <typename T>
struct __nv_tex_rmet_ret { };

template<> struct __nv_tex_rmet_ret<char> { typedef char type; };
template<> struct __nv_tex_rmet_ret<signed char> { typedef signed char type; };
template<> struct __nv_tex_rmet_ret<unsigned char> { typedef unsigned char type; };
template<> struct __nv_tex_rmet_ret<char1> { typedef char1 type; };
template<> struct __nv_tex_rmet_ret<uchar1> { typedef uchar1 type; };
template<> struct __nv_tex_rmet_ret<char2> { typedef char2 type; };
template<> struct __nv_tex_rmet_ret<uchar2> { typedef uchar2 type; };
template<> struct __nv_tex_rmet_ret<char4> { typedef char4 type; };
template<> struct __nv_tex_rmet_ret<uchar4> { typedef uchar4 type; };

template<> struct __nv_tex_rmet_ret<short> { typedef short type; };
template<> struct __nv_tex_rmet_ret<unsigned short> { typedef unsigned short type; };
template<> struct __nv_tex_rmet_ret<short1> { typedef short1 type; };
template<> struct __nv_tex_rmet_ret<ushort1> { typedef ushort1 type; };
template<> struct __nv_tex_rmet_ret<short2> { typedef short2 type; };
template<> struct __nv_tex_rmet_ret<ushort2> { typedef ushort2 type; };
template<> struct __nv_tex_rmet_ret<short4> { typedef short4 type; };
template<> struct __nv_tex_rmet_ret<ushort4> { typedef ushort4 type; };

template<> struct __nv_tex_rmet_ret<int> { typedef int type; };
template<> struct __nv_tex_rmet_ret<unsigned int> { typedef unsigned int type; };
template<> struct __nv_tex_rmet_ret<int1> { typedef int1 type; };
template<> struct __nv_tex_rmet_ret<uint1> { typedef uint1 type; };
template<> struct __nv_tex_rmet_ret<int2> { typedef int2 type; };
template<> struct __nv_tex_rmet_ret<uint2> { typedef uint2 type; };
template<> struct __nv_tex_rmet_ret<int4> { typedef int4 type; };
template<> struct __nv_tex_rmet_ret<uint4> { typedef uint4 type; };


template<> struct __nv_tex_rmet_ret<long> { typedef long type; };
template<> struct __nv_tex_rmet_ret<unsigned long> { typedef unsigned long type; };
template<> struct __nv_tex_rmet_ret<long1> { typedef long1 type; };
template<> struct __nv_tex_rmet_ret<ulong1> { typedef ulong1 type; };
template<> struct __nv_tex_rmet_ret<long2> { typedef long2 type; };
template<> struct __nv_tex_rmet_ret<ulong2> { typedef ulong2 type; };
template<> struct __nv_tex_rmet_ret<long4> { typedef long4 type; };
template<> struct __nv_tex_rmet_ret<ulong4> { typedef ulong4 type; };
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
template<> struct __nv_tex_rmet_ret<float> { typedef float type; };
template<> struct __nv_tex_rmet_ret<float1> { typedef float1 type; };
template<> struct __nv_tex_rmet_ret<float2> { typedef float2 type; };
template<> struct __nv_tex_rmet_ret<float4> { typedef float4 type; };


template <typename T> struct __nv_tex_rmet_cast { typedef T* type;  };

template<> struct __nv_tex_rmet_cast<long> { typedef int *type; };
template<> struct __nv_tex_rmet_cast<unsigned long> { typedef unsigned int *type; };
template<> struct __nv_tex_rmet_cast<long1> { typedef int1 *type; };
template<> struct __nv_tex_rmet_cast<ulong1> { typedef uint1 *type; };
template<> struct __nv_tex_rmet_cast<long2> { typedef int2 *type; };
template<> struct __nv_tex_rmet_cast<ulong2> { typedef uint2 *type; };
template<> struct __nv_tex_rmet_cast<long4> { typedef int4 *type; };
template<> struct __nv_tex_rmet_cast<ulong4> { typedef uint4 *type; };
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__)  typename __nv_tex_rmet_ret<T>::type tex1Dfetch(texture<T, 0x01, cudaReadModeElementType> t, int x)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1Dfetch_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x);
  return temp;
#line 139 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
struct __nv_tex_rmnf_ret { };

template <> struct __nv_tex_rmnf_ret<char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<signed char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<unsigned char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<short> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<unsigned short> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<char1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<uchar1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<short1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<ushort1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<char2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<uchar2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<short2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<ushort2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<char4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<uchar4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<short4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<ushort4> { typedef float4 type; };

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex1Dfetch(texture<T, 0x01, cudaReadModeNormalizedFloat> t, int x) 
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1Dfetch_rmnf_v2", &type_dummy, &retval, t, x);
  return retval;
#line 171 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex1D(texture<T, 0x01, cudaReadModeElementType> t, float x)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1D_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x);
  return temp;
#line 182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex1D(texture<T, 0x01, cudaReadModeNormalizedFloat> t, float x)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1D_rmnf_v2", &type_dummy, &retval, t, x);
  return retval;
#line 193 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex2D(texture<T, 0x02, cudaReadModeElementType> t, float x, float y)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;

  __nv_tex_surf_handler("__tex2D_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, y);
  return temp;
#line 206 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex2D(texture<T, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2D_rmnf_v2", &type_dummy, &retval, t, x, y);
  return retval;
#line 217 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex1DLayered(texture<T, 0xF1, cudaReadModeElementType> t, float x, int layer)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DLayered_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, layer);
  return temp;
#line 229 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex1DLayered(texture<T, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DLayered_rmnf_v2", &type_dummy, &retval, t, x, layer);
  return retval;
#line 240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex2DLayered(texture<T, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DLayered_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, y, layer);
  return temp;
#line 252 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex2DLayered(texture<T, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DLayered_rmnf_v2", &type_dummy, &retval, t, x, y, layer);
  return retval;
#line 263 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex3D(texture<T, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex3D_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, y, z);
  return temp;
#line 274 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex3D(texture<T, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex3D_rmnf_v2", &type_dummy, &retval, t, x, y, z);
  return retval;
#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type texCubemap(texture<T, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemap_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, y, z);
  return temp;
#line 296 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type texCubemap(texture<T, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemap_rmnf_v2", &type_dummy, &retval, t, x, y, z);
  return retval;
#line 307 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
struct __nv_tex2dgather_ret { };
template <> struct __nv_tex2dgather_ret<char> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<signed char> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char1> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char2> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char3> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char4> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<unsigned char> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar1> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar2> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar3> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar4> { typedef uchar4 type; };

template <> struct __nv_tex2dgather_ret<short> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short1> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short2> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short3> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short4> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<unsigned short> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort1> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort2> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort3> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort4> { typedef ushort4 type; };

template <> struct __nv_tex2dgather_ret<int> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int1> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int2> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int3> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int4> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<unsigned int> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint1> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint2> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint3> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint4> { typedef uint4 type; };

template <> struct __nv_tex2dgather_ret<float> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float1> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float2> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float3> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float4> { typedef float4 type; };

template <typename T>
static __declspec(__device__) __forceinline typename __nv_tex2dgather_ret<T>::type tex2Dgather(texture<T, 0x02, cudaReadModeElementType> t, float x, float y, int comp=0)
{ 

  T type_dummy;
  typename __nv_tex2dgather_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2Dgather_v2", &type_dummy, &retval, t, x, y, comp);
  return retval;
#line 361 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template<typename T> struct __nv_tex2dgather_rmnf_ret { };
template<> struct __nv_tex2dgather_rmnf_ret<char> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<signed char> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<unsigned char> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<char1> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<uchar1> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<char2> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<uchar2> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<char3> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<uchar3> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<char4> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<uchar4> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<signed short> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<unsigned short> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<short1> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<ushort1> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<short2> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<ushort2> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<short3> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<ushort3> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<short4> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<ushort4> { typedef float4 type; };

template <typename T>
static __declspec(__device__) __forceinline  typename __nv_tex2dgather_rmnf_ret<T>::type tex2Dgather(texture<T, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{  

  T type_dummy;
  typename __nv_tex2dgather_rmnf_ret<T>::type  retval;
  __nv_tex_surf_handler("__tex2Dgather_rmnf_v2", &type_dummy, &retval, t, x, y, comp);
  return retval;
#line 396 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex1DLod(texture<T, 0x01, cudaReadModeElementType> t, float x, float level)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, level);
  return temp;
#line 408 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex1DLod(texture<T, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DLod_rmnf_v2", &type_dummy, &retval, t, x, level);
  return retval;
#line 419 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex2DLod(texture<T, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, level);
  return temp;
#line 430 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex2DLod(texture<T, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DLod_rmnf_v2", &type_dummy, &retval, t, x, y, level);
  return retval;
#line 441 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex1DLayeredLod(texture<T, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DLayeredLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, layer, level);
  return temp;
#line 452 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex1DLayeredLod(texture<T, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DLayeredLod_rmnf_v2", &type_dummy, &retval, t, x, layer, level);
  return retval;
#line 463 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex2DLayeredLod(texture<T, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DLayeredLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, layer, level);
  return temp;
#line 474 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex2DLayeredLod(texture<T, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DLayeredLod_rmnf_v2", &type_dummy, &retval, t, x, y, layer, level);
  return retval;
#line 485 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex3DLod(texture<T, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex3DLod_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, level);
  return temp;
#line 496 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex3DLod(texture<T, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex3DLod_rmnf_v2", &type_dummy, &retval, t, x, y, z, level);
  return retval;
#line 507 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type texCubemapLod(texture<T, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapLod_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, level);
  return temp;
#line 518 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type texCubemapLod(texture<T, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapLod_rmnf_v2", &type_dummy, &retval, t, x, y, z, level);
  return retval;
#line 529 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type texCubemapLayered(texture<T, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapLayered_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, layer);
  return temp;
#line 541 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type texCubemapLayered(texture<T, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapLayered_rmnf_v2", &type_dummy, &retval, t, x, y, z, layer);
  return retval;
#line 552 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type texCubemapLayeredLod(texture<T, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapLayeredLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, layer, level);
  return temp;
#line 564 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type texCubemapLayeredLod(texture<T, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapLayeredLod_rmnf_v2", &type_dummy, &retval, t, x, y, z, layer, level);
  return retval;
#line 575 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type texCubemapGrad(texture<T, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, &dPdx, &dPdy);
  return temp;
#line 587 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type texCubemapGrad(texture<T, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapGrad_rmnf_v2", &type_dummy, &retval, t,  x, y, z, &dPdx, &dPdy);
  return retval;
#line 598 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type texCubemapLayeredGrad(texture<T, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float4 dPdx, float4 dPdy)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapLayeredGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, layer, &dPdx, &dPdy);
  return temp;
#line 610 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type texCubemapLayeredGrad(texture<T, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapLayeredGrad_rmnf_v2", &type_dummy, &retval,t, x, y, z, layer, &dPdx, &dPdy);
  return retval;
#line 621 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex1DGrad(texture<T, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, dPdx, dPdy);
  return temp;
#line 633 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex1DGrad(texture<T, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DGrad_rmnf_v2", &type_dummy, &retval,t, x,dPdx, dPdy);
  return retval;
#line 644 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex2DGrad(texture<T, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, &dPdx, &dPdy);
  return temp;
#line 656 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex2DGrad(texture<T, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DGrad_rmnf_v2", &type_dummy, &retval,t, x, y, &dPdx, &dPdy);
  return retval;
#line 667 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex1DLayeredGrad(texture<T, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DLayeredGrad_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, layer, dPdx, dPdy);
  return temp;
#line 678 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex1DLayeredGrad(texture<T, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DLayeredGrad_rmnf_v2", &type_dummy, &retval,t, x, layer, dPdx, dPdy);
  return retval;
#line 689 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex2DLayeredGrad(texture<T, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DLayeredGrad_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, layer, &dPdx, &dPdy);
  return temp;
#line 700 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex2DLayeredGrad(texture<T, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DLayeredGrad_rmnf_v2", &type_dummy, &retval,t, x, y, layer, &dPdx, &dPdy);
  return retval;
#line 711 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}


template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmet_ret<T>::type tex3DGrad(texture<T, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{ 

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex3DGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, &dPdx, &dPdy);
  return temp;
#line 722 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}

template <typename T>
static __declspec(deprecated) __forceinline __declspec(__device__) typename __nv_tex_rmnf_ret<T>::type tex3DGrad(texture<T, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{ 

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex3DGrad_rmnf_v2", &type_dummy, &retval,t, x, y, z, &dPdx, &dPdy);
  return retval;
#line 733 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
}



#line 738 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"

#line 740 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_fetch_functions.h"
#line 3304 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"




#line 63 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"

template <typename T> struct __nv_itex_trait {   };
template<> struct __nv_itex_trait<char> { typedef void type; };
template<> struct __nv_itex_trait<signed char> { typedef void type; };
template<> struct __nv_itex_trait<char1> { typedef void type; };
template<> struct __nv_itex_trait<char2> { typedef void type; };
template<> struct __nv_itex_trait<char4> { typedef void type; };
template<> struct __nv_itex_trait<unsigned char> { typedef void type; };
template<> struct __nv_itex_trait<uchar1> { typedef void type; };
template<> struct __nv_itex_trait<uchar2> { typedef void type; };
template<> struct __nv_itex_trait<uchar4> { typedef void type; };
template<> struct __nv_itex_trait<short> { typedef void type; };
template<> struct __nv_itex_trait<short1> { typedef void type; };
template<> struct __nv_itex_trait<short2> { typedef void type; };
template<> struct __nv_itex_trait<short4> { typedef void type; };
template<> struct __nv_itex_trait<unsigned short> { typedef void type; };
template<> struct __nv_itex_trait<ushort1> { typedef void type; };
template<> struct __nv_itex_trait<ushort2> { typedef void type; };
template<> struct __nv_itex_trait<ushort4> { typedef void type; };
template<> struct __nv_itex_trait<int> { typedef void type; };
template<> struct __nv_itex_trait<int1> { typedef void type; };
template<> struct __nv_itex_trait<int2> { typedef void type; };
template<> struct __nv_itex_trait<int4> { typedef void type; };
template<> struct __nv_itex_trait<unsigned int> { typedef void type; };
template<> struct __nv_itex_trait<uint1> { typedef void type; };
template<> struct __nv_itex_trait<uint2> { typedef void type; };
template<> struct __nv_itex_trait<uint4> { typedef void type; };

template<> struct __nv_itex_trait<long> { typedef void type; };
template<> struct __nv_itex_trait<long1> { typedef void type; };
template<> struct __nv_itex_trait<long2> { typedef void type; };
template<> struct __nv_itex_trait<long4> { typedef void type; };
template<> struct __nv_itex_trait<unsigned long> { typedef void type; };
template<> struct __nv_itex_trait<ulong1> { typedef void type; };
template<> struct __nv_itex_trait<ulong2> { typedef void type; };
template<> struct __nv_itex_trait<ulong4> { typedef void type; };
#line 100 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
template<> struct __nv_itex_trait<float> { typedef void type; };
template<> struct __nv_itex_trait<float1> { typedef void type; };
template<> struct __nv_itex_trait<float2> { typedef void type; };
template<> struct __nv_itex_trait<float4> { typedef void type; };



template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex1Dfetch(T *ptr, cudaTextureObject_t obj, int x)
{

   __nv_tex_surf_handler("__itex1Dfetch", ptr, obj, x);
#line 113 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__) T tex1Dfetch(cudaTextureObject_t texObject, int x)
{

  T ret;
  tex1Dfetch(&ret, texObject, x);
  return ret;
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex1D(T *ptr, cudaTextureObject_t obj, float x)
{

   __nv_tex_surf_handler("__itex1D", ptr, obj, x);
#line 131 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <class T>
static __declspec(__device__)  T tex1D(cudaTextureObject_t texObject, float x)
{

  T ret;
  tex1D(&ret, texObject, x);
  return ret;
#line 142 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2D(T *ptr, cudaTextureObject_t obj, float x, float y)
{

   __nv_tex_surf_handler("__itex2D", ptr, obj, x, y);
#line 151 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2D(cudaTextureObject_t texObject, float x, float y)
{

  T ret;
  tex2D(&ret, texObject, x, y);
  return ret;
#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2D(T *ptr, cudaTextureObject_t obj, float x, float y, 
                                                          bool* isResident)
{

  unsigned char res;
   __nv_tex_surf_handler("__itex2D_sparse", ptr, obj, x, y, &res);
   *isResident = (res != 0);
#line 173 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2D(cudaTextureObject_t texObject, float x, float y, bool* isResident)
{

  T ret;
  tex2D(&ret, texObject, x, y, isResident);
  return ret;
#line 183 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

#line 186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex3D(T *ptr, cudaTextureObject_t obj, float x, float y, float z)
{

   __nv_tex_surf_handler("__itex3D", ptr, obj, x, y, z);
#line 194 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex3D(cudaTextureObject_t texObject, float x, float y, float z)
{

  T ret;
  tex3D(&ret, texObject, x, y, z);
  return ret;
#line 204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex3D(T *ptr, cudaTextureObject_t obj, float x, float y, float z, 
                                                          bool* isResident)
{

  unsigned char res;
   __nv_tex_surf_handler("__itex3D_sparse", ptr, obj, x, y, z, &res);
   *isResident = (res != 0);
#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex3D(cudaTextureObject_t texObject, float x, float y, float z, bool* isResident)
{

  T ret;
  tex3D(&ret, texObject, x, y, z, isResident);
  return ret;
#line 226 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}
#line 228 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex1DLayered(T *ptr, cudaTextureObject_t obj, float x, int layer)
{

   __nv_tex_surf_handler("__itex1DLayered", ptr, obj, x, layer);
#line 236 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex1DLayered(cudaTextureObject_t texObject, float x, int layer)
{

  T ret;
  tex1DLayered(&ret, texObject, x, layer);
  return ret;
#line 246 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DLayered(T *ptr, cudaTextureObject_t obj, float x, float y, int layer)
{

  __nv_tex_surf_handler("__itex2DLayered", ptr, obj, x, y, layer);
#line 254 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer)
{

  T ret;
  tex2DLayered(&ret, texObject, x, y, layer);
  return ret;
#line 264 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DLayered(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, bool* isResident)
{

  unsigned char res;
  __nv_tex_surf_handler("__itex2DLayered_sparse", ptr, obj, x, y, layer, &res);
  *isResident = (res != 0);
#line 275 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer, bool* isResident)
{

  T ret;
  tex2DLayered(&ret, texObject, x, y, layer, isResident);
  return ret;
#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}
#line 287 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type texCubemap(T *ptr, cudaTextureObject_t obj, float x, float y, float z)
{

  __nv_tex_surf_handler("__itexCubemap", ptr, obj, x, y, z);
#line 295 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <class T>
static __declspec(__device__)  T texCubemap(cudaTextureObject_t texObject, float x, float y, float z)
{

  T ret;
  texCubemap(&ret, texObject, x, y, z);
  return ret;
#line 306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type texCubemapLayered(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer)
{ 

  __nv_tex_surf_handler("__itexCubemapLayered", ptr, obj, x, y, z, layer);
#line 315 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer)
{

  T ret;
  texCubemapLayered(&ret, texObject, x, y, z, layer);
  return ret;
#line 325 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2Dgather(T *ptr, cudaTextureObject_t obj, float x, float y, int comp = 0)
{

  __nv_tex_surf_handler("__itex2Dgather", ptr, obj, x, y, comp);
#line 333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0)
{

  T ret;
  tex2Dgather(&ret, to, x, y, comp);
  return ret;
#line 343 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2Dgather(T *ptr, cudaTextureObject_t obj, float x, float y, bool* isResident, int comp = 0)
{

  unsigned char res;
  __nv_tex_surf_handler("__itex2Dgather_sparse", ptr, obj, x, y, comp,  &res);
  *isResident = (res != 0);
#line 354 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2Dgather(cudaTextureObject_t to, float x, float y, bool* isResident, int comp = 0)
{

  T ret;
  tex2Dgather(&ret, to, x, y,  isResident, comp);
  return ret;
#line 364 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

#line 367 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"

template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex1DLod(T *ptr, cudaTextureObject_t obj, float x, float level)
{

  __nv_tex_surf_handler("__itex1DLod", ptr, obj, x, level);
#line 374 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex1DLod(cudaTextureObject_t texObject, float x, float level)
{

  T ret;
  tex1DLod(&ret, texObject, x, level);
  return ret;
#line 384 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float level)
{

  __nv_tex_surf_handler("__itex2DLod", ptr, obj, x, y, level);
#line 393 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level)
{

  T ret;
  tex2DLod(&ret, texObject, x, y, level);
  return ret;
#line 403 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}



template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float level, bool* isResident)
{

  unsigned char res;
  __nv_tex_surf_handler("__itex2DLod_sparse", ptr, obj, x, y, level, &res);
  *isResident = (res != 0);
#line 415 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level, bool* isResident)
{

  T ret;
  tex2DLod(&ret, texObject, x, y, level, isResident);
  return ret;
#line 425 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

#line 428 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex3DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level)
{ 

  __nv_tex_surf_handler("__itex3DLod", ptr, obj, x, y, z, level);
#line 436 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{

  T ret;
  tex3DLod(&ret, texObject, x, y, z, level);
  return ret;
#line 446 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex3DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level, bool* isResident)
{ 

  unsigned char res;
  __nv_tex_surf_handler("__itex3DLod_sparse", ptr, obj, x, y, z, level, &res);
  *isResident = (res != 0);
#line 457 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level, bool* isResident)
{

  T ret;
  tex3DLod(&ret, texObject, x, y, z, level, isResident);
  return ret;
#line 467 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

#line 470 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex1DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, int layer, float level)
{ 

  __nv_tex_surf_handler("__itex1DLayeredLod", ptr, obj, x, layer, level);
#line 478 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level)
{

  T ret;
  tex1DLayeredLod(&ret, texObject, x, layer, level);
  return ret;
#line 488 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float level)
{ 

  __nv_tex_surf_handler("__itex2DLayeredLod", ptr, obj, x, y, layer, level);
#line 497 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level)
{

  T ret;
  tex2DLayeredLod(&ret, texObject, x, y, layer, level);
  return ret;
#line 507 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float level, bool* isResident)
{ 

  unsigned char res;
  __nv_tex_surf_handler("__itex2DLayeredLod_sparse", ptr, obj, x, y, layer, level, &res);
  *isResident = (res != 0);
#line 518 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level, bool* isResident)
{

  T ret;
  tex2DLayeredLod(&ret, texObject, x, y, layer, level, isResident);
  return ret;
#line 528 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}
#line 530 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"

template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type texCubemapLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level)
{ 

  __nv_tex_surf_handler("__itexCubemapLod", ptr, obj, x, y, z, level);
#line 537 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{

  T ret;
  texCubemapLod(&ret, texObject, x, y, z, level);
  return ret;
#line 547 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type texCubemapGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy)
{ 

  __nv_tex_surf_handler("__itexCubemapGrad_v2", ptr, obj, x, y, z, &dPdx, &dPdy);
#line 556 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T texCubemapGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  T ret;
  texCubemapGrad(&ret, texObject, x, y, z, dPdx, dPdy);
  return ret;
#line 566 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type texCubemapLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer, float level)
{ 

  __nv_tex_surf_handler("__itexCubemapLayeredLod", ptr, obj, x, y, z, layer, level);
#line 574 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{

  T ret;
  texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level);
  return ret;
#line 584 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex1DGrad(T *ptr, cudaTextureObject_t obj, float x, float dPdx, float dPdy)
{

  __nv_tex_surf_handler("__itex1DGrad", ptr, obj, x, dPdx, dPdy);
#line 592 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{

  T ret;
  tex1DGrad(&ret, texObject, x, dPdx, dPdy);
  return ret;
#line 602 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float2 dPdx, float2 dPdy)
{ 

  __nv_tex_surf_handler("__itex2DGrad_v2", ptr, obj, x, y, &dPdx, &dPdy);
#line 611 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"

}

template <class T>
static __declspec(__device__)  T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{

  T ret;
  tex2DGrad(&ret, texObject, x, y, dPdx, dPdy);
  return ret;
#line 622 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float2 dPdx, float2 dPdy, bool* isResident)
{ 

  unsigned char res;
  __nv_tex_surf_handler("__itex2DGrad_sparse", ptr, obj, x, y, &dPdx, &dPdy, &res);
  *isResident = (res != 0);
#line 633 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"

}

template <class T>
static __declspec(__device__)  T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy, bool* isResident)
{

  T ret;
  tex2DGrad(&ret, texObject, x, y, dPdx, dPdy, isResident);
  return ret;
#line 644 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}
#line 646 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex3DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy)
{ 

  __nv_tex_surf_handler("__itex3DGrad_v2", ptr, obj, x, y, z, &dPdx, &dPdy);
#line 654 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  T ret;
  tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy);
  return ret;
#line 664 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex3DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy, bool* isResident)
{ 

  unsigned char res;
  __nv_tex_surf_handler("__itex3DGrad_sparse", ptr, obj, x, y, z, &dPdx, &dPdy, &res);
  *isResident = (res != 0);
#line 675 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy, bool* isResident)
{

  T ret;
  tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy, isResident);
  return ret;
#line 685 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

#line 688 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex1DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, int layer, float dPdx, float dPdy)
{ 

  __nv_tex_surf_handler("__itex1DLayeredGrad", ptr, obj, x, layer, dPdx, dPdy);
#line 696 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{

  T ret;
  tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy);
  return ret;
#line 706 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DLayeredGrad(T * ptr, cudaTextureObject_t obj, float x, float y, int layer, float2 dPdx, float2 dPdy)
{ 

  __nv_tex_surf_handler("__itex2DLayeredGrad_v2", ptr, obj, x, y, layer, &dPdx, &dPdy);
#line 715 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{

  T ret;
  tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy);
  return ret;
#line 725 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type tex2DLayeredGrad(T * ptr, cudaTextureObject_t obj, float x, float y, int layer, float2 dPdx, float2 dPdy, bool* isResident)
{ 

  unsigned char res;
  __nv_tex_surf_handler("__itex2DLayeredGrad_sparse", ptr, obj, x, y, layer, &dPdx, &dPdy, &res);
  *isResident = (res != 0);
#line 736 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy, bool* isResident)
{

  T ret;
  tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy, isResident);
  return ret;
#line 746 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}
#line 748 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"


template <typename T>
static __declspec(__device__) typename __nv_itex_trait<T>::type texCubemapLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer, float4 dPdx, float4 dPdy)
{

  __nv_tex_surf_handler("__itexCubemapLayeredGrad_v2", ptr, obj, x, y, z, layer, &dPdx, &dPdy);
#line 756 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}

template <class T>
static __declspec(__device__)  T texCubemapLayeredGrad(cudaTextureObject_t texObject, float x, float y, float z, int layer, float4 dPdx, float4 dPdy)
{

  T ret;
  texCubemapLayeredGrad(&ret, texObject, x, y, z, layer, dPdx, dPdy);
  return ret;
#line 766 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
}



#line 771 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
#line 772 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\texture_indirect_functions.h"
#line 3305 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
























































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\cuda_runtime_api.h"
#line 58 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"

template<typename T> struct __nv_isurf_trait { };
template<> struct __nv_isurf_trait<char> { typedef void type; };
template<> struct __nv_isurf_trait<signed char> { typedef void type; };
template<> struct __nv_isurf_trait<char1> { typedef void type; };
template<> struct __nv_isurf_trait<unsigned char> { typedef void type; };
template<> struct __nv_isurf_trait<uchar1> { typedef void type; };
template<> struct __nv_isurf_trait<short> { typedef void type; };
template<> struct __nv_isurf_trait<short1> { typedef void type; };
template<> struct __nv_isurf_trait<unsigned short> { typedef void type; };
template<> struct __nv_isurf_trait<ushort1> { typedef void type; };
template<> struct __nv_isurf_trait<int> { typedef void type; };
template<> struct __nv_isurf_trait<int1> { typedef void type; };
template<> struct __nv_isurf_trait<unsigned int> { typedef void type; };
template<> struct __nv_isurf_trait<uint1> { typedef void type; };
template<> struct __nv_isurf_trait<long long> { typedef void type; };
template<> struct __nv_isurf_trait<longlong1> { typedef void type; };
template<> struct __nv_isurf_trait<unsigned long long> { typedef void type; };
template<> struct __nv_isurf_trait<ulonglong1> { typedef void type; };
template<> struct __nv_isurf_trait<float> { typedef void type; };
template<> struct __nv_isurf_trait<float1> { typedef void type; };

template<> struct __nv_isurf_trait<char2> { typedef void type; };
template<> struct __nv_isurf_trait<uchar2> { typedef void type; };
template<> struct __nv_isurf_trait<short2> { typedef void type; };
template<> struct __nv_isurf_trait<ushort2> { typedef void type; };
template<> struct __nv_isurf_trait<int2> { typedef void type; };
template<> struct __nv_isurf_trait<uint2> { typedef void type; };
template<> struct __nv_isurf_trait<longlong2> { typedef void type; };
template<> struct __nv_isurf_trait<ulonglong2> { typedef void type; };
template<> struct __nv_isurf_trait<float2> { typedef void type; };

template<> struct __nv_isurf_trait<char4> { typedef void type; };
template<> struct __nv_isurf_trait<uchar4> { typedef void type; };
template<> struct __nv_isurf_trait<short4> { typedef void type; };
template<> struct __nv_isurf_trait<ushort4> { typedef void type; };
template<> struct __nv_isurf_trait<int4> { typedef void type; };
template<> struct __nv_isurf_trait<uint4> { typedef void type; };
template<> struct __nv_isurf_trait<float4> { typedef void type; };


template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type  surf1Dread(T *ptr, cudaSurfaceObject_t obj, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf1Dread", ptr, obj, x, mode);
#line 105 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <class T>
static __declspec(__device__) T surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf1Dread(&ret, surfObject, x, boundaryMode);
   return ret;
#line 115 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type  surf2Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf2Dread", ptr, obj, x, y, mode);
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <class T>
static __declspec(__device__) T surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf2Dread(&ret, surfObject, x, y, boundaryMode);
   return ret;
#line 133 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}


template <typename T>
static __declspec(__device__) typename  __nv_isurf_trait<T>::type  surf3Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf3Dread", ptr, obj, x, y, z, mode);
#line 142 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <class T>
static __declspec(__device__) T surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf3Dread(&ret, surfObject, x, y, z, boundaryMode);
   return ret;
#line 152 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename  __nv_isurf_trait<T>::type  surf1DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf1DLayeredread", ptr, obj, x, layer, mode);
#line 160 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <class T>
static __declspec(__device__) T surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode);
   return ret;
#line 170 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__)  typename __nv_isurf_trait<T>::type  surf2DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf2DLayeredread", ptr, obj, x, y, layer, mode);
#line 178 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <class T>
static __declspec(__device__) T surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode);
   return ret;
#line 188 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type  surfCubemapread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurfCubemapread", ptr, obj, x, y, face, mode);
#line 196 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <class T>
static __declspec(__device__) T surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surfCubemapread(&ret, surfObject, x, y, face, boundaryMode);
   return ret;
#line 206 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__)  typename __nv_isurf_trait<T>::type  surfCubemapLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layerface, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurfCubemapLayeredread", ptr, obj, x, y, layerface, mode);
#line 214 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <class T>
static __declspec(__device__) T surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surfCubemapLayeredread(&ret, surfObject, x, y, layerface, boundaryMode);
   return ret;
#line 224 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type surf1Dwrite(T val, cudaSurfaceObject_t obj, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{ 

  __nv_tex_surf_handler("__isurf1Dwrite_v2", &val, obj, x, mode);
#line 232 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type surf2Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf2Dwrite_v2", &val, obj, x, y, mode);
#line 240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type surf3Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf3Dwrite_v2", &val, obj, x, y, z, mode);
#line 248 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type surf1DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf1DLayeredwrite_v2", &val, obj, x, layer, mode);
#line 256 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type surf2DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf2DLayeredwrite_v2", &val, obj, x, y, layer, mode);
#line 264 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type surfCubemapwrite(T val, cudaSurfaceObject_t obj, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurfCubemapwrite_v2", &val, obj, x, y, face, mode);
#line 272 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

template <typename T>
static __declspec(__device__) typename __nv_isurf_trait<T>::type surfCubemapLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layerface, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurfCubemapLayeredwrite_v2", &val, obj, x, y, layerface, mode);
#line 280 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"
}

#line 283 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"

#line 285 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\surface_indirect_functions.h"


#line 3306 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\cudacc_ext.h"

























































#line 59 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\cudacc_ext.h"





#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt\\cudacc_ext.h"
#line 3307 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"


extern "C" __declspec(__host__) __declspec(__device__)  unsigned __stdcall __cudaPushCallConfiguration(dim3 gridDim,
                                      dim3 blockDim, 
                                      size_t sharedMem = 0, 
                                      struct CUstream_st *stream = 0);
#line 3314 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"

#line 3316 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"




#line 3321 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\crt/device_functions.h"
#line 119 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"




















































#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"


























































































































































































































































































































































































































































#line 444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\vector_types.h"
#line 54 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"






#line 61 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"


#line 64 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"

#line 66 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"


extern "C" {
#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"

uint3 __declspec(__device_builtin__) extern const threadIdx;
uint3 __declspec(__device_builtin__) extern const blockIdx;
dim3 __declspec(__device_builtin__) extern const blockDim;
dim3 __declspec(__device_builtin__) extern const gridDim;
int __declspec(__device_builtin__) extern const warpSize;




}
#line 82 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"






#line 89 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"






#line 96 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"






#line 103 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"






#line 110 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"






#line 117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"

#line 119 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.8\\include\\device_launch_parameters.h"
#line 120 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"





#line 126 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"


#line 129 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"

#line 131 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"




#line 136 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"





#line 142 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"






#line 149 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
























































template<class T>
static __inline __declspec(__host__) cudaError_t cudaLaunchKernel(
  const T *func,
  dim3 gridDim,
  dim3 blockDim,
  void **args,
  size_t sharedMem = 0,
  cudaStream_t stream = 0
)
{
    return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream);
}







































































#line 289 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"


















































template<class T>
static __inline __declspec(__host__) cudaError_t cudaLaunchCooperativeKernel(
  const T *func,
  dim3 gridDim,
  dim3 blockDim,
  void **args,
  size_t sharedMem = 0,
  cudaStream_t stream = 0
)
{
    return ::cudaLaunchCooperativeKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream);
}
































static __inline __declspec(__host__) cudaError_t cudaEventCreate(
  cudaEvent_t  *event,
  unsigned int  flags
)
{
  return ::cudaEventCreateWithFlags(event, flags);
}


























































static __inline __declspec(__host__) cudaError_t cudaMallocHost(
  void         **ptr,
  size_t         size,
  unsigned int   flags
)
{
  return ::cudaHostAlloc(ptr, size, flags);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaHostAlloc(
  T            **ptr,
  size_t         size,
  unsigned int   flags
)
{
  return ::cudaHostAlloc((void**)(void*)ptr, size, flags);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaHostGetDevicePointer(
  T            **pDevice,
  void          *pHost,
  unsigned int   flags
)
{
  return ::cudaHostGetDevicePointer((void**)(void*)pDevice, pHost, flags);
}





































































































template<class T>
static __inline __declspec(__host__) cudaError_t cudaMallocManaged(
  T            **devPtr,
  size_t         size,
  unsigned int   flags = 0x01
)
{
  return ::cudaMallocManaged((void**)(void*)devPtr, size, flags);
}

















































































template<class T>
static __inline __declspec(__host__) cudaError_t cudaStreamAttachMemAsync(
  cudaStream_t   stream,
  T              *devPtr,
  size_t         length = 0,
  unsigned int   flags  = 0x04
)
{
  return ::cudaStreamAttachMemAsync(stream, (void*)devPtr, length, flags);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaMalloc(
  T      **devPtr,
  size_t   size
)
{
  return ::cudaMalloc((void**)(void*)devPtr, size);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaMallocHost(
  T            **ptr,
  size_t         size,
  unsigned int   flags = 0
)
{
  return cudaMallocHost((void**)(void*)ptr, size, flags);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaMallocPitch(
  T      **devPtr,
  size_t  *pitch,
  size_t   width,
  size_t   height
)
{
  return ::cudaMallocPitch((void**)(void*)devPtr, pitch, width, height);
}










static __inline __declspec(__host__) cudaError_t cudaMallocAsync(
  void        **ptr,
  size_t        size,
  cudaMemPool_t memPool,
  cudaStream_t  stream
)
{
  return ::cudaMallocFromPoolAsync(ptr, size, memPool, stream);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaMallocAsync(
  T           **ptr,
  size_t        size,
  cudaMemPool_t memPool,
  cudaStream_t  stream
)
{
  return ::cudaMallocFromPoolAsync((void**)(void*)ptr, size, memPool, stream);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaMallocAsync(
  T           **ptr,
  size_t        size,
  cudaStream_t  stream
)
{
  return ::cudaMallocAsync((void**)(void*)ptr, size, stream);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaMallocFromPoolAsync(
  T           **ptr,
  size_t        size,
  cudaMemPool_t memPool,
  cudaStream_t  stream
)
{
  return ::cudaMallocFromPoolAsync((void**)(void*)ptr, size, memPool, stream);
}






































template<class T>
static __inline __declspec(__host__) cudaError_t cudaMemcpyToSymbol(
  const T                   &symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice
)
{
  return ::cudaMemcpyToSymbol((const void*)&symbol, src, count, offset, kind);
}











































template<class T>
static __inline __declspec(__host__) cudaError_t cudaMemcpyToSymbolAsync(
  const T                   &symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice,
        cudaStream_t         stream = 0
)
{
  return ::cudaMemcpyToSymbolAsync((const void*)&symbol, src, count, offset, kind, stream);
}




































template<class T>
static __inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbol(
        void                *dst,
  const T                   &symbol,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost
)
{
  return ::cudaMemcpyFromSymbol(dst, (const void*)&symbol, count, offset, kind);
}











































template<class T>
static __inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbolAsync(
        void                *dst,
  const T                   &symbol,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost,
        cudaStream_t         stream = 0
)
{
  return ::cudaMemcpyFromSymbolAsync(dst, (const void*)&symbol, count, offset, kind, stream);
}

























































template<class T>
static __inline __declspec(__host__) cudaError_t cudaGraphAddMemcpyNodeToSymbol(
    cudaGraphNode_t *pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t *pDependencies,
    size_t numDependencies,
    const T &symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphAddMemcpyNodeToSymbol(pGraphNode, graph, pDependencies, numDependencies, (const void*)&symbol, src, count, offset, kind);
}

























































template<class T>
static __inline __declspec(__host__) cudaError_t cudaGraphAddMemcpyNodeFromSymbol(
    cudaGraphNode_t* pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t* pDependencies,
    size_t numDependencies,
    void* dst,
    const T &symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphAddMemcpyNodeFromSymbol(pGraphNode, graph, pDependencies, numDependencies, dst, (const void*)&symbol, count, offset, kind);
}





































template<class T>
static __inline __declspec(__host__) cudaError_t cudaGraphMemcpyNodeSetParamsToSymbol(
    cudaGraphNode_t node,
    const T &symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphMemcpyNodeSetParamsToSymbol(node, (const void*)&symbol, src, count, offset, kind);
}





































template<class T>
static __inline __declspec(__host__) cudaError_t cudaGraphMemcpyNodeSetParamsFromSymbol(
    cudaGraphNode_t node,
    void* dst,
    const T &symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphMemcpyNodeSetParamsFromSymbol(node, dst, (const void*)&symbol, count, offset, kind);
}















































template<class T>
static __inline __declspec(__host__) cudaError_t cudaGraphExecMemcpyNodeSetParamsToSymbol(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    const T &symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
    return ::cudaGraphExecMemcpyNodeSetParamsToSymbol(hGraphExec, node, (const void*)&symbol, src, count, offset, kind);
}















































template<class T>
static __inline __declspec(__host__) cudaError_t cudaGraphExecMemcpyNodeSetParamsFromSymbol(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    void* dst,
    const T &symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphExecMemcpyNodeSetParamsFromSymbol(hGraphExec, node, dst, (const void*)&symbol, count, offset, kind);
}




















































#line 1373 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
























template<class T>
static __inline __declspec(__host__) cudaError_t cudaGetSymbolAddress(
        void **devPtr,
  const T     &symbol
)
{
  return ::cudaGetSymbolAddress(devPtr, (const void*)&symbol);
}
























template<class T>
static __inline __declspec(__host__) cudaError_t cudaGetSymbolSize(
        size_t *size,
  const T      &symbol
)
{
  return ::cudaGetSymbolSize(size, (const void*)&symbol);
}




































template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindTexture(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  const struct cudaChannelFormatDesc     &desc,
        size_t                            size = 0xffffffff
)
{
  return ::cudaBindTexture(offset, &tex, devPtr, &desc, size);
}



































template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindTexture(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
        size_t                            size = 0xffffffff
)
{
  return cudaBindTexture(offset, tex, devPtr, tex.channelDesc, size);
}















































template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindTexture2D(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  const struct cudaChannelFormatDesc     &desc,
  size_t                                  width,
  size_t                                  height,
  size_t                                  pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch);
}














































template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindTexture2D(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  size_t                                  width,
  size_t                                  height,
  size_t                                  pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &tex.channelDesc, width, height, pitch);
}































template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t                       array,
  const struct cudaChannelFormatDesc     &desc
)
{
  return ::cudaBindTextureToArray(&tex, array, &desc);
}






























template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t                       array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t                  err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindTextureToArray(tex, array, desc) : err;
}































template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t              mipmappedArray,
  const struct cudaChannelFormatDesc     &desc
)
{
  return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc);
}






























template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t              mipmappedArray
)
{
  struct cudaChannelFormatDesc desc;
  cudaArray_t                  levelArray;
  cudaError_t                  err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0);
  
  if (err != cudaSuccess) {
      return err;
  }
  err = ::cudaGetChannelDesc(&desc, levelArray);

  return err == cudaSuccess ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err;
}


























template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaUnbindTexture(
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaUnbindTexture(&tex);
}





























template<class T, int dim, enum cudaTextureReadMode readMode>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaGetTextureAlignmentOffset(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaGetTextureAlignmentOffset(offset, &tex);
}












































template<class T>
static __inline __declspec(__host__) cudaError_t cudaFuncSetCacheConfig(
  T                  *func,
  enum cudaFuncCache  cacheConfig
)
{
  return ::cudaFuncSetCacheConfig((const void*)func, cacheConfig);
}

template<class T>
static __inline __declspec(__host__) cudaError_t cudaFuncSetSharedMemConfig(
  T                        *func,
  enum cudaSharedMemConfig  config
)
{
  return ::cudaFuncSetSharedMemConfig((const void*)func, config);
}

#line 1948 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"





























template<class T>
static __inline __declspec(__host__) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(
    int   *numBlocks,
    T      func,
    int    blockSize,
    size_t dynamicSMemSize)
{
    return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void*)func, blockSize, dynamicSMemSize, 0x00);
}











































template<class T>
static __inline __declspec(__host__) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
    int         *numBlocks,
    T            func,
    int          blockSize,
    size_t       dynamicSMemSize,
    unsigned int flags)
{
    return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void*)func, blockSize, dynamicSMemSize, flags);
}




class __cudaOccupancyB2DHelper {
  size_t n;
public:
  inline __declspec(__host__) __declspec(__device__) __cudaOccupancyB2DHelper(size_t n_) : n(n_) {}
  inline __declspec(__host__) __declspec(__device__) size_t operator()(int)
  {
      return n;
  }
};















































template<typename UnaryFunction, class T>
static __inline __declspec(__host__) __declspec(__device__) cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(
    int           *minGridSize,
    int           *blockSize,
    T              func,
    UnaryFunction  blockSizeToDynamicSMemSize,
    int            blockSizeLimit = 0,
    unsigned int   flags = 0)
{
    cudaError_t status;

    
    int                       device;
    struct cudaFuncAttributes attr;

    
    int maxThreadsPerMultiProcessor;
    int warpSize;
    int devMaxThreadsPerBlock;
    int multiProcessorCount;
    int funcMaxThreadsPerBlock;
    int occupancyLimit;
    int granularity;

    
    int maxBlockSize = 0;
    int numBlocks    = 0;
    int maxOccupancy = 0;

    
    int blockSizeToTryAligned;
    int blockSizeToTry;
    int blockSizeLimitAligned;
    int occupancyInBlocks;
    int occupancyInThreads;
    size_t dynamicSMemSize;

    
    
    

    if (!minGridSize || !blockSize || !func) {
        return cudaErrorInvalidValue;
    }

    
    
    

    status = ::cudaGetDevice(&device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &maxThreadsPerMultiProcessor,
        cudaDevAttrMaxThreadsPerMultiProcessor,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &warpSize,
        cudaDevAttrWarpSize,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &devMaxThreadsPerBlock,
        cudaDevAttrMaxThreadsPerBlock,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &multiProcessorCount,
        cudaDevAttrMultiProcessorCount,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaFuncGetAttributes(&attr, func);
    if (status != cudaSuccess) {
        return status;
    }
    
    funcMaxThreadsPerBlock = attr.maxThreadsPerBlock;

    
    
    

    occupancyLimit = maxThreadsPerMultiProcessor;
    granularity    = warpSize;

    if (blockSizeLimit == 0) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (devMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (funcMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = funcMaxThreadsPerBlock;
    }

    blockSizeLimitAligned = ((blockSizeLimit + (granularity - 1)) / granularity) * granularity;

    for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) {
        
        
        
        if (blockSizeLimit < blockSizeToTryAligned) {
            blockSizeToTry = blockSizeLimit;
        } else {
            blockSizeToTry = blockSizeToTryAligned;
        }
        
        dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry);

        status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
            &occupancyInBlocks,
            func,
            blockSizeToTry,
            dynamicSMemSize,
            flags);

        if (status != cudaSuccess) {
            return status;
        }

        occupancyInThreads = blockSizeToTry * occupancyInBlocks;

        if (occupancyInThreads > maxOccupancy) {
            maxBlockSize = blockSizeToTry;
            numBlocks    = occupancyInBlocks;
            maxOccupancy = occupancyInThreads;
        }

        
        
        if (occupancyLimit == maxOccupancy) {
            break;
        }
    }

    
    
    

    
    
    *minGridSize = numBlocks * multiProcessorCount;
    *blockSize = maxBlockSize;

    return status;
}

































template<typename UnaryFunction, class T>
static __inline __declspec(__host__) __declspec(__device__) cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMem(
    int           *minGridSize,
    int           *blockSize,
    T              func,
    UnaryFunction  blockSizeToDynamicSMemSize,
    int            blockSizeLimit = 0)
{
    return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0x00);
}




































template<class T>
static __inline __declspec(__host__) __declspec(__device__) cudaError_t cudaOccupancyMaxPotentialBlockSize(
    int    *minGridSize,
    int    *blockSize,
    T       func,
    size_t  dynamicSMemSize = 0,
    int     blockSizeLimit = 0)
{
  return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit, 0x00);
}




























template<class T>
static __inline __declspec(__host__) cudaError_t cudaOccupancyAvailableDynamicSMemPerBlock(
    size_t *dynamicSmemSize,
    T      func,
    int    numBlocks,
    int    blockSize)
{
    return ::cudaOccupancyAvailableDynamicSMemPerBlock(dynamicSmemSize, (const void*)func, numBlocks, blockSize);
}


















































template<class T>
static __inline __declspec(__host__) __declspec(__device__) cudaError_t cudaOccupancyMaxPotentialBlockSizeWithFlags(
    int    *minGridSize,
    int    *blockSize,
    T      func,
    size_t dynamicSMemSize = 0,
    int    blockSizeLimit = 0,
    unsigned int flags = 0)
{
    return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit, flags);
}

































template<class T>
static __inline __declspec(__host__) cudaError_t cudaOccupancyMaxPotentialClusterSize(
    int *clusterSize,
    T *func,
    const cudaLaunchConfig_t *config)
{
    return ::cudaOccupancyMaxPotentialClusterSize(clusterSize, (const void*)func, config);
}



































template<class T>
static __inline __declspec(__host__) cudaError_t cudaOccupancyMaxActiveClusters(
    int *numClusters,
    T *func,
    const cudaLaunchConfig_t *config)
{
    return ::cudaOccupancyMaxActiveClusters(numClusters, (const void*)func, config);
}
































template<class T>
static __inline __declspec(__host__) cudaError_t cudaFuncGetAttributes(
  struct cudaFuncAttributes *attr,
  T                         *entry
)
{
  return ::cudaFuncGetAttributes(attr, (const void*)entry);
}






















































template<class T>
static __inline __declspec(__host__) cudaError_t cudaFuncSetAttribute(
  T                         *entry,
  enum cudaFuncAttribute    attr,
  int                       value
)
{
  return ::cudaFuncSetAttribute((const void*)entry, attr, value);
}























template<class T, int dim>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim>       &surf,
  cudaArray_const_t                   array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindSurfaceToArray(&surf, array, &desc);
}






















template<class T, int dim>
static __declspec(deprecated) __inline __declspec(__host__) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t             array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t                  err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindSurfaceToArray(surf, array, desc) : err;
}

#line 2703 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"

 

#line 2707 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"






#line 2714 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#pragma warning(pop)
#line 2716 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 2717 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"






#line 2724 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"

#line 2726 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 1 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"








#line 10 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"

#line 1 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
























































typedef unsigned __int32 cuuint32_t;
typedef unsigned __int64 cuuint64_t;




#line 64 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"



#line 68 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"





#line 74 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"



#line 78 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"





#line 84 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
    
    
#line 87 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"





























































































































#line 213 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"

























extern "C" {
#line 240 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"






typedef unsigned long long CUdeviceptr_v2;


#line 250 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
typedef CUdeviceptr_v2 CUdeviceptr;                          

typedef int CUdevice_v1;                                     
typedef CUdevice_v1 CUdevice;                                
typedef struct CUctx_st *CUcontext;                          
typedef struct CUmod_st *CUmodule;                           
typedef struct CUfunc_st *CUfunction;                        
typedef struct CUarray_st *CUarray;                          
typedef struct CUmipmappedArray_st *CUmipmappedArray;        
typedef struct CUtexref_st *CUtexref;                        
typedef struct CUsurfref_st *CUsurfref;                      
typedef struct CUevent_st *CUevent;                          
typedef struct CUstream_st *CUstream;                        
typedef struct CUgraphicsResource_st *CUgraphicsResource;    
typedef unsigned long long CUtexObject_v1;                   
typedef CUtexObject_v1 CUtexObject;                          
typedef unsigned long long CUsurfObject_v1;                  
typedef CUsurfObject_v1 CUsurfObject;                         
typedef struct CUextMemory_st *CUexternalMemory;             
typedef struct CUextSemaphore_st *CUexternalSemaphore;       
typedef struct CUgraph_st *CUgraph;                          
typedef struct CUgraphNode_st *CUgraphNode;                  
typedef struct CUgraphExec_st *CUgraphExec;                  
typedef struct CUmemPoolHandle_st *CUmemoryPool;             
typedef struct CUuserObject_st *CUuserObject;                
















typedef struct CUipcEventHandle_st {
    char reserved[64];
} CUipcEventHandle_v1;
typedef CUipcEventHandle_v1 CUipcEventHandle;




typedef struct CUipcMemHandle_st {
    char reserved[64];
} CUipcMemHandle_v1;
typedef CUipcMemHandle_v1 CUipcMemHandle;




typedef enum CUipcMem_flags_enum {
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 0x1 
} CUipcMem_flags;





typedef enum CUmemAttach_flags_enum {
    CU_MEM_ATTACH_GLOBAL = 0x1, 
    CU_MEM_ATTACH_HOST   = 0x2, 
    CU_MEM_ATTACH_SINGLE = 0x4  
} CUmemAttach_flags;




typedef enum CUctx_flags_enum {
    CU_CTX_SCHED_AUTO          = 0x00, 
    CU_CTX_SCHED_SPIN          = 0x01, 
    CU_CTX_SCHED_YIELD         = 0x02, 
    CU_CTX_SCHED_BLOCKING_SYNC = 0x04, 
    CU_CTX_BLOCKING_SYNC       = 0x04, 


    CU_CTX_SCHED_MASK          = 0x07,
    CU_CTX_MAP_HOST            = 0x08, 


    CU_CTX_LMEM_RESIZE_TO_MAX  = 0x10, 
    CU_CTX_FLAGS_MASK          = 0x1f
} CUctx_flags;




typedef enum CUevent_sched_flags_enum {
    CU_EVENT_SCHED_AUTO = 0x00, 
    CU_EVENT_SCHED_SPIN = 0x01, 
    CU_EVENT_SCHED_YIELD = 0x02, 
    CU_EVENT_SCHED_BLOCKING_SYNC = 0x04, 
} CUevent_sched_flags;




typedef enum cl_event_flags_enum {
    NVCL_EVENT_SCHED_AUTO = 0x00, 
    NVCL_EVENT_SCHED_SPIN = 0x01, 
    NVCL_EVENT_SCHED_YIELD = 0x02, 
    NVCL_EVENT_SCHED_BLOCKING_SYNC = 0x04, 
} cl_event_flags;




typedef enum cl_context_flags_enum {
    NVCL_CTX_SCHED_AUTO = 0x00, 
    NVCL_CTX_SCHED_SPIN = 0x01, 
    NVCL_CTX_SCHED_YIELD = 0x02, 
    NVCL_CTX_SCHED_BLOCKING_SYNC = 0x04, 
} cl_context_flags;





typedef enum CUstream_flags_enum {
    CU_STREAM_DEFAULT             = 0x0, 
    CU_STREAM_NON_BLOCKING        = 0x1  
} CUstream_flags;
























typedef enum CUevent_flags_enum {
    CU_EVENT_DEFAULT        = 0x0, 
    CU_EVENT_BLOCKING_SYNC  = 0x1, 
    CU_EVENT_DISABLE_TIMING = 0x2, 
    CU_EVENT_INTERPROCESS   = 0x4  
} CUevent_flags;




typedef enum CUevent_record_flags_enum {
    CU_EVENT_RECORD_DEFAULT  = 0x0, 
    CU_EVENT_RECORD_EXTERNAL = 0x1  


} CUevent_record_flags;




typedef enum CUevent_wait_flags_enum {
    CU_EVENT_WAIT_DEFAULT  = 0x0, 
    CU_EVENT_WAIT_EXTERNAL = 0x1  


} CUevent_wait_flags;




typedef enum CUstreamWaitValue_flags_enum {
    CU_STREAM_WAIT_VALUE_GEQ   = 0x0,   


    CU_STREAM_WAIT_VALUE_EQ    = 0x1,   
    CU_STREAM_WAIT_VALUE_AND   = 0x2,   
    CU_STREAM_WAIT_VALUE_NOR   = 0x3,   


    CU_STREAM_WAIT_VALUE_FLUSH = 1<<30  








} CUstreamWaitValue_flags;




typedef enum CUstreamWriteValue_flags_enum {
    CU_STREAM_WRITE_VALUE_DEFAULT           = 0x0, 
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 0x1  






} CUstreamWriteValue_flags;




typedef enum CUstreamBatchMemOpType_enum {
    CU_STREAM_MEM_OP_WAIT_VALUE_32  = 1,     
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2,     
    CU_STREAM_MEM_OP_WAIT_VALUE_64  = 4,     
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = 5,     
    CU_STREAM_MEM_OP_BARRIER = 6,             
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3 

} CUstreamBatchMemOpType;




typedef enum CUstreamMemoryBarrier_flags_enum {
    CU_STREAM_MEMORY_BARRIER_TYPE_SYS = 0x0, 
    CU_STREAM_MEMORY_BARRIER_TYPE_GPU = 0x1 
} CUstreamMemoryBarrier_flags;




typedef union CUstreamBatchMemOpParams_union {
    CUstreamBatchMemOpType operation;
    struct CUstreamMemOpWaitValueParams_st {
        CUstreamBatchMemOpType operation;
        CUdeviceptr address;
        union {
            cuuint32_t value;
            cuuint64_t value64;
        };
        unsigned int flags;
        CUdeviceptr alias; 
    } waitValue;
    struct CUstreamMemOpWriteValueParams_st {
        CUstreamBatchMemOpType operation;
        CUdeviceptr address;
        union {
            cuuint32_t value;
            cuuint64_t value64;
        };
        unsigned int flags;
        CUdeviceptr alias; 
    } writeValue;
    struct CUstreamMemOpFlushRemoteWritesParams_st {
        CUstreamBatchMemOpType operation;
        unsigned int flags;
    } flushRemoteWrites;
    struct CUstreamMemOpMemoryBarrierParams_st { 
        CUstreamBatchMemOpType operation;
        unsigned int flags;
    } memoryBarrier;
    cuuint64_t pad[6];
} CUstreamBatchMemOpParams_v1;
typedef CUstreamBatchMemOpParams_v1 CUstreamBatchMemOpParams;

typedef struct CUDA_BATCH_MEM_OP_NODE_PARAMS_st {
    CUcontext ctx;
    unsigned int count;
    CUstreamBatchMemOpParams *paramArray;
    unsigned int flags;
} CUDA_BATCH_MEM_OP_NODE_PARAMS;




typedef enum CUoccupancy_flags_enum {
    CU_OCCUPANCY_DEFAULT                  = 0x0, 
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 0x1  
} CUoccupancy_flags;




typedef enum CUstreamUpdateCaptureDependencies_flags_enum {
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES = 0x0, 
    CU_STREAM_SET_CAPTURE_DEPENDENCIES = 0x1  
} CUstreamUpdateCaptureDependencies_flags;




typedef enum CUarray_format_enum {
    CU_AD_FORMAT_UNSIGNED_INT8  = 0x01, 
    CU_AD_FORMAT_UNSIGNED_INT16 = 0x02, 
    CU_AD_FORMAT_UNSIGNED_INT32 = 0x03, 
    CU_AD_FORMAT_SIGNED_INT8    = 0x08, 
    CU_AD_FORMAT_SIGNED_INT16   = 0x09, 
    CU_AD_FORMAT_SIGNED_INT32   = 0x0a, 
    CU_AD_FORMAT_HALF           = 0x10, 
    CU_AD_FORMAT_FLOAT          = 0x20, 
    CU_AD_FORMAT_NV12           = 0xb0, 
    CU_AD_FORMAT_UNORM_INT8X1   = 0xc0, 
    CU_AD_FORMAT_UNORM_INT8X2   = 0xc1, 
    CU_AD_FORMAT_UNORM_INT8X4   = 0xc2, 
    CU_AD_FORMAT_UNORM_INT16X1  = 0xc3, 
    CU_AD_FORMAT_UNORM_INT16X2  = 0xc4, 
    CU_AD_FORMAT_UNORM_INT16X4  = 0xc5, 
    CU_AD_FORMAT_SNORM_INT8X1   = 0xc6, 
    CU_AD_FORMAT_SNORM_INT8X2   = 0xc7, 
    CU_AD_FORMAT_SNORM_INT8X4   = 0xc8, 
    CU_AD_FORMAT_SNORM_INT16X1  = 0xc9, 
    CU_AD_FORMAT_SNORM_INT16X2  = 0xca, 
    CU_AD_FORMAT_SNORM_INT16X4  = 0xcb, 
    CU_AD_FORMAT_BC1_UNORM      = 0x91, 
    CU_AD_FORMAT_BC1_UNORM_SRGB = 0x92, 
    CU_AD_FORMAT_BC2_UNORM      = 0x93, 
    CU_AD_FORMAT_BC2_UNORM_SRGB = 0x94, 
    CU_AD_FORMAT_BC3_UNORM      = 0x95, 
    CU_AD_FORMAT_BC3_UNORM_SRGB = 0x96, 
    CU_AD_FORMAT_BC4_UNORM      = 0x97, 
    CU_AD_FORMAT_BC4_SNORM      = 0x98, 
    CU_AD_FORMAT_BC5_UNORM      = 0x99, 
    CU_AD_FORMAT_BC5_SNORM      = 0x9a, 
    CU_AD_FORMAT_BC6H_UF16      = 0x9b, 
    CU_AD_FORMAT_BC6H_SF16      = 0x9c, 
    CU_AD_FORMAT_BC7_UNORM      = 0x9d, 
    CU_AD_FORMAT_BC7_UNORM_SRGB = 0x9e  
} CUarray_format;




typedef enum CUaddress_mode_enum {
    CU_TR_ADDRESS_MODE_WRAP   = 0, 
    CU_TR_ADDRESS_MODE_CLAMP  = 1, 
    CU_TR_ADDRESS_MODE_MIRROR = 2, 
    CU_TR_ADDRESS_MODE_BORDER = 3  
} CUaddress_mode;




typedef enum CUfilter_mode_enum {
    CU_TR_FILTER_MODE_POINT  = 0, 
    CU_TR_FILTER_MODE_LINEAR = 1  
} CUfilter_mode;




typedef enum CUdevice_attribute_enum {
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,                          
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,                                
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,                                
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,                                
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,                                 
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,                                 
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,                                 
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,                    
    CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8,                        
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,                          
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,                                     
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,                                     
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,                       
    CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12,                           
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,                                    
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,                             
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,                                   
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,                          
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,                           
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,                                    
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,                           
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,                                  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,                      
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,                      
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,               
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,              
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,              
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27,                 
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = 28,                
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = 29,             
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,                             
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,                            
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,                                   
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,                                    
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,                                 
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,                                    
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,                             
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,                       
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,                                 
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,                
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,                            
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,                            
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,               
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,              
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,                              
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,                
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,               
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47,             
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,            
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49,             
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,                                 
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,                  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,          
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54,         
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,                      
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,                      
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,                       
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,               
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,              
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,               
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,              
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,              
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,                  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,          
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68,         
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,                
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,                
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,               
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,                
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73,             
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,            
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,                      
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,                      
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77,             
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,                   
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,                     
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,                      
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,          
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,              
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,                                
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,                               
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,                      
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,                  
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,         
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,                        
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,                     
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,                  
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91,       
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS = 92,                        
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = 93,                 
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = 94,                 
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = 95,                            
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = 96,               
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = 97,             
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = 98,                       
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = 99,                       
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = 100, 
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = 101,          
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = 102,         
    CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = 102,         
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = 103,  
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = 104,           
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = 105,       
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = 106,                
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = 107,                
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = 108,                 
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = 109,                
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = 110,      
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = 111,             
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = 112,                  
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = 113,            
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = 114,         
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = 115,                       
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = 116,                    
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = 117,         
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = 118,              
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = 119,               
    CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH = 120,                               
    CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED = 121,        
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V2 = 122,             
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2 = 123,             
    CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED = 124,                             
    CU_DEVICE_ATTRIBUTE_MAX
} CUdevice_attribute;




typedef struct CUdevprop_st {
    int maxThreadsPerBlock;     
    int maxThreadsDim[3];       
    int maxGridSize[3];         
    int sharedMemPerBlock;      
    int totalConstantMemory;    
    int SIMDWidth;              
    int memPitch;               
    int regsPerBlock;           
    int clockRate;              
    int textureAlign;           
} CUdevprop_v1;
typedef CUdevprop_v1 CUdevprop;




typedef enum CUpointer_attribute_enum {
    CU_POINTER_ATTRIBUTE_CONTEXT = 1,                     
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,                 
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,              
    CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,                
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,                  
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,                 
    CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,                   
    CU_POINTER_ATTRIBUTE_IS_MANAGED = 8,                  
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,              
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = 10, 
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11,           
    CU_POINTER_ATTRIBUTE_RANGE_SIZE = 12,                 
    CU_POINTER_ATTRIBUTE_MAPPED = 13,                     
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14,       
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15, 
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16,               
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17              
    ,
    CU_POINTER_ATTRIBUTE_MAPPING_SIZE = 18,               
    CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR = 19,          
    CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID = 20             
} CUpointer_attribute;




typedef enum CUfunction_attribute_enum {
    




    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,

    




    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,

    



    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,

    


    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,

    


    CU_FUNC_ATTRIBUTE_NUM_REGS = 4,

    






    CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,

    






    CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,

    



    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,

    





    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,

    






    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,

    




    CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET = 10,

    








    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH = 11,

    








    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT = 12,

    








    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH = 13,

    



















    CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED = 14,

    




    CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 15,

    CU_FUNC_ATTRIBUTE_MAX
} CUfunction_attribute;




typedef enum CUfunc_cache_enum {
    CU_FUNC_CACHE_PREFER_NONE    = 0x00, 
    CU_FUNC_CACHE_PREFER_SHARED  = 0x01, 
    CU_FUNC_CACHE_PREFER_L1      = 0x02, 
    CU_FUNC_CACHE_PREFER_EQUAL   = 0x03  
} CUfunc_cache;




typedef enum CUsharedconfig_enum {
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE    = 0x00, 
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE  = 0x01, 
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 0x02  
} CUsharedconfig;




typedef enum CUshared_carveout_enum {
    CU_SHAREDMEM_CARVEOUT_DEFAULT       = -1,  
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED    = 100, 
    CU_SHAREDMEM_CARVEOUT_MAX_L1        = 0    
} CUshared_carveout;




typedef enum CUmemorytype_enum {
    CU_MEMORYTYPE_HOST    = 0x01,    
    CU_MEMORYTYPE_DEVICE  = 0x02,    
    CU_MEMORYTYPE_ARRAY   = 0x03,    
    CU_MEMORYTYPE_UNIFIED = 0x04     
} CUmemorytype;




typedef enum CUcomputemode_enum {
    CU_COMPUTEMODE_DEFAULT           = 0, 
    CU_COMPUTEMODE_PROHIBITED        = 2, 
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3  
} CUcomputemode;




typedef enum CUmem_advise_enum {
    CU_MEM_ADVISE_SET_READ_MOSTLY          = 1, 
    CU_MEM_ADVISE_UNSET_READ_MOSTLY        = 2, 
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION   = 3, 
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4, 
    CU_MEM_ADVISE_SET_ACCESSED_BY          = 5, 
    CU_MEM_ADVISE_UNSET_ACCESSED_BY        = 6  
} CUmem_advise;

typedef enum CUmem_range_attribute_enum {
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY            = 1, 
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION     = 2, 
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY            = 3, 
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = 4  
} CUmem_range_attribute;




typedef enum CUjit_option_enum
{
    




    CU_JIT_MAX_REGISTERS = 0,

    












    CU_JIT_THREADS_PER_BLOCK,

    





    CU_JIT_WALL_TIME,

    






    CU_JIT_INFO_LOG_BUFFER,

    






    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES,

    






    CU_JIT_ERROR_LOG_BUFFER,

    






    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES,

    





    CU_JIT_OPTIMIZATION_LEVEL,

    





    CU_JIT_TARGET_FROM_CUCONTEXT,

    





    CU_JIT_TARGET,

    






    CU_JIT_FALLBACK_STRATEGY,

    





    CU_JIT_GENERATE_DEBUG_INFO,

    




    CU_JIT_LOG_VERBOSE,

    




    CU_JIT_GENERATE_LINE_INFO,

    





    CU_JIT_CACHE_MODE,

    



    CU_JIT_NEW_SM3X_OPT,

    


    CU_JIT_FAST_COMPILE,

    











    CU_JIT_GLOBAL_SYMBOL_NAMES,

    






    CU_JIT_GLOBAL_SYMBOL_ADDRESSES,

    





    CU_JIT_GLOBAL_SYMBOL_COUNT,

    





    CU_JIT_LTO,

    






    CU_JIT_FTZ,

    







    CU_JIT_PREC_DIV,

    







    CU_JIT_PREC_SQRT,

    






    CU_JIT_FMA,

    














    CU_JIT_REFERENCED_KERNEL_NAMES,

    




    CU_JIT_REFERENCED_KERNEL_COUNT,

    














    CU_JIT_REFERENCED_VARIABLE_NAMES,

    




    CU_JIT_REFERENCED_VARIABLE_COUNT,

    









    CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES,

    CU_JIT_NUM_OPTIONS

} CUjit_option;




typedef enum CUjit_target_enum
{
    CU_TARGET_COMPUTE_20 = 20,       
    CU_TARGET_COMPUTE_21 = 21,       
    CU_TARGET_COMPUTE_30 = 30,       
    CU_TARGET_COMPUTE_32 = 32,       
    CU_TARGET_COMPUTE_35 = 35,       
    CU_TARGET_COMPUTE_37 = 37,       
    CU_TARGET_COMPUTE_50 = 50,       
    CU_TARGET_COMPUTE_52 = 52,       
    CU_TARGET_COMPUTE_53 = 53,       
    CU_TARGET_COMPUTE_60 = 60,       
    CU_TARGET_COMPUTE_61 = 61,       
    CU_TARGET_COMPUTE_62 = 62,       
    CU_TARGET_COMPUTE_70 = 70,       
    CU_TARGET_COMPUTE_72 = 72,       
    CU_TARGET_COMPUTE_75 = 75,       
    CU_TARGET_COMPUTE_80 = 80,       
    CU_TARGET_COMPUTE_86 = 86,       
    CU_TARGET_COMPUTE_87 = 87,       
    CU_TARGET_COMPUTE_89 = 89,       
    CU_TARGET_COMPUTE_90 = 90        
} CUjit_target;




typedef enum CUjit_fallback_enum
{
    CU_PREFER_PTX = 0,  

    CU_PREFER_BINARY    

} CUjit_fallback;




typedef enum CUjit_cacheMode_enum
{
    CU_JIT_CACHE_OPTION_NONE = 0, 
    CU_JIT_CACHE_OPTION_CG,       
    CU_JIT_CACHE_OPTION_CA        
} CUjit_cacheMode;




typedef enum CUjitInputType_enum
{
    



    CU_JIT_INPUT_CUBIN = 0,

    



    CU_JIT_INPUT_PTX,

    



    CU_JIT_INPUT_FATBINARY,

    



    CU_JIT_INPUT_OBJECT,

    



    CU_JIT_INPUT_LIBRARY,

    



    CU_JIT_INPUT_NVVM,

    CU_JIT_NUM_INPUT_TYPES
} CUjitInputType;

typedef struct CUlinkState_st *CUlinkState;




typedef enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE           = 0x00,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY      = 0x01,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD  = 0x02,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST   = 0x04,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 0x08
} CUgraphicsRegisterFlags;




typedef enum CUgraphicsMapResourceFlags_enum {
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE          = 0x00,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY     = 0x01,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 0x02
} CUgraphicsMapResourceFlags;




typedef enum CUarray_cubemap_face_enum {
    CU_CUBEMAP_FACE_POSITIVE_X  = 0x00, 
    CU_CUBEMAP_FACE_NEGATIVE_X  = 0x01, 
    CU_CUBEMAP_FACE_POSITIVE_Y  = 0x02, 
    CU_CUBEMAP_FACE_NEGATIVE_Y  = 0x03, 
    CU_CUBEMAP_FACE_POSITIVE_Z  = 0x04, 
    CU_CUBEMAP_FACE_NEGATIVE_Z  = 0x05  
} CUarray_cubemap_face;




typedef enum CUlimit_enum {
    CU_LIMIT_STACK_SIZE                       = 0x00, 
    CU_LIMIT_PRINTF_FIFO_SIZE                 = 0x01, 
    CU_LIMIT_MALLOC_HEAP_SIZE                 = 0x02, 
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH           = 0x03, 
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 0x04, 
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY         = 0x05, 
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE         = 0x06, 
    CU_LIMIT_MAX
} CUlimit;




typedef enum CUresourcetype_enum {
    CU_RESOURCE_TYPE_ARRAY           = 0x00, 
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01, 
    CU_RESOURCE_TYPE_LINEAR          = 0x02, 
    CU_RESOURCE_TYPE_PITCH2D         = 0x03  
} CUresourcetype;





#line 1441 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"





typedef void (__stdcall *CUhostFn)(void *userData);




typedef enum CUaccessProperty_enum {
    CU_ACCESS_PROPERTY_NORMAL           = 0,    
    CU_ACCESS_PROPERTY_STREAMING        = 1,    
    CU_ACCESS_PROPERTY_PERSISTING       = 2     
} CUaccessProperty;













typedef struct CUaccessPolicyWindow_st {
    void *base_ptr;                     
    size_t num_bytes;                   
    float hitRatio;                     
    CUaccessProperty hitProp;           
    CUaccessProperty missProp;          
} CUaccessPolicyWindow_v1;
typedef CUaccessPolicyWindow_v1 CUaccessPolicyWindow;




typedef struct CUDA_KERNEL_NODE_PARAMS_st {
    CUfunction func;             
    unsigned int gridDimX;       
    unsigned int gridDimY;       
    unsigned int gridDimZ;       
    unsigned int blockDimX;      
    unsigned int blockDimY;      
    unsigned int blockDimZ;      
    unsigned int sharedMemBytes; 
    void **kernelParams;         
    void **extra;                
} CUDA_KERNEL_NODE_PARAMS_v1;
typedef CUDA_KERNEL_NODE_PARAMS_v1 CUDA_KERNEL_NODE_PARAMS;




typedef struct CUDA_MEMSET_NODE_PARAMS_st {
    CUdeviceptr dst;                        
    size_t pitch;                           
    unsigned int value;                     
    unsigned int elementSize;               
    size_t width;                           
    size_t height;                          
} CUDA_MEMSET_NODE_PARAMS_v1;
typedef CUDA_MEMSET_NODE_PARAMS_v1 CUDA_MEMSET_NODE_PARAMS;




typedef struct CUDA_HOST_NODE_PARAMS_st {
    CUhostFn fn;    
    void* userData; 
} CUDA_HOST_NODE_PARAMS_v1;
typedef CUDA_HOST_NODE_PARAMS_v1 CUDA_HOST_NODE_PARAMS;




typedef enum CUgraphNodeType_enum {
    CU_GRAPH_NODE_TYPE_KERNEL           = 0, 
    CU_GRAPH_NODE_TYPE_MEMCPY           = 1, 
    CU_GRAPH_NODE_TYPE_MEMSET           = 2, 
    CU_GRAPH_NODE_TYPE_HOST             = 3, 
    CU_GRAPH_NODE_TYPE_GRAPH            = 4, 
    CU_GRAPH_NODE_TYPE_EMPTY            = 5, 
    CU_GRAPH_NODE_TYPE_WAIT_EVENT       = 6, 
    CU_GRAPH_NODE_TYPE_EVENT_RECORD     = 7, 
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = 8, 
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT   = 9, 
    CU_GRAPH_NODE_TYPE_MEM_ALLOC        = 10,
    CU_GRAPH_NODE_TYPE_MEM_FREE         = 11 
    ,
    CU_GRAPH_NODE_TYPE_BATCH_MEM_OP     = 12 
} CUgraphNodeType;

typedef enum CUsynchronizationPolicy_enum {
    CU_SYNC_POLICY_AUTO = 1,
    CU_SYNC_POLICY_SPIN = 2,
    CU_SYNC_POLICY_YIELD = 3,
    CU_SYNC_POLICY_BLOCKING_SYNC = 4
} CUsynchronizationPolicy;




typedef enum CUclusterSchedulingPolicy_enum {
    CU_CLUSTER_SCHEDULING_POLICY_DEFAULT        = 0, 
    CU_CLUSTER_SCHEDULING_POLICY_SPREAD         = 1, 
    CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING = 2  
} CUclusterSchedulingPolicy;

typedef enum CUlaunchAttributeID_enum {
    CU_LAUNCH_ATTRIBUTE_IGNORE = 0 
  , CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW   = 1 
  , CU_LAUNCH_ATTRIBUTE_COOPERATIVE            = 2 
  , CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = 3 
  , CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION                    = 4 
  , CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 5 
  , CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION    = 6 







  , CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT                   = 7 


















  , CU_LAUNCH_ATTRIBUTE_PRIORITY               = 8 
} CUlaunchAttributeID;

typedef union CUlaunchAttributeValue_union {
    char pad[64]; 
    CUaccessPolicyWindow accessPolicyWindow;
    int cooperative;
    CUsynchronizationPolicy syncPolicy;
    struct {
        unsigned int x;
        unsigned int y;
        unsigned int z;
    } clusterDim;
    CUclusterSchedulingPolicy clusterSchedulingPolicyPreference;
    int programmaticStreamSerializationAllowed;
    struct {
        CUevent event;
        int flags;                      
        int triggerAtBlockStart;
    } programmaticEvent;
    int priority;
} CUlaunchAttributeValue;

typedef struct CUlaunchAttribute_st {
    CUlaunchAttributeID id;
    char pad[8 - sizeof(CUlaunchAttributeID)];
    CUlaunchAttributeValue value;
} CUlaunchAttribute;

typedef struct CUlaunchConfig_st {
    unsigned int gridDimX;       
    unsigned int gridDimY;       
    unsigned int gridDimZ;       
    unsigned int blockDimX;      
    unsigned int blockDimY;      
    unsigned int blockDimZ;      
    unsigned int sharedMemBytes; 
    CUstream hStream;            
    CUlaunchAttribute *attrs;    
    unsigned int numAttrs;       
} CUlaunchConfig;




typedef CUlaunchAttributeID CUkernelNodeAttrID;









typedef CUlaunchAttributeValue CUkernelNodeAttrValue_v1;
typedef CUkernelNodeAttrValue_v1 CUkernelNodeAttrValue;




typedef enum CUstreamCaptureStatus_enum {
    CU_STREAM_CAPTURE_STATUS_NONE        = 0, 
    CU_STREAM_CAPTURE_STATUS_ACTIVE      = 1, 
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2  

} CUstreamCaptureStatus;





typedef enum CUstreamCaptureMode_enum {
    CU_STREAM_CAPTURE_MODE_GLOBAL       = 0,
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = 1,
    CU_STREAM_CAPTURE_MODE_RELAXED      = 2
} CUstreamCaptureMode;




typedef CUlaunchAttributeID CUstreamAttrID;






typedef CUlaunchAttributeValue CUstreamAttrValue_v1;
typedef CUstreamAttrValue_v1 CUstreamAttrValue;




typedef enum CUdriverProcAddress_flags_enum {
    CU_GET_PROC_ADDRESS_DEFAULT = 0,                        
    CU_GET_PROC_ADDRESS_LEGACY_STREAM = 1 << 0,             
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = 1 << 1   
} CUdriverProcAddress_flags;




typedef enum CUexecAffinityType_enum {
    CU_EXEC_AFFINITY_TYPE_SM_COUNT = 0,  
    CU_EXEC_AFFINITY_TYPE_MAX
} CUexecAffinityType;




typedef struct CUexecAffinitySmCount_st {
    unsigned int val;    
} CUexecAffinitySmCount_v1;
typedef CUexecAffinitySmCount_v1 CUexecAffinitySmCount;




typedef struct CUexecAffinityParam_st {
    CUexecAffinityType type;
    union {
        CUexecAffinitySmCount smCount;    
    } param;
} CUexecAffinityParam_v1;
typedef CUexecAffinityParam_v1 CUexecAffinityParam;




typedef enum cudaError_enum {
    




    CUDA_SUCCESS                              = 0,

    



    CUDA_ERROR_INVALID_VALUE                  = 1,

    



    CUDA_ERROR_OUT_OF_MEMORY                  = 2,

    



    CUDA_ERROR_NOT_INITIALIZED                = 3,

    


    CUDA_ERROR_DEINITIALIZED                  = 4,

    




    CUDA_ERROR_PROFILER_DISABLED              = 5,

    





    CUDA_ERROR_PROFILER_NOT_INITIALIZED       = 6,

    




    CUDA_ERROR_PROFILER_ALREADY_STARTED       = 7,

    




    CUDA_ERROR_PROFILER_ALREADY_STOPPED       = 8,

    




    CUDA_ERROR_STUB_LIBRARY                   = 34,

    




    CUDA_ERROR_DEVICE_UNAVAILABLE            = 46,

    



    CUDA_ERROR_NO_DEVICE                      = 100,

    




    CUDA_ERROR_INVALID_DEVICE                 = 101,

    


    CUDA_ERROR_DEVICE_NOT_LICENSED            = 102,

    



    CUDA_ERROR_INVALID_IMAGE                  = 200,

    







    CUDA_ERROR_INVALID_CONTEXT                = 201,

    






    CUDA_ERROR_CONTEXT_ALREADY_CURRENT        = 202,

    


    CUDA_ERROR_MAP_FAILED                     = 205,

    


    CUDA_ERROR_UNMAP_FAILED                   = 206,

    



    CUDA_ERROR_ARRAY_IS_MAPPED                = 207,

    


    CUDA_ERROR_ALREADY_MAPPED                 = 208,

    





    CUDA_ERROR_NO_BINARY_FOR_GPU              = 209,

    


    CUDA_ERROR_ALREADY_ACQUIRED               = 210,

    


    CUDA_ERROR_NOT_MAPPED                     = 211,

    



    CUDA_ERROR_NOT_MAPPED_AS_ARRAY            = 212,

    



    CUDA_ERROR_NOT_MAPPED_AS_POINTER          = 213,

    



    CUDA_ERROR_ECC_UNCORRECTABLE              = 214,

    



    CUDA_ERROR_UNSUPPORTED_LIMIT              = 215,

    




    CUDA_ERROR_CONTEXT_ALREADY_IN_USE         = 216,

    



    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED        = 217,

    


    CUDA_ERROR_INVALID_PTX                    = 218,

    


    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT       = 219,

    



    CUDA_ERROR_NVLINK_UNCORRECTABLE           = 220,

    


    CUDA_ERROR_JIT_COMPILER_NOT_FOUND         = 221,

    



    CUDA_ERROR_UNSUPPORTED_PTX_VERSION        = 222,

    


    CUDA_ERROR_JIT_COMPILATION_DISABLED       = 223,

    


 
    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY      = 224,

    



    CUDA_ERROR_INVALID_SOURCE                 = 300,

    


    CUDA_ERROR_FILE_NOT_FOUND                 = 301,

    


    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,

    


    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED      = 303,

    


    CUDA_ERROR_OPERATING_SYSTEM               = 304,

    



    CUDA_ERROR_INVALID_HANDLE                 = 400,

    



    CUDA_ERROR_ILLEGAL_STATE                  = 401,

    




    CUDA_ERROR_NOT_FOUND                      = 500,

    





    CUDA_ERROR_NOT_READY                      = 600,

    






    CUDA_ERROR_ILLEGAL_ADDRESS                = 700,

    








    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES        = 701,

    







    CUDA_ERROR_LAUNCH_TIMEOUT                 = 702,

    



    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING  = 703,

    




    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED    = 704,

    




    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED        = 705,

    



    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE         = 708,

    




    CUDA_ERROR_CONTEXT_IS_DESTROYED           = 709,

    





    CUDA_ERROR_ASSERT                         = 710,

    




    CUDA_ERROR_TOO_MANY_PEERS                 = 711,

    



    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,

    



    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED     = 713,

    






    CUDA_ERROR_HARDWARE_STACK_ERROR           = 714,

    





    CUDA_ERROR_ILLEGAL_INSTRUCTION            = 715,

    






    CUDA_ERROR_MISALIGNED_ADDRESS             = 716,

    








    CUDA_ERROR_INVALID_ADDRESS_SPACE          = 717,

    





    CUDA_ERROR_INVALID_PC                     = 718,

    








    CUDA_ERROR_LAUNCH_FAILED                  = 719,

    






    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE   = 720,

    


    CUDA_ERROR_NOT_PERMITTED                  = 800,

    



    CUDA_ERROR_NOT_SUPPORTED                  = 801,

    






    CUDA_ERROR_SYSTEM_NOT_READY               = 802,

    




    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH         = 803,

    






    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = 804,

    


    CUDA_ERROR_MPS_CONNECTION_FAILED          = 805,

    


    CUDA_ERROR_MPS_RPC_FAILURE                = 806,

    



    CUDA_ERROR_MPS_SERVER_NOT_READY           = 807,

    


    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED        = 808,

    


    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED    = 809,

    


    CUDA_ERROR_MPS_CLIENT_TERMINATED          = 810,

    



    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED     = 900,

    



    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED     = 901,

    



    CUDA_ERROR_STREAM_CAPTURE_MERGE           = 902,

    


    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED       = 903,

    



    CUDA_ERROR_STREAM_CAPTURE_UNJOINED        = 904,

    




    CUDA_ERROR_STREAM_CAPTURE_ISOLATION       = 905,

    



    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT        = 906,

    



    CUDA_ERROR_CAPTURED_EVENT                 = 907,

    




    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD    = 908,

    


    CUDA_ERROR_TIMEOUT                        = 909,

    



    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE      = 910,

    







    CUDA_ERROR_EXTERNAL_DEVICE               = 911,

    


    CUDA_ERROR_INVALID_CLUSTER_SIZE           = 912,

    


    CUDA_ERROR_UNKNOWN                        = 999
} CUresult;




typedef enum CUdevice_P2PAttribute_enum {
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK                     = 0x01,  
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED                     = 0x02,  
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED              = 0x03,  
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED              = 0x04,  
    CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED          = 0x04   
} CUdevice_P2PAttribute;







typedef void (__stdcall *CUstreamCallback)(CUstream hStream, CUresult status, void *userData);







typedef size_t (__stdcall *CUoccupancyB2DSize)(int blockSize);
































































typedef struct CUDA_MEMCPY2D_st {
    size_t srcXInBytes;         
    size_t srcY;                

    CUmemorytype srcMemoryType; 
    const void *srcHost;        
    CUdeviceptr srcDevice;      
    CUarray srcArray;           
    size_t srcPitch;            

    size_t dstXInBytes;         
    size_t dstY;                

    CUmemorytype dstMemoryType; 
    void *dstHost;              
    CUdeviceptr dstDevice;      
    CUarray dstArray;           
    size_t dstPitch;            

    size_t WidthInBytes;        
    size_t Height;              
} CUDA_MEMCPY2D_v2;
typedef CUDA_MEMCPY2D_v2 CUDA_MEMCPY2D;




typedef struct CUDA_MEMCPY3D_st {
    size_t srcXInBytes;         
    size_t srcY;                
    size_t srcZ;                
    size_t srcLOD;              
    CUmemorytype srcMemoryType; 
    const void *srcHost;        
    CUdeviceptr srcDevice;      
    CUarray srcArray;           
    void *reserved0;            
    size_t srcPitch;            
    size_t srcHeight;           

    size_t dstXInBytes;         
    size_t dstY;                
    size_t dstZ;                
    size_t dstLOD;              
    CUmemorytype dstMemoryType; 
    void *dstHost;              
    CUdeviceptr dstDevice;      
    CUarray dstArray;           
    void *reserved1;            
    size_t dstPitch;            
    size_t dstHeight;           

    size_t WidthInBytes;        
    size_t Height;              
    size_t Depth;               
} CUDA_MEMCPY3D_v2;
typedef CUDA_MEMCPY3D_v2 CUDA_MEMCPY3D;




typedef struct CUDA_MEMCPY3D_PEER_st {
    size_t srcXInBytes;         
    size_t srcY;                
    size_t srcZ;                
    size_t srcLOD;              
    CUmemorytype srcMemoryType; 
    const void *srcHost;        
    CUdeviceptr srcDevice;      
    CUarray srcArray;           
    CUcontext srcContext;       
    size_t srcPitch;            
    size_t srcHeight;           

    size_t dstXInBytes;         
    size_t dstY;                
    size_t dstZ;                
    size_t dstLOD;              
    CUmemorytype dstMemoryType; 
    void *dstHost;              
    CUdeviceptr dstDevice;      
    CUarray dstArray;           
    CUcontext dstContext;       
    size_t dstPitch;            
    size_t dstHeight;           

    size_t WidthInBytes;        
    size_t Height;              
    size_t Depth;               
} CUDA_MEMCPY3D_PEER_v1;
typedef CUDA_MEMCPY3D_PEER_v1 CUDA_MEMCPY3D_PEER;




typedef struct CUDA_ARRAY_DESCRIPTOR_st
{
    size_t Width;             
    size_t Height;            

    CUarray_format Format;    
    unsigned int NumChannels; 
} CUDA_ARRAY_DESCRIPTOR_v2;
typedef CUDA_ARRAY_DESCRIPTOR_v2 CUDA_ARRAY_DESCRIPTOR;




typedef struct CUDA_ARRAY3D_DESCRIPTOR_st
{
    size_t Width;             
    size_t Height;            
    size_t Depth;             

    CUarray_format Format;    
    unsigned int NumChannels; 
    unsigned int Flags;       
} CUDA_ARRAY3D_DESCRIPTOR_v2;
typedef CUDA_ARRAY3D_DESCRIPTOR_v2 CUDA_ARRAY3D_DESCRIPTOR;









typedef struct CUDA_ARRAY_SPARSE_PROPERTIES_st {
    struct {
        unsigned int width;     
        unsigned int height;    
        unsigned int depth;     
    } tileExtent;

    


    unsigned int miptailFirstLevel;
    


    unsigned long long miptailSize;
    


    unsigned int flags;
    unsigned int reserved[4];
} CUDA_ARRAY_SPARSE_PROPERTIES_v1;
typedef CUDA_ARRAY_SPARSE_PROPERTIES_v1 CUDA_ARRAY_SPARSE_PROPERTIES;




typedef struct CUDA_ARRAY_MEMORY_REQUIREMENTS_st {
    size_t size;                
    size_t alignment;           
    unsigned int reserved[4];
} CUDA_ARRAY_MEMORY_REQUIREMENTS_v1;
typedef CUDA_ARRAY_MEMORY_REQUIREMENTS_v1 CUDA_ARRAY_MEMORY_REQUIREMENTS;




typedef struct CUDA_RESOURCE_DESC_st
{
    CUresourcetype resType;                   

    union {
        struct {
            CUarray hArray;                   
        } array;
        struct {
            CUmipmappedArray hMipmappedArray; 
        } mipmap;
        struct {
            CUdeviceptr devPtr;               
            CUarray_format format;            
            unsigned int numChannels;         
            size_t sizeInBytes;               
        } linear;
        struct {
            CUdeviceptr devPtr;               
            CUarray_format format;            
            unsigned int numChannels;         
            size_t width;                     
            size_t height;                    
            size_t pitchInBytes;              
        } pitch2D;
        struct {
            int reserved[32];
        } reserved;
    } res;

    unsigned int flags;                       
} CUDA_RESOURCE_DESC_v1;
typedef CUDA_RESOURCE_DESC_v1 CUDA_RESOURCE_DESC;




typedef struct CUDA_TEXTURE_DESC_st {
    CUaddress_mode addressMode[3];  
    CUfilter_mode filterMode;       
    unsigned int flags;             
    unsigned int maxAnisotropy;     
    CUfilter_mode mipmapFilterMode; 
    float mipmapLevelBias;          
    float minMipmapLevelClamp;      
    float maxMipmapLevelClamp;      
    float borderColor[4];           
    int reserved[12];
} CUDA_TEXTURE_DESC_v1;
typedef CUDA_TEXTURE_DESC_v1 CUDA_TEXTURE_DESC;




typedef enum CUresourceViewFormat_enum
{
    CU_RES_VIEW_FORMAT_NONE          = 0x00, 
    CU_RES_VIEW_FORMAT_UINT_1X8      = 0x01, 
    CU_RES_VIEW_FORMAT_UINT_2X8      = 0x02, 
    CU_RES_VIEW_FORMAT_UINT_4X8      = 0x03, 
    CU_RES_VIEW_FORMAT_SINT_1X8      = 0x04, 
    CU_RES_VIEW_FORMAT_SINT_2X8      = 0x05, 
    CU_RES_VIEW_FORMAT_SINT_4X8      = 0x06, 
    CU_RES_VIEW_FORMAT_UINT_1X16     = 0x07, 
    CU_RES_VIEW_FORMAT_UINT_2X16     = 0x08, 
    CU_RES_VIEW_FORMAT_UINT_4X16     = 0x09, 
    CU_RES_VIEW_FORMAT_SINT_1X16     = 0x0a, 
    CU_RES_VIEW_FORMAT_SINT_2X16     = 0x0b, 
    CU_RES_VIEW_FORMAT_SINT_4X16     = 0x0c, 
    CU_RES_VIEW_FORMAT_UINT_1X32     = 0x0d, 
    CU_RES_VIEW_FORMAT_UINT_2X32     = 0x0e, 
    CU_RES_VIEW_FORMAT_UINT_4X32     = 0x0f, 
    CU_RES_VIEW_FORMAT_SINT_1X32     = 0x10, 
    CU_RES_VIEW_FORMAT_SINT_2X32     = 0x11, 
    CU_RES_VIEW_FORMAT_SINT_4X32     = 0x12, 
    CU_RES_VIEW_FORMAT_FLOAT_1X16    = 0x13, 
    CU_RES_VIEW_FORMAT_FLOAT_2X16    = 0x14, 
    CU_RES_VIEW_FORMAT_FLOAT_4X16    = 0x15, 
    CU_RES_VIEW_FORMAT_FLOAT_1X32    = 0x16, 
    CU_RES_VIEW_FORMAT_FLOAT_2X32    = 0x17, 
    CU_RES_VIEW_FORMAT_FLOAT_4X32    = 0x18, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1  = 0x19, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2  = 0x1a, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3  = 0x1b, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4  = 0x1c, 
    CU_RES_VIEW_FORMAT_SIGNED_BC4    = 0x1d, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5  = 0x1e, 
    CU_RES_VIEW_FORMAT_SIGNED_BC5    = 0x1f, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 0x20, 
    CU_RES_VIEW_FORMAT_SIGNED_BC6H   = 0x21, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7  = 0x22  
} CUresourceViewFormat;




typedef struct CUDA_RESOURCE_VIEW_DESC_st
{
    CUresourceViewFormat format;   
    size_t width;                  
    size_t height;                 
    size_t depth;                  
    unsigned int firstMipmapLevel; 
    unsigned int lastMipmapLevel;  
    unsigned int firstLayer;       
    unsigned int lastLayer;        
    unsigned int reserved[16];
} CUDA_RESOURCE_VIEW_DESC_v1;
typedef CUDA_RESOURCE_VIEW_DESC_v1 CUDA_RESOURCE_VIEW_DESC;




typedef struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    unsigned long long p2pToken;
    unsigned int vaSpaceToken;
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1;
typedef CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 CUDA_POINTER_ATTRIBUTE_P2P_TOKENS;





typedef enum CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum {
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE      = 0x0,   
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ      = 0x1,   
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = 0x3    
} CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS;




typedef struct CUDA_LAUNCH_PARAMS_st {
    CUfunction function;         
    unsigned int gridDimX;       
    unsigned int gridDimY;       
    unsigned int gridDimZ;       
    unsigned int blockDimX;      
    unsigned int blockDimY;      
    unsigned int blockDimZ;      
    unsigned int sharedMemBytes; 
    CUstream hStream;            
    void **kernelParams;         
} CUDA_LAUNCH_PARAMS_v1;
typedef CUDA_LAUNCH_PARAMS_v1 CUDA_LAUNCH_PARAMS;




typedef enum CUexternalMemoryHandleType_enum {
    


    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD          = 1,
    


    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32       = 2,
    


    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT   = 3,
    


    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP         = 4,
    


    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE     = 5,
    


    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE     = 6,
    


    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7,
    


    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = 8
} CUexternalMemoryHandleType;








































typedef struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    


    CUexternalMemoryHandleType type;
    union {
        




        int fd;
        














        struct {
            


            void *handle;
            



            const void *name;
        } win32;
        



        const void *nvSciBufObject;
    } handle;
    


    unsigned long long size;
    


    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1;
typedef CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 CUDA_EXTERNAL_MEMORY_HANDLE_DESC;




typedef struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    


    unsigned long long offset;
    


    unsigned long long size;
    


    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1;
typedef CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 CUDA_EXTERNAL_MEMORY_BUFFER_DESC;




typedef struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    



    unsigned long long offset;
    


    CUDA_ARRAY3D_DESCRIPTOR arrayDesc;
    


    unsigned int numLevels;
    unsigned int reserved[16];
} CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1;
typedef CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC;




typedef enum CUexternalSemaphoreHandleType_enum {
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD             = 1,
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32          = 2,
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT      = 3,
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE           = 4,
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE           = 5,
    


	CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC             = 6,
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX     = 7,
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = 8,
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = 9,
    


    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10
} CUexternalSemaphoreHandleType;




typedef struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    


    CUexternalSemaphoreHandleType type;
    union {
        





        int fd;
        














        struct {
            


            void *handle;
            



            const void *name;
        } win32;
        


        const void* nvSciSyncObj;
    } handle;
    


    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1;
typedef CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC;




typedef struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    struct {
        


        struct {
            


            unsigned long long value;
        } fence;
        union {
            



            void *fence;
            unsigned long long reserved;
        } nvSciSync;
        


        struct {
            


            unsigned long long key;
        } keyedMutex;
        unsigned int reserved[12];
    } params;
    









    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1;
typedef CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS;




typedef struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    struct {
        


        struct {
            


            unsigned long long value;
        } fence;
        



        union {
            void *fence;
            unsigned long long reserved;
        } nvSciSync;
        


        struct {
            


            unsigned long long key;
            


            unsigned int timeoutMs;
        } keyedMutex;
        unsigned int reserved[10];
    } params;
    








    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1;
typedef CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS;




typedef struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    CUexternalSemaphore* extSemArray;                         
    const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS* paramsArray; 
    unsigned int numExtSems;                                  
} CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1;
typedef CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 CUDA_EXT_SEM_SIGNAL_NODE_PARAMS;




typedef struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    CUexternalSemaphore* extSemArray;                       
    const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS* paramsArray; 
    unsigned int numExtSems;                                
} CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1;
typedef CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 CUDA_EXT_SEM_WAIT_NODE_PARAMS;

typedef unsigned long long CUmemGenericAllocationHandle_v1;
typedef CUmemGenericAllocationHandle_v1 CUmemGenericAllocationHandle;




typedef enum CUmemAllocationHandleType_enum {
    CU_MEM_HANDLE_TYPE_NONE                  = 0x0,  
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = 0x1,  
    CU_MEM_HANDLE_TYPE_WIN32                 = 0x2,  
    CU_MEM_HANDLE_TYPE_WIN32_KMT             = 0x4,  
    CU_MEM_HANDLE_TYPE_MAX                   = 0x7FFFFFFF
} CUmemAllocationHandleType;




typedef enum CUmemAccess_flags_enum {
    CU_MEM_ACCESS_FLAGS_PROT_NONE        = 0x0,  
    CU_MEM_ACCESS_FLAGS_PROT_READ        = 0x1,  
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE   = 0x3,  
    CU_MEM_ACCESS_FLAGS_PROT_MAX         = 0x7FFFFFFF
} CUmemAccess_flags;




typedef enum CUmemLocationType_enum {
    CU_MEM_LOCATION_TYPE_INVALID = 0x0,
    CU_MEM_LOCATION_TYPE_DEVICE  = 0x1,  
    CU_MEM_LOCATION_TYPE_MAX     = 0x7FFFFFFF
} CUmemLocationType;




typedef enum CUmemAllocationType_enum {
    CU_MEM_ALLOCATION_TYPE_INVALID = 0x0,

    


    CU_MEM_ALLOCATION_TYPE_PINNED  = 0x1,
    CU_MEM_ALLOCATION_TYPE_MAX     = 0x7FFFFFFF
} CUmemAllocationType;




typedef enum CUmemAllocationGranularity_flags_enum {
    CU_MEM_ALLOC_GRANULARITY_MINIMUM     = 0x0,     
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = 0x1      
} CUmemAllocationGranularity_flags;




typedef enum CUmemRangeHandleType_enum
{
    CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD = 0x1,
    CU_MEM_RANGE_HANDLE_TYPE_MAX        = 0x7FFFFFFF
} CUmemRangeHandleType;




typedef enum CUarraySparseSubresourceType_enum {
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1
} CUarraySparseSubresourceType;




typedef enum CUmemOperationType_enum {
    CU_MEM_OPERATION_TYPE_MAP = 1,
    CU_MEM_OPERATION_TYPE_UNMAP = 2
} CUmemOperationType;




typedef enum CUmemHandleType_enum {
    CU_MEM_HANDLE_TYPE_GENERIC = 0
} CUmemHandleType;




typedef struct CUarrayMapInfo_st {    
    CUresourcetype resourceType;                    

    union {
        CUmipmappedArray mipmap;
        CUarray array;
    } resource;

    CUarraySparseSubresourceType subresourceType;   

    union {
        struct {
            unsigned int level;                                 
            unsigned int layer;                     
            unsigned int offsetX;                   
            unsigned int offsetY;                   
            unsigned int offsetZ;                               
            unsigned int extentWidth;               
            unsigned int extentHeight;              
            unsigned int extentDepth;               
        } sparseLevel;
        struct {
            unsigned int layer;                     
            unsigned long long offset;              
            unsigned long long size;                
        } miptail;
    } subresource;
    
    CUmemOperationType memOperationType;            
    CUmemHandleType memHandleType;                  

    union {
        CUmemGenericAllocationHandle memHandle;
    } memHandle;
    
    unsigned long long offset;                      
    unsigned int deviceBitMask;                     
    unsigned int flags;                             
    unsigned int reserved[2];                       
} CUarrayMapInfo_v1;
typedef CUarrayMapInfo_v1 CUarrayMapInfo;




typedef struct CUmemLocation_st {
    CUmemLocationType type; 
    int id;                 
} CUmemLocation_v1;
typedef CUmemLocation_v1 CUmemLocation;




typedef enum CUmemAllocationCompType_enum {
    CU_MEM_ALLOCATION_COMP_NONE = 0x0, 
    CU_MEM_ALLOCATION_COMP_GENERIC = 0x1 
} CUmemAllocationCompType;









typedef struct CUmemAllocationProp_st {
    
    CUmemAllocationType type;
    
    CUmemAllocationHandleType requestedHandleTypes;
    
    CUmemLocation location;
    






    void *win32HandleMetaData;
    struct {
         









         unsigned char compressionType;
         unsigned char gpuDirectRDMACapable;
         
         unsigned short usage;
         unsigned char reserved[4];
    } allocFlags;
} CUmemAllocationProp_v1;
typedef CUmemAllocationProp_v1 CUmemAllocationProp;




typedef struct CUmemAccessDesc_st {
    CUmemLocation location;        
    CUmemAccess_flags flags;       
} CUmemAccessDesc_v1;
typedef CUmemAccessDesc_v1 CUmemAccessDesc;

typedef enum CUgraphExecUpdateResult_enum {
    CU_GRAPH_EXEC_UPDATE_SUCCESS                     = 0x0, 
    CU_GRAPH_EXEC_UPDATE_ERROR                       = 0x1, 
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED      = 0x2, 
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED     = 0x3, 
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED      = 0x4, 
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED    = 0x5, 
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED         = 0x6, 
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = 0x7, 
    CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED    = 0x8  
} CUgraphExecUpdateResult;




typedef enum CUmemPool_attribute_enum {
    







    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = 1,

    




    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC,

    





    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES,

    







    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD,

    



    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT,

    




    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH,

    



    CU_MEMPOOL_ATTR_USED_MEM_CURRENT,

    




    CU_MEMPOOL_ATTR_USED_MEM_HIGH
} CUmemPool_attribute;




typedef struct CUmemPoolProps_st {
    CUmemAllocationType allocType;         
    CUmemAllocationHandleType handleTypes; 
    CUmemLocation location;                
    





    void *win32SecurityAttributes;
    unsigned char reserved[64]; 
} CUmemPoolProps_v1;
typedef CUmemPoolProps_v1 CUmemPoolProps;




typedef struct CUmemPoolPtrExportData_st {
    unsigned char reserved[64];
} CUmemPoolPtrExportData_v1;
typedef CUmemPoolPtrExportData_v1 CUmemPoolPtrExportData;




typedef struct CUDA_MEM_ALLOC_NODE_PARAMS_st {
    



    CUmemPoolProps poolProps;
    const CUmemAccessDesc *accessDescs; 
    size_t accessDescCount; 
    size_t bytesize; 
    CUdeviceptr dptr; 
} CUDA_MEM_ALLOC_NODE_PARAMS;

typedef enum CUgraphMem_attribute_enum {
    



    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT,

    




    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH,

    




    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT,

    




    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH
} CUgraphMem_attribute;
































































































 








































































typedef enum CUflushGPUDirectRDMAWritesOptions_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST   = 1<<0, 
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = 1<<1  
} CUflushGPUDirectRDMAWritesOptions;




typedef enum CUGPUDirectRDMAWritesOrdering_enum {
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE        = 0,   
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER       = 100, 
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = 200  
} CUGPUDirectRDMAWritesOrdering;




typedef enum CUflushGPUDirectRDMAWritesScope_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER       = 100, 
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = 200  
} CUflushGPUDirectRDMAWritesScope;
 



typedef enum CUflushGPUDirectRDMAWritesTarget_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = 0 
} CUflushGPUDirectRDMAWritesTarget;




typedef enum CUgraphDebugDot_flags_enum {
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE                        = 1<<0,  
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES                  = 1<<1,  
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS             = 1<<2,  
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS             = 1<<3,  
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS             = 1<<4,  
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS               = 1<<5,  
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS              = 1<<6,  
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS   = 1<<7,  
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS     = 1<<8,  
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES         = 1<<9,  
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES                        = 1<<10, 
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS          = 1<<11, 
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS           = 1<<12  
    ,
    CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS       = 1<<13  
} CUgraphDebugDot_flags;




typedef enum CUuserObject_flags_enum {
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = 1  
} CUuserObject_flags;




typedef enum CUuserObjectRetain_flags_enum {
    CU_GRAPH_USER_OBJECT_MOVE = 1  
} CUuserObjectRetain_flags;




typedef enum CUgraphInstantiate_flags_enum {
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH  = 1 
  , CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY    = 8 

} CUgraphInstantiate_flags;

 





#line 3700 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"





#line 3706 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
































CUresult __stdcall cuGetErrorString(CUresult error, const char **pStr);




















CUresult __stdcall cuGetErrorName(CUresult error, const char **pStr);

 































CUresult __stdcall cuInit(unsigned int Flags);

 



































CUresult __stdcall cuDriverGetVersion(int *driverVersion);

 








































CUresult __stdcall cuDeviceGet(CUdevice *device, int ordinal);




























CUresult __stdcall cuDeviceGetCount(int *count);































CUresult __stdcall cuDeviceGetName(char *name, int len, CUdevice dev);
































CUresult __stdcall cuDeviceGetUuid(CUuuid *uuid, CUdevice dev);




























CUresult __stdcall cuDeviceGetUuid_v2(CUuuid *uuid, CUdevice dev);




























CUresult __stdcall cuDeviceGetLuid(char *luid, unsigned int *deviceNodeMask, CUdevice dev);




























CUresult __stdcall cuDeviceTotalMem_v2(size_t *bytes, CUdevice dev);






























CUresult __stdcall cuDeviceGetTexture1DLinearMaxWidth(size_t *maxWidthInElements, CUarray_format format, unsigned numChannels, CUdevice dev);






























































































































































































































CUresult __stdcall cuDeviceGetAttribute(int *pi, CUdevice_attribute attrib, CUdevice dev);
















































CUresult __stdcall cuDeviceGetNvSciSyncAttributes(void *nvSciSyncAttrList, CUdevice dev, int flags);

















CUresult __stdcall cuDeviceSetMemPool(CUdevice dev, CUmemoryPool pool);















CUresult __stdcall cuDeviceGetMemPool(CUmemoryPool *pool, CUdevice dev);

















CUresult __stdcall cuDeviceGetDefaultMemPool(CUmemoryPool *pool_out, CUdevice dev);






























CUresult __stdcall cuFlushGPUDirectRDMAWrites(CUflushGPUDirectRDMAWritesTarget target, CUflushGPUDirectRDMAWritesScope scope);

 











































































__declspec(deprecated) CUresult __stdcall cuDeviceGetProperties(CUdevprop *prop, CUdevice dev);

































__declspec(deprecated) CUresult __stdcall cuDeviceComputeCapability(int *major, int *minor, CUdevice dev);

 
































































CUresult __stdcall cuDevicePrimaryCtxRetain(CUcontext *pctx, CUdevice dev);








































CUresult __stdcall cuDevicePrimaryCtxRelease_v2(CUdevice dev);
































































CUresult __stdcall cuDevicePrimaryCtxSetFlags_v2(CUdevice dev, unsigned int flags);

























CUresult __stdcall cuDevicePrimaryCtxGetState(CUdevice dev, unsigned int *flags, int *active);







































CUresult __stdcall cuDevicePrimaryCtxReset_v2(CUdevice dev);

 






























CUresult __stdcall cuDeviceGetExecAffinitySupport(int *pi, CUexecAffinityType type, CUdevice dev);












































































































CUresult __stdcall cuCtxCreate_v2(CUcontext *pctx, unsigned int flags, CUdevice dev);










































































































CUresult __stdcall cuCtxCreate_v3(CUcontext *pctx, CUexecAffinityParam *paramsArray, int numParams, unsigned int flags, CUdevice dev);












































CUresult __stdcall cuCtxDestroy_v2(CUcontext ctx);

































CUresult __stdcall cuCtxPushCurrent_v2(CUcontext ctx);

































CUresult __stdcall cuCtxPopCurrent_v2(CUcontext *pctx);





























CUresult __stdcall cuCtxSetCurrent(CUcontext ctx);






















CUresult __stdcall cuCtxGetCurrent(CUcontext *pctx);





























CUresult __stdcall cuCtxGetDevice(CUdevice *device);



























CUresult __stdcall cuCtxGetFlags(unsigned int *flags);





























CUresult __stdcall cuCtxSynchronize(void);


































































































CUresult __stdcall cuCtxSetLimit(CUlimit limit, size_t value);









































CUresult __stdcall cuCtxGetLimit(size_t *pvalue, CUlimit limit);











































CUresult __stdcall cuCtxGetCacheConfig(CUfunc_cache *pconfig);


















































CUresult __stdcall cuCtxSetCacheConfig(CUfunc_cache config);









































CUresult __stdcall cuCtxGetSharedMemConfig(CUsharedconfig *pConfig);




















































CUresult __stdcall cuCtxSetSharedMemConfig(CUsharedconfig config);





































CUresult __stdcall cuCtxGetApiVersion(CUcontext ctx, unsigned int *version);







































CUresult __stdcall cuCtxGetStreamPriorityRange(int *leastPriority, int *greatestPriority);















CUresult __stdcall cuCtxResetPersistingL2Cache(void);























CUresult __stdcall cuCtxGetExecAffinity(CUexecAffinityParam *pExecAffinity, CUexecAffinityType type);


 




















































__declspec(deprecated) CUresult __stdcall cuCtxAttach(CUcontext *pctx, unsigned int flags);



































__declspec(deprecated) CUresult __stdcall cuCtxDetach(CUcontext ctx);

 





















































CUresult __stdcall cuModuleLoad(CUmodule *module, const char *fname);





































CUresult __stdcall cuModuleLoadData(CUmodule *module, const void *image);











































CUresult __stdcall cuModuleLoadDataEx(CUmodule *module, const void *image, unsigned int numOptions, CUjit_option *options, void **optionValues);










































CUresult __stdcall cuModuleLoadFatBinary(CUmodule *module, const void *fatCubin);

























CUresult __stdcall cuModuleUnload(CUmodule hmod);




typedef enum CUmoduleLoadingMode_enum {
    CU_MODULE_EAGER_LOADING = 0x1, 
    CU_MODULE_LAZY_LOADING  = 0x2, 
} CUmoduleLoadingMode;

















CUresult __stdcall cuModuleGetLoadingMode(CUmoduleLoadingMode *mode);





























CUresult __stdcall cuModuleGetFunction(CUfunction *hfunc, CUmodule hmod, const char *name);


































CUresult __stdcall cuModuleGetGlobal_v2(CUdeviceptr *dptr, size_t *bytes, CUmodule hmod, const char *name);


































CUresult __stdcall cuModuleGetTexRef(CUtexref *pTexRef, CUmodule hmod, const char *name);
































CUresult __stdcall cuModuleGetSurfRef(CUsurfref *pSurfRef, CUmodule hmod, const char *name);







































CUresult __stdcall
cuLinkCreate_v2(unsigned int numOptions, CUjit_option *options, void **optionValues, CUlinkState *stateOut);




































CUresult __stdcall
cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void *data, size_t size, const char *name,
    unsigned int numOptions, CUjit_option *options, void **optionValues);





































CUresult __stdcall
cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char *path,
    unsigned int numOptions, CUjit_option *options, void **optionValues);
























CUresult __stdcall
cuLinkComplete(CUlinkState state, void **cubinOut, size_t *sizeOut);












CUresult __stdcall
cuLinkDestroy(CUlinkState state);

 























































CUresult __stdcall cuMemGetInfo_v2(size_t *free, size_t *total);

































CUresult __stdcall cuMemAlloc_v2(CUdeviceptr *dptr, size_t bytesize);





























































CUresult __stdcall cuMemAllocPitch_v2(CUdeviceptr *dptr, size_t *pPitch, size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes);



































CUresult __stdcall cuMemFree_v2(CUdeviceptr dptr);

































CUresult __stdcall cuMemGetAddressRange_v2(CUdeviceptr *pbase, size_t *psize, CUdeviceptr dptr);














































CUresult __stdcall cuMemAllocHost_v2(void **pp, size_t bytesize);





























CUresult __stdcall cuMemFreeHost(void *p);














































































CUresult __stdcall cuMemHostAlloc(void **pp, size_t bytesize, unsigned int Flags);




















































CUresult __stdcall cuMemHostGetDevicePointer_v2(CUdeviceptr *pdptr, void *p, unsigned int Flags);


























CUresult __stdcall cuMemHostGetFlags(unsigned int *pFlags, void *p);













































































































CUresult __stdcall cuMemAllocManaged(CUdeviceptr *dptr, size_t bytesize, unsigned int flags);




























CUresult __stdcall cuDeviceGetByPCIBusId(CUdevice *dev, const char *pciBusId);































CUresult __stdcall cuDeviceGetPCIBusId(char *pciBusId, int len, CUdevice dev);












































CUresult __stdcall cuIpcGetEventHandle(CUipcEventHandle *pHandle, CUevent event);







































CUresult __stdcall cuIpcOpenEventHandle(CUevent *phEvent, CUipcEventHandle handle);








































CUresult __stdcall cuIpcGetMemHandle(CUipcMemHandle *pHandle, CUdeviceptr dptr);

























































CUresult __stdcall cuIpcOpenMemHandle_v2(CUdeviceptr *pdptr, CUipcMemHandle handle, unsigned int Flags);

































CUresult __stdcall cuIpcCloseMemHandle(CUdeviceptr dptr);






















































































CUresult __stdcall cuMemHostRegister_v2(void *p, size_t bytesize, unsigned int Flags);

























CUresult __stdcall cuMemHostUnregister(void *p);







































CUresult __stdcall cuMemcpy(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount);





























CUresult __stdcall cuMemcpyPeer(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount);



































CUresult __stdcall cuMemcpyHtoD_v2(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount);



































CUresult __stdcall cuMemcpyDtoH_v2(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount);



































CUresult __stdcall cuMemcpyDtoD_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount);



































CUresult __stdcall cuMemcpyDtoA_v2(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount);





































CUresult __stdcall cuMemcpyAtoD_v2(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount);




































CUresult __stdcall cuMemcpyHtoA_v2(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount);




































CUresult __stdcall cuMemcpyAtoH_v2(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount);







































CUresult __stdcall cuMemcpyAtoA_v2(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount);



































































































































































CUresult __stdcall cuMemcpy2D_v2(const CUDA_MEMCPY2D *pCopy);

































































































































































CUresult __stdcall cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D *pCopy);








































































































































































CUresult __stdcall cuMemcpy3D_v2(const CUDA_MEMCPY3D *pCopy);























CUresult __stdcall cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER *pCopy);












































CUresult __stdcall cuMemcpyAsync(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream);
































CUresult __stdcall cuMemcpyPeerAsync(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream);








































CUresult __stdcall cuMemcpyHtoDAsync_v2(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount, CUstream hStream);








































CUresult __stdcall cuMemcpyDtoHAsync_v2(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);








































CUresult __stdcall cuMemcpyDtoDAsync_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);









































CUresult __stdcall cuMemcpyHtoAAsync_v2(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount, CUstream hStream);









































CUresult __stdcall cuMemcpyAtoHAsync_v2(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream);








































































































































































CUresult __stdcall cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D *pCopy, CUstream hStream);













































































































































































CUresult __stdcall cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D *pCopy, CUstream hStream);

























CUresult __stdcall cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER *pCopy, CUstream hStream);


































CUresult __stdcall cuMemsetD8_v2(CUdeviceptr dstDevice, unsigned char uc, size_t N);


































CUresult __stdcall cuMemsetD16_v2(CUdeviceptr dstDevice, unsigned short us, size_t N);


































CUresult __stdcall cuMemsetD32_v2(CUdeviceptr dstDevice, unsigned int ui, size_t N);







































CUresult __stdcall cuMemsetD2D8_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height);








































CUresult __stdcall cuMemsetD2D16_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height);








































CUresult __stdcall cuMemsetD2D32_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height);




































CUresult __stdcall cuMemsetD8Async(CUdeviceptr dstDevice, unsigned char uc, size_t N, CUstream hStream);




































CUresult __stdcall cuMemsetD16Async(CUdeviceptr dstDevice, unsigned short us, size_t N, CUstream hStream);



































CUresult __stdcall cuMemsetD32Async(CUdeviceptr dstDevice, unsigned int ui, size_t N, CUstream hStream);









































CUresult __stdcall cuMemsetD2D8Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, CUstream hStream);










































CUresult __stdcall cuMemsetD2D16Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, CUstream hStream);










































CUresult __stdcall cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, CUstream hStream);







































































































CUresult __stdcall cuArrayCreate_v2(CUarray *pHandle, const CUDA_ARRAY_DESCRIPTOR *pAllocateArray);

































CUresult __stdcall cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR *pArrayDescriptor, CUarray hArray);























CUresult __stdcall cuArrayGetSparseProperties(CUDA_ARRAY_SPARSE_PROPERTIES *sparseProperties, CUarray array);
























CUresult __stdcall cuMipmappedArrayGetSparseProperties(CUDA_ARRAY_SPARSE_PROPERTIES *sparseProperties, CUmipmappedArray mipmap);






















CUresult __stdcall cuArrayGetMemoryRequirements(CUDA_ARRAY_MEMORY_REQUIREMENTS *memoryRequirements, CUarray array, CUdevice device);
 






















CUresult __stdcall cuMipmappedArrayGetMemoryRequirements(CUDA_ARRAY_MEMORY_REQUIREMENTS *memoryRequirements, CUmipmappedArray mipmap, CUdevice device);
































CUresult __stdcall cuArrayGetPlane(CUarray *pPlaneArray, CUarray hArray, unsigned int planeIdx);






























CUresult __stdcall cuArrayDestroy(CUarray hArray);



















































































































































































CUresult __stdcall cuArray3DCreate_v2(CUarray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pAllocateArray);





































CUresult __stdcall cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR *pArrayDescriptor, CUarray hArray);













































































































































CUresult __stdcall cuMipmappedArrayCreate(CUmipmappedArray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pMipmappedArrayDesc, unsigned int numMipmapLevels);





























CUresult __stdcall cuMipmappedArrayGetLevel(CUarray *pLevelArray, CUmipmappedArray hMipmappedArray, unsigned int level);
























CUresult __stdcall cuMipmappedArrayDestroy(CUmipmappedArray hMipmappedArray);
































CUresult __stdcall cuMemGetHandleForAddressRange(void *handle, CUdeviceptr dptr, size_t size, CUmemRangeHandleType handleType, unsigned long long flags);

 






































CUresult __stdcall cuMemAddressReserve(CUdeviceptr *ptr, size_t size, size_t alignment, CUdeviceptr addr, unsigned long long flags);




















CUresult __stdcall cuMemAddressFree(CUdeviceptr ptr, size_t size);






































CUresult __stdcall cuMemCreate(CUmemGenericAllocationHandle *handle, size_t size, const CUmemAllocationProp *prop, unsigned long long flags);


























CUresult __stdcall cuMemRelease(CUmemGenericAllocationHandle handle);











































CUresult __stdcall cuMemMap(CUdeviceptr ptr, size_t size, size_t offset, CUmemGenericAllocationHandle handle, unsigned long long flags);






































































































































CUresult __stdcall cuMemMapArrayAsync(CUarrayMapInfo  *mapInfoList, unsigned int count, CUstream hStream);




























CUresult __stdcall cuMemUnmap(CUdeviceptr ptr, size_t size);
























CUresult __stdcall cuMemSetAccess(CUdeviceptr ptr, size_t size, const CUmemAccessDesc *desc, size_t count);


















CUresult __stdcall cuMemGetAccess(unsigned long long *flags, const CUmemLocation *location, CUdeviceptr ptr);
































CUresult __stdcall cuMemExportToShareableHandle(void *shareableHandle, CUmemGenericAllocationHandle handle, CUmemAllocationHandleType handleType, unsigned long long flags);


























CUresult __stdcall cuMemImportFromShareableHandle(CUmemGenericAllocationHandle *handle, void *osHandle, CUmemAllocationHandleType shHandleType);





















CUresult __stdcall cuMemGetAllocationGranularity(size_t *granularity, const CUmemAllocationProp *prop, CUmemAllocationGranularity_flags option);
















CUresult __stdcall cuMemGetAllocationPropertiesFromHandle(CUmemAllocationProp *prop, CUmemGenericAllocationHandle handle);























CUresult __stdcall cuMemRetainAllocationHandle(CUmemGenericAllocationHandle *handle, void *addr);

 






















































CUresult __stdcall cuMemFreeAsync(CUdeviceptr dptr, CUstream hStream);
































CUresult __stdcall cuMemAllocAsync(CUdeviceptr *dptr, size_t bytesize, CUstream hStream);

























CUresult __stdcall cuMemPoolTrimTo(CUmemoryPool pool, size_t minBytesToKeep);










































CUresult __stdcall cuMemPoolSetAttribute(CUmemoryPool pool, CUmemPool_attribute attr, void *value);














































CUresult __stdcall cuMemPoolGetAttribute(CUmemoryPool pool, CUmemPool_attribute attr, void *value);
















CUresult __stdcall cuMemPoolSetAccess(CUmemoryPool pool, const CUmemAccessDesc *map, size_t count);













CUresult __stdcall cuMemPoolGetAccess(CUmemAccess_flags *flags, CUmemoryPool memPool, CUmemLocation *location);





















CUresult __stdcall cuMemPoolCreate(CUmemoryPool *pool, const CUmemPoolProps *poolProps);






















CUresult __stdcall cuMemPoolDestroy(CUmemoryPool pool);





































CUresult __stdcall cuMemAllocFromPoolAsync(CUdeviceptr *dptr, size_t bytesize, CUmemoryPool pool, CUstream hStream);




























CUresult __stdcall cuMemPoolExportToShareableHandle(void *handle_out, CUmemoryPool pool, CUmemAllocationHandleType handleType, unsigned long long flags);























CUresult __stdcall cuMemPoolImportFromShareableHandle(
        CUmemoryPool *pool_out,
        void *handle,
        CUmemAllocationHandleType handleType,
        unsigned long long flags);



















CUresult __stdcall cuMemPoolExportPointer(CUmemPoolPtrExportData *shareData_out, CUdeviceptr ptr);




























CUresult __stdcall cuMemPoolImportPointer(CUdeviceptr *ptr_out, CUmemoryPool pool, CUmemPoolPtrExportData *shareData);

 


























































































































































































































































































CUresult __stdcall cuPointerGetAttribute(void *data, CUpointer_attribute attribute, CUdeviceptr ptr);



































































CUresult __stdcall cuMemPrefetchAsync(CUdeviceptr devPtr, size_t count, CUdevice dstDevice, CUstream hStream);

















































































































CUresult __stdcall cuMemAdvise(CUdeviceptr devPtr, size_t count, CUmem_advise advice, CUdevice device);

























































CUresult __stdcall cuMemRangeGetAttribute(void *data, size_t dataSize, CUmem_range_attribute attribute, CUdeviceptr devPtr, size_t count);







































CUresult __stdcall cuMemRangeGetAttributes(void **data, size_t *dataSizes, CUmem_range_attribute *attributes, size_t numAttributes, CUdeviceptr devPtr, size_t count);









































CUresult __stdcall cuPointerSetAttribute(const void *value, CUpointer_attribute attribute, CUdeviceptr ptr);
















































CUresult __stdcall cuPointerGetAttributes(unsigned int numAttributes, CUpointer_attribute *attributes, void **data, CUdeviceptr ptr);

 
















































CUresult __stdcall cuStreamCreate(CUstream *phStream, unsigned int Flags);
















































CUresult __stdcall cuStreamCreateWithPriority(CUstream *phStream, unsigned int flags, int priority);






























CUresult __stdcall cuStreamGetPriority(CUstream hStream, int *priority);



























CUresult __stdcall cuStreamGetFlags(CUstream hStream, unsigned int *flags);











































CUresult __stdcall cuStreamGetCtx(CUstream hStream, CUcontext *pctx);




































CUresult __stdcall cuStreamWaitEvent(CUstream hStream, CUevent hEvent, unsigned int Flags);










































































CUresult __stdcall cuStreamAddCallback(CUstream hStream, CUstreamCallback callback, void *userData, unsigned int flags);





































CUresult __stdcall cuStreamBeginCapture_v2(CUstream hStream, CUstreamCaptureMode mode);




















































CUresult __stdcall cuThreadExchangeStreamCaptureMode(CUstreamCaptureMode *mode);





























CUresult __stdcall cuStreamEndCapture(CUstream hStream, CUgraph *phGraph);







































CUresult __stdcall cuStreamIsCapturing(CUstream hStream, CUstreamCaptureStatus *captureStatus);



























CUresult __stdcall cuStreamGetCaptureInfo(CUstream hStream, CUstreamCaptureStatus *captureStatus_out, cuuint64_t *id_out);





















































CUresult __stdcall cuStreamGetCaptureInfo_v2(CUstream hStream, CUstreamCaptureStatus *captureStatus_out,
        cuuint64_t *id_out, CUgraph *graph_out, const CUgraphNode **dependencies_out, size_t *numDependencies_out);































CUresult __stdcall cuStreamUpdateCaptureDependencies(CUstream hStream, CUgraphNode *dependencies, size_t numDependencies, unsigned int flags);























































































CUresult __stdcall cuStreamAttachMemAsync(CUstream hStream, CUdeviceptr dptr, size_t length, unsigned int flags);





























CUresult __stdcall cuStreamQuery(CUstream hStream);




























CUresult __stdcall cuStreamSynchronize(CUstream hStream);





























CUresult __stdcall cuStreamDestroy_v2(CUstream hStream);



















CUresult __stdcall cuStreamCopyAttributes(CUstream dst, CUstream src);




















CUresult __stdcall cuStreamGetAttribute(CUstream hStream, CUstreamAttrID attr,
                                      CUstreamAttrValue *value_out);





















CUresult __stdcall cuStreamSetAttribute(CUstream hStream, CUstreamAttrID attr,
                                      const CUstreamAttrValue *value);

 





















































CUresult __stdcall cuEventCreate(CUevent *phEvent, unsigned int Flags);









































CUresult __stdcall cuEventRecord(CUevent hEvent, CUstream hStream);
















































CUresult __stdcall cuEventRecordWithFlags(CUevent hEvent, CUstream hStream, unsigned int flags);































CUresult __stdcall cuEventQuery(CUevent hEvent);






























CUresult __stdcall cuEventSynchronize(CUevent hEvent);




























CUresult __stdcall cuEventDestroy_v2(CUevent hEvent);












































CUresult __stdcall cuEventElapsedTime(float *pMilliseconds, CUevent hStart, CUevent hEnd);

 













 

































































































































































CUresult __stdcall cuImportExternalMemory(CUexternalMemory *extMem_out, const CUDA_EXTERNAL_MEMORY_HANDLE_DESC *memHandleDesc);





















































CUresult __stdcall cuExternalMemoryGetMappedBuffer(CUdeviceptr *devPtr, CUexternalMemory extMem, const CUDA_EXTERNAL_MEMORY_BUFFER_DESC *bufferDesc);























































CUresult __stdcall cuExternalMemoryGetMappedMipmappedArray(CUmipmappedArray *mipmap, CUexternalMemory extMem, const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC *mipmapDesc);





















CUresult __stdcall cuDestroyExternalMemory(CUexternalMemory extMem);




























































































































































CUresult __stdcall cuImportExternalSemaphore(CUexternalSemaphore *extSem_out, const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC *semHandleDesc);


































































CUresult __stdcall cuSignalExternalSemaphoresAsync(const CUexternalSemaphore *extSemArray, const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS *paramsArray, unsigned int numExtSems, CUstream stream);











































































CUresult __stdcall cuWaitExternalSemaphoresAsync(const CUexternalSemaphore *extSemArray, const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS *paramsArray, unsigned int numExtSems, CUstream stream);




















CUresult __stdcall cuDestroyExternalSemaphore(CUexternalSemaphore extSem);

 


























































































































CUresult __stdcall cuStreamWaitValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);












































CUresult __stdcall cuStreamWaitValue64(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags);


































CUresult __stdcall cuStreamWriteValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);

































CUresult __stdcall cuStreamWriteValue64(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags);












































CUresult __stdcall cuStreamBatchMemOp(CUstream stream, unsigned int count, CUstreamBatchMemOpParams *paramArray, unsigned int flags);













































CUresult __stdcall cuStreamWaitValue32_v2(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);












































CUresult __stdcall cuStreamWaitValue64_v2(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags);




























CUresult __stdcall cuStreamWriteValue32_v2(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);






























CUresult __stdcall cuStreamWriteValue64_v2(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags);










































CUresult __stdcall cuStreamBatchMemOp_v2(CUstream stream, unsigned int count, CUstreamBatchMemOpParams *paramArray, unsigned int flags);

 




























































































CUresult __stdcall cuFuncGetAttribute(int *pi, CUfunction_attribute attrib, CUfunction hfunc);






























































CUresult __stdcall cuFuncSetAttribute(CUfunction hfunc, CUfunction_attribute attrib, int value);











































CUresult __stdcall cuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config);



















































CUresult __stdcall cuFuncSetSharedMemConfig(CUfunction hfunc, CUsharedconfig config);

























CUresult __stdcall cuFuncGetModule(CUmodule *hmod, CUfunction hfunc);












































































































CUresult __stdcall cuLaunchKernel(CUfunction f,
                                unsigned int gridDimX,
                                unsigned int gridDimY,
                                unsigned int gridDimZ,
                                unsigned int blockDimX,
                                unsigned int blockDimY,
                                unsigned int blockDimZ,
                                unsigned int sharedMemBytes,
                                CUstream hStream,
                                void **kernelParams,
                                void **extra);












































































































































































CUresult __stdcall cuLaunchKernelEx(const CUlaunchConfig *config,
                                  CUfunction f,
                                  void **kernelParams,
                                  void **extra);













































































CUresult __stdcall cuLaunchCooperativeKernel(CUfunction f,
                                unsigned int gridDimX,
                                unsigned int gridDimY,
                                unsigned int gridDimZ,
                                unsigned int blockDimX,
                                unsigned int blockDimY,
                                unsigned int blockDimZ,
                                unsigned int sharedMemBytes,
                                CUstream hStream,
                                void **kernelParams);








































































































































__declspec(deprecated) CUresult __stdcall cuLaunchCooperativeKernelMultiDevice(CUDA_LAUNCH_PARAMS *launchParamsList, unsigned int numDevices, unsigned int flags);
































































CUresult __stdcall cuLaunchHostFunc(CUstream hStream, CUhostFn fn, void *userData);

 















































__declspec(deprecated) CUresult __stdcall cuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z);

































__declspec(deprecated) CUresult __stdcall cuFuncSetSharedSize(CUfunction hfunc, unsigned int bytes);































__declspec(deprecated) CUresult __stdcall cuParamSetSize(CUfunction hfunc, unsigned int numbytes);
































__declspec(deprecated) CUresult __stdcall cuParamSeti(CUfunction hfunc, int offset, unsigned int value);
































__declspec(deprecated) CUresult __stdcall cuParamSetf(CUfunction hfunc, int offset, float value);


































__declspec(deprecated) CUresult __stdcall cuParamSetv(CUfunction hfunc, int offset, void *ptr, unsigned int numbytes);



















































__declspec(deprecated) CUresult __stdcall cuLaunch(CUfunction f);





















































__declspec(deprecated) CUresult __stdcall cuLaunchGrid(CUfunction f, int grid_width, int grid_height);





























































__declspec(deprecated) CUresult __stdcall cuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream);
























__declspec(deprecated) CUresult __stdcall cuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef);
 












































CUresult __stdcall cuGraphCreate(CUgraph *phGraph, unsigned int flags);



































































































CUresult __stdcall cuGraphAddKernelNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_KERNEL_NODE_PARAMS *nodeParams);































CUresult __stdcall cuGraphKernelNodeGetParams(CUgraphNode hNode, CUDA_KERNEL_NODE_PARAMS *nodeParams);






















CUresult __stdcall cuGraphKernelNodeSetParams(CUgraphNode hNode, const CUDA_KERNEL_NODE_PARAMS *nodeParams);















































CUresult __stdcall cuGraphAddMemcpyNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_MEMCPY3D *copyParams, CUcontext ctx);






















CUresult __stdcall cuGraphMemcpyNodeGetParams(CUgraphNode hNode, CUDA_MEMCPY3D *nodeParams);






















CUresult __stdcall cuGraphMemcpyNodeSetParams(CUgraphNode hNode, const CUDA_MEMCPY3D *nodeParams);









































CUresult __stdcall cuGraphAddMemsetNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_MEMSET_NODE_PARAMS *memsetParams, CUcontext ctx);






















CUresult __stdcall cuGraphMemsetNodeGetParams(CUgraphNode hNode, CUDA_MEMSET_NODE_PARAMS *nodeParams);






















CUresult __stdcall cuGraphMemsetNodeSetParams(CUgraphNode hNode, const CUDA_MEMSET_NODE_PARAMS *nodeParams);








































CUresult __stdcall cuGraphAddHostNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_HOST_NODE_PARAMS *nodeParams);






















CUresult __stdcall cuGraphHostNodeGetParams(CUgraphNode hNode, CUDA_HOST_NODE_PARAMS *nodeParams);






















CUresult __stdcall cuGraphHostNodeSetParams(CUgraphNode hNode, const CUDA_HOST_NODE_PARAMS *nodeParams);







































CUresult __stdcall cuGraphAddChildGraphNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUgraph childGraph);


























CUresult __stdcall cuGraphChildGraphNodeGetGraph(CUgraphNode hNode, CUgraph *phGraph);





































CUresult __stdcall cuGraphAddEmptyNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies);








































CUresult __stdcall cuGraphAddEventRecordNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUevent event);
 























CUresult __stdcall cuGraphEventRecordNodeGetEvent(CUgraphNode hNode, CUevent *event_out);
























CUresult __stdcall cuGraphEventRecordNodeSetEvent(CUgraphNode hNode, CUevent event);









































CUresult __stdcall cuGraphAddEventWaitNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUevent event);
























CUresult __stdcall cuGraphEventWaitNodeGetEvent(CUgraphNode hNode, CUevent *event_out);
























CUresult __stdcall cuGraphEventWaitNodeSetEvent(CUgraphNode hNode, CUevent event);















































CUresult __stdcall cuGraphAddExternalSemaphoresSignalNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *nodeParams);






























CUresult __stdcall cuGraphExternalSemaphoresSignalNodeGetParams(CUgraphNode hNode, CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *params_out);
























CUresult __stdcall cuGraphExternalSemaphoresSignalNodeSetParams(CUgraphNode hNode, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *nodeParams);















































CUresult __stdcall cuGraphAddExternalSemaphoresWaitNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_EXT_SEM_WAIT_NODE_PARAMS *nodeParams);






























CUresult __stdcall cuGraphExternalSemaphoresWaitNodeGetParams(CUgraphNode hNode, CUDA_EXT_SEM_WAIT_NODE_PARAMS *params_out);
























CUresult __stdcall cuGraphExternalSemaphoresWaitNodeSetParams(CUgraphNode hNode, const CUDA_EXT_SEM_WAIT_NODE_PARAMS *nodeParams);






















































CUresult __stdcall cuGraphAddBatchMemOpNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_BATCH_MEM_OP_NODE_PARAMS *nodeParams);



























CUresult __stdcall cuGraphBatchMemOpNodeGetParams(CUgraphNode hNode, CUDA_BATCH_MEM_OP_NODE_PARAMS *nodeParams_out);

























CUresult __stdcall cuGraphBatchMemOpNodeSetParams(CUgraphNode hNode, const CUDA_BATCH_MEM_OP_NODE_PARAMS *nodeParams);













































CUresult __stdcall cuGraphExecBatchMemOpNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_BATCH_MEM_OP_NODE_PARAMS *nodeParams);









































































CUresult __stdcall cuGraphAddMemAllocNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUDA_MEM_ALLOC_NODE_PARAMS *nodeParams);
























CUresult __stdcall cuGraphMemAllocNodeGetParams(CUgraphNode hNode, CUDA_MEM_ALLOC_NODE_PARAMS *params_out);
























































CUresult __stdcall cuGraphAddMemFreeNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUdeviceptr dptr);





















CUresult __stdcall cuGraphMemFreeNodeGetParams(CUgraphNode hNode, CUdeviceptr *dptr_out);



















CUresult __stdcall cuDeviceGraphMemTrim(CUdevice device);



























CUresult __stdcall cuDeviceGetGraphMemAttribute(CUdevice device, CUgraphMem_attribute attr, void* value);
























CUresult __stdcall cuDeviceSetGraphMemAttribute(CUdevice device, CUgraphMem_attribute attr, void* value);
























CUresult __stdcall cuGraphClone(CUgraph *phGraphClone, CUgraph originalGraph);

























CUresult __stdcall cuGraphNodeFindInClone(CUgraphNode *phNode, CUgraphNode hOriginalNode, CUgraph hClonedGraph);






























CUresult __stdcall cuGraphNodeGetType(CUgraphNode hNode, CUgraphNodeType *type);






























CUresult __stdcall cuGraphGetNodes(CUgraph hGraph, CUgraphNode *nodes, size_t *numNodes);






























CUresult __stdcall cuGraphGetRootNodes(CUgraph hGraph, CUgraphNode *rootNodes, size_t *numRootNodes);

































CUresult __stdcall cuGraphGetEdges(CUgraph hGraph, CUgraphNode *from, CUgraphNode *to, size_t *numEdges);






























CUresult __stdcall cuGraphNodeGetDependencies(CUgraphNode hNode, CUgraphNode *dependencies, size_t *numDependencies);































CUresult __stdcall cuGraphNodeGetDependentNodes(CUgraphNode hNode, CUgraphNode *dependentNodes, size_t *numDependentNodes);




























CUresult __stdcall cuGraphAddDependencies(CUgraph hGraph, const CUgraphNode *from, const CUgraphNode *to, size_t numDependencies);































CUresult __stdcall cuGraphRemoveDependencies(CUgraph hGraph, const CUgraphNode *from, const CUgraphNode *to, size_t numDependencies);


























CUresult __stdcall cuGraphDestroyNode(CUgraphNode hNode);





































CUresult __stdcall cuGraphInstantiate_v2(CUgraphExec *phGraphExec, CUgraph hGraph, CUgraphNode *phErrorNode, char *logBuffer, size_t bufferSize);














































CUresult __stdcall cuGraphInstantiateWithFlags(CUgraphExec *phGraphExec, CUgraph hGraph, unsigned long long flags);











































CUresult __stdcall cuGraphExecKernelNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_KERNEL_NODE_PARAMS *nodeParams);













































CUresult __stdcall cuGraphExecMemcpyNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_MEMCPY3D *copyParams, CUcontext ctx);













































CUresult __stdcall cuGraphExecMemsetNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_MEMSET_NODE_PARAMS *memsetParams, CUcontext ctx);




































CUresult __stdcall cuGraphExecHostNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_HOST_NODE_PARAMS *nodeParams);










































CUresult __stdcall cuGraphExecChildGraphNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, CUgraph childGraph);







































CUresult __stdcall cuGraphExecEventRecordNodeSetEvent(CUgraphExec hGraphExec, CUgraphNode hNode, CUevent event);







































CUresult __stdcall cuGraphExecEventWaitNodeSetEvent(CUgraphExec hGraphExec, CUgraphNode hNode, CUevent event);










































CUresult __stdcall cuGraphExecExternalSemaphoresSignalNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *nodeParams);










































CUresult __stdcall cuGraphExecExternalSemaphoresWaitNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_EXT_SEM_WAIT_NODE_PARAMS *nodeParams);



































CUresult __stdcall cuGraphNodeSetEnabled(CUgraphExec hGraphExec, CUgraphNode hNode, unsigned int isEnabled);





























CUresult __stdcall cuGraphNodeGetEnabled(CUgraphExec hGraphExec, CUgraphNode hNode, unsigned int *isEnabled);

























CUresult __stdcall cuGraphUpload(CUgraphExec hGraphExec, CUstream hStream);





























CUresult __stdcall cuGraphLaunch(CUgraphExec hGraphExec, CUstream hStream);
























CUresult __stdcall cuGraphExecDestroy(CUgraphExec hGraphExec);



















CUresult __stdcall cuGraphDestroy(CUgraph hGraph);














































































CUresult __stdcall cuGraphExecUpdate(CUgraphExec hGraphExec, CUgraph hGraph, CUgraphNode *hErrorNode_out, CUgraphExecUpdateResult *updateResult_out);



















CUresult __stdcall cuGraphKernelNodeCopyAttributes(CUgraphNode dst, CUgraphNode src);




















CUresult __stdcall cuGraphKernelNodeGetAttribute(CUgraphNode hNode, CUkernelNodeAttrID attr,
                                      CUkernelNodeAttrValue *value_out);
 



















CUresult __stdcall cuGraphKernelNodeSetAttribute(CUgraphNode hNode, CUkernelNodeAttrID attr,
                                      const CUkernelNodeAttrValue *value);


















CUresult __stdcall cuGraphDebugDotPrint(CUgraph hGraph, const char *path, unsigned int flags);



































CUresult __stdcall cuUserObjectCreate(CUuserObject *object_out, void *ptr, CUhostFn destroy,
                                    unsigned int initialRefcount, unsigned int flags);























CUresult __stdcall cuUserObjectRetain(CUuserObject object, unsigned int count);



























CUresult __stdcall cuUserObjectRelease(CUuserObject object, unsigned int count);



























CUresult __stdcall cuGraphRetainUserObject(CUgraph graph, CUuserObject object, unsigned int count, unsigned int flags);
























CUresult __stdcall cuGraphReleaseUserObject(CUgraph graph, CUuserObject object, unsigned int count);

 




































CUresult __stdcall cuOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize);









































CUresult __stdcall cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize, unsigned int flags);



















































CUresult __stdcall cuOccupancyMaxPotentialBlockSize(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit);













































CUresult __stdcall cuOccupancyMaxPotentialBlockSizeWithFlags(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned int flags);






















CUresult __stdcall cuOccupancyAvailableDynamicSMemPerBlock(size_t *dynamicSmemSize, CUfunction func, int numBlocks, int blockSize);


































CUresult __stdcall cuOccupancyMaxPotentialClusterSize(int *clusterSize, CUfunction func, const CUlaunchConfig *config);




































CUresult __stdcall cuOccupancyMaxActiveClusters(int *numClusters, CUfunction func, const CUlaunchConfig *config);
 











































__declspec(deprecated) CUresult __stdcall cuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned int Flags);






























__declspec(deprecated) CUresult __stdcall cuTexRefSetMipmappedArray(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, unsigned int Flags);














































__declspec(deprecated) CUresult __stdcall cuTexRefSetAddress_v2(size_t *ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes);























































__declspec(deprecated) CUresult __stdcall cuTexRefSetAddress2D_v3(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR *desc, CUdeviceptr dptr, size_t Pitch);



































__declspec(deprecated) CUresult __stdcall cuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents);














































__declspec(deprecated) CUresult __stdcall cuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am);




































__declspec(deprecated) CUresult __stdcall cuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm);




































__declspec(deprecated) CUresult __stdcall cuTexRefSetMipmapFilterMode(CUtexref hTexRef, CUfilter_mode fm);





























__declspec(deprecated) CUresult __stdcall cuTexRefSetMipmapLevelBias(CUtexref hTexRef, float bias);































__declspec(deprecated) CUresult __stdcall cuTexRefSetMipmapLevelClamp(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp);






























__declspec(deprecated) CUresult __stdcall cuTexRefSetMaxAnisotropy(CUtexref hTexRef, unsigned int maxAniso);




































__declspec(deprecated) CUresult __stdcall cuTexRefSetBorderColor(CUtexref hTexRef, float *pBorderColor);













































__declspec(deprecated) CUresult __stdcall cuTexRefSetFlags(CUtexref hTexRef, unsigned int Flags);


























__declspec(deprecated) CUresult __stdcall cuTexRefGetAddress_v2(CUdeviceptr *pdptr, CUtexref hTexRef);


























__declspec(deprecated) CUresult __stdcall cuTexRefGetArray(CUarray *phArray, CUtexref hTexRef);


























__declspec(deprecated) CUresult __stdcall cuTexRefGetMipmappedArray(CUmipmappedArray *phMipmappedArray, CUtexref hTexRef);



























__declspec(deprecated) CUresult __stdcall cuTexRefGetAddressMode(CUaddress_mode *pam, CUtexref hTexRef, int dim);

























__declspec(deprecated) CUresult __stdcall cuTexRefGetFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);



























__declspec(deprecated) CUresult __stdcall cuTexRefGetFormat(CUarray_format *pFormat, int *pNumChannels, CUtexref hTexRef);

























__declspec(deprecated) CUresult __stdcall cuTexRefGetMipmapFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);

























__declspec(deprecated) CUresult __stdcall cuTexRefGetMipmapLevelBias(float *pbias, CUtexref hTexRef);


























__declspec(deprecated) CUresult __stdcall cuTexRefGetMipmapLevelClamp(float *pminMipmapLevelClamp, float *pmaxMipmapLevelClamp, CUtexref hTexRef);

























__declspec(deprecated) CUresult __stdcall cuTexRefGetMaxAnisotropy(int *pmaxAniso, CUtexref hTexRef);




























__declspec(deprecated) CUresult __stdcall cuTexRefGetBorderColor(float *pBorderColor, CUtexref hTexRef);
























__declspec(deprecated) CUresult __stdcall cuTexRefGetFlags(unsigned int *pFlags, CUtexref hTexRef);
























__declspec(deprecated) CUresult __stdcall cuTexRefCreate(CUtexref *pTexRef);



















__declspec(deprecated) CUresult __stdcall cuTexRefDestroy(CUtexref hTexRef);

 









































__declspec(deprecated) CUresult __stdcall cuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned int Flags);






















__declspec(deprecated) CUresult __stdcall cuSurfRefGetArray(CUarray *phArray, CUsurfref hSurfRef);

 













































































































































































































































CUresult __stdcall cuTexObjectCreate(CUtexObject *pTexObject, const CUDA_RESOURCE_DESC *pResDesc, const CUDA_TEXTURE_DESC *pTexDesc, const CUDA_RESOURCE_VIEW_DESC *pResViewDesc);



















CUresult __stdcall cuTexObjectDestroy(CUtexObject texObject);




















CUresult __stdcall cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC *pResDesc, CUtexObject texObject);




















CUresult __stdcall cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC *pTexDesc, CUtexObject texObject);





















CUresult __stdcall cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC *pResViewDesc, CUtexObject texObject);

 








































CUresult __stdcall cuSurfObjectCreate(CUsurfObject *pSurfObject, const CUDA_RESOURCE_DESC *pResDesc);



















CUresult __stdcall cuSurfObjectDestroy(CUsurfObject surfObject);




















CUresult __stdcall cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC *pResDesc, CUsurfObject surfObject);

 







































CUresult __stdcall cuDeviceCanAccessPeer(int *canAccessPeer, CUdevice dev, CUdevice peerDev);




















































CUresult __stdcall cuCtxEnablePeerAccess(CUcontext peerContext, unsigned int Flags);


























CUresult __stdcall cuCtxDisablePeerAccess(CUcontext peerContext);







































CUresult __stdcall cuDeviceGetP2PAttribute(int* value, CUdevice_P2PAttribute attrib, CUdevice srcDevice, CUdevice dstDevice);

 









































CUresult __stdcall cuGraphicsUnregisterResource(CUgraphicsResource resource);







































CUresult __stdcall cuGraphicsSubResourceGetMappedArray(CUarray *pArray, CUgraphicsResource resource, unsigned int arrayIndex, unsigned int mipLevel);






























CUresult __stdcall cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray *pMipmappedArray, CUgraphicsResource resource);

































CUresult __stdcall cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr *pDevPtr, size_t *pSize, CUgraphicsResource resource);








































CUresult __stdcall cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource resource, unsigned int flags);







































CUresult __stdcall cuGraphicsMapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);




































CUresult __stdcall cuGraphicsUnmapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);

 































































CUresult __stdcall cuGetProcAddress(const char *symbol, void **pfn, int cudaVersion, cuuint64_t flags);

 

CUresult __stdcall cuGetExportTable(const void **ppExportTable, const CUuuid *pExportTableId);

























































































































































































































































































































































#line 20272 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"









#line 20282 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"


}
#line 20286 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"





#line 20292 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"



#line 20296 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda.h"
#line 12 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#line 1 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 2726 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime.h"
#line 13 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#line 1 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\device_launch_parameters.h"





















































































































#line 119 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\device_launch_parameters.h"
#line 14 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#line 1 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime_api.h"



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13381 "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.8/include\\cuda_runtime_api.h"
#line 15 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\climits"





#pragma once







#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\climits"
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\climits"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdio"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )
















namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: FILE;
using :: _Mbstatet;

using :: size_t;
using :: fpos_t;
using :: FILE;
using :: clearerr;
using :: fclose;
using :: feof;
using :: ferror;
using :: fflush;
using :: fgetc;
using :: fgetpos;
using :: fgets;
using :: fopen;
using :: fprintf;
using :: fputc;
using :: fputs;
using :: fread;
using :: freopen;
using :: fscanf;
using :: fseek;
using :: fsetpos;
using :: ftell;
using :: fwrite;
using :: getc;
using :: getchar;
using :: perror;
using :: putc;
using :: putchar;
using :: printf;
using :: puts;
using :: remove;
using :: rename;
using :: rewind;
using :: scanf;
using :: setbuf;
using :: setvbuf;
using :: sprintf;
using :: sscanf;
using :: tmpfile;
using :: tmpnam;
using :: ungetc;
using :: vfprintf;
using :: vprintf;
using :: vsprintf;

using :: snprintf;
using :: vsnprintf;
using :: vfscanf;
using :: vscanf;
using :: vsscanf;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdio"
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstdio"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstring"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: size_t;
using :: memchr;
using :: memcmp;
using :: memcpy;
using :: memmove;
using :: memset;
using :: strcat;
using :: strchr;
using :: strcmp;
using :: strcoll;
using :: strcpy;
using :: strcspn;
using :: strerror;
using :: strlen;
using :: strncat;
using :: strncmp;
using :: strncpy;
using :: strpbrk;
using :: strrchr;
using :: strspn;
using :: strstr;
using :: strtok;
using :: strxfrm;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstring"
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cstring"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cwchar"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"









#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
     
     errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
     int __cdecl _cputws(
          wchar_t const* _Buffer
        );

           wint_t __cdecl _getwch  (void);
           wint_t __cdecl _getwche (void);
      wint_t __cdecl _putwch  (  wchar_t _Character);
      wint_t __cdecl _ungetwch(  wint_t  _Character);

           wint_t __cdecl _getwch_nolock  (void);
           wint_t __cdecl _getwche_nolock (void);
      wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
      wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
     int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
     int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_l(_Format, 0, _ArgList);
    }
#line 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vcwscanf_l(_Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

#line 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {











    

#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"
        
    #line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"

     const unsigned short* __cdecl __pctype_func(void);
     const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"





















   int __cdecl iswalnum  (  wint_t _C);
   int __cdecl iswalpha  (  wint_t _C);
   int __cdecl iswascii  (  wint_t _C);
   int __cdecl iswblank  (  wint_t _C);
   int __cdecl iswcntrl  (  wint_t _C);


   int __cdecl iswdigit  (  wint_t _C);

   int __cdecl iswgraph  (  wint_t _C);
   int __cdecl iswlower  (  wint_t _C);
   int __cdecl iswprint  (  wint_t _C);
   int __cdecl iswpunct  (  wint_t _C);
   int __cdecl iswspace  (  wint_t _C);
   int __cdecl iswupper  (  wint_t _C);
   int __cdecl iswxdigit (  wint_t _C);
   int __cdecl __iswcsymf(  wint_t _C);
   int __cdecl __iswcsym (  wint_t _C);

   int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


   wint_t __cdecl towupper(  wint_t _C);
   wint_t __cdecl towlower(  wint_t _C);
   int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

   wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
   wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
   int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



       int __cdecl isleadbyte(  int _C);
       int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details."))  int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"


















































































#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wdirect.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






 
   
 __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
 __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
 int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
 int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
 int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"








#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_share.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )











    
    
    
    
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_share.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {










    
    
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

 
 int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


 errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
 int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  
 int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
 intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
 int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

 int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
 int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

 errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

 
  wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

 
 
 intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
 intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
 intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
 int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
 int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
 int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


 errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

 errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wprocess.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    

         intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wprocess.h"
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )



    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/types.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"


















    
    
    
    
    
    
    
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"
















    
    
    
    
    
    
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"



 int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

 int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

 int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

 int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

 int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

 int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

 int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

 int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

 int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

 int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

 int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

 int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys/stat.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





        
     wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
     _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



     wint_t __cdecl btowc(
          int _Ch
        );

     size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
     errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

       size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

     
     errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

      size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

     
     errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

      size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

     int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cwchar"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




using _Mbstatet = mbstate_t;

namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

using :: mbstate_t;
using :: size_t;
using :: tm;
using :: wint_t;

using :: btowc;
using :: fgetwc;
using :: fgetws;
using :: fputwc;
using :: fputws;
using :: fwide;
using :: fwprintf;
using :: fwscanf;
using :: getwc;
using :: getwchar;
using :: mbrlen;
using :: mbrtowc;
using :: mbsrtowcs;
using :: mbsinit;
using :: putwc;
using :: putwchar;
using :: swprintf;
using :: swscanf;
using :: ungetwc;
using :: vfwprintf;
using :: vswprintf;
using :: vwprintf;
using :: wcrtomb;
using :: wprintf;
using :: wscanf;
using :: wcsrtombs;
using :: wcstol;
using :: wcscat;
using :: wcschr;
using :: wcscmp;
using :: wcscoll;
using :: wcscpy;
using :: wcscspn;
using :: wcslen;
using :: wcsncat;
using :: wcsncmp;
using :: wcsncpy;
using :: wcspbrk;
using :: wcsrchr;
using :: wcsspn;
using :: wcstod;
using :: wcstoul;
using :: wcsstr;
using :: wcstok;
using :: wcsxfrm;
using :: wctob;
using :: wmemchr;
using :: wmemcmp;
using :: wmemcpy;
using :: wmemmove;
using :: wmemset;
using :: wcsftime;

using :: vfwscanf;
using :: vswscanf;
using :: vwscanf;
using :: wcstof;
using :: wcstold;
using :: wcstoll;
using :: wcstoull;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cwchar"
#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cwchar"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {



















#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"


using streamoff  = long long;
using streamsize = long long;

template <class _Statetype>
class fpos { 
public:
     fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

    fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

    [[nodiscard]] _Statetype state() const {
        return _Mystate;
    }

    void state(_Statetype _State) {
        _Mystate = _State;
    }

    operator streamoff() const {
        
        
        return _Myoff + _Fpos;
    }


    [[deprecated("warning STL4019: " "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with " "workarounds for old versions of Visual C++. It will be removed in a future release, and in this " "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as " "conversions to and from streamoff, or an integral type, instead. If you are receiving this message " "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use " "standards-conforming mechanisms, as it does for other compilers. You can define " "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have received this warning, " "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t seekpos() const noexcept {
        return {};
    }
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"

    [[nodiscard]] streamoff operator-(const fpos& _Right) const {
        return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
    }

    fpos& operator+=(streamoff _Off) { 
        _Myoff += _Off;
        return *this;
    }

    fpos& operator-=(streamoff _Off) { 
        _Myoff -= _Off;
        return *this;
    }

    [[nodiscard]] fpos operator+(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] fpos operator-(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] bool operator==(const fpos& _Right) const {
        return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    friend bool operator==(const fpos& _Left, const _Int _Right) {
        return static_cast<streamoff>(_Left) == _Right;
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    friend bool operator==(const _Int _Left, const fpos& _Right) {
        return _Left == static_cast<streamoff>(_Right);
    }

    [[nodiscard]] bool operator!=(const fpos& _Right) const {
        return static_cast<streamoff>(*this) != static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    friend bool operator!=(const fpos& _Left, const _Int _Right) {
        return static_cast<streamoff>(_Left) != _Right;
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    friend bool operator!=(const _Int _Left, const fpos& _Right) {
        return _Left != static_cast<streamoff>(_Right);
    }

private:
    streamoff _Myoff; 
    fpos_t _Fpos; 
    _Statetype _Mystate; 
};

using streampos  = fpos<_Mbstatet>;
using wstreampos = streampos;

class locale;
template <class _Facet>
const _Facet& __cdecl use_facet(const locale&);

template <class _Elem>
struct char_traits;
template <>
struct char_traits<char>;




template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;

template <>
struct char_traits<unsigned short>;
#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"

template <class _Ty>
class allocator;
class ios_base;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ios;
template <class _Elem, class _Traits = char_traits<_Elem>>
class istreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class ostreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_streambuf;

#pragma vtordisp(push, 2) 
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_istream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ostream;
#pragma vtordisp(pop) 

template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_iostream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringbuf;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_istringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_ostringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_filebuf;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ifstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ofstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_fstream;







#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"








#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"

using ios           = basic_ios<char, char_traits<char>>;
using streambuf     = basic_streambuf<char, char_traits<char>>;
using istream       = basic_istream<char, char_traits<char>>;
using ostream       = basic_ostream<char, char_traits<char>>;
using iostream      = basic_iostream<char, char_traits<char>>;
using stringbuf     = basic_stringbuf<char, char_traits<char>, allocator<char>>;
using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
using stringstream  = basic_stringstream<char, char_traits<char>, allocator<char>>;
using filebuf       = basic_filebuf<char, char_traits<char>>;
using ifstream      = basic_ifstream<char, char_traits<char>>;
using ofstream      = basic_ofstream<char, char_traits<char>>;
using fstream       = basic_fstream<char, char_traits<char>>;



#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"

using wios           = basic_ios<wchar_t, char_traits<wchar_t>>;
using wstreambuf     = basic_streambuf<wchar_t, char_traits<wchar_t>>;
using wistream       = basic_istream<wchar_t, char_traits<wchar_t>>;
using wostream       = basic_ostream<wchar_t, char_traits<wchar_t>>;
using wiostream      = basic_iostream<wchar_t, char_traits<wchar_t>>;
using wstringbuf     = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wstringstream  = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wfilebuf       = basic_filebuf<wchar_t, char_traits<wchar_t>>;
using wifstream      = basic_ifstream<wchar_t, char_traits<wchar_t>>;
using wofstream      = basic_ofstream<wchar_t, char_traits<wchar_t>>;
using wfstream       = basic_fstream<wchar_t, char_traits<wchar_t>>;



#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"





#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
}



#pragma warning(pop)
#pragma pack(pop)
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iosfwd"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"





#pragma once








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"





#pragma once













#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Left, _Right)))  {
    
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
template <class _Ty>
[[nodiscard]]   constexpr const _Ty&(max)(
    const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right))  {
    
    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)

template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>, _Pr); 

template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>); 

template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Right, _Left)))  {
    
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
template <class _Ty>
[[nodiscard]]   constexpr const _Ty&(min)(
    const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left))  {
    
    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)

template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>, _Pr); 

template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>); 

template <class _FwdIt1, class _FwdIt2>
inline void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { 
    swap(*_Left, *_Right);
}

template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> _Enabled>
inline void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    if (&_Left != &_Right) {
        _Ty* _First1 = _Left;
        _Ty* _Last1  = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            ::std:: iter_swap(_First1, _First2);
        }
    }
}



#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
template <class _Ty, int _Enabled>
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
inline void swap(_Ty& _Left, _Ty& _Right) noexcept(
    is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {
    _Ty _Tmp = ::std:: move(_Left);
    _Left    = ::std:: move(_Right);
    _Right   = ::std:: move(_Tmp);
}

template <class _Ty>
inline void _Swap_adl(_Ty& _Left, _Ty& _Right) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    swap(_Left, _Right);
}

struct piecewise_construct_t { 
    explicit piecewise_construct_t() = default;
};

 constexpr piecewise_construct_t piecewise_construct{};

template <class...>
class tuple;

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

template <class _Ty1, class _Ty2>
struct pair { 
    using first_type  = _Ty1;
    using second_type = _Ty2;









#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>,
                        _Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>,
            int> = 0>
    constexpr pair() noexcept(
        is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) 
        : first(), second() {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>,
                        negation<conjunction<_Is_implicitly_default_constructible<_Uty1>,
                            _Is_implicitly_default_constructible<_Uty2>>>>,
            int> = 0>
    constexpr explicit pair() noexcept(
        is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) 
        : first(), second() {}
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"








#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>,
                        is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>,
            int> = 0>
    constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2) noexcept(
        is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<
            conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>,
                negation<conjunction<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>>>,
            int> = 0>
    constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2) noexcept(
        is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}
#line 179 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"








#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>,
            int> = 0>
    constexpr pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
        is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
        is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {}
#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"

    pair(const pair&) = default;
    pair(pair&&)      = default;









#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>,
                        is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>,
            int> = 0>
    constexpr pair(const pair<_Other1, _Other2>& _Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&&
            is_nothrow_constructible_v<_Ty2, const _Other2&>) 
        : first(_Right.first), second(_Right.second) {}

    template <class _Other1, class _Other2,
        enable_if_t<
            conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>,
                negation<conjunction<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_constructible_v<_Ty1, const _Other1&>&&
            is_nothrow_constructible_v<_Ty2, const _Other2&>) 
        : first(_Right.first), second(_Right.second) {}
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"








#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>,
            int> = 0>
    constexpr pair(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"

    template <class _Tuple1, class _Tuple2, size_t... _Indexes1, size_t... _Indexes2>
    constexpr pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>)
        : first(_Tuple_get<_Indexes1>(::std:: move(_Val1))...), second(_Tuple_get<_Indexes2>(::std:: move(_Val2))...) {}

    template <class... _Types1, class... _Types2>
    inline pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
        : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

    pair& operator=(const volatile pair&) = delete;

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    inline pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    inline pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>)  {
        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    inline pair& operator=(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, const _Other1&>&&
            is_nothrow_assignable_v<_Ty2&, const _Other2&>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    inline pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>)  {
        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }

    inline void swap(pair& _Right) noexcept(
        _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {
        if (this != ::std:: addressof(_Right)) {
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }

    _Ty1 first; 
    _Ty2 second; 
};




#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"

template <class _Ty1, class _Ty2, enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value, int> = 0>
inline void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return _Left.first == _Right.first && _Left.second == _Right.second;
}












template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return !(_Left == _Right);
}
#line 359 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return _Right < _Left;
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return !(_Right < _Left);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return !(_Left < _Right);
}
#line 380 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"

template <class _Ty>
struct _Unrefwrap_helper { 
    using type = _Ty;
};

template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { 
    using type = _Ty&;
};


template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2) noexcept(
    is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>&&
        is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>)  {
    
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2));
}

namespace  rel_ops {
    template <class _Ty>
     [[nodiscard]] bool operator!=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left == _Right);
    }

    template <class _Ty>
     [[nodiscard]] bool operator>(const _Ty& _Left, const _Ty& _Right) {
        return _Right < _Left;
    }

    template <class _Ty>
     [[nodiscard]] bool operator<=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Right < _Left);
    }

    template <class _Ty>
     [[nodiscard]] bool operator>=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left < _Right);
    }
} 

template <class _Tuple>
struct tuple_size;

template <class _Tuple, class = void>
struct _Tuple_size_sfinae {}; 

template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> {}; 

template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct  tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct  tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Ty>
 constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

template <size_t _Index, class _Tuple>
struct tuple_element;

template <size_t _Index, class _Tuple>
struct  tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_const_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct   tuple_element<_Index, volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_volatile_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct   tuple_element<_Index, const volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_cv_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

template <class _Ty, size_t _Size>
class array;

template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size> {}; 

template <size_t _Idx, class _Ty, size_t _Size>
struct  tuple_element<_Idx, array<_Ty, _Size>> {
    static_assert(_Idx < _Size, "array index out of bounds");

    using type = _Ty;
};

template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> {}; 

template <size_t _Index>
struct  tuple_element<_Index, tuple<>> { 
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};

template <class _This, class... _Rest>
struct  tuple_element<0, tuple<_This, _Rest...>> { 
    using type = _This;
    
    using _Ttype = tuple<_This, _Rest...>;
};

template <size_t _Index, class _This, class... _Rest>
struct  tuple_element<_Index, tuple<_This, _Rest...>>
    : tuple_element<_Index - 1, tuple<_Rest...>> {}; 

template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> {}; 

template <size_t _Idx, class _Ty1, class _Ty2>
struct  tuple_element<_Idx, pair<_Ty1, _Ty2>> {
    static_assert(_Idx < 2, "pair index out of bounds");

    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};

template <class _Ret, class _Pair>
constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 0>) noexcept { 
    return _Pr.first;
}

template <class _Ret, class _Pair>
constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 1>) noexcept { 
    return _Pr.second;
}

template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(
    pair<_Ty1, _Ty2>& _Pr) noexcept { 
    using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
    return _Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>{});
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<0>(_Pr);
}

template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<1>(_Pr);
}

template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
    return _Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>{});
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<0>(_Pr);
}

template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<1>(_Pr);
}

template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(
    pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
    return ::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr));
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<0>(::std:: move(_Pr));
}

template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<1>(::std:: move(_Pr));
}

template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
    return ::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr));
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<0>(::std:: move(_Pr));
}

template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<1>(::std:: move(_Pr));
}

template <class _Ty, class _Other = _Ty>
inline _Ty exchange(_Ty& _Val, _Other&& _New_val) noexcept(
    conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>)  {
    
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val         = static_cast<_Other&&>(_New_val);
    return _Old_val;
}

template <class _Ty>
[[nodiscard]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { 
    return _Val;
}

template <class _Ty>
void as_const(const _Ty&&) = delete;




















#line 635 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"










































































































#line 742 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: get;
    using ::std:: tuple_element;
    using ::std:: tuple_size;
} 
#line 750 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"

}



#pragma warning(pop)
#pragma pack(pop)
#line 758 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
#line 759 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\utility"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )







#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"






#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"





#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"


extern "C" {







__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;
}
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

namespace std {

template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] inline _To _Bit_cast(const _From& _Val) noexcept {

    _To _To_obj; 
    :: memcpy(::std:: addressof(_To_obj), ::std:: addressof(_Val), sizeof(_To));
    return _To_obj;


#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
}

template <class _Ty>
struct _Get_first_parameter;

template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { 
    using type = _First;
};

template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;

template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { 
    using type = _Ty<_Newfirst, _Rest...>;
};

template <class _Ty, class = void>
struct _Get_element_type {
    using type = typename _Get_first_parameter<_Ty>::type;
};

template <class _Ty>
struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>> {
    using type = typename _Ty::element_type;
};

template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};

template <class _Iter>
[[nodiscard]] constexpr void* _Voidify_iter(_Iter _It) noexcept {
    if constexpr (is_pointer_v<_Iter>) {
        return const_cast<void*>(static_cast<const volatile void*>(_It));
    } else {
        return const_cast<void*>(static_cast<const volatile void*>(::std:: addressof(*_It)));
    }
}








#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _Ty, class... _Types>
inline void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(
    is_nothrow_constructible_v<_Ty, _Types...>) {





    {
        ::new (_Voidify_iter(::std:: addressof(_Obj))) _Ty(::std:: forward<_Types>(_Args)...);
    }
}

template <class _Ty>
void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>) {
    ::new (_Voidify_iter(::std:: addressof(_Obj))) _Ty;
}

template <class _Ty>
struct pointer_traits {
    using pointer         = _Ty;
    using element_type    = typename _Get_element_type<_Ty>::type;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

    using _Reftype = conditional_t<is_void_v<element_type>, char, element_type>&;

    [[nodiscard]] static pointer pointer_to(_Reftype _Val) noexcept(noexcept(_Ty::pointer_to(_Val)))  {
        return _Ty::pointer_to(_Val);
    }
};

template <class _Ty>
struct pointer_traits<_Ty*> {
    using pointer         = _Ty*;
    using element_type    = _Ty;
    using difference_type = ptrdiff_t;

    template <class _Other>
    using rebind = _Other*;

    using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;

    [[nodiscard]] static inline pointer pointer_to(_Reftype _Val) noexcept {
        return ::std:: addressof(_Val);
    }
};









































#line 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"


template <class _Fx>
struct _Ref_fn { 
    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) { 
        if constexpr (is_member_pointer_v<_Fx>) {
            return ::std:: invoke(_Fn, ::std:: forward<_Args>(_Vals)...);
        } else {
            return _Fn(::std:: forward<_Args>(_Vals)...);
        }
    }

    _Fx& _Fn;
};

template <class _Fn>
 constexpr bool _Pass_functor_by_value_v = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
    is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;

template <class _Fn, enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0> 
constexpr _Fn _Pass_fn(_Fn _Val) { 
    return _Val;
}

template <class _Fn, enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val) { 
    return {_Val};
}

struct _Unused_parameter { 
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};

using _Any_tag = _Unused_parameter; 

template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;


struct input_iterator_tag {};

struct output_iterator_tag {};

struct forward_iterator_tag : input_iterator_tag {};

struct bidirectional_iterator_tag : forward_iterator_tag {};

struct random_access_iterator_tag : bidirectional_iterator_tag {};















































































































































































































































































































































































































































































































































































































































































































































































































































































































template <class, class = void>
struct _Iterator_traits_base {}; 

template <class _Iter>
struct _Iterator_traits_base<_Iter,
    void_t<typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type,
        typename _Iter::pointer, typename _Iter::reference>> {
    
    using iterator_category = typename _Iter::iterator_category;
    using value_type = typename _Iter::value_type;
    using difference_type = typename _Iter::difference_type;
    using pointer = typename _Iter::pointer;
    using reference = typename _Iter::reference;
};

template <class _Ty, bool = is_object_v<_Ty>>
struct _Iterator_traits_pointer_base { 
    using iterator_category = random_access_iterator_tag;
    using value_type = remove_cv_t<_Ty>;
    using difference_type = ptrdiff_t;
    using pointer = _Ty*;
    using reference = _Ty&;
};

template <class _Ty>
struct _Iterator_traits_pointer_base<_Ty, false> {}; 

template <class _Iter>
struct iterator_traits : _Iterator_traits_base<_Iter> {}; 

template <class _Ty>
struct iterator_traits<_Ty*> : _Iterator_traits_pointer_base<_Ty> {}; 

template <class _Iter>
using _Iter_ref_t = typename iterator_traits<_Iter>::reference;

template <class _Iter>
using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

template <class _Iter>
using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;
#line 1203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

template <class _Ty, class = void>
 constexpr bool _Is_iterator_v = false;

template <class _Ty>
 constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};

template <class _Iter>
 constexpr bool _Is_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

template <class _Iter>
 constexpr bool _Is_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

template <class _Iter>
 constexpr bool _Is_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

template <class _Iter>
 constexpr bool _Is_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

template <class, class = void>
struct _Is_checked_helper {}; 







#line 1241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _Iter, class = void>
 constexpr bool _Allow_inheriting_unwrap_v = true;

template <class _Iter>
 constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
    is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;

template <class _Iter, class _Sentinel = _Iter, class = void>
 constexpr bool _Range_verifiable_v = false;

template <class _Iter, class _Sentinel>
 constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>> =
    _Allow_inheriting_unwrap_v<_Iter>;

template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
    
    if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    }
}

template <class _Iter, class = void>
 constexpr bool _Unwrappable_v = false;

template <class _Iter>
 constexpr bool _Unwrappable_v<_Iter,
    void_t<decltype(::std:: declval<_Remove_cvref_t<_Iter>&>()._Seek_to(::std:: declval<_Iter>()._Unwrapped()))>> =
    _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std:: declval<_Iter>()))>;

template <class _Iter, class = bool>
 constexpr bool _Do_unwrap_when_unverified_v = false;

template <class _Iter>
 constexpr bool
    _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
        static_cast<bool>(_Iter::_Unwrap_when_unverified);

template <class _Iter>
 constexpr bool _Unwrappable_for_unverified_v =
    _Unwrappable_v<_Iter>&& _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std:: declval<_Iter>()))>;

struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template <class _Diff>
 constexpr auto _Max_possible_v = _Diff{static_cast<make_unsigned_t<_Diff>>(-1) >> 1};

template <class _Diff>
 constexpr auto _Min_possible_v = _Diff{-_Max_possible_v<_Diff> - 1};

template <class _Iter, class = void>
 constexpr bool _Offset_verifiable_v = false;

template <class _Iter>
 constexpr bool
    _Offset_verifiable_v<_Iter, void_t<decltype(::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> =
        true;

template <class _Iter>
 constexpr bool _Unwrappable_for_offset_v =
    _Unwrappable_v<_Iter>&& _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class _Diff>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
        
        using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
        using _CDiff     = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);

        ;
#line 1352 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
        (void) _COff;

        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter, class _UIter, class = void>
 constexpr bool _Wrapped_seekable_v = false;

template <class _Iter, class _UIter>
 constexpr bool
    _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<_UIter>()))>> =
        true;

template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(::std:: forward<_UIter>(_UIt));
    } else {
        _It = ::std:: forward<_UIter>(_UIt);
    }
}



































#line 1417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _Checked, class _Iter>
[[nodiscard]] constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
    
    if constexpr (_Is_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        return _Distance_unknown{};
    }
}

template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { 
    using type = underlying_type_t<_Elem>;
};

template <class _Elem>
struct _Unwrap_enum<_Elem, false> { 
    using type = _Elem;
};

template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;



















































#line 1492 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"


template <class _InIt, class _Diff>
inline void advance(_InIt& _Where, _Diff _Off) { 
    if constexpr (_Is_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>) {
            ;
        }

        decltype(auto) _UWhere      = _Get_unwrapped_n(::std:: move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std:: move(_Where), _Off))>;

        if constexpr (is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>) {
            for (; _Off < 0; ++_Off) {
                --_UWhere;
            }
        }

        for (; 0 < _Off; --_Off) {
            ++_UWhere;
        }

        if constexpr (_Need_rewrap) {
            _Seek_wrapped(_Where, ::std:: move(_UWhere));
        }
    }
}

template <class _InIt>
[[nodiscard]] inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
    if constexpr (_Is_random_iter_v<_InIt>) {
        return _Last - _First; 
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst             = _Get_unwrapped(_First);
        const auto _ULast        = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { 
    return ++_First;
}

template <class _InIt>
[[nodiscard]] inline _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1) { 
    static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");

    ::std:: advance(_First, _Off);
    return _First;
}

template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { 
    return --_First;
}

template <class _BidIt>
[[nodiscard]] inline _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1) { 
    static_assert(_Is_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

    ::std:: advance(_First, -_Off);
    return _First;
}

template <class _BidIt>
class reverse_iterator {
public:
    using iterator_type = _BidIt;







    using iterator_category = _Iter_cat_t<_BidIt>;
#line 1578 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
    using value_type      = _Iter_value_t<_BidIt>;
    using difference_type = _Iter_diff_t<_BidIt>;
    using pointer         = typename iterator_traits<_BidIt>::pointer;
    using reference       = _Iter_ref_t<_BidIt>;

    template <class>
    friend class reverse_iterator;

    inline reverse_iterator() = default;

    inline explicit reverse_iterator(_BidIt _Right) noexcept(
        is_nothrow_move_constructible_v<_BidIt>) 
        : current(::std:: move(_Right)) {}

    
    template <class _Other>



    inline reverse_iterator(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_BidIt, const _Other&>) 
        : current(_Right.current) {}

    template <class _Other>




    inline reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) {
        current = _Right.current;
        return *this;
    }
    

    [[nodiscard]] inline _BidIt base() const {
        return current;
    }

    [[nodiscard]] inline reference operator*() const {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }















    [[nodiscard]] inline pointer operator->() const {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v<_BidIt>) {
            return _Tmp;
        } else {
            return _Tmp.operator->();
        }
    }
#line 1645 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

    inline reverse_iterator& operator++() {
        --current;
        return *this;
    }

    inline reverse_iterator operator++(int) {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    inline reverse_iterator& operator--() {
        ++current;
        return *this;
    }

    inline reverse_iterator operator--(int) {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    [[nodiscard]] inline reverse_iterator operator+(const difference_type _Off) const {
        return reverse_iterator(current - _Off);
    }

    inline reverse_iterator& operator+=(const difference_type _Off) {
        current -= _Off;
        return *this;
    }

    [[nodiscard]] inline reverse_iterator operator-(const difference_type _Off) const {
        return reverse_iterator(current + _Off);
    }

    inline reverse_iterator& operator-=(const difference_type _Off) {
        current += _Off;
        return *this;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const {
        return current[static_cast<difference_type>(-_Off - 1)];
    }





















    using _Prevent_inheriting_unwrap = reverse_iterator;

    template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    friend constexpr void _Verify_range(const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) {
        _Verify_range(_Last._Get_current(), _First.current); 
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const {
        do { if (_Off != _Min_possible_v<difference_type>) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        current._Verify_offset(-_Off);
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const {
        return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) {
        current._Seek_to(_It.current);
    }

    [[nodiscard]] constexpr const _BidIt& _Get_current() const noexcept {
        return current;
    }

protected:
    _BidIt current{};
};

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() == _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() != _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() > _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() < _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() >= _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() <= _Right._Get_current(); }









template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline auto operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    -> decltype(_Right._Get_current() - _Left._Get_current()) {
    return _Right._Get_current() - _Left._Get_current();
}

template <class _BidIt>
[[nodiscard]] inline reverse_iterator<_BidIt> operator+(
    typename reverse_iterator<_BidIt>::difference_type _Off, const reverse_iterator<_BidIt>& _Right) {
    return _Right + _Off;
}

template <class _BidIt>
[[nodiscard]] inline reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter) noexcept(
    is_nothrow_move_constructible_v<_BidIt>)  {
    return reverse_iterator<_BidIt>(::std:: move(_Iter));
}









template <class _Container>
[[nodiscard]] inline auto begin(_Container& _Cont) -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

template <class _Container>
[[nodiscard]] inline auto begin(const _Container& _Cont) -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

template <class _Container>
[[nodiscard]] inline auto end(_Container& _Cont) -> decltype(_Cont.end()) {
    return _Cont.end();
}

template <class _Container>
[[nodiscard]] inline auto end(const _Container& _Cont) -> decltype(_Cont.end()) {
    return _Cont.end();
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {
    return _Array + _Size;
}

template <class _Container>
[[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std:: begin(_Cont)))
    -> decltype(::std:: begin(_Cont)) {
    return ::std:: begin(_Cont);
}

template <class _Container>
[[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std:: end(_Cont)))
    -> decltype(::std:: end(_Cont)) {
    return ::std:: end(_Cont);
}

template <class _Container>
[[nodiscard]] inline auto rbegin(_Container& _Cont) -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

template <class _Container>
[[nodiscard]] inline auto rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

template <class _Container>
[[nodiscard]] inline auto rend(_Container& _Cont) -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

template <class _Container>
[[nodiscard]] inline auto rend(const _Container& _Cont) -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

template <class _Ty, size_t _Size>
[[nodiscard]] inline reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) {
    return reverse_iterator<_Ty*>(_Array + _Size);
}

template <class _Ty, size_t _Size>
[[nodiscard]] inline reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) {
    return reverse_iterator<_Ty*>(_Array);
}

template <class _Elem>
[[nodiscard]] inline reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) {
    return reverse_iterator<const _Elem*>(_Ilist.end());
}

template <class _Elem>
[[nodiscard]] inline reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) {
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}

template <class _Container>
[[nodiscard]] inline auto crbegin(const _Container& _Cont) -> decltype(::std:: rbegin(_Cont)) {
    return ::std:: rbegin(_Cont);
}

template <class _Container>
[[nodiscard]] inline auto crend(const _Container& _Cont) -> decltype(::std:: rend(_Cont)) {
    return ::std:: rend(_Cont);
}

template <class _Container>
[[nodiscard]] constexpr auto size(const _Container& _Cont) -> decltype(_Cont.size()) {
    return _Cont.size();
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept {
    return _Size;
}













#line 1958 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _Container>
[[nodiscard]] constexpr auto empty(const _Container& _Cont) -> decltype(_Cont.empty()) {
    return _Cont.empty();
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr bool empty(const _Ty (&)[_Size]) noexcept {
    return false;
}

template <class _Elem>
[[nodiscard]] constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.size() == 0;
}

template <class _Container>
[[nodiscard]] constexpr auto data(_Container& _Cont) -> decltype(_Cont.data()) {
    return _Cont.data();
}

template <class _Container>
[[nodiscard]] constexpr auto data(const _Container& _Cont) -> decltype(_Cont.data()) {
    return _Cont.data();
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

template <class _Elem>
[[nodiscard]] constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































struct _Container_proxy;
struct _Iterator_base12;

struct _Default_sentinel {}; 

















template <class _Iter>
struct _Move_iterator_category {
    using iterator_category = _Iter_cat_t<_Iter>;
};
#line 3637 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _Iter>
class move_iterator : public _Move_iterator_category<_Iter> {
public:
    using iterator_type   = _Iter;
    using value_type      = _Iter_value_t<_Iter>;
    using difference_type = _Iter_diff_t<_Iter>;
    using pointer         = _Iter;





    using reference =
        conditional_t<is_reference_v<_Iter_ref_t<_Iter>>, remove_reference_t<_Iter_ref_t<_Iter>>&&, _Iter_ref_t<_Iter>>;
#line 3653 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

    inline move_iterator() = default;

    inline explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Right)) {}

    
    template <class _Other>



    inline move_iterator(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) 
        : _Current(_Right.base()) {}

    template <class _Other>




    inline move_iterator& operator=(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>)  {
        _Current = _Right.base();
        return *this;
    }
    









    [[nodiscard]] inline iterator_type base() const {
        return _Current;
    }
#line 3692 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

    [[nodiscard]] inline reference operator*() const {



        return static_cast<reference>(*_Current);
#line 3699 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
    }

     [[nodiscard]] inline pointer operator->() const {
        return _Current;
    }

    inline move_iterator& operator++() {
        ++_Current;
        return *this;
    }

    inline auto operator++(int) {



            move_iterator _Tmp = *this;
            ++_Current;
            return _Tmp;





    }

    inline move_iterator& operator--() {
        --_Current;
        return *this;
    }

    inline move_iterator operator--(int) {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() == _Sentinel) {
        return _Current == _Sentinel;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() != _Sentinel) {
        return _Current != _Sentinel;
    }

    [[nodiscard]] inline move_iterator operator+(const difference_type _Off) const {
        return move_iterator(_Current + _Off);
    }

    inline move_iterator& operator+=(const difference_type _Off) {
        _Current += _Off;
        return *this;
    }

    [[nodiscard]] inline move_iterator operator-(const difference_type _Off) const {
        return move_iterator(_Current - _Off);
    }

    inline move_iterator& operator-=(const difference_type _Off) {
        _Current -= _Off;
        return *this;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const {



        return ::std:: move(_Current[_Off]);
#line 3771 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
    }









































    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) {
        _Verify_range(_First._Current, _Last.base());
    }







    using _Prevent_inheriting_unwrap = move_iterator;

    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const {
        _Current._Verify_offset(_Off);
    }

    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& {
        return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) {
        _Current._Seek_to(_It.base());
    }
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(move_iterator<_Src>&& _It) {
        _Current._Seek_to(::std:: move(_It).base());
    }

private:
    iterator_type _Current{};
};

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)







{ return _Left.base() == _Right.base(); }


template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator!=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) {
    return !(_Left == _Right);
}
#line 3872 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)







{ return _Left.base() < _Right.base(); }

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator>(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)





{ return _Right < _Left; }

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator<=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)





{ return !(_Right < _Left); }

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator>=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)





{ return !(_Left < _Right); }









template <class _Iter1, class _Iter2>
[[nodiscard]] inline auto operator-(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    -> decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

template <class _Iter>
[[nodiscard]] inline move_iterator<_Iter> operator+(
    typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right)







{ return move_iterator<_Iter>{_Right.base() + _Off}; }

template <class _Iter>
[[nodiscard]] inline move_iterator<_Iter> make_move_iterator(_Iter _It) { 
    return move_iterator<_Iter>(::std:: move(_It));
}



































template <class _Iter>
 constexpr bool _Iterator_is_contiguous = is_pointer_v<_Iter>;

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const _Iter& _Val) noexcept {
    ;
    return _Val;
}
#line 3985 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"



template <class _Iter1, class _Iter2>
 constexpr bool _Iterators_are_contiguous =
    _Iterator_is_contiguous<_Iter1>&& _Iterator_is_contiguous<_Iter2>;

template <class _Source, class _Dest>
struct _Ptr_cat_helper {
    using _USource                        = _Unwrap_enum_t<_Source>;
    using _UDest                          = _Unwrap_enum_t<_Dest>;
    static constexpr bool _Really_trivial = conjunction_v<
        bool_constant<sizeof(_USource) == sizeof(_UDest) && is_same_v<bool, _USource> == is_same_v<bool, _UDest>>,
        is_integral<_USource>, is_integral<_UDest>>;
    static constexpr bool _Trivially_copyable = _Really_trivial;
};

template <class _Elem>
struct _Ptr_cat_helper<_Elem, _Elem> { 
    static constexpr bool _Really_trivial     = is_trivial_v<_Elem>;
    static constexpr bool _Trivially_copyable = is_trivially_copyable_v<_Elem>;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, const _Anything*> {
    
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, volatile _Anything*> {
    
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, const volatile _Anything*> {
    
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

struct _False_copy_cat {
    static constexpr bool _Really_trivial     = false;
    static constexpr bool _Trivially_copyable = false;
};


template <class _Source, class _Dest, bool _Non_contiguous = !_Iterators_are_contiguous<_Source, _Dest>>
struct _Ptr_move_cat : _False_copy_cat {};

template <class _Source, class _Dest>
struct _Ptr_move_cat<_Source, _Dest, false>
    : conditional_t<is_trivially_assignable_v<_Iter_ref_t<_Dest>, remove_reference_t<_Iter_ref_t<_Source>>>,
          _Ptr_cat_helper<_Iter_value_t<_Source>, _Iter_value_t<_Dest>>, _False_copy_cat> {};

template <class _Source, class _Dest>
struct _Ptr_move_cat<move_iterator<_Source>, _Dest, true> : _Ptr_move_cat<_Source, _Dest> {};

template <class _Source, class _Dest, bool _Non_contiguous = !_Iterators_are_contiguous<_Source, _Dest>>
struct _Ptr_copy_cat : _False_copy_cat {};

template <class _Source, class _Dest>
struct _Ptr_copy_cat<_Source, _Dest, false>
    : conditional_t<is_trivially_assignable_v<_Iter_ref_t<_Dest>, _Iter_ref_t<_Source>>,
          _Ptr_cat_helper<_Iter_value_t<_Source>, _Iter_value_t<_Dest>>, _False_copy_cat> {};

template <class _Source, class _Dest>
struct _Ptr_copy_cat<move_iterator<_Source>, _Dest, true> : _Ptr_move_cat<_Source, _Dest> {};

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    :: memmove(_Dest_ch, _First_ch, _Count);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);
    } else {
        return _Dest + (_LastPtr - _FirstPtr);
    }
}

template <class _InIt, class _OutIt>
_OutIt _Copy_memmove(move_iterator<_InIt> _First, move_iterator<_InIt> _Last, _OutIt _Dest) {
    return _Copy_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _It, bool _RequiresMutable = false>
 constexpr bool _Is_vb_iterator = false;

template <class _InIt, class _OutIt>
inline _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    
    if constexpr (_Ptr_copy_cat<_InIt, _OutIt>::_Trivially_copyable) {



        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = *_First;
    }

    return _Dest;
}

template <class _InIt, class _OutIt>
inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}










#line 4122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"












































































template <class _InIt, class _Diff, class _OutIt>
inline _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Trivially_copyable) {



            {
                _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
                _Seek_wrapped(_Dest, _UDest);
                return _Dest;
            }
        }

        for (;;) {
            *_UDest = *_UFirst;
            ++_UDest;
            --_Count;
            if (_Count == 0) { 
                               
                break;
            }

            ++_UFirst;
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}










#line 4244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _CtgIt1, class _CtgIt2>
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
    
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    auto _Result                = :: memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v<_CtgIt2>) {
        return static_cast<_CtgIt2>(_Result);
    } else {
        return _Dest - (_LastPtr - _FirstPtr);
    }
}

template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    if constexpr (_Ptr_copy_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {



        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = *--_Last;
    }

    return _Dest;
}

template <class _BidIt1, class _BidIt2>
inline _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}








#line 4306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _InIt, class _OutIt>
inline _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    
    if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {



        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = ::std:: move(*_First);
    }

    return _Dest;
}

template <class _InIt, class _OutIt>
inline _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}










#line 4348 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _BidIt1, class _BidIt2>
inline _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    
    if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {



        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = ::std:: move(*--_Last);
    }

    return _Dest;
}

template <class _BidIt1, class _BidIt2>
inline _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}








#line 4388 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"


template <class _Ty>
struct _Is_character : false_type {}; 

template <>
struct _Is_character<char> : true_type {}; 

template <>
struct _Is_character<signed char> : true_type {}; 

template <>
struct _Is_character<unsigned char> : true_type {}; 






template <class _Ty>
struct _Is_character_or_bool : _Is_character<_Ty>::type {};

template <>
struct _Is_character_or_bool<bool> : true_type {};

template <class _Ty>
struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};








template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
 constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
    _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
 constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
 constexpr bool _Fill_zero_memset_is_safe =
    conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
 constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _CtgIt, class _Ty>
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
    
    _Iter_value_t<_CtgIt> _Dest_val = _Val;
    :: memset(_To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
}

template <class _CtgIt>
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
    :: memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
}

template <class _Ty>
[[nodiscard]] bool _Is_all_bits_zero(const _Ty& _Val) {
    
    ;
    constexpr _Ty _Zero{};
    return :: memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
}

template <class _FwdIt, class _Ty>
inline void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_FwdIt, true>) {
        _Fill_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);



        {
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
                return;
            } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                if (_Is_all_bits_zero(_Val)) {
                    _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}









#line 4498 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _OutIt, class _Diff, class _Ty>
inline _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_OutIt, true>) {
            const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
            _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        } else {
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);



            {
                if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
                    _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
                    _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
                        _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }

            _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}









#line 4546 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

















































#pragma warning(push)
#pragma warning(disable : 4806) 
template <class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) 
        && is_integral_v<_Elem1> && !is_volatile_v<_Elem1> 
        && is_integral_v<_Elem2> && !is_volatile_v<_Elem2>>
 constexpr bool _Can_memcmp_elements =
    is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
#pragma warning(pop)












template <class _Ty1, class _Ty2>
 constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = is_same_v<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>;

template <class _Elem1, class _Elem2>
 constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;





template <class _Elem1, class _Elem2, class _Pr>
 constexpr bool _Pred_is_consistent_with_memcmp = false;



template <class _Elem>
 constexpr bool _Pred_is_consistent_with_memcmp<_Elem, _Elem, equal_to<_Elem>> = true;


template <class _Elem1, class _Elem2>
 constexpr bool _Pred_is_consistent_with_memcmp<_Elem1, _Elem2, equal_to<>> = true;










template <class _Elem1, class _Elem2, class _Pr>
 constexpr bool _Can_memcmp_elements_with_pred = _Can_memcmp_elements<_Elem1, _Elem2> 
    && _Pred_is_consistent_with_memcmp<_Elem1, _Elem2, _Pr>;




template <class _Iter1, class _Iter2, class _Pr>
 constexpr bool _Equal_memcmp_is_safe_helper = _Iterators_are_contiguous<_Iter1, _Iter2> 
    && _Can_memcmp_elements_with_pred<remove_const_t<remove_reference_t<_Iter_ref_t<_Iter1>>>,
        remove_const_t<remove_reference_t<_Iter_ref_t<_Iter2>>>, _Pr>;

template <class _Iter1, class _Iter2, class _Pr>
 constexpr bool _Equal_memcmp_is_safe =
    _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, _Pr>;

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2) {
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _Last1_ch  = reinterpret_cast<const char*>(_To_address(_Last1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));
}

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
}

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {



        {
            return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }

    return true;
}





#line 4710 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>{});
}








#line 4725 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_InIt1> && _Is_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return ::std:: equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}





#line 4767 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
}








#line 4783 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"































































































































template <class _Elem1, class _Elem2, class _FTy>
struct _Lex_compare_check_element_types_helper
    : bool_constant<
          conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, _Is_character<_FTy>, is_unsigned<_FTy>>> {
    
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
    : bool_constant<
          conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>> {
    
};













template <class _Memcmp_pr>
struct _Lex_compare_optimize {
    explicit _Lex_compare_optimize() = default;

    using _Pred = _Memcmp_pr;
}; 

template <class _Memcmp_pr, class _Obj1, class _Obj2, class _FTy>
using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<
    _Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value, _Memcmp_pr,
    void>>; 

template <class _InIt1, class _InIt2, class _Pr>
constexpr auto _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&) {
    
    return _Lex_compare_optimize<void>{};
}

template <class _CtgIt1, class _CtgIt2, class _FTy, enable_if_t<_Iterators_are_contiguous<_CtgIt1, _CtgIt2>, int> = 0>
constexpr auto _Lex_compare_memcmp_classify(const _CtgIt1&, const _CtgIt2&, const less<_FTy>&) {
    
    return _Lex_compare_check_element_types<less<int>, remove_reference_t<_Iter_ref_t<_CtgIt1>>,
        remove_reference_t<_Iter_ref_t<_CtgIt2>>, _FTy>{};
}

template <class _CtgIt1, class _CtgIt2, class _FTy, enable_if_t<_Iterators_are_contiguous<_CtgIt1, _CtgIt2>, int> = 0>
constexpr auto _Lex_compare_memcmp_classify(const _CtgIt1&, const _CtgIt2&, const greater<_FTy>&) {
    
    return _Lex_compare_check_element_types<greater<int>, remove_reference_t<_Iter_ref_t<_CtgIt1>>,
        remove_reference_t<_Iter_ref_t<_CtgIt2>>, _FTy>{};
}

















template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool _Lex_compare_unchecked(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<void>) {
    
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) { 
        if (static_cast<bool>(_Pred(*_First1, *_First2))) {
            return true;
        } else if (_Pred(*_First2, *_First1)) {
            return false;
        }
    }

    return _First1 == _Last1 && _First2 != _Last2;
}

template <class _CtgIt1, class _CtgIt2, class _Pr, class _Memcmp_pr>
[[nodiscard]] inline bool _Lex_compare_unchecked(
    _CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2, _CtgIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<_Memcmp_pr>) {
    





    (void) _Pred;
    const auto _Num1 = static_cast<size_t>(_Last1 - _First1);
    const auto _Num2 = static_cast<size_t>(_Last2 - _First2);
    const int _Ans   = _Memcmp_count(_First1, _First2, (::std:: min)(_Num1, _Num2));
    return _Memcmp_pr{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
}

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool lexicographical_compare(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    return _Lex_compare_unchecked(
        _UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred), _Lex_compare_memcmp_classify(_UFirst1, _UFirst2, _Pred));
}

template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
}





















#line 5056 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"




























































template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag, false_type) {
    
    return (-128) <= _Val && _Val <= 127;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type, false_type) {
    
    return _Val <= 127 || static_cast<_Ty>((-128)) <= _Val;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type, false_type) {
    
    return _Val <= 127;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag, false_type) {
    
    return 0 <= _Val && _Val <= 0xff;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag, false_type) {
    
    return _Val <= 0xff;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, _Any_tag, _Any_tag, _Any_tag, true_type) {
    
    return _Val == true || _Val == false;
}

template <class _InIt, class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _InIt&, const _Ty& _Val) {
    
    using _Elem = _Iter_value_t<_InIt>;
    return _Within_limits(_Val, bool_constant<is_signed_v<_Elem>>{}, bool_constant<is_signed_v<_Ty>>{},
        bool_constant<-1 == static_cast<_Ty>(-1)>{}, bool_constant<is_same_v<_Elem, bool>>{});
}

template <class _InIt>
[[nodiscard]] constexpr bool _Within_limits(const _InIt&, const bool&) { 
    return true;
}








template <class _Iter, class _Ty>
 constexpr bool _Memchr_in_find_is_safe =
    _Iterator_is_contiguous<_Iter>&&
        disjunction_v<conjunction<is_integral<_Ty>, _Is_character_or_bool<_Iter_value_t<_Iter>>>




            > && !is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;

template <class _InIt, class _Ty>
[[nodiscard]] constexpr _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, false_type) {
    
    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, true_type) {
    
    if (!_Within_limits(_First, _Val)) {
        return _Last;
    }







    const auto _First_ptr = _To_address(_First);
    const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
        :: memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
    if constexpr (is_pointer_v<_InIt>) {
        return _Result ? _Result : _Last;
    } else {
        return _Result ? _First + (_Result - _First_ptr) : _Last;
    }
}

template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    
    return _Find_unchecked1(_First, _Last, _Val, bool_constant<_Memchr_in_find_is_safe<_InIt, _Ty>>{});
}

template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    return _First;
}




#line 5235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

























































































template <class _InIt, class _Ty>
[[nodiscard]] inline _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst               = _Get_unwrapped(_First);
    const auto _ULast          = _Get_unwrapped(_Last);
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _UFirst != _ULast; ++_UFirst) {
        if (*_UFirst == _Val) {
            ++_Count;
        }
    }

    return _Count;
}





#line 5346 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> _Count_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool _Check_match_counts(
    const _FwdIt1 _First1, _FwdIt1 _Last1, const _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
    ;
    ;
    if constexpr (_Is_bidi_iter_v<_FwdIt1> && _Is_bidi_iter_v<_FwdIt2>) {
        do { 
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));
        ++_Last1;
        ++_Last2;
    }

    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) { 
            _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; 
            }

            _FwdIt1 _Skip1                = _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; 
            }
        }
    }

    return true;
}

template <class _BidIt>
inline void reverse(const _BidIt _First, const _BidIt _Last) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);

    using _Elem                         = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
    constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
        _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

#pragma warning(suppress : 6326) 
    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {



        {
            if constexpr (_Nx == 1) {
                __std_reverse_trivially_swappable_1(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 2) {
                __std_reverse_trivially_swappable_2(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 4) {
                __std_reverse_trivially_swappable_4(_To_address(_UFirst), _To_address(_ULast));
            } else {
                __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));
            }

            return;
        }
    }
#line 5435 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

    for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
        ::std:: iter_swap(_UFirst, _ULast);
    }
}








#line 5449 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _BidIt>
constexpr pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    
    while (_First != _Sentinel && _Last != _Sentinel) {
        ::std:: iter_swap(_First, --_Last);
        ++_First;
    }

    return pair<_BidIt, _BidIt>(_First, _Last);
}

template <class _FwdIt>
inline _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    
    
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    auto _UMid        = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_random_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        ::std:: reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_bidi_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std:: reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { 
            ::std:: iter_swap(_UFirst, _UNext);
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { 
            _UNext = _UMid;
            do {
                ::std:: iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}








#line 5525 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _InIt, class _Pr>
[[nodiscard]] inline _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}










































































































































































































































































template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid                   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: lower_bound(_First, _Last, _Val, less<>{});
}

template <class _FwdIt1, class _FwdIt2>
inline _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    
    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        ::std:: iter_swap(_First1, _First2);
    }

    return _First2;
}


template <class _Ty, enable_if_t<_Is_trivially_swappable_v<_Ty>, int> = 0>
inline _Ty* _Swap_ranges_unchecked(_Ty* _First1, _Ty* const _Last1, _Ty* _First2) {
    










    __std_swap_ranges_trivially_swappable_noalias(_First1, _Last1, _First2);
    return _First2 + (_Last1 - _First1);
}
#line 5862 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"

template <class _Diff, class _Urng>
class _Rng_from_urng { 
public:
    using _Ty0 = make_unsigned_t<_Diff>;
    using _Ty1 = typename _Urng::result_type;

    using _Udiff = conditional_t<sizeof(_Ty1) < sizeof(_Ty0), _Ty0, _Ty1>;

    explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(8 * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {
        for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {
            --_Bits;
        }
    }

    _Diff operator()(_Diff _Index) { 
        for (;;) { 
            _Udiff _Ret  = 0; 
            _Udiff _Mask = 0; 

            while (_Mask < _Udiff(_Index - 1)) { 
                _Ret <<= _Bits - 1; 
                _Ret <<= 1;
                _Ret |= _Get_bits();
                _Mask <<= _Bits - 1; 
                _Mask <<= 1;
                _Mask |= _Bmask;
            }

            
            if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {
                return static_cast<_Diff>(_Ret % _Index);
            }
        }
    }

    _Udiff _Get_all_bits() {
        _Udiff _Ret = 0;

        for (size_t _Num = 0; _Num < 8 * sizeof(_Udiff); _Num += _Bits) { 
            _Ret <<= _Bits - 1; 
            _Ret <<= 1;
            _Ret |= _Get_bits();
        }

        return _Ret;
    }

    _Rng_from_urng(const _Rng_from_urng&) = delete;
    _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
    _Udiff _Get_bits() { 
        for (;;) { 
            _Udiff _Val = _Ref() - (_Urng::min)();

            if (_Val <= _Bmask) {
                return _Val;
            }
        }
    }

    _Urng& _Ref; 
    size_t _Bits; 
    _Udiff _Bmask; 
};

template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type {}; 

template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type {}; 

struct allocator_arg_t { 
    explicit allocator_arg_t() = default;
};

 constexpr allocator_arg_t allocator_arg{};

[[noreturn]]  void __cdecl _Xbad_alloc();
[[noreturn]]  void __cdecl _Xinvalid_argument(  const char*);
[[noreturn]]  void __cdecl _Xlength_error(  const char*);
[[noreturn]]  void __cdecl _Xout_of_range(  const char*);
[[noreturn]]  void __cdecl _Xoverflow_error(  const char*);
[[noreturn]]  void __cdecl _Xruntime_error(  const char*);
[[noreturn]]  void __cdecl _XGetLastError();

template <class _Ty, class _Alloc>
struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {
    
};

template <class _Ty, class _Alloc>
 constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*, class _Reference = _Ty&>
struct  iterator { 
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] inline auto _Float_abs_bits(const _Ty& _Xx) {
    using _Traits    = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast<_Uint_type>(_Xx);
    return _Bits & ~_Traits::_Shifted_sign_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] inline _Ty _Float_abs(const _Ty _Xx) { 
    return _Bit_cast<_Ty>(_Float_abs_bits(_Xx));
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] inline _Ty _Float_copysign(const _Ty _Magnitude, const _Ty _Sign) { 
    using _Traits       = _Floating_type_traits<_Ty>;
    using _Uint_type    = typename _Traits::_Uint_type;
    const auto _Signbit = _Bit_cast<_Uint_type>(_Sign) & _Traits::_Shifted_sign_mask;
    return _Bit_cast<_Ty>(_Float_abs_bits(_Magnitude) | _Signbit);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] inline bool _Is_nan(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) > _Traits::_Shifted_exponent_mask;
}





template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] inline bool _Is_signaling_nan(const _Ty& _Xx) { 
    using _Traits        = _Floating_type_traits<_Ty>;
    const auto _Abs_bits = _Float_abs_bits(_Xx);
    return _Abs_bits > _Traits::_Shifted_exponent_mask && ((_Abs_bits & _Traits::_Special_nan_mantissa_mask) == 0);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] inline bool _Is_inf(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) == _Traits::_Shifted_exponent_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] inline bool _Is_finite(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) < _Traits::_Shifted_exponent_mask;
}

struct _Nontrivial_dummy_type {
    constexpr _Nontrivial_dummy_type() noexcept {
        
    }
};
;





}


#pragma warning(pop)
#pragma pack(pop)
#line 6034 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
#line 6035 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xutility"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Container>
class back_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;




    using difference_type = void;
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

    inline explicit back_insert_iterator(_Container& _Cont) noexcept 
        : container(::std:: addressof(_Cont)) {}

    inline back_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        container->push_back(_Val);
        return *this;
    }

    inline back_insert_iterator& operator=(typename _Container::value_type&& _Val) {
        container->push_back(::std:: move(_Val));
        return *this;
    }

    [[nodiscard]] inline back_insert_iterator& operator*() noexcept  {
        return *this;
    }

    inline back_insert_iterator& operator++() noexcept  {
        return *this;
    }

    inline back_insert_iterator operator++(int) noexcept  {
        return *this;
    }

protected:
    _Container* container;
};

template <class _Container>
[[nodiscard]] inline back_insert_iterator<_Container> back_inserter(_Container& _Cont) noexcept  {
    
    return back_insert_iterator<_Container>(_Cont);
}

template <class _Container>
class front_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;




    using difference_type = void;
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

    inline explicit front_insert_iterator(_Container& _Cont) : container(::std:: addressof(_Cont)) {}

    inline front_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        
        container->push_front(_Val);
        return *this;
    }

    inline front_insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        container->push_front(::std:: move(_Val));
        return *this;
    }

    [[nodiscard]] inline front_insert_iterator& operator*() { 
        return *this;
    }

    inline front_insert_iterator& operator++() { 
        return *this;
    }

    inline front_insert_iterator operator++(int) { 
        return *this;
    }

protected:
    _Container* container;
};

template <class _Container>
[[nodiscard]] inline front_insert_iterator<_Container> front_inserter(_Container& _Cont) {
    return front_insert_iterator<_Container>(_Cont);
}

template <class _Container>
class insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;




    using difference_type = void;
    using _Wrapped_iter   = typename _Container::iterator;
#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

    inline insert_iterator(_Container& _Cont, _Wrapped_iter _Where)
        : container(::std:: addressof(_Cont)), iter(::std:: move(_Where)) {}

    inline insert_iterator& operator=(const typename _Container::value_type& _Val) {
        
        iter = container->insert(iter, _Val);
        ++iter;
        return *this;
    }

    inline insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        iter = container->insert(iter, ::std:: move(_Val));
        ++iter;
        return *this;
    }

    [[nodiscard]] inline insert_iterator& operator*() { 
        return *this;
    }

    inline insert_iterator& operator++() { 
        return *this;
    }

    inline insert_iterator& operator++(int) { 
        return *this;
    }

protected:
    _Container* container;
    _Wrapped_iter iter;
};


template <class _Container>
[[nodiscard]] inline insert_iterator<_Container> inserter(_Container& _Cont, typename _Container::iterator _Where) {
    return insert_iterator<_Container>(_Cont, _Where);
}









































#line 220 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>, class _Diff = ptrdiff_t>
class istream_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = const _Ty*;
    using reference         = const _Ty&;
    using char_type         = _Elem;
    using traits_type       = _Traits;
    using istream_type      = basic_istream<_Elem, _Traits>;

    static_assert(conjunction_v<is_default_constructible<_Ty>, is_copy_constructible<_Ty>, is_copy_assignable<_Ty>>,
        "istream_iterator<T> requires T to be default constructible, copy constructible, and copy assignable. "
        "(N4835 [istream.iterator]/2)");

    constexpr istream_iterator() noexcept(is_nothrow_default_constructible_v<_Ty>)  {}






    istream_iterator(istream_type& _Istr) : _Myistr(::std:: addressof(_Istr)) {
        _Getval();
    }

    [[nodiscard]] const _Ty& operator*() const noexcept  {
        ;
        return _Myval;
    }

    [[nodiscard]] const _Ty* operator->() const noexcept  {
        ;
        return ::std:: addressof(_Myval);
    }

    istream_iterator& operator++() {
        _Getval();
        return *this;
    }

    istream_iterator operator++(int) {
        istream_iterator _Tmp = *this;
        _Getval();
        return _Tmp;
    }

    [[nodiscard]] bool _Equal(const istream_iterator& _Right) const noexcept {
        return _Myistr == _Right._Myistr;
    }







private:
    void _Getval() { 
        ;
        if (!(*_Myistr >> _Myval)) {
            _Myistr = nullptr;
        }
    }

    istream_type* _Myistr{nullptr}; 
    _Ty _Myval{}; 
};

template <class _Ty, class _Elem, class _Traits, class _Diff>
[[nodiscard]] bool operator==(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) noexcept  {
    return _Left._Equal(_Right);
}


template <class _Ty, class _Elem, class _Traits, class _Diff>
[[nodiscard]] bool operator!=(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) noexcept  {
    return !(_Left == _Right);
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>>
class ostream_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;



    using difference_type = void;
#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
    using pointer      = void;
    using reference    = void;
    using char_type    = _Elem;
    using traits_type  = _Traits;
    using ostream_type = basic_ostream<_Elem, _Traits>;

    ostream_iterator(ostream_type& _Ostr, const _Elem* const _Delim = nullptr) noexcept 
        : _Mydelim(_Delim), _Myostr(::std:: addressof(_Ostr)) {}

    ostream_iterator& operator=(const _Ty& _Val) { 
        *_Myostr << _Val;
        if (_Mydelim) {
            *_Myostr << _Mydelim;
        }

        return *this;
    }

    [[nodiscard]] ostream_iterator& operator*() noexcept  {
        return *this;
    }

    ostream_iterator& operator++() noexcept  {
        return *this;
    }

    ostream_iterator& operator++(int) noexcept  {
        return *this;
    }

private:
    const _Elem* _Mydelim; 
    ostream_type* _Myostr; 
};

template <class _Elem, class _Traits>
class istreambuf_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Elem;
    using difference_type   = typename _Traits::off_type;
    using pointer           = const _Elem*;
    using reference         = _Elem;
    using char_type         = _Elem;
    using traits_type       = _Traits;
    using int_type          = typename traits_type::int_type;
    using streambuf_type    = basic_streambuf<_Elem, _Traits>;
    using istream_type      = basic_istream<_Elem, _Traits>;

    constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}




    istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

    istreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb), _Got(!_Sb), _Val() {}

private:
    class _Istreambuf_proxy {
    public:
        [[nodiscard]] _Elem operator*() const noexcept(is_nothrow_copy_constructible_v<_Elem>)  {
            return _Keep;
        }

    private:
        friend istreambuf_iterator;
        _Istreambuf_proxy(streambuf_type* _Strbuf_, _Elem _Keep_) noexcept(
            is_nothrow_copy_constructible_v<_Elem>) 
            : _Strbuf(_Strbuf_), _Keep(_Keep_) {}

        streambuf_type* _Strbuf;
        _Elem _Keep;
    };

public:
    istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept : _Strbuf(_Px._Strbuf), _Got(!_Strbuf), _Val() {}

    [[nodiscard]] _Elem operator*() const {
        if (!_Got) {
            _Peek();
        }



#line 401 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

        return _Val;
    }

    istreambuf_iterator& operator++() {


#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

        _Inc();
        return *this;
    }

    _Istreambuf_proxy operator++(int) {
        if (!_Got) {
            _Peek();
        }

        _Istreambuf_proxy _Tmp{_Strbuf, _Val};
        ++*this;
        return _Tmp;
    }

    [[nodiscard]] bool equal(const istreambuf_iterator& _Right) const {
        if (!_Got) {
            _Peek();
        }

        if (!_Right._Got) {
            _Right._Peek();
        }

        return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);
    }











private:
    void _Inc() { 
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {
            _Strbuf = nullptr;
            _Got    = true;
        } else {
            _Got = false;
        }
    }

    _Elem _Peek() const { 
        int_type _Meta;
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {
            _Strbuf = nullptr;
        } else {
            _Val = traits_type::to_char_type(_Meta);
        }

        _Got = true;
        return _Val;
    }

    mutable streambuf_type* _Strbuf; 
    mutable bool _Got; 
    mutable _Elem _Val; 
};

template <class _Elem, class _Traits>
[[nodiscard]] bool operator==(
    const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {
    return _Left.equal(_Right);
}


template <class _Elem, class _Traits>
[[nodiscard]] bool operator!=(
    const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {
    return !(_Left == _Right);
}
#line 486 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

template <class _Elem, class _Traits>
class ostreambuf_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;



    using difference_type = void;
#line 497 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
    using pointer        = void;
    using reference      = void;
    using char_type      = _Elem;
    using traits_type    = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using ostream_type   = basic_ostream<_Elem, _Traits>;

    ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

    ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Strbuf(_Ostr.rdbuf()) {}

    ostreambuf_iterator& operator=(_Elem _Right) { 
        if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
            _Failed = true;
        }

        return *this;
    }

    [[nodiscard]] ostreambuf_iterator& operator*() noexcept  {
        return *this;
    }

    ostreambuf_iterator& operator++() noexcept  {
        return *this;
    }

    ostreambuf_iterator& operator++(int) noexcept  {
        return *this;
    }

    [[nodiscard]] bool failed() const noexcept {
        return _Failed;
    }

private:
    bool _Failed = false; 
    streambuf_type* _Strbuf;
};





























































































































































































































































































































































































































































































































































































































































































































































































































































































}

namespace stdext {
using ::std:: iterator_traits;
using ::std:: size_t;

template <class _Ptr>
class checked_array_iterator { 
    static_assert(::std:: is_pointer_v<_Ptr>, "checked_array_iterator requires pointers");

public:
    using iterator_category = typename iterator_traits<_Ptr>::iterator_category;
    using value_type        = typename iterator_traits<_Ptr>::value_type;
    using difference_type   = typename iterator_traits<_Ptr>::difference_type;
    using pointer           = typename iterator_traits<_Ptr>::pointer;
    using reference         = typename iterator_traits<_Ptr>::reference;

    constexpr checked_array_iterator() noexcept : _Myarray(nullptr), _Mysize(0), _Myindex(0) {}

    constexpr checked_array_iterator(const _Ptr _Array, const size_t _Size, const size_t _Index = 0) noexcept
        : _Myarray(_Array), _Mysize(_Size), _Myindex(_Index) {
        do { if (_Index <= _Size) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
    }

    [[nodiscard]] constexpr _Ptr base() const noexcept {
        return _Myarray + _Myindex;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *operator->();
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        do { if (_Myindex < _Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        return _Myarray + _Myindex;
    }

    constexpr checked_array_iterator& operator++() noexcept {
        do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        do { if (_Myindex < _Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        ++_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator++(int) noexcept {
        checked_array_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator--() noexcept {
        do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        do { if (_Myindex != 0) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        --_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator--(int) noexcept {
        checked_array_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator+=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        }

        if (_Off < 0) {
            do { if (_Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1469 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        }

        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1474 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        }

        _Myindex += _Off;
        return *this;
    }

    [[nodiscard]] constexpr checked_array_iterator operator+(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }




    friend constexpr checked_array_iterator operator+(
        const difference_type _Off, const checked_array_iterator<_Ptr>& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr checked_array_iterator& operator-=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        }

        if (_Off > 0) {
            do { if (_Myindex >= static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        }

        if (_Off < 0) {
            do { if (_Mysize - _Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1506 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        }

        _Myindex -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr checked_array_iterator operator-(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1521 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        return static_cast<difference_type>(_Myindex - _Right._Myindex);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1531 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        return _Myindex == _Right._Myindex;
    }







#line 1541 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
    [[nodiscard]] constexpr bool operator!=(const checked_array_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] constexpr bool operator<(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1548 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        return _Myindex < _Right._Myindex;
    }

    [[nodiscard]] constexpr bool operator>(const checked_array_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] constexpr bool operator<=(const checked_array_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] constexpr bool operator>=(const checked_array_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 1563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

    friend constexpr void _Verify_range(
        const checked_array_iterator& _First, const checked_array_iterator& _Last) noexcept {
        do { if (_First._Myarray == _Last._Myarray && _First._Mysize == _Last._Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        do { if (_First._Myindex <= _Last._Myindex) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        if (_Off < 0) {
            do { if (_Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1575 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        }

        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1580 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
        }
    }

    using _Prevent_inheriting_unwrap = checked_array_iterator;

    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myarray + _Myindex;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myindex = static_cast<size_t>(_It - _Myarray);
    }

private:
    _Ptr _Myarray; 
    size_t _Mysize; 
    size_t _Myindex; 
};

template <class _Ptr>
[[nodiscard]] constexpr checked_array_iterator<_Ptr> make_checked_array_iterator(
    const _Ptr _Array, const size_t _Size, const size_t _Index = 0) {
    return checked_array_iterator<_Ptr>(_Array, _Size, _Index);
}

template <class _Ptr>
class unchecked_array_iterator { 
    static_assert(::std:: is_pointer_v<_Ptr>, "unchecked_array_iterator requires pointers");

public:
    using iterator_category = typename iterator_traits<_Ptr>::iterator_category;
    using value_type        = typename iterator_traits<_Ptr>::value_type;
    using difference_type   = typename iterator_traits<_Ptr>::difference_type;
    using pointer           = typename iterator_traits<_Ptr>::pointer;
    using reference         = typename iterator_traits<_Ptr>::reference;

    constexpr unchecked_array_iterator() noexcept : _Myptr(nullptr) {}

    constexpr explicit unchecked_array_iterator(const _Ptr _Src) noexcept : _Myptr(_Src) {}

    [[nodiscard]] constexpr _Ptr base() const noexcept {
        return _Myptr;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *_Myptr;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return _Myptr;
    }

    constexpr unchecked_array_iterator& operator++() noexcept {
        ++_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator++(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        ++_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator--() noexcept {
        --_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator--(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        --_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator+=(const difference_type _Off) noexcept {
        _Myptr += _Off;
        return *this;
    }

    [[nodiscard]] constexpr unchecked_array_iterator operator+(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }




    friend constexpr unchecked_array_iterator operator+(
        const difference_type _Off, const unchecked_array_iterator& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr unchecked_array_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] constexpr unchecked_array_iterator operator-(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr - _Right._Myptr;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr == _Right._Myptr;
    }





#line 1700 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
    [[nodiscard]] constexpr bool operator!=(const unchecked_array_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] constexpr bool operator<(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr < _Right._Myptr;
    }

    [[nodiscard]] constexpr bool operator>(const unchecked_array_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] constexpr bool operator<=(const unchecked_array_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] constexpr bool operator>=(const unchecked_array_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 1720 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"






#line 1727 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"

    using _Prevent_inheriting_unwrap = unchecked_array_iterator;

    static constexpr bool _Unwrap_when_unverified = true;

    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myptr;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myptr = _It;
    }

private:
    _Ptr _Myptr; 
};

template <class _Ptr>
[[nodiscard]] unchecked_array_iterator<_Ptr> make_unchecked_array_iterator(const _Ptr _It) noexcept {
    return unchecked_array_iterator<_Ptr>(_It);
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 1755 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
#line 1756 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iterator"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\share.h"







#pragma once




#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\share.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_system_error_abi.hpp"





#pragma once






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )








#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_system_error_abi.hpp"

extern "C" {
[[nodiscard]] size_t __stdcall __std_get_string_size_without_trailing_whitespace(
    const char* _Str, size_t _Size) noexcept;

[[nodiscard]] size_t __stdcall __std_system_error_allocate_message(
    unsigned long _Message_id, char** _Ptr_str) noexcept;
void __stdcall __std_system_error_deallocate_message(char* _Str) noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_system_error_abi.hpp"
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_system_error_abi.hpp"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cerrno"





#pragma once







#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cerrno"
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cerrno"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"







#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cfloat"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"








#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
    #line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"



















    






        
    #line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
























































































































































#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"

    

#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"











 unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141) 

 
 unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


 void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


 errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


 unsigned int __cdecl _statusfp(void);


 void __cdecl _fpreset(void);















 unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );












 
 int* __cdecl __fpecode(void);



 
 int __cdecl __fpe_flt_rounds(void);












   double __cdecl _copysign(  double _Number,   double _Sign);
   double __cdecl _chgsign(  double _X);
   double __cdecl _scalb(  double _X,   long _Y);
   double __cdecl _logb(  double _X);
   double __cdecl _nextafter(  double _X,   double _Y);
   int    __cdecl _finite(  double _X);
   int    __cdecl _isnan(  double _X);
   int    __cdecl _fpclass(  double _X);


       float __cdecl _scalbf(  float _X,   long _Y);
#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"










    
    
    

    
     void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cfloat"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cfloat"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.h"












#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"













#pragma once





#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C" {
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"






























#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"


#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"






#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"




#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"




#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"




#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"






#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"




#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"




#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"




#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"




#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"




#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"









unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _bittest(long const *, long);


long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);



__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedand64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedAnd8(char volatile * _Value, char _Mask);






long  _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);



long  _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);
__int64 _InterlockedDecrement64(__int64 volatile * _Addend);
__int64 _interlockeddecrement64(__int64 volatile * _Addend);
long  _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);
__int64 _interlockedexchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long  _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);
__int64 _interlockedexchangeadd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);









long  _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);
__int64 _InterlockedIncrement64(__int64 volatile * _Addend);
__int64 _interlockedincrement64(__int64 volatile * _Addend);

long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);



__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);



__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedxor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);
__int16 __iso_volatile_load16(const volatile __int16 *);
__int32 __iso_volatile_load32(const volatile __int32 *);
__int64 __iso_volatile_load64(const volatile __int64 *);
__int8 __iso_volatile_load8(const volatile __int8 *);
void __iso_volatile_store16(volatile __int16 *, __int16);
void __iso_volatile_store32(volatile __int32 *, __int32);
void __iso_volatile_store64(volatile __int64 *, __int64);
void __iso_volatile_store8(volatile __int8 *, __int8);


unsigned char _interlockedbittestandset(long volatile *, long);



void _mm_pause(void);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);

unsigned int _tzcnt_u32(unsigned int);
unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);
double __ceil(double);
float __ceilf(float);
double __floor(double);
float __floorf(float);
double __round(double);
float __roundf(float);
double __trunc(double);
float __truncf(float);
double __copysign(double, double);
float __copysignf(float, float);
unsigned __signbitvalue(double);
unsigned __signbitvaluef(float);
int _cvt_ftoi_sat (float a);
unsigned _cvt_ftoui_sat (float a);
long long _cvt_ftoll_sat (float a);
unsigned long long _cvt_ftoull_sat (float a);
int _cvt_ftoi_sent (float a);
unsigned _cvt_ftoui_sent (float a);
long long _cvt_ftoll_sent (float a);
unsigned long long _cvt_ftoull_sent (float a);
int _cvt_dtoi_sat (double a);
unsigned _cvt_dtoui_sat (double a);
long long _cvt_dtoll_sat (double a);
unsigned long long _cvt_dtoull_sat (double a);
int _cvt_dtoi_sent (double a);
unsigned _cvt_dtoui_sent (double a);
long long _cvt_dtoll_sent (double a);
unsigned long long _cvt_dtoull_sent (double a);



#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
void * __cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept;
#line 312 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
#line 313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"








}
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
#pragma warning(pop) 
#line 325 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.inl.h"
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.h"
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\intrin0.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\isa_availability.h"














enum ISA_AVAILABILITY
{
    __ISA_AVAILABLE_X86   = 0,
    __ISA_AVAILABLE_SSE2  = 1,
    __ISA_AVAILABLE_SSE42 = 2,
    __ISA_AVAILABLE_AVX   = 3,
    __ISA_AVAILABLE_ENFSTRG = 4,
    __ISA_AVAILABLE_AVX2 = 5,
    __ISA_AVAILABLE_AVX512 = 6,

    __ISA_AVAILABLE_ARMNT   = 0,   
    __ISA_AVAILABLE_NEON    = 1,   
    __ISA_AVAILABLE_NEON_ARM64 = 2,
                                   
};








#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\isa_availability.h"






#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\isa_availability.h"

#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\isa_availability.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
enum float_denorm_style { 
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};

enum float_round_style { 
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};

struct _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss          = false;
    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};

template <class _Ty>
class numeric_limits : public _Num_base { 
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty(max)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty lowest() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty epsilon() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty round_error() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty denorm_min() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty infinity() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept {
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> {}; 

struct _Num_int_base : _Num_base { 
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};

struct _Num_float_base : _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_present;
    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2;
};

template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr bool(min)() noexcept {
        return false;
    }

    [[nodiscard]] static constexpr bool(max)() noexcept {
        return true;
    }

    [[nodiscard]] static constexpr bool lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr bool epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool signaling_NaN() noexcept {
        return 0;
    }

    static constexpr int digits = 1;
};

template <>
class numeric_limits<char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr char lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr signed char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr signed char lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr signed char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char(max)() noexcept {
        return 0xff;
    }

    [[nodiscard]] static constexpr unsigned char lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};















































template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr char16_t lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr char16_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr char32_t lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr char32_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept {
        return 0x0000;
    }

    [[nodiscard]] static constexpr wchar_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr wchar_t lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr wchar_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr short(min)() noexcept {
        return (-32768);
    }

    [[nodiscard]] static constexpr short(max)() noexcept {
        return 32767;
    }

    [[nodiscard]] static constexpr short lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr int(min)() noexcept {
        return (-2147483647 - 1);
    }

    [[nodiscard]] static constexpr int(max)() noexcept {
        return 2147483647;
    }

    [[nodiscard]] static constexpr int lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long(min)() noexcept {
        return (-2147483647L - 1);
    }

    [[nodiscard]] static constexpr long(max)() noexcept {
        return 2147483647L;
    }

    [[nodiscard]] static constexpr long lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long long(min)() noexcept {
        return (-9223372036854775807i64 - 1);
    }

    [[nodiscard]] static constexpr long long(max)() noexcept {
        return 9223372036854775807i64;
    }

    [[nodiscard]] static constexpr long long lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};


template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr unsigned short lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 711 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"

template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr unsigned int lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long(max)() noexcept {
        return 0xffffffffUL;
    }

    [[nodiscard]] static constexpr unsigned long lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long(max)() noexcept {
        return 0xffffffffffffffffui64;
    }

    [[nodiscard]] static constexpr unsigned long long lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};

template <>
class numeric_limits<float> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr float(min)() noexcept {
        return 1.175494351e-38F;
    }

    [[nodiscard]] static constexpr float(max)() noexcept {
        return 3.402823466e+38F;
    }

    [[nodiscard]] static constexpr float lowest() noexcept {
        return -(max)();
    }

    [[nodiscard]] static constexpr float epsilon() noexcept {
        return 1.192092896e-07F;
    }

    [[nodiscard]] static constexpr float round_error() noexcept {
        return 0.5F;
    }

    [[nodiscard]] static constexpr float denorm_min() noexcept {
        return 1.401298464e-45F;
    }

    [[nodiscard]] static constexpr float infinity() noexcept {
        return __builtin_huge_valf();
    }

    [[nodiscard]] static constexpr float quiet_NaN() noexcept {
        return __builtin_nanf("0");
    }

    [[nodiscard]] static constexpr float signaling_NaN() noexcept {
        return __builtin_nansf("1");
    }

    static constexpr int digits         = 24;
    static constexpr int digits10       = 6;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128;
    static constexpr int max_exponent10 = 38;
    static constexpr int min_exponent   = (-125);
    static constexpr int min_exponent10 = (-37);
};

template <>
class numeric_limits<double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr double lowest() noexcept {
        return -(max)();
    }

    [[nodiscard]] static constexpr double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr double round_error() noexcept {
        return 0.5;
    }

    [[nodiscard]] static constexpr double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    [[nodiscard]] static constexpr double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};

template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr long double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr long double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr long double lowest() noexcept {
        return -(max)();
    }

    [[nodiscard]] static constexpr long double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr long double round_error() noexcept {
        return 0.5L;
    }

    [[nodiscard]] static constexpr long double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    [[nodiscard]] static constexpr long double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr long double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr long double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};




template <class _Ty>
[[nodiscard]] constexpr int _Countl_zero_fallback(_Ty _Val) noexcept {
    _Ty _Yy = 0;

    unsigned int _Nn = numeric_limits<_Ty>::digits;
    unsigned int _Cc = numeric_limits<_Ty>::digits / 2;
    do {
        _Yy = static_cast<_Ty>(_Val >> _Cc);
        if (_Yy != 0) {
            _Nn -= _Cc;
            _Val = _Yy;
        }
        _Cc >>= 1;
    } while (_Cc != 0);
    return static_cast<int>(_Nn) - static_cast<int>(_Val);
}




template <class _Ty>
[[nodiscard]] constexpr int _Countr_zero_fallback(const _Ty _Val) noexcept {
    constexpr int _Digits = std::numeric_limits<_Ty>::digits;
    return _Digits - _Countl_zero_fallback(static_cast<_Ty>(static_cast<_Ty>(~_Val) & static_cast<_Ty>(_Val - 1)));
}


extern "C" {
extern int __isa_available;






#line 1028 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
}

template <class _Ty>
[[nodiscard]] int _Countr_zero_tzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max    = (numeric_limits<_Ty>::max)();

    if constexpr (_Digits <= 32) {
        
        
        
        return static_cast<int>(_tzcnt_u32(static_cast<unsigned int>(~_Max | _Val)));
    } else {









        return static_cast<int>(_tzcnt_u64(_Val));
#line 1052 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
    }
}

template <class _Ty>
[[nodiscard]] int _Countr_zero_bsf(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max    = (numeric_limits<_Ty>::max) ();

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        
        
        
        if (!_BitScanForward(&_Result, static_cast<unsigned int>(~_Max | _Val))) {
            return _Digits;
        }
    } else {













        if (!_BitScanForward64(&_Result, _Val)) {
            return _Digits;
        }
#line 1086 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
    }
    return static_cast<int>(_Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countr_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_tzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
    if (_Definitely_have_tzcnt) {
        return _Countr_zero_tzcnt(_Val);
    } else {
        return _Countr_zero_bsf(_Val);
    }
#line 1102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
}



#line 1107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"

template <class _Ty>
constexpr bool _Is_standard_unsigned_integer =
    _Is_any_of_v<remove_cv_t<_Ty>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int _Countr_zero(const _Ty _Val) noexcept {






#line 1121 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
    
    return _Countr_zero_fallback(_Val);
}

}


#pragma warning(pop)
#pragma pack(pop)
#line 1131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
#line 1132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\limits"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"





#pragma once








#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )

















#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"












#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"




namespace std {
























#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"
enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"

using _Atomic_counter_t = unsigned long;

template <class _Integral, class _Ty>
[[nodiscard]] volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<volatile _Integral&>(_Source);
}

template <class _Integral, class _Ty>
[[nodiscard]] const volatile _Integral* _Atomic_address_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<const volatile _Integral&>(_Source);
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"
#line 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xatomic.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"




#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Ty>
struct [[nodiscard]] _Tidy_guard { 
    _Ty* _Target;
    inline ~_Tidy_guard() {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};

template <class _Ty>
struct [[nodiscard]] _Tidy_deallocate_guard { 
    _Ty* _Target;
    inline ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};

template <class _Keycmp, class _Lhs, class _Rhs>
 constexpr bool _Nothrow_compare = noexcept(
    static_cast<bool>(::std:: declval<const _Keycmp&>()(::std:: declval<const _Lhs&>(), ::std:: declval<const _Rhs&>())));

template <size_t _Ty_size>
[[nodiscard]] constexpr size_t _Get_size_of_n(const size_t _Count) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if constexpr (_Overflow_is_possible) {
        constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
        if (_Count > _Max_possible) {
            _Throw_bad_array_new_length(); 
        }
    }

    return _Count * _Ty_size;
}

template <class _Ty>
 constexpr size_t _New_alignof = (::std:: max)(alignof(_Ty),
    static_cast<size_t>(16ull) 
);

struct _Default_allocate_traits {
    __declspec(allocator) static



        void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }



















};

constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}


constexpr size_t _Big_allocation_threshold = 4096;
constexpr size_t _Big_allocation_alignment = 32;

static_assert(2 * sizeof(void*) <= _Big_allocation_alignment,
    "Big allocation alignment should at least match vector register alignment");
static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");




constexpr size_t _Non_user_size           = sizeof(void*) + _Big_allocation_alignment - 1;
#line 119 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"


constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;


#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

template <class _Traits>
__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {
    
    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) {
        _Throw_bad_array_new_length(); 
    }

    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    do { if (_Ptr_container != 0) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false); 
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;




    return _Ptr;
}

inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {
    
    _Bytes += _Non_user_size;

    const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container   = _Ptr_user[-1];

    
    
    ;

    
    



    constexpr uintptr_t _Min_back_shift = sizeof(void*);
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    do { if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

















































#line 218 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(!0 || _Align <= 16ull), int> = 0>
__declspec(allocator) inline void* _Allocate(const size_t _Bytes) {
    




    {
        if (_Bytes >= _Big_allocation_threshold) { 
            return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
        }
    }
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

    if (_Bytes != 0) {
        return _Traits::_Allocate(_Bytes);
    }

    return nullptr;
}

template <size_t _Align, enable_if_t<(!0 || _Align <= 16ull), int> = 0>
inline void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {
    





    {

        if (_Bytes >= _Big_allocation_threshold) { 
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }
#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
        ::operator delete(_Ptr, _Bytes);
    }
}



template <class _Ty, class... _Types>
_Ty* _Global_new(_Types&&... _Args) { 
    struct [[nodiscard]] _Guard_type {
        void* _Result;
        ~_Guard_type() {
            if (_Result) {
                _Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
            }
        }
    };

    _Guard_type _Guard{_Allocate<_New_alignof<_Ty>>(sizeof(_Ty))};
    ::new (_Guard._Result) _Ty(::std:: forward<_Types>(_Args)...);
    return static_cast<_Ty*>(::std:: exchange(_Guard._Result, nullptr));
}

template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(_Pointer _Ptr) noexcept {
    return _Ptr;
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
inline void _Destroy_range(_NoThrowFwdIt _First, _NoThrowSentinel _Last) noexcept;

template <class _Ty>
inline void _Destroy_in_place(_Ty& _Obj) noexcept {
    if constexpr (is_array_v<_Ty>) {
        _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
    } else {
        _Obj.~_Ty();
    }
}













#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

template <class _Ptrty>
auto _Const_cast(_Ptrty _Ptr) noexcept { 
    using _Elem       = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest       = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}

template <class _Ty>
auto _Const_cast(_Ty* _Ptr) noexcept {
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}

template <class _Ty, class = void>
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> {
    using type = typename _Ty::pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> {
    using type = typename _Ty::const_pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<void>;
};

template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> {
    using type = typename _Ty::void_pointer;
};

template <class _Ty, class = void>
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const void>;
};

template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> {
    using type = typename _Ty::const_void_pointer;
};

template <class _Ty, class = void>
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::difference_type;
};

template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class = void>
struct _Get_size_type {
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};

template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> {
    using type = typename _Ty::size_type;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_copy {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>> {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_move {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>> {
    using type = typename _Ty::propagate_on_container_move_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_swap {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>> {
    using type = typename _Ty::propagate_on_container_swap;
};

template <class _Ty, class = void>
struct _Get_is_always_equal {
    using type = bool_constant<is_empty_v<_Ty>>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> {
    using type = typename _Ty::is_always_equal;
};
__pragma(warning(pop))

template <class _Ty, class _Other, class = void>
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>> {
    using type = typename _Ty::template rebind<_Other>::other;
};
__pragma(warning(pop))

template <class _Ty>
class allocator;

template <class _Alloc, class = void>
struct _Is_default_allocator : false_type {};

template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, void_t<typename allocator<_Ty>::_From_primary>>
    : is_same<typename allocator<_Ty>::_From_primary, allocator<_Ty>>::type {};

template <class _Void, class... _Types>
struct _Has_no_allocator_construct : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_allocator_construct<
    void_t<decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct =
    disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;

template <class _Alloc, class _Ptr, class = void>
struct _Has_no_alloc_destroy : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
    : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template <class _Alloc, class _Ptr>
using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;

template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
struct _Has_allocate_hint : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(::std:: declval<_Alloc&>().allocate(
        ::std:: declval<const _Size_type&>(), ::std:: declval<const _Const_void_pointer&>()))>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_max_size : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(::std:: declval<const _Alloc&>().max_size())>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(::std:: declval<const _Alloc&>().select_on_container_copy_construction())>> : true_type {};

template <class _Alloc>
struct allocator_traits;

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Normal_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer      = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer       = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

    using size_type       = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap            = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal                        = typename _Get_is_always_equal<_Alloc>::type;

    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

    [[nodiscard]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count) {
        return _Al.allocate(_Count);
    }

    [[nodiscard]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count, const const_void_pointer _Hint) {
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            return _Al.allocate(_Count);
        }
    }

    static inline void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count) {
        _Al.deallocate(_Ptr, _Count);
    }

    template <class _Ty, class... _Types>
    static inline void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
            (void) _Al; 



            ::new (static_cast<void*>(_Ptr)) _Ty(::std:: forward<_Types>(_Args)...);
#line 572 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
        } else {
            _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
        }
    }

    template <class _Ty>
    static inline void destroy(_Alloc& _Al, _Ty* _Ptr) {
        if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {



            _Ptr->~_Ty();
#line 585 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
        } else {
            _Al.destroy(_Ptr);
        }
    }

    [[nodiscard]] static inline size_type max_size(const _Alloc& _Al) noexcept {
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        } else {
            return (numeric_limits<size_type>::max)() / sizeof(value_type);
        }
    }

    [[nodiscard]] static inline _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }
};
__pragma(warning(pop))

template <class _Alloc>
struct _Default_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = value_type*;
    using const_pointer      = const value_type*;
    using void_pointer       = void*;
    using const_void_pointer = const void*;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap            = false_type;
    using is_always_equal                        = true_type;

    template <class _Other>
    using rebind_alloc = allocator<_Other>;

    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;

    [[nodiscard]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count) {





        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    [[nodiscard]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count, const_void_pointer) {





        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    static inline void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {
        





        {
            (void) _Al;
            _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
        }
    }

    template <class _Objty, class... _Types>
    static inline void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {





        {
            ::new (_Voidify_iter(_Ptr)) _Objty(::std:: forward<_Types>(_Args)...);
        }
    }

    template <class _Uty>
    static inline void destroy(_Alloc&, _Uty* const _Ptr) {



        _Ptr->~_Uty();
#line 692 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
    }

    [[nodiscard]] static inline size_type max_size(const _Alloc&) noexcept {
        return static_cast<size_t>(-1) / sizeof(value_type);
    }

    [[nodiscard]] static inline _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        return _Al;
    }
};

template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
                              _Normal_allocator_traits<_Alloc>> {};



template <class _Alloc>
using _Choose_pocca = bool_constant<allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
                                    && !allocator_traits<_Alloc>::is_always_equal::value>;

struct _Equal_allocators {}; 
using _Propagate_allocators    = true_type; 
using _No_propagate_allocators = false_type; 

template <class _Alloc>
using _Choose_pocma = conditional_t<allocator_traits<_Alloc>::is_always_equal::value, _Equal_allocators,
    typename allocator_traits<_Alloc>::propagate_on_container_move_assignment::type>;

template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;



template <class _Alloc, class _Value_type>
using _Maybe_rebind_alloc_t =
    typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&,
        _Rebind_alloc_t<_Alloc, _Value_type>>;

template <class _Alloc> 
 constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>&&
    is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>&&
        is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>&&
            is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;

template <class _Value_type>
struct _Simple_types { 
                       
    using value_type      = _Value_type;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = value_type*;
    using const_pointer   = const value_type*;
};

template <class _Ty>
class allocator {
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
                                    "because allocator<const T> is ill-formed.");

    using _From_primary = allocator;

    using value_type = _Ty;


     typedef _Ty* pointer;
     typedef const _Ty* const_pointer;

     typedef _Ty& reference;
     typedef const _Ty& const_reference;
#line 764 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;


    using is_always_equal  = true_type;

    template <class _Other>
    struct  rebind {
        using other = allocator<_Other>;
    };

     [[nodiscard]] _Ty* address(_Ty& _Val) const noexcept {
        return ::std:: addressof(_Val);
    }

     [[nodiscard]] const _Ty* address(const _Ty& _Val) const noexcept {
        return ::std:: addressof(_Val);
    }
#line 786 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

    constexpr allocator() noexcept {}

    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept {}
    inline ~allocator()       = default;
    inline allocator& operator=(const allocator&) = default;

    inline void deallocate(_Ty* const _Ptr, const size_t _Count) {
        
        _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }

    [[nodiscard]] inline __declspec(allocator) _Ty* allocate( const size_t _Count) {
        return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }


     [[nodiscard]] __declspec(allocator) _Ty* allocate(
         const size_t _Count, const void*) {
        return allocate(_Count);
    }

    template <class _Objty, class... _Types>
     void construct(_Objty* const _Ptr, _Types&&... _Args) {
        ::new (_Voidify_iter(_Ptr)) _Objty(::std:: forward<_Types>(_Args)...);
    }

    template <class _Uty>
     void destroy(_Uty* const _Ptr) {
        _Ptr->~_Uty();
    }

     [[nodiscard]] size_t max_size() const noexcept {
        return static_cast<size_t>(-1) / sizeof(_Ty);
    }
#line 824 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
};

template <>
class allocator<void> {
public:
    using value_type = void;

     typedef void* pointer;
     typedef const void* const_pointer;
#line 834 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;


    using is_always_equal  = true_type;

    template <class _Other>
    struct  rebind {
        using other = allocator<_Other>;
    };
#line 848 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
};

template <class _Ty, class _Other>
[[nodiscard]] inline bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return true;
}


template <class _Ty, class _Other>
[[nodiscard]] bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return false;
}
#line 861 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"






#line 868 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

template <class _Alloc>
using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;

template <class _Alloc>
using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;

template <class _Alloc>
inline void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    }
}

template <class _Alloc>
inline void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { 
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = ::std:: move(_Right);
    }
}

template <class _Alloc>
inline void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        _Swap_adl(_Left, _Right);
    } else {
        ;
    }
}

template <class _Alloc>
inline void _Destroy_range(
    _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
        }
    }
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
inline void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {
    
    if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
}

template <class _Size_type>
[[nodiscard]] constexpr _Size_type _Convert_size(const size_t _Len) noexcept(is_same_v<_Size_type, size_t>) {
    
    if constexpr (!is_same_v<_Size_type, size_t>) {
        if (_Len > (numeric_limits<_Size_type>::max)()) {
            _Xlength_error("size_t too long for _Size_type");
        }
    }

    return static_cast<_Size_type>(_Len);
}

template <class _Alloc>
inline void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    } else {
        using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}

template <class _Alloc>
inline void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    _Ptr->~_Ty();
    _Deallocate_plain(_Al, _Ptr);
}

template <class _Alloc>
struct _Alloc_construct_ptr { 
    using pointer = _Alloc_ptr_t<_Alloc>;
    _Alloc& _Al;
    pointer _Ptr;

    inline explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

    [[nodiscard]] inline pointer _Release() noexcept { 
        return ::std:: exchange(_Ptr, nullptr);
    }

    inline void _Allocate() { 
        _Ptr = nullptr; 
        _Ptr = _Al.allocate(1);
    }

    inline ~_Alloc_construct_ptr() { 
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }

    _Alloc_construct_ptr(const _Alloc_construct_ptr&) = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};

struct _Fake_allocator {};

struct _Container_base0 {
    inline void _Orphan_all() noexcept {}
    inline void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}
    inline void _Alloc_proxy(const _Fake_allocator&) noexcept {}
    inline void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept {}
};

struct _Iterator_base0 {
    inline void _Adopt(const void*) noexcept {}
    inline const _Container_base0* _Getcont() const noexcept {
        return nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = true;
};

struct _Container_base12;
struct _Container_proxy { 
    inline _Container_proxy() noexcept = default;
    inline _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

    const _Container_base12* _Mycont       = nullptr;
    mutable _Iterator_base12* _Myfirstiter = nullptr;
};

struct _Container_base12 {
public:
    inline _Container_base12() noexcept = default;

    _Container_base12(const _Container_base12&) = delete;
    _Container_base12& operator=(const _Container_base12&) = delete;

    inline void _Orphan_all() noexcept;
    inline void _Swap_proxy_and_iterators(_Container_base12&) noexcept;

    template <class _Alloc>
    inline void _Alloc_proxy(_Alloc&& _Al) {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy            = _New_proxy;
        _New_proxy->_Mycont = this;
    }

    template <class _Alloc>
    inline void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
        
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Myproxy, _New_proxy));
    }

    _Container_proxy* _Myproxy = nullptr;

private:
    inline void _Orphan_all_unlocked_v3() noexcept;
    inline void _Swap_proxy_and_iterators_unlocked(_Container_base12&) noexcept;

    void _Orphan_all_locked_v3() noexcept {
        _Lockit _Lock(3);
        _Orphan_all_unlocked_v3();
    }

    void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {
        _Lockit _Lock(3);
        _Swap_proxy_and_iterators_unlocked(_Right);
    }
};

struct _Iterator_base12 { 
public:
    inline _Iterator_base12() noexcept = default; 

    inline _Iterator_base12(const _Iterator_base12& _Right) noexcept {
        *this = _Right;
    }

    inline _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {









#line 1069 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
        _Myproxy = _Right._Myproxy;
#line 1071 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
        return *this;
    }























#line 1097 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
    inline void _Adopt(const _Container_base12* _Parent) noexcept {
        if (_Parent) { 
            _Myproxy = _Parent->_Myproxy;
        } else { 
            _Myproxy = nullptr;
        }
    }
#line 1105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

    inline const _Container_base12* _Getcont() const noexcept {
        return _Myproxy ? _Myproxy->_Mycont : nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = 0 == 0;

    mutable _Container_proxy* _Myproxy    = nullptr;
    mutable _Iterator_base12* _Mynextiter = nullptr;































































#line 1178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
};

inline void _Container_base12::_Orphan_all_unlocked_v3() noexcept {
    if (!_Myproxy) { 
        return;
    }

    
    for (auto& _Pnext = _Myproxy->_Myfirstiter; _Pnext; _Pnext = _Pnext->_Mynextiter) { 
        _Pnext->_Myproxy = nullptr;
    }
    _Myproxy->_Myfirstiter = nullptr;
}

inline void _Container_base12::_Orphan_all() noexcept {









#line 1203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
}

inline void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy                = _Right._Myproxy;
    _Right._Myproxy         = _Temp;

    if (_Myproxy) {
        _Myproxy->_Mycont = this;
    }

    if (_Right._Myproxy) {
        _Right._Myproxy->_Mycont = &_Right;
    }
}

inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {









#line 1230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
    _Swap_proxy_and_iterators_unlocked(_Right);
#line 1232 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
}


using _Container_base = _Container_base0;
using _Iterator_base  = _Iterator_base0;



#line 1241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

struct _Leave_proxy_unbound {
    explicit _Leave_proxy_unbound() = default;
}; 

struct _Fake_proxy_ptr_impl { 
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&) = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    inline _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept {}
    inline _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

    inline void _Bind(const _Fake_allocator&, _Container_base0*) noexcept {}
    inline void _Release() noexcept {}
};

struct _Basic_container_proxy_ptr12 {
    
    _Container_proxy* _Ptr = nullptr;

    constexpr void _Release() noexcept { 
        _Ptr = nullptr;
    }

protected:
    inline _Basic_container_proxy_ptr12()             = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&)      = delete;
};

template <class _Alloc>
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {
    
    _Alloc& _Al;

    inline _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }

    inline _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, ::std:: addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }

    inline void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept {
        
        
        _Ptr->_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Mycont->_Myproxy, ::std:: exchange(_Ptr, nullptr)));
    }

    inline ~_Container_proxy_ptr12() {
        if (_Ptr) {
            _Delete_plain_internal(_Al, _Ptr);
        }
    }
};


 constexpr _Fake_allocator _Fake_alloc{};

template <class _Alloc>
using _Container_proxy_ptr = _Fake_proxy_ptr_impl;




#line 1312 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

struct _Zero_then_variadic_args_t {
    explicit _Zero_then_variadic_args_t() = default;
}; 

struct _One_then_variadic_args_t {
    explicit _One_then_variadic_args_t() = default;
}; 

template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 { 
public:
    _Ty2 _Myval2;

    using _Mybase = _Ty1; 

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return *this;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return *this;
    }
};

template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final { 
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return _Myval1;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return _Myval1;
    }
};

struct _Move_allocator_tag {
    explicit _Move_allocator_tag() = default;
};

template <class _Ty>
pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept {
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;





            {
                _Pbuf = ::operator new(_Size, nothrow);
            }

            if (_Pbuf) {
                return {static_cast<_Ty*>(_Pbuf), _Count};
            }
        }
    }

    return {nullptr, 0};
}

template <class _Ty>
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept {





    {
        ::operator delete(_Pbuf);
    }
}

template <class _NoThrowFwdIt>
struct [[nodiscard]] _Uninitialized_backout {
    
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

    constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

    _Uninitialized_backout(const _Uninitialized_backout&) = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

    inline ~_Uninitialized_backout() {
        _Destroy_range(_First, _Last);
    }

    template <class... _Types>
    inline void _Emplace_back(_Types&&... _Vals) {
        
        _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr _NoThrowFwdIt _Release() { 
        _First = _Last;
        return _Last;
    }
};

template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt _Uninitialized_move_unchecked(
    _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Ptr_move_cat<_InIt, _NoThrowFwdIt>::_Really_trivial) {



        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(::std:: move(*_First));
    }

    return _Backout._Release();
}













































































































































template <class _Alloc>
class [[nodiscard]] _Uninitialized_backout_al {
    
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    inline _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_)
        : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_backout_al(const _Uninitialized_backout_al&) = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

    inline ~_Uninitialized_backout_al() {
        _Destroy_range(_First, _Last, _Al);
    }

    template <class... _Types>
    inline void _Emplace_back(_Types&&... _Vals) { 
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr pointer _Release() { 
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _InIt, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval = typename _Alloc::value_type*;

    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {



        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            _Dest += _ULast - _UFirst;
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt _Uninitialized_copy_unchecked(
    _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Ptr_copy_cat<_InIt, _NoThrowFwdIt>::_Really_trivial) {



        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(*_First);
    }

    return _Backout._Release();
}

template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_move(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval     = typename _Alloc::value_type*;
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(::std:: move(*_UFirst))>>) {



        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(::std:: move(*_UFirst));
    }

    return _Backout._Release();
}

template <class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_fill_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {



        {
            _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
            return _First + _Count;
        }
    } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {



        {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }

    return _Backout._Release();
}

template <class _NoThrowFwdIt, class _Tval>
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                return;
            }
        }

        _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }

        _Backout._Release();
    }
}

template <class _NoThrowFwdIt>
 constexpr bool _Use_memset_value_construct_v =
    conjunction_v<bool_constant<_Iterator_is_contiguous<_NoThrowFwdIt>>, is_scalar<_Iter_value_t<_NoThrowFwdIt>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
        negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;

template <class _Ptr>
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { 
    char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
    char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
    :: memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}

template <class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {
    
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {



        {
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }

    return _Backout._Release();
}

template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {
    
    ;
    if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
        return _Zero_range(_UFirst, _UFirst + _Count);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}


template <class _Ty>
 [[nodiscard]] pair<_Ty*, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept {
    return _Get_temporary_buffer<_Ty>(_Count);
}

template <class _Ty>
 void return_temporary_buffer(_Ty* _Pbuf) {
    _Return_temporary_buffer(_Pbuf);
}
#line 1847 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"


template <class _Key, class... _Args>
struct _In_place_key_extract_set {
    
    static constexpr bool _Extractable = false;
};

template <class _Key>
struct _In_place_key_extract_set<_Key, _Key> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val) noexcept {
        return _Val;
    }
};


template <class _Key, class... _Args>
struct _In_place_key_extract_map {
    
    static constexpr bool _Extractable = false;
};

template <class _Key, class _Second>
struct _In_place_key_extract_map<_Key, _Key, _Second> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {
        return _Val;
    }
};

template <class _Key, class _First, class _Second>
struct _In_place_key_extract_map<_Key, pair<_First, _Second>> {
    
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_cvref_t<_First>>;
    static const _Key& _Extract(const pair<_First, _Second>& _Val) {
        return _Val.first;
    }
};

#pragma warning(push)
#pragma warning(disable : 4624) 
template <class _Ty>
struct _Wrap {
    _Ty _Value; 
};
#pragma warning(pop)

template <class _Alloc>
struct _Alloc_temporary2 {
    using value_type = typename _Alloc::value_type;
    using _Traits    = allocator_traits<_Alloc>;

    _Alloc& _Al;














    union {
        value_type _Value;
    };

    [[nodiscard]] inline value_type& _Get_value() noexcept {
        return _Value;
    }

    [[nodiscard]] inline const value_type& _Get_value() const noexcept {
        return _Value;
    }
#line 1929 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"

    template <class... _Args>
    inline explicit _Alloc_temporary2(_Alloc& _Al_, _Args&&... _Vals) noexcept(
        noexcept(_Traits::construct(_Al_, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...)))
        : _Al(_Al_) {
        _Traits::construct(_Al, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...);
    }

    _Alloc_temporary2(const _Alloc_temporary2&) = delete;
    _Alloc_temporary2& operator=(const _Alloc_temporary2&) = delete;

    inline ~_Alloc_temporary2() {
        _Traits::destroy(_Al, ::std:: addressof(_Get_value()));
    }
};

template <class _Alloc>
[[nodiscard]] constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {
    if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: find_if(_UFirst, _ULast, _Pass_fn(_Pred));
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

template <class _Container, class _Uty>
inline typename _Container::size_type _Erase_remove(_Container& _Cont, const _Uty& _Val) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std:: remove(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
inline typename _Container::size_type _Erase_remove_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std:: remove_if(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pred));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
typename _Container::size_type _Erase_nodes_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    while (_First != _Last) {
        if (_Pred(*_First)) {
            _First = _Cont.erase(_First);
        } else {
            ++_First;
        }
    }
    return _Old_size - _Cont.size();
}



























































































#line 2125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
}



#pragma warning(pop)
#pragma pack(pop)
#line 2132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
#line 2133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xmemory"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"



#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )








#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

namespace std {
template <class _Elem, class _Int_type>
struct _Char_traits { 
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = _Mbstatet;


#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    

    static inline _Elem* copy(  _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        


#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"











        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        return _First1;
    }

      static inline _Elem* _Copy_s( 
                                                                                 _Elem* const _First1,
        const size_t _Dest_size,   const _Elem* const _First2, const size_t _Count) noexcept {
        
        do { if (_Count <= _Dest_size) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }

    static inline _Elem* move(  _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        


#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"





































        :: memmove(_First1, _First2, _Count * sizeof(_Elem));
#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        return _First1;
    }

    
    

    [[nodiscard]] static inline int compare(  const _Elem* _First1,
          const _Elem* _First2, size_t _Count) noexcept  {
        
        for (; 0 < _Count; --_Count, ++_First1, ++_First2) {
            if (*_First1 != *_First2) {
                return *_First1 < *_First2 ? -1 : +1;
            }
        }

        return 0;
    }

    [[nodiscard]] static inline size_t length(  const _Elem* _First) noexcept  {
        
        size_t _Count = 0;
        while (*_First != _Elem()) {
            ++_Count;
            ++_First;
        }

        return _Count;
    }

    [[nodiscard]] static inline const _Elem* find(
          const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept  {
        
        for (; 0 < _Count; --_Count, ++_First) {
            if (*_First == _Ch) {
                return _First;
            }
        }

        return nullptr;
    }

    static inline _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        







        {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                *_Next = _Ch;
            }
        }

        return _First;
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept {





        {
            _Left = _Right;
        }
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left < _Right;
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return static_cast<int_type>(_Ch);
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return static_cast<int_type>((-1));
    }
};

template <class _Elem>
struct _WChar_traits : private _Char_traits<_Elem, unsigned short> {
    
private:
    using _Primary_char_traits = _Char_traits<_Elem, unsigned short>;

public:
    using char_type  = _Elem;
    using int_type   = unsigned short;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;


#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    [[nodiscard]] static inline int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        






#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return :: wmemcmp(
            reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
#line 257 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }

    [[nodiscard]] static inline size_t length(  const _Elem* _First) noexcept  {
        






#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return :: wcslen(reinterpret_cast<const wchar_t*>(_First));
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }

    [[nodiscard]] static inline const _Elem* find(
          const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept  {
        






#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return reinterpret_cast<const _Elem*>(:: wmemchr(reinterpret_cast<const wchar_t*>(_First), _Ch, _Count));
#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }

    static inline _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        






        return reinterpret_cast<_Elem*>(:: wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept {
        _Left = _Right;
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left < _Right;
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return _Meta;
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return _Ch;
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return ((wint_t)(0xFFFF));
    }
};

template <class _Elem>
struct char_traits : _Char_traits<_Elem, long> {}; 

template <>
struct char_traits<char16_t> : _WChar_traits<char16_t> {};

using u16streampos = streampos;

template <>
struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int> {};

using u32streampos = streampos;

template <>
struct char_traits<wchar_t> : _WChar_traits<wchar_t> {};


template <>
struct char_traits<unsigned short> : _WChar_traits<unsigned short> {};
#line 351 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"



#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

#line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

template <class _Elem, class _Int_type>
struct _Narrow_char_traits : private _Char_traits<_Elem, _Int_type> {
    
private:
    using _Primary_char_traits = _Char_traits<_Elem, _Int_type>;

public:
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;


#line 373 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    [[nodiscard]] static inline int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        


#line 384 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return :: memcmp(_First1, _First2, _Count);
#line 386 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }

    [[nodiscard]] static inline size_t length(  const _Elem* const _First) noexcept  {
        













#line 404 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return :: strlen(reinterpret_cast<const char*>(_First));
#line 406 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }

    [[nodiscard]] static inline const _Elem* find(  const _Elem* const _First, const size_t _Count,
        const _Elem& _Ch) noexcept  {
        













#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return static_cast<const _Elem*>(:: memchr(_First, _Ch, _Count));
#line 427 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }

    static inline _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        






        return static_cast<_Elem*>(:: memset(_First, _Ch, _Count));
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept {
        _Left = _Right;
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return static_cast<unsigned char>(_Ch);
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return static_cast<int_type>((-1));
    }
};




template <>
struct char_traits<char> : _Narrow_char_traits<char, int> {}; 










template <class _Elem, class _Traits, class _SizeT>
basic_ostream<_Elem, _Traits>& _Insert_string(
    basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
    
    using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
    typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

    _SizeT _Pad;
    if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
        _Pad = 0;
    } else {
        _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
    }

    const typename _Ostr_t::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= _Ostr_t::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }

        if (_State == _Ostr_t::goodbit
            && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
            _State |= _Ostr_t::badbit;
        } else {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(_Ostr_t::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
struct _Char_traits_eq {
    using _Elem = typename _Traits::char_type;

    bool operator()(_Elem _Left, _Elem _Right) const {
        return _Traits::eq(_Left, _Right);
    }
};

template <class _Traits>
struct _Char_traits_lt {
    using _Elem = typename _Traits::char_type;

    bool operator()(_Elem _Left, _Elem _Right) const {
        return _Traits::lt(_Left, _Right);
    }
};



template <class _Elem>
 constexpr bool _Pred_is_consistent_with_memcmp<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>> = true;

template <class _Traits>
using _Traits_ch_t = typename _Traits::char_type;

template <class _Traits>
using _Traits_ptr_t = const typename _Traits::char_type*;

template <class _Traits>
constexpr bool _Traits_equal(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    
    return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
}

template <class _Traits>
constexpr int _Traits_compare(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    
    const int _Ans = _Traits::compare(_Left, _Right, (::std:: min)(_Left_size, _Right_size));

    if (_Ans != 0) {
        return _Ans;
    }

    if (_Left_size < _Right_size) {
        return -1;
    }

    if (_Left_size > _Right_size) {
        return 1;
    }

    return 0;
}

template <class _Traits>
constexpr size_t _Traits_find(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
        
        
        
        
        
        
        
        
        return static_cast<size_t>(-1);
    }

    if (_Needle_size == 0) { 
        return _Start_at;
    }

    const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
    for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
        _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
        if (!_Match_try) { 
            return static_cast<size_t>(-1);
        }

        if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { 
            return static_cast<size_t>(_Match_try - _Haystack);
        }
    }
}

template <class _Traits>
constexpr size_t _Traits_find_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Start_at < _Hay_size) {
        const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
        if (_Found_at) {
            return static_cast<size_t>(_Found_at - _Haystack);
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size == 0) {
        return (::std:: min)(_Start_at, _Hay_size); 
    }

    if (_Needle_size <= _Hay_size) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
            if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Elem, bool = _Is_character<_Elem>::value>
class _String_bitmap { 
public:
    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
        
        
        for (; _First != _Last; ++_First) {
            _Matches[static_cast<unsigned char>(*_First)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const { 
        return _Matches[static_cast<unsigned char>(_Ch)];
    }

private:
    bool _Matches[256] = {};
};

template <class _Elem>
class _String_bitmap<_Elem, false> { 
public:
    static_assert(is_unsigned_v<_Elem>,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
        "Visual C++ accepts other unsigned integral types as an extension.");

    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
        
        
        for (; _First != _Last; ++_First) {
            const auto _Ch = *_First;
            if (_Ch >= 256U) {
                return false;
            }

            _Matches[static_cast<unsigned char>(_Ch)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const { 
        return _Ch < 256U && _Matches[_Ch];
    }

private:
    bool _Matches[256] = {};
};

template <class _Traits>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    
    
    if (_Needle_size != 0 && _Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    
    
    if (_Needle_size != 0 && _Start_at < _Hay_size) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                
            return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    
    
    if (_Needle_size != 0 && _Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    
    
    if (_Needle_size != 0 && _Hay_size != 0) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                
            return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    
    
    if (_Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    
    
    if (_Start_at < _Hay_size) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                
            return _Traits_find_first_not_of<_Traits>(
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    
    
    if (_Hay_size != 0) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                
            return _Traits_find_last_not_of<_Traits>(
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}























































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

template <class _Mystr>
class _String_const_iterator : public _Iterator_base {
public:



    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Mystr::value_type;
    using difference_type   = typename _Mystr::difference_type;
    using pointer           = typename _Mystr::const_pointer;
    using reference         = const value_type&;

    inline _String_const_iterator() noexcept : _Ptr() {}

    inline _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept
        : _Ptr(_Parg) {
        this->_Adopt(_Pstring);
    }

    [[nodiscard]] inline reference operator*() const noexcept {









#line 1904 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        ;
        return *_Ptr;
    }

    [[nodiscard]] inline pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    inline _String_const_iterator& operator++() noexcept {






#line 1921 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        ++_Ptr;
        return *this;
    }

    inline _String_const_iterator operator++(int) noexcept {
        _String_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    inline _String_const_iterator& operator--() noexcept {






#line 1940 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        --_Ptr;
        return *this;
    }

    inline _String_const_iterator operator--(int) noexcept {
        _String_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    inline void _Verify_offset(const difference_type _Off) const noexcept {





















#line 1974 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        (void) _Off;
#line 1976 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }

    inline _String_const_iterator& operator+=(const difference_type _Off) noexcept {


#line 1982 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        _Ptr += _Off;
        return *this;
    }

    [[nodiscard]] inline _String_const_iterator operator+(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp += _Off; 
        return _Tmp;
    }

    inline _String_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] inline _String_const_iterator operator-(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp -= _Off; 
        return _Tmp;
    }

    [[nodiscard]] inline difference_type operator-(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] inline bool operator==(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }






#line 2022 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    [[nodiscard]] bool operator!=(const _String_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }

    [[nodiscard]] bool operator>(const _String_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _String_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _String_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 2043 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline void _Compat(const _String_const_iterator& _Right) const noexcept {
        



#line 2050 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        (void) _Right;
#line 2052 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }







#line 2061 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    using _Prevent_inheriting_unwrap = _String_const_iterator;

    [[nodiscard]] inline const value_type* _Unwrapped() const noexcept {
        return _Unfancy(_Ptr);
    }

    inline void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
    }

    pointer _Ptr; 
};

template <class _Mystr>
[[nodiscard]] inline _String_const_iterator<_Mystr> operator+(
    typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next) noexcept {
    return _Next += _Off;
}






























#line 2111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

template <class _Mystr>
class _String_iterator : public _String_const_iterator<_Mystr> {
public:
    using _Mybase = _String_const_iterator<_Mystr>;




    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Mystr::value_type;
    using difference_type   = typename _Mystr::difference_type;
    using pointer           = typename _Mystr::pointer;
    using reference         = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] inline reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] inline pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    inline _String_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    inline _String_iterator operator++(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _String_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    inline _String_iterator operator--(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _String_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] inline _String_iterator operator+(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp += _Off; 
        return _Tmp;
    }

    inline _String_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] inline _String_iterator operator-(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp -= _Off; 
        return _Tmp;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _String_iterator;

    [[nodiscard]] inline value_type* _Unwrapped() const noexcept {
        return const_cast<value_type*>(_Unfancy(this->_Ptr));
    }
};

template <class _Mystr>
[[nodiscard]] inline _String_iterator<_Mystr> operator+(
    typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next) noexcept {
    return _Next += _Off;
}






























#line 2229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference>
struct _String_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

template <class _Val_types>
class _String_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    inline _String_val() noexcept : _Bx() {}

    
    static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
    
    static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
                                           : sizeof(value_type) <= 2 ? 7
                                           : sizeof(value_type) <= 4 ? 3
                                           : sizeof(value_type) <= 8 ? 1
                                                                     : 0;

    inline value_type* _Myptr() noexcept {
        value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    inline const value_type* _Myptr() const noexcept {
        const value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    inline bool _Large_string_engaged() const noexcept {





        return _BUF_SIZE <= _Myres;
    }

    inline void _Check_offset(const size_type _Off) const {
        
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    inline void _Check_offset_exclusive(const size_type _Off) const {
        
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid string position");
    }

    inline size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        
        return (::std:: min)(_Size, _Mysize - _Off);
    }

    union _Bxty { 
        inline _Bxty() noexcept : _Ptr() {} 

        inline ~_Bxty() noexcept {} 

        value_type _Buf[_BUF_SIZE];
        pointer _Ptr;
        char _Alias[_BUF_SIZE]; 
    } _Bx;

    size_type _Mysize = 0; 
    size_type _Myres  = 0; 
};

template <class _Ty>
constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); 

struct _String_constructor_concat_tag {
    
    explicit _String_constructor_concat_tag() = default;
};

struct _String_constructor_rvalue_allocator_tag {
    
    explicit _String_constructor_rvalue_allocator_tag() = default;
};

[[noreturn]] inline void _Xlen_string() {
    _Xlength_error("string too long");
}

template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_string { 
private:
    friend _Tidy_deallocate_guard<basic_string>;
    friend basic_stringbuf<_Elem, _Traits, _Alloc>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
    using _Alty_traits = allocator_traits<_Alty>;

    using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;

    static_assert(!0 || is_same_v<_Elem, typename _Alloc::value_type>,
        "basic_string<T, Traits, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
        "char_traits character type match the string's character type.");

    static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
        "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
        "[strings.general]/1.");

public:
    using traits_type    = _Traits;
    using allocator_type = _Alloc;

    using value_type      = _Elem;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    using iterator       = _String_iterator<_Scary_val>;
    using const_iterator = _String_const_iterator<_Scary_val>;

    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

private:
    static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
    static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;

    
    
    
    
    
    
    
    
    
    
    static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
    
    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
    static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;

    template <class _Iter>
    using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;







#line 2414 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

public:
    inline basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Construct_lv_contents(_Right);
        _Proxy._Release();
    }

    inline basic_string(const basic_string& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Construct_lv_contents(_Right);
        _Proxy._Release();
    }

    inline basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Tidy_init();
    }

    inline explicit basic_string(const _Alloc& _Al) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Tidy_init();
    }

    inline basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Right, _Roff, npos);
        _Proxy._Release();
    }

    inline basic_string(
        const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Right, _Roff, _Count);
        _Proxy._Release();
    }

    inline basic_string(
          const _Elem* const _Ptr,  const size_type _Count)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr, _Count);
        _Proxy._Release();
    }

    inline basic_string(
          const _Elem* const _Ptr,  const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr, _Count);
        _Proxy._Release();
    }

    inline basic_string(  const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr);
        _Proxy._Release();
    }



#line 2494 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    inline basic_string(  const _Elem* const _Ptr, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr);
        _Proxy._Release();
    }

    inline basic_string( const size_type _Count, const _Elem _Ch)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Count, _Ch);
        _Proxy._Release();
    }



#line 2516 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    inline basic_string( const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Count, _Ch);
        _Proxy._Release();
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        _Adl_verify_range(_First, _Last);
        _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        _Proxy._Release();
    }

    template <class _Iter>
    inline void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
        
        _Tidy_deallocate_guard<basic_string> _Guard{this};
        for (; _First != _Last; ++_First) {
            push_back(*_First);
        }

        _Guard._Target = nullptr;
    }

    template <class _Iter>
    inline void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
        
        const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        reserve(_Count);
        _Construct(_First, _Last, input_iterator_tag{});
    }

    inline void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
        
        if (_First != _Last) {
            assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
        }
    }

    inline void _Construct(
        const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
        
        if (_First != _Last) {
            assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
        }
    }

    inline basic_string(basic_string&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal())) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Take_contents(_Right);
    }

    inline basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
        _Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                _Construct_lv_contents(_Right);
                _Proxy._Release();
                return;
            }
        }

        _Take_contents(_Right);
        _Proxy._Release();
    }

    inline basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al,
        const _Elem* const _Left_ptr, const size_type _Left_size, const _Elem* const _Right_ptr,
        const size_type _Right_size)
        : _Mypair(
            _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
        ;
        ;
        ;
        const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
        size_type _New_capacity = _BUF_SIZE - 1;
        auto& _My_data          = _Mypair._Myval2;
        _Elem* _Ptr             = _My_data._Bx._Buf;
        auto&& _Alproxy         = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); 




        const bool _Activate_large_mode = _New_capacity < _New_size;
#line 2613 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        if (_Activate_large_mode) {
            
            const size_type _Requested_size = (::std:: max)(_New_size, _BUF_SIZE);
            _New_capacity                   = _Calculate_growth(_Requested_size, _BUF_SIZE - 1, max_size());
            const pointer _Fancyptr         = _Getal().allocate(_New_capacity + 1); 
            _Ptr                            = _Unfancy(_Fancyptr);
            _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        }







        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        _Traits::copy(_Ptr, _Left_ptr, _Left_size);
        _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
        _Traits::assign(_Ptr[_New_size], _Elem());
        _Proxy._Release();
    }

    inline basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {
        auto& _My_data    = _Mypair._Myval2;
        auto& _Left_data  = _Left._Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Left_data._Orphan_all();
        _Right_data._Orphan_all();
        const auto _Left_size  = _Left_data._Mysize;
        const auto _Right_size = _Right_data._Mysize;

        const auto _Left_capacity  = _Left_data._Myres;
        const auto _Right_capacity = _Right_data._Myres;
        
        const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
        const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
        if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
            
            _My_data._Alloc_proxy(_Fake_alloc); 
            _Take_contents(_Left);
            const auto _Ptr = _My_data._Myptr();
            _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
            _My_data._Mysize = _New_size;
            return;
        }

        const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
        if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
            
            
            
            
            
            
            
            
            
            ;
            _My_data._Alloc_proxy(_Fake_alloc); 
            _Take_contents(_Right);
            const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
            _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
            _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
            _My_data._Mysize = _New_size;
            return;
        }

        
        const auto _Max = max_size();
        if (_Max - _Left_size < _Right_size) { 
            _Xlen_string();
        }

        const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
        auto&& _Alproxy          = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); 
        const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); 
        





        _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        const auto _Ptr  = _Unfancy(_Fancyptr);
        _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
        _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
        _Proxy._Release();
    }






















#line 2730 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"








#line 2739 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

private:
    inline void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
        _Tidy_deallocate();
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right);
    }

    inline void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            
            _Mypair._Myval2._Orphan_all();
            _Mypair._Myval2._Reload_proxy(
                _Fake_alloc, _Fake_alloc);
            _Pocma(_Getal(), _Right._Getal());
            _Take_contents(_Right);
        }
    }

    inline void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

public:











































#line 2813 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline basic_string& operator=(basic_string&& _Right) noexcept(
        noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
        if (this != ::std:: addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }

        return *this;
    }

    inline basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = ::std:: move(_Right))) {
        *this = ::std:: move(_Right);
        return *this;
    }

private:
    void _Memcpy_val_from(const basic_string& _Right) noexcept {
        ; 
        const auto _My_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
        const auto _Right_data_mem =
            reinterpret_cast<const unsigned char*>(::std:: addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
        :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
    }

    inline void _Take_contents(basic_string& _Right) noexcept {
        
        
        
        
        
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        if constexpr (_Can_memcpy_val) {



            {







#line 2860 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

                _Memcpy_val_from(_Right);
                _Right._Tidy_init();
                return;
            }
        }

        if (_Right_data._Large_string_engaged()) { 
            _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            _Right_data._Bx._Ptr = nullptr;
            _Swap_proxy_and_iterators(_Right);
        } else { 
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Right_data._Orphan_all();
        }

        _My_data._Mysize = _Right_data._Mysize;
        _My_data._Myres  = _Right_data._Myres;
        _Right._Tidy_init();
    }

    inline void _Construct_lv_contents(const basic_string& _Right) {
        
        
        
        
        auto& _Right_data             = _Right._Mypair._Myval2;
        const size_type _Right_size   = _Right_data._Mysize;
        const _Elem* const _Right_ptr = _Right_data._Myptr();
        auto& _My_data                = _Mypair._Myval2;




        const bool _Stay_small = _Right_size < _BUF_SIZE;
#line 2896 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        
        
        if (_Stay_small) { 
            _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
            _My_data._Mysize = _Right_size;
            _My_data._Myres  = _BUF_SIZE - 1;
            return;
        }

        auto& _Al                     = _Getal();
        const size_type _New_capacity = (::std:: min)(_Right_size | _ALLOC_MASK, max_size());
        const pointer _New_array      = _Al.allocate(_New_capacity + 1); 
        _Construct_in_place(_My_data._Bx._Ptr, _New_array);






        _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
        _My_data._Mysize = _Right_size;
        _My_data._Myres  = _New_capacity;
    }

public:
    inline basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        _Proxy._Release();
    }

    inline basic_string& operator=(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline basic_string& operator+=(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline basic_string& assign(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline basic_string& append(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {


#line 2951 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        return begin() + static_cast<difference_type>(_Off);
    }

    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
        
        _Adl_verify_range(_First, _Last);


#line 2963 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline ~basic_string() noexcept {
        _Tidy_deallocate();





#line 2976 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    }

    static constexpr auto npos{static_cast<size_type>(-1)};

private:
    void _Copy_assign_val_from_small(const basic_string& _Right) {
        



        _Tidy_deallocate();
        if constexpr (_Can_memcpy_val) {
            _Memcpy_val_from(_Right);
        } else {
            auto& _My_data    = _Mypair._Myval2;
            auto& _Right_data = _Right._Mypair._Myval2;

            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _My_data._Mysize = _Right_data._Mysize;
            _My_data._Myres  = _Right_data._Myres;
        }
    }

    inline void _Copy_assign(const basic_string& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline void _Copy_assign(const basic_string& _Right, true_type) {
        auto& _Al             = _Getal();
        const auto& _Right_al = _Right._Getal();
        if (_Al == _Right_al) {
            _Copy_assign(_Right, false_type{});
            return;
        }

        auto&& _Alproxy       = _Fake_alloc;
        auto&& _Right_alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); 

        if (_Right._Mypair._Myval2._Large_string_engaged()) {
            const auto _New_size     = _Right._Mypair._Myval2._Mysize;
            const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
            auto _Right_al_non_const = _Right_al;
            const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity); 







            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
            _Tidy_deallocate();
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
            _Mypair._Myval2._Mysize  = _New_size;
            _Mypair._Myval2._Myres   = _New_capacity;
        } else {
            _Copy_assign_val_from_small(_Right);
        }

        _Pocca(_Al, _Right_al);
        _New_proxy._Bind(_Alproxy, ::std:: addressof(_Mypair._Myval2));
    }

public:
    inline basic_string& operator=(const basic_string& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }

        return *this;
    }






#line 3056 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline basic_string& operator=(  const _Elem* const _Ptr) {
        return assign(_Ptr);
    }

    inline basic_string& operator=(const _Elem _Ch) { 
        _Mypair._Myval2._Mysize = 1;
        _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
        _Traits::assign(_Ptr[0], _Ch);
        _Traits::assign(_Ptr[1], _Elem());
        return *this;
    }

    inline basic_string& operator+=(const basic_string& _Right) {
        return append(_Right);
    }






#line 3079 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline basic_string& operator+=(  const _Elem* const _Ptr) { 
        return append(_Ptr);
    }

    inline basic_string& operator+=(_Elem _Ch) {
        push_back(_Ch);
        return *this;
    }

    inline basic_string& append(const basic_string& _Right) {
        return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline basic_string& append(
        const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }















#line 3116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline basic_string& append(
          const _Elem* const _Ptr,  const size_type _Count) {
        
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
                const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
    }

    inline basic_string& append(  const _Elem* const _Ptr) { 
        return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    inline basic_string& append( const size_type _Count, const _Elem _Ch) {
        
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& append(const _Iter _First, const _Iter _Last) {
        
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

    inline basic_string& assign(const basic_string& _Right) {
        *this = _Right;
        return *this;
    }

    inline basic_string& assign(
        const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }















#line 3208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline basic_string& assign(
          const _Elem* const _Ptr,  const size_type _Count) {
        
        if (_Count <= _Mypair._Myval2._Myres) {
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::move(_Old_ptr, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
    }

    inline basic_string& assign(  const _Elem* const _Ptr) {
        return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    inline basic_string& assign( const size_type _Count, const _Elem _Ch) {
        
        if (_Count <= _Mypair._Myval2._Myres) {
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::assign(_Old_ptr, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& assign(const _Iter _First, const _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            basic_string _Right(_UFirst, _ULast, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right);
                return *this;
            } else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }

    inline basic_string& insert(const size_type _Off, const basic_string& _Right) {
        
        return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline basic_string& insert(
        const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }
















#line 3300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline basic_string& insert(
        const size_type _Off,   const _Elem* const _Ptr,  const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;

        
        



        const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
#line 3314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        if (_Check_overlap) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            
            
            size_type _Ptr_shifted_after;
            if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                
                _Ptr_shifted_after = _Count; 
            } else if (_Insert_at <= _Ptr) { 
                _Ptr_shifted_after = 0;
            } else { 
                _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
            }

            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
    }

    inline basic_string& insert(const size_type _Off,   const _Elem* const _Ptr) {
        
        return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    inline basic_string& insert(
        const size_type _Off,  const size_type _Count, const _Elem _Ch) {
        
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::assign(_Insert_at, _Count, _Ch); 
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
    }

    inline iterator insert(const const_iterator _Where, const _Elem _Ch) { 


#line 3383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, 1, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    inline iterator insert(
        const const_iterator _Where,  const size_type _Count, const _Elem _Ch) {
        


#line 3394 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Count, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
        


#line 3405 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        return begin() + static_cast<difference_type>(_Off);
    }

    inline basic_string& erase(const size_type _Off = 0) { 
        _Mypair._Myval2._Check_offset(_Off);
        _Eos(_Off);
        return *this;
    }

private:
    inline basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {
        _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
        _Elem* const _Erase_at    = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Mypair._Myval2._Mysize   = _New_size;
        _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); 
        return *this;
    }

public:
    inline basic_string& erase(const size_type _Off, const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Erase_noexcept(_Off, _Count);
    }

    inline iterator erase(const const_iterator _Where) noexcept  {


#line 3448 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, 1);
        return begin() + static_cast<difference_type>(_Off);
    }

    inline iterator erase(const const_iterator _First, const const_iterator _Last) noexcept
     {
        _Adl_verify_range(_First, _Last);


#line 3459 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
        return begin() + static_cast<difference_type>(_Off);
    }

    inline void clear() noexcept { 
        _Eos(0);
    }

    inline basic_string& replace(
        const size_type _Off, const size_type _Nx, const basic_string& _Right) {
        
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline basic_string& replace(const size_type _Off, size_type _Nx, const basic_string& _Right,
        const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }

















#line 3499 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline basic_string& replace(
        const size_type _Off, size_type _Nx,   const _Elem* const _Ptr, const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Nx == _Count) { 
            _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
            return *this;
        }

        const size_type _Old_size    = _Mypair._Myval2._Mysize;
        const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
        if (_Count < _Nx) { 
            _Mypair._Myval2._Mysize = _Old_size - (_Nx - _Count);
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at, _Ptr, _Count);
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);
            return *this;
        }

        const size_type _Growth = static_cast<size_type>(_Count - _Nx);

        
        



        {
            if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { 
                _Mypair._Myval2._Mysize = _Old_size + _Growth;
                _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Elem* const _Suffix_at = _Insert_at + _Nx;

                size_type _Ptr_shifted_after; 
                if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                    _Ptr_shifted_after = _Count;
                } else if (_Suffix_at <= _Ptr) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
                }

                _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
                
                
                
                _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
                
                
                _Traits::copy(
                    _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return *this;
            }
        }

        return _Reallocate_grow_by(
            _Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Ptr, _Count);
    }

    inline basic_string& replace(
        const size_type _Off, const size_type _Nx,   const _Elem* const _Ptr) {
        
        return replace(_Off, _Nx, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    inline basic_string& replace(
        const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch) {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Count == _Nx) {
            _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
            return *this;
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count < _Nx || _Count - _Nx <= _Mypair._Myval2._Myres - _Old_size) {
            
            _Mypair._Myval2._Mysize = _Old_size + _Count - _Nx; 
                                                                
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count - _Nx,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Count, _Ch);
    }

    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
        
        _Adl_verify_range(_First, _Last);


#line 3614 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }













#line 3631 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline basic_string& replace(const const_iterator _First, const const_iterator _Last,
          const _Elem* const _Ptr, const size_type _Count) {
        
        _Adl_verify_range(_First, _Last);


#line 3639 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
    }

    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last,   const _Elem* const _Ptr) {
        
        _Adl_verify_range(_First, _Last);


#line 3650 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
    }

    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
        
        _Adl_verify_range(_First, _Last);


#line 3661 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
        
        _Adl_verify_range(_First, _Last);


#line 3673 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2  = _Get_unwrapped(_Last2);
        if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
            return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
        } else {
            const basic_string _Right(_UFirst2, _ULast2, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

    [[nodiscard]] inline iterator begin() noexcept {
        return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline const_iterator begin() const noexcept {
        return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline iterator end() noexcept {
        return iterator(
            _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline const_iterator end() const noexcept {
        return const_iterator(
            _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline _Elem* _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] inline const _Elem* _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] inline _Elem* _Unchecked_end() noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] inline const _Elem* _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] inline reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] inline reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] inline const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] inline const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] inline const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] inline const_reverse_iterator crend() const noexcept {
        return rend();
    }

    inline void shrink_to_fit() { 
        auto& _My_data = _Mypair._Myval2;




        {
            if (!_My_data._Large_string_engaged()) { 
                return;
            }

            if (_My_data._Mysize < _BUF_SIZE) {
                _Become_small();
                return;
            }
        }

        size_type _Target_capacity = (::std:: min)(_My_data._Mysize | _ALLOC_MASK, max_size());





        if (_Target_capacity < _My_data._Myres) { 
            auto& _Al              = _Getal();
            const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); 







            _My_data._Orphan_all();
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
            _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
            _My_data._Bx._Ptr = _New_ptr;
            _My_data._Myres   = _Target_capacity;
        }
    }

    [[nodiscard]] inline reference at(const size_type _Off) {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] inline const_reference at(const size_type _Off) const {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] inline reference operator[](const size_type _Off) noexcept  {


#line 3809 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] inline const_reference operator[](const size_type _Off) const noexcept
     {


#line 3817 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }






#line 3826 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    inline void push_back(const _Elem _Ch) { 
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Old_size < _Mypair._Myval2._Myres) {
            _Mypair._Myval2._Mysize = _Old_size + 1;
            _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
            _Traits::assign(_Ptr[_Old_size], _Ch);
            _Traits::assign(_Ptr[_Old_size + 1], _Elem());
            return;
        }

        _Reallocate_grow_by(
            1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
    }

    inline void pop_back() noexcept  {
        const size_type _Old_size = _Mypair._Myval2._Mysize;


#line 3852 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        _Eos(_Old_size - 1);
    }

    [[nodiscard]] inline reference front() noexcept  {


#line 3859 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

    [[nodiscard]] inline const_reference front() const noexcept  {


#line 3867 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

    [[nodiscard]] inline reference back() noexcept  {


#line 3875 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    [[nodiscard]] inline const_reference back() const noexcept  {


#line 3883 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    [[nodiscard]] inline   const _Elem* c_str() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] inline   const _Elem* data() const noexcept {
        return _Mypair._Myval2._Myptr();
    }





#line 3900 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline size_type length() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] inline size_type size() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] inline size_type max_size() const noexcept {
        const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
        const size_type _Storage_max = 
            (::std:: max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
        return (::std:: min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),
            _Storage_max - 1 
        );
    }

    inline void resize( const size_type _Newsize, const _Elem _Ch = _Elem()) {
        
        const size_type _Old_size = size();
        if (_Newsize <= _Old_size) {
            _Eos(_Newsize);
        } else {
            append(_Newsize - _Old_size, _Ch);
        }
    }

    [[nodiscard]] inline size_type capacity() const noexcept {
        return _Mypair._Myval2._Myres;
    }






















#line 3954 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    void reserve( const size_type _Newcap = 0) { 
        if (_Mypair._Myval2._Mysize > _Newcap) { 
            return; 
        }

        if (_Mypair._Myval2._Myres == _Newcap) { 
            return; 
        }

        if (_Mypair._Myval2._Myres < _Newcap) { 
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            _Reallocate_grow_by(
                _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
                });

            _Mypair._Myval2._Mysize = _Old_size;
            return;
        }

        if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {
            
            _Become_small();
            return;
        }

        
    }
#line 3983 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline bool empty() const noexcept {
        return size() == 0;
    }

    inline size_type copy(
          _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    inline   size_type
        _Copy_s(  _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) {
        
        

        const pointer _Ptr = _Starts_large._Bx._Ptr;
        _Destroy_in_place(_Starts_large._Bx._Ptr);
        _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);
        _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
    }

    inline void _Swap_data(basic_string& _Right) {
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        if constexpr (_Can_memcpy_val) {



            {
                const auto _My_data_mem =
                    reinterpret_cast<unsigned char*>(::std:: addressof(_My_data)) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast<unsigned char*>(::std:: addressof(_Right_data)) + _Memcpy_val_offset;
                unsigned char _Temp_mem[_Memcpy_val_size];
                :: memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
                :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
                :: memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);
                return;
            }
        }

        const bool _My_large    = _My_data._Large_string_engaged();
        const bool _Right_large = _Right_data._Large_string_engaged();
        if (_My_large) {
            if (_Right_large) { 
                _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            } else { 
                _Swap_bx_large_with_small(_My_data, _Right_data);
            }
        } else {
            if (_Right_large) { 
                _Swap_bx_large_with_small(_Right_data, _My_data);
            } else {
                _Elem _Temp_buf[_BUF_SIZE];
                _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _BUF_SIZE);
                _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _BUF_SIZE);
                _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _BUF_SIZE);
            }
        }

        ::std:: swap(_My_data._Mysize, _Right_data._Mysize);
        ::std:: swap(_My_data._Myres, _Right_data._Myres);
    }

    inline void swap(basic_string& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());















#line 4080 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
        }

        _Swap_data(_Right);
    }









#line 4094 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline size_type find(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] inline size_type find(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] inline size_type find(
          const _Elem* const _Ptr, const size_type _Off = 0) const noexcept  {
        
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] inline size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }









#line 4132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline size_type rfind(
        const basic_string& _Right, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] inline size_type rfind(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] inline size_type rfind(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] inline size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }










#line 4171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline size_type find_first_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_of(  const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_of(
          const _Elem* const _Ptr, const size_type _Off = 0) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }










#line 4211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline size_type find_last_of(
        const basic_string& _Right, size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_of(  const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_of(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_of(
        const _Elem _Ch, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }











#line 4252 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline size_type find_first_not_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_not_of(  const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_not_of(
          const _Elem* const _Ptr, size_type _Off = 0) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_not_of(
        const _Elem _Ch, const size_type _Off = 0) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }











#line 4293 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline size_type find_last_not_of(
        const basic_string& _Right, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_not_of(  const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_not_of(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_not_of(
        const _Elem _Ch, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }






#line 4329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline basic_string substr(
        const size_type _Off = 0, const size_type _Count = npos) const {
        
        return basic_string(*this, _Off, _Count, get_allocator());
    }

    inline bool _Equal(const basic_string& _Right) const noexcept {
        
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline bool _Equal(  const _Elem* const _Ptr) const noexcept {
        
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }






























#line 4377 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline int compare(const basic_string& _Right) const noexcept {
        
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    [[nodiscard]] inline int compare(size_type _Off, size_type _Nx, const basic_string& _Right) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    [[nodiscard]] inline int compare(const size_type _Off, const size_type _Nx, const basic_string& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Right._Mypair._Myval2._Check_offset(_Roff);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }

    [[nodiscard]] inline int compare(  const _Elem* const _Ptr) const noexcept  {
        
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] inline int compare(
        const size_type _Off, const size_type _Nx,   const _Elem* const _Ptr) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] inline int compare(const size_type _Off, const size_type _Nx,
          const _Elem* const _Ptr, const size_type _Count) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx), _Ptr, _Count);
    }

























#line 4446 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

    [[nodiscard]] inline allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    [[nodiscard]] static inline size_type _Calculate_growth(
        const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {
        const size_type _Masked = _Requested | _ALLOC_MASK;
        if (_Masked > _Max) { 
            return _Max;
        }

        if (_Old > _Max - _Old / 2) { 
            return _Max;
        }

        return (::std:: max)(_Masked, _Old + _Old / 2);
    }

    [[nodiscard]] inline size_type _Calculate_growth(const size_type _Requested) const noexcept {
        return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
    }

    template <class _Fty, class... _ArgTys>
    inline basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {
        
        
        if (_New_size > max_size()) {
            _Xlen_string(); 
        }

        const size_type _Old_capacity = _Mypair._Myval2._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 






        _Mypair._Myval2._Orphan_all();
        _Mypair._Myval2._Mysize = _New_size;
        _Mypair._Myval2._Myres  = _New_capacity;
        _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
        if (_BUF_SIZE <= _Old_capacity) {
            _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
        } else {
            _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
        }

        return *this;
    }

    template <class _Fty, class... _ArgTys>
    inline basic_string& _Reallocate_grow_by(
        const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {
        
        
        auto& _My_data            = _Mypair._Myval2;
        const size_type _Old_size = _My_data._Mysize;
        if (max_size() - _Old_size < _Size_increase) {
            _Xlen_string(); 
        }

        const size_type _New_size     = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 






        _My_data._Orphan_all();
        _My_data._Mysize      = _New_size;
        _My_data._Myres       = _New_capacity;
        _Elem* const _Raw_new = _Unfancy(_New_ptr);
        if (_BUF_SIZE <= _Old_capacity) {
            const pointer _Old_ptr = _My_data._Bx._Ptr;
            _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
            _Al.deallocate(_Old_ptr, _Old_capacity + 1);
            _My_data._Bx._Ptr = _New_ptr;
        } else {
            _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
            _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
        }

        return *this;
    }

    void _Become_small() {
        
        
        
        

        _Mypair._Myval2._Orphan_all();
        const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
        auto& _Al          = _Getal();
        _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
        _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);
        _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
        _Mypair._Myval2._Myres = _BUF_SIZE - 1;
    }

    inline void _Eos(const size_type _Newsize) { 
        _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());
    }

    inline void _Tidy_init() noexcept { 
        auto& _My_data   = _Mypair._Myval2;
        _My_data._Mysize = 0;












        {
            _My_data._Myres = _BUF_SIZE - 1;
            
            _Traits::assign(_My_data._Bx._Buf[0], _Elem());
        }
    }

    inline void _Tidy_deallocate() noexcept { 
        _Mypair._Myval2._Orphan_all();
        if (_Mypair._Myval2._Large_string_engaged()) {
            const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
            auto& _Al          = _Getal();
            _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
            _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
        }








        {
            _Mypair._Myval2._Mysize = 0;
            _Mypair._Myval2._Myres  = _BUF_SIZE - 1;
            
            _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());
        }
    }

public:
    inline void _Orphan_all() noexcept { 
        _Mypair._Myval2._Orphan_all();
    }

private:
    inline void _Swap_proxy_and_iterators(basic_string& _Right) {
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    inline _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    inline const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};
















#line 4643 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

template <class _Elem, class _Traits, class _Alloc>
inline void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Left_size  = _Left.size();
    const auto _Right_size = _Right.size();
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size  = _Convert_size<_Size_type>(_Traits::length(_Left));
    const auto _Right_size = _Right.size();
    if (_Right.max_size() - _Right_size < _Left_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Right_size = _Right.size();
    if (_Right_size == _Right.max_size()) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Right, ::std:: addressof(_Left), 1, _Right.c_str(), _Right_size};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size  = _Left.size();
    const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem _Right) {
    const auto _Left_size = _Left.size();
    if (_Left_size == _Left.max_size()) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, ::std:: addressof(_Right), 1};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return ::std:: move(_Left.append(_Right));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {






#line 4732 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
    return {_String_constructor_concat_tag{}, _Left, _Right};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, 1, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left,   const _Elem* const _Right) {
    return ::std:: move(_Left.append(_Right));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right) {
    _Left.push_back(_Right);
    return ::std:: move(_Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Left._Equal(_Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return _Left._Equal(_Right);
}













#line 4785 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator==(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return _Right._Equal(_Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Left.compare(_Right) < 0;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return _Right.compare(_Left) > 0;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return _Left.compare(_Right) < 0;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Left < _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return !(_Left < _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return !(_Left < _Right);
}
#line 4870 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

using string  = basic_string<char, char_traits<char>, allocator<char>>;
using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;



using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

template <class _Elem, class _Traits, class _Alloc>
struct hash<basic_string<_Elem, _Traits, _Alloc>> {
     typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const basic_string<_Elem, _Traits, _Alloc>& _Keyval) const noexcept {
        return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
    }
};

template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    using _Myis   = basic_istream<_Elem, _Traits>;
    using _Ctype  = typename _Myis::_Ctype;
    using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysizt = typename _Mystr::size_type;

    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed                  = false;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());
        _Str.erase();

        try {
        _Mysizt _Size;
        if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {
            _Size = static_cast<_Mysizt>(_Istr.width());
        } else {
            _Size = _Str.max_size();
        }

        typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

        for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= _Myis::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                break; 
            } else { 
                _Str.push_back(_Traits::to_char_type(_Meta));
                _Changed = true;
            }
        }
        } catch (...) { (_Istr) .setstate(_Myis::badbit, true); }
    }

    _Istr.width(0);
    if (!_Changed) {
        _State |= _Myis::failbit;
    }

    _Istr.setstate(_State);
    return _Istr;
}

template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    return ::std:: move(_Istr) >> _Str;
}

template <class _Elem, class _Traits, class _Alloc>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}

inline namespace literals {
    inline namespace string_literals {





#line 4958 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"

        [[nodiscard]] inline string operator"" s(const char* _Str, size_t _Len) {
            return string(_Str, _Len);
        }

        [[nodiscard]] inline wstring operator"" s(const wchar_t* _Str, size_t _Len) {
            return wstring(_Str, _Len);
        }







        [[nodiscard]] inline u16string operator"" s(const char16_t* _Str, size_t _Len) {
            return u16string(_Str, _Len);
        }

        [[nodiscard]] inline u32string operator"" s(const char32_t* _Str, size_t _Len) {
            return u32string(_Str, _Len);
        }



    } 
} 













#line 4999 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"














#line 5014 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
}



#pragma warning(pop)
#pragma pack(pop)
#line 5021 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
#line 5022 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xstring"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )



namespace std {
class logic_error : public exception { 
public:
    using _Mybase = exception;

    explicit logic_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit logic_error(const char* _Message) : _Mybase(_Message) {}






#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

class domain_error : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit domain_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit domain_error(const char* _Message) : _Mybase(_Message) {}






#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

class invalid_argument : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit invalid_argument(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit invalid_argument(const char* _Message) : _Mybase(_Message) {}






#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

class length_error : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit length_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit length_error(const char* _Message) : _Mybase(_Message) {}






#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

class out_of_range : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit out_of_range(const char* _Message) : _Mybase(_Message) {}






#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

class runtime_error : public exception { 
public:
    using _Mybase = exception;

    explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit runtime_error(const char* _Message) : _Mybase(_Message) {}






#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

class overflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit overflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit overflow_error(const char* _Message) : _Mybase(_Message) {}






#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

class underflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit underflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit underflow_error(const char* _Message) : _Mybase(_Message) {}






#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

class range_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit range_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit range_error(const char* _Message) : _Mybase(_Message) {}






#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
};

[[noreturn]] inline void _Throw_range_error(const char* const _Message) {
    throw range_error{_Message};
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\stdexcept"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xcall_once.h"





#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
struct once_flag { 
    constexpr once_flag() noexcept : _Opaque(nullptr) {}

    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;

    void* _Opaque;
};

using _Execute_once_fp_t = int(__stdcall*)(void*, void*, void**);

 int __cdecl _Execute_once(
    once_flag& _Flag, _Execute_once_fp_t _Callback, void* _Pv) noexcept;

template <class _Ty>
union _Immortalizer_impl { 
    constexpr _Immortalizer_impl() noexcept : _Storage{} {}
    _Immortalizer_impl(const _Immortalizer_impl&) = delete;
    _Immortalizer_impl& operator=(const _Immortalizer_impl&) = delete;
    ~_Immortalizer_impl() {
        
    }

    _Ty _Storage;
};
}



#pragma warning(pop)
#pragma pack(pop)
#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xcall_once.h"
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xcall_once.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xerrc.h"





#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
enum class errc { 
    address_family_not_supported       = 102, 
    address_in_use                     = 100, 
    address_not_available              = 101, 
    already_connected                  = 113, 
    argument_list_too_long             = 7, 
    argument_out_of_domain             = 33, 
    bad_address                        = 14, 
    bad_file_descriptor                = 9, 
    bad_message                        = 104, 
    broken_pipe                        = 32, 
    connection_aborted                 = 106, 
    connection_already_in_progress     = 103, 
    connection_refused                 = 107, 
    connection_reset                   = 108, 
    cross_device_link                  = 18, 
    destination_address_required       = 109, 
    device_or_resource_busy            = 16, 
    directory_not_empty                = 41, 
    executable_format_error            = 8, 
    file_exists                        = 17, 
    file_too_large                     = 27, 
    filename_too_long                  = 38, 
    function_not_supported             = 40, 
    host_unreachable                   = 110, 
    identifier_removed                 = 111, 
    illegal_byte_sequence              = 42, 
    inappropriate_io_control_operation = 25, 
    interrupted                        = 4, 
    invalid_argument                   = 22, 
    invalid_seek                       = 29, 
    io_error                           = 5, 
    is_a_directory                     = 21, 
    message_size                       = 115, 
    network_down                       = 116, 
    network_reset                      = 117, 
    network_unreachable                = 118, 
    no_buffer_space                    = 119, 
    no_child_process                   = 10, 
    no_link                            = 121, 
    no_lock_available                  = 39, 
    no_message_available               = 120, 
    no_message                         = 122, 
    no_protocol_option                 = 123, 
    no_space_on_device                 = 28, 
    no_stream_resources                = 124, 
    no_such_device_or_address          = 6, 
    no_such_device                     = 19, 
    no_such_file_or_directory          = 2, 
    no_such_process                    = 3, 
    not_a_directory                    = 20, 
    not_a_socket                       = 128, 
    not_a_stream                       = 125, 
    not_connected                      = 126, 
    not_enough_memory                  = 12, 
    not_supported                      = 129, 
    operation_canceled                 = 105, 
    operation_in_progress              = 112, 
    operation_not_permitted            = 1, 
    operation_not_supported            = 130, 
    operation_would_block              = 140, 
    owner_dead                         = 133, 
    permission_denied                  = 13, 
    protocol_error                     = 134, 
    protocol_not_supported             = 135, 
    read_only_file_system              = 30, 
    resource_deadlock_would_occur      = 36, 
    resource_unavailable_try_again     = 11, 
    result_out_of_range                = 34, 
    state_not_recoverable              = 127, 
    stream_timeout                     = 137, 
    text_file_busy                     = 139, 
    timed_out                          = 138, 
    too_many_files_open_in_system      = 23, 
    too_many_files_open                = 24, 
    too_many_links                     = 31, 
    too_many_symbolic_link_levels      = 114, 
    value_too_large                    = 132, 
    wrong_protocol_type                = 136 
};

}



#pragma warning(pop)
#pragma pack(pop)

#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xerrc.h"
#line 110 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xerrc.h"
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"





#pragma once















#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtimec.h"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ctime"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
using :: clock_t;
using :: size_t;
using :: time_t;
using :: tm;
using :: asctime;
using :: clock;
using :: ctime;
using :: difftime;
using :: gmtime;
using :: localtime;
using :: mktime;
using :: strftime;
using :: time;



#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ctime"
}



#pragma warning(pop)
#pragma pack(pop)

#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ctime"
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ctime"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtimec.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




extern "C" {

struct xtime { 
    __time64_t sec;
    long nsec;
};

 int __cdecl xtime_get(xtime*, int);

 long __cdecl _Xtime_diff_to_millis(const xtime*);
 long __cdecl _Xtime_diff_to_millis2(const xtime*, const xtime*);
 long long __cdecl _Xtime_get_ticks();

 long long __cdecl _Query_perf_counter();
 long long __cdecl _Query_perf_frequency();

}



#pragma warning(pop)
#pragma pack(pop)
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtimec.h"
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xtimec.h"
















#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




extern "C" {
using _Thrd_id_t = unsigned int;
struct _Thrd_t { 
    void* _Hnd; 
    _Thrd_id_t _Id;
};

























#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"

using _Mtx_t = struct _Mtx_internal_imp_t*;

using _Cnd_t = struct _Cnd_internal_imp_t*;

enum { _Thrd_success, _Thrd_nomem, _Thrd_timedout, _Thrd_busy, _Thrd_error };


 int __cdecl _Thrd_detach(_Thrd_t);
 int __cdecl _Thrd_join(_Thrd_t, int*);
 void __cdecl _Thrd_sleep(const xtime*);
 void __cdecl _Thrd_yield();
 unsigned int __cdecl _Thrd_hardware_concurrency();
 _Thrd_id_t __cdecl _Thrd_id();


enum { 
    _Mtx_plain     = 0x01,
    _Mtx_try       = 0x02,
    _Mtx_timed     = 0x04,
    _Mtx_recursive = 0x100
};

 int __cdecl _Mtx_init(_Mtx_t*, int);
 void __cdecl _Mtx_destroy(_Mtx_t);
 void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
 void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
 int __cdecl _Mtx_current_owns(_Mtx_t);
 int __cdecl _Mtx_lock(_Mtx_t);
 int __cdecl _Mtx_trylock(_Mtx_t);
 int __cdecl _Mtx_timedlock(_Mtx_t, const xtime*);
 int __cdecl _Mtx_unlock(_Mtx_t); 

 void* __cdecl _Mtx_getconcrtcs(_Mtx_t);
 void __cdecl _Mtx_clear_owner(_Mtx_t);
 void __cdecl _Mtx_reset_owner(_Mtx_t);



using _Smtx_t = void*;
void __cdecl _Smtx_lock_exclusive(_Smtx_t*);
void __cdecl _Smtx_lock_shared(_Smtx_t*);
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t*);
int __cdecl _Smtx_try_lock_shared(_Smtx_t*);
void __cdecl _Smtx_unlock_exclusive(_Smtx_t*);
void __cdecl _Smtx_unlock_shared(_Smtx_t*);


 int __cdecl _Cnd_init(_Cnd_t*);
 void __cdecl _Cnd_destroy(_Cnd_t);
 void __cdecl _Cnd_init_in_situ(_Cnd_t);
 void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
 int __cdecl _Cnd_wait(_Cnd_t, _Mtx_t); 
 int __cdecl _Cnd_timedwait(_Cnd_t, _Mtx_t, const xtime*);
 int __cdecl _Cnd_broadcast(_Cnd_t); 
 int __cdecl _Cnd_signal(_Cnd_t); 
 void __cdecl _Cnd_register_at_thread_exit(_Cnd_t, _Mtx_t, int*);
 void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t);
 void __cdecl _Cnd_do_broadcast_at_thread_exit();
}

namespace std {
enum { 
    _DEVICE_OR_RESOURCE_BUSY,
    _INVALID_ARGUMENT,
    _NO_SUCH_PROCESS,
    _NOT_ENOUGH_MEMORY,
    _OPERATION_NOT_PERMITTED,
    _RESOURCE_DEADLOCK_WOULD_OCCUR,
    _RESOURCE_UNAVAILABLE_TRY_AGAIN
};

[[noreturn]]  void __cdecl _Throw_C_error(int _Code);
[[noreturn]]  void __cdecl _Throw_Cpp_error(int _Code);

inline int _Check_C_return(int _Res) { 
    if (_Res != _Thrd_success) {
        _Throw_C_error(_Res);
    }

    return _Res;
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"
#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xthreads.h"
















#pragma external_header(pop)
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )









#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"




#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"






#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"




#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"





extern "C" [[nodiscard]] unsigned char __stdcall __std_atomic_compare_exchange_128(
      long long* _Destination,   long long _ExchangeHigh,   long long _ExchangeLow,
      long long* _ComparandResult) noexcept;
extern "C" [[nodiscard]] char __stdcall __std_atomic_has_cmpxchg16b() noexcept;

#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"




#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"













































































#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"


























#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"















extern "C" {
_Smtx_t* __stdcall __std_atomic_get_mutex(const void* _Key) noexcept;
}





#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

namespace std {



#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

template <class _Ty>
struct _Storage_for {
    
    alignas(_Ty) unsigned char _Storage[sizeof(_Ty)];

    _Storage_for()                    = default;
    _Storage_for(const _Storage_for&) = delete;
    _Storage_for& operator=(const _Storage_for&) = delete;






#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    [[nodiscard]] _Ty& _Ref() noexcept {
        return reinterpret_cast<_Ty&>(_Storage);
    }

    [[nodiscard]] _Ty* _Ptr() noexcept {
        return reinterpret_cast<_Ty*>(&_Storage);
    }
};





#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

extern "C" inline void atomic_thread_fence(const memory_order _Order) noexcept {
    if (_Order == memory_order_relaxed) {
        return;
    }


    __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    if (_Order == memory_order_seq_cst) {
        volatile long _Guard; 

        
        
        
#pragma warning(suppress : 6001) 
#pragma warning(suppress : 28113) 
                                  
        (void) _InterlockedIncrement(&_Guard);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    }




#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
}

extern "C" inline void atomic_signal_fence(const memory_order _Order) noexcept {
    if (_Order != memory_order_relaxed) {
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    }
}

template <class _Ty>
_Ty kill_dependency(_Ty _Arg) noexcept { 
    return _Arg;
}

inline void _Check_memory_order(const memory_order _Order) noexcept {
    
    if (static_cast<unsigned int>(_Order) > static_cast<unsigned int>(memory_order_seq_cst)) {
        ;
    }
}

inline void _Check_store_memory_order(const memory_order _Order) noexcept {
    switch (_Order) {
    case memory_order_relaxed:
    case memory_order_release:
    case memory_order_seq_cst:
        
        break;
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_acq_rel:
    default:
        ;
        break;
    }
}

inline void _Check_load_memory_order(const memory_order _Order) noexcept {
    switch (_Order) {
    case memory_order_relaxed:
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_seq_cst:
        
        break;
    case memory_order_release:
    case memory_order_acq_rel:
    default:
        ;
        break;
    }
}

[[nodiscard]] inline memory_order _Combine_cas_memory_orders(
    const memory_order _Success, const memory_order _Failure) noexcept {
    
    
    
    
    
    

    
    
    
    
    static constexpr memory_order _Combined_memory_orders[6][6] = {
        {memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_consume, memory_order_consume, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_acquire, memory_order_acquire, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_release, memory_order_acq_rel, memory_order_acq_rel, memory_order_release, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst,
            memory_order_seq_cst}};

    _Check_memory_order(_Success);
    _Check_load_memory_order(_Failure);
    return _Combined_memory_orders[static_cast<int>(_Success)][static_cast<int>(_Failure)];
}

template <class _Integral, class _Ty>
[[nodiscard]] _Integral _Atomic_reinterpret_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    if constexpr (is_integral_v<_Ty> && sizeof(_Integral) == sizeof(_Ty)) {
        return static_cast<_Integral>(_Source);
    } else if constexpr (is_pointer_v<_Ty> && sizeof(_Integral) == sizeof(_Ty)) {
        return reinterpret_cast<_Integral>(_Source);
    } else {
        _Integral _Result{}; 
        :: memcpy(&_Result, ::std:: addressof(_Source), sizeof(_Source));
        return _Result;
    }
}

inline void _Load_barrier(const memory_order _Order) noexcept { 
    switch (_Order) {
    case memory_order_relaxed:
        
        break;
    default:
    case memory_order_release:
    case memory_order_acq_rel:
        ;
        
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_seq_cst:
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        break;
    }
}


template <class _Ty>
struct _Atomic_padded {
    alignas(sizeof(_Ty)) mutable _Ty _Value; 
};







































#line 430 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

template <class _Ty>
struct _Atomic_storage_types {
    using _TStorage = _Atomic_padded<_Ty>;
    using _Spinlock = long;
};

template <class _Ty>
struct _Atomic_storage_types<_Ty&> {
    using _TStorage = _Ty&;
    using _Spinlock = _Smtx_t*; 
};


template <class _Ty, size_t = sizeof(remove_reference_t<_Ty>)>


#line 448 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
struct _Atomic_storage;




























#line 478 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"


inline void _Atomic_lock_acquire(long& _Spinlock) noexcept {

    
    
    
    int _Current_backoff   = 1;
    const int _Max_backoff = 64;
    while (_InterlockedExchange(&_Spinlock, 1) != 0) {
        while (__iso_volatile_load32(&reinterpret_cast<int&>(_Spinlock)) != 0) {
            for (int _Count_down = _Current_backoff; _Count_down != 0; --_Count_down) {
                _mm_pause();
            }
            _Current_backoff = _Current_backoff < _Max_backoff ? _Current_backoff << 1 : _Max_backoff;
        }
    }








#line 504 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
}

inline void _Atomic_lock_release(long& _Spinlock) noexcept {

    _InterlockedExchange(&_Spinlock, 0); 






#line 516 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
}

inline void _Atomic_lock_acquire(_Smtx_t* _Spinlock) noexcept {
    _Smtx_lock_exclusive(_Spinlock);
}

inline void _Atomic_lock_release(_Smtx_t* _Spinlock) noexcept {
    _Smtx_unlock_exclusive(_Spinlock);
}

template <class _Spinlock_t>
class [[nodiscard]] _Atomic_lock_guard {
public:
    explicit _Atomic_lock_guard(_Spinlock_t& _Spinlock_) noexcept : _Spinlock(_Spinlock_) {
        _Atomic_lock_acquire(_Spinlock);
    }

    ~_Atomic_lock_guard() {
        _Atomic_lock_release(_Spinlock);
    }

    _Atomic_lock_guard(const _Atomic_lock_guard&) = delete;
    _Atomic_lock_guard& operator=(const _Atomic_lock_guard&) = delete;

private:
    _Spinlock_t& _Spinlock;
};
























#line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

template <class _Ty, size_t >
struct _Atomic_storage {
    
    

    using _TVal  = remove_reference_t<_Ty>;
    using _Guard = _Atomic_lock_guard<typename _Atomic_storage_types<_Ty>::_Spinlock>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage(_Value) {
        
    }

    void store(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        _Check_store_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _Storage = _Value;
    }

    [[nodiscard]] _TVal load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        
        _Check_load_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _TVal _Local(_Storage);
        return _Local;
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        _Check_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _TVal _Result(_Storage);
        _Storage = _Value;
        return _Result;
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        _Check_memory_order(_Order);
        const auto _Storage_ptr  = ::std:: addressof(_Storage);
        const auto _Expected_ptr = ::std:: addressof(_Expected);
        bool _Result;


#line 618 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Guard _Lock{_Spinlock};










#line 630 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Result = :: memcmp(_Storage_ptr, _Expected_ptr, sizeof(_TVal)) == 0;
#line 632 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        if (_Result) {
            :: memcpy(_Storage_ptr, ::std:: addressof(_Desired), sizeof(_TVal));
        } else {
            :: memcpy(_Expected_ptr, _Storage_ptr, sizeof(_TVal));
        }

        return _Result;
    }













































#line 686 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"


protected:
    void _Init_spinlock_for_ref() noexcept {
        _Spinlock = __std_atomic_get_mutex(::std:: addressof(_Storage));
    }

private:
    
    mutable typename _Atomic_storage_types<_Ty>::_Spinlock _Spinlock{};

public:
    _Ty _Storage{};




#line 704 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
};

template <class _Ty>
struct _Atomic_storage<_Ty, 1> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem      = _Atomic_address_as<char>(_Storage);
        const char _As_bytes = _Atomic_reinterpret_as<char>(_Value);




#line 726 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        (void) _InterlockedExchange8(_Mem, _As_bytes);
#line 728 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem      = _Atomic_address_as<char>(_Storage);
        const char _As_bytes = _Atomic_reinterpret_as<char>(_Value);
        switch (_Order) {
        case memory_order_relaxed:
            __iso_volatile_store8(_Mem, _As_bytes);
            return;
        case memory_order_release:
            __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
            __iso_volatile_store8(_Mem, _As_bytes);
            return;
        default:
        case memory_order_consume:
        case memory_order_acquire:
        case memory_order_acq_rel:
            ;
            
        case memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<char>(_Storage);
        char _As_bytes  = __iso_volatile_load8(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<char>(_Storage);
        char _As_bytes  = __iso_volatile_load8(_Mem);
        _Load_barrier(_Order);
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        char _As_bytes;
        _Check_memory_order(_Order); _As_bytes = _InterlockedExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Value));
#line 772 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        char _Expected_bytes = _Atomic_reinterpret_as<char>(_Expected); 
        char _Prev_bytes;




















#line 800 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Check_memory_order(_Order); _Prev_bytes = _InterlockedCompareExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Desired), _Expected_bytes);
#line 802 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        reinterpret_cast<char&>(_Expected) = _Prev_bytes;
        return false;
    }













#line 823 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 2> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem       = _Atomic_address_as<short>(_Storage);
        const short _As_bytes = _Atomic_reinterpret_as<short>(_Value);




#line 847 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        (void) _InterlockedExchange16(_Mem, _As_bytes);
#line 849 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem       = _Atomic_address_as<short>(_Storage);
        const short _As_bytes = _Atomic_reinterpret_as<short>(_Value);
        switch (_Order) {
        case memory_order_relaxed:
            __iso_volatile_store16(_Mem, _As_bytes);
            return;
        case memory_order_release:
            __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
            __iso_volatile_store16(_Mem, _As_bytes);
            return;
        default:
        case memory_order_consume:
        case memory_order_acquire:
        case memory_order_acq_rel:
            ;
            
        case memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<short>(_Storage);
        short _As_bytes = __iso_volatile_load16(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<short>(_Storage);
        short _As_bytes = __iso_volatile_load16(_Mem);
        _Load_barrier(_Order);
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        short _As_bytes;
        _Check_memory_order(_Order); _As_bytes = _InterlockedExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Value));
#line 893 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        short _Expected_bytes = _Atomic_reinterpret_as<short>(_Expected); 
        short _Prev_bytes;



















#line 920 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Check_memory_order(_Order); _Prev_bytes = _InterlockedCompareExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Desired), _Expected_bytes);
#line 922 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_Ty));
        return false;
    }













#line 943 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 4> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 




#line 965 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        (void) _InterlockedExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Value));
#line 967 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem     = _Atomic_address_as<int>(_Storage);
        const int _As_bytes = _Atomic_reinterpret_as<int>(_Value);
        switch (_Order) {
        case memory_order_relaxed:
            __iso_volatile_store32(_Mem, _As_bytes);
            return;
        case memory_order_release:
            __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
            __iso_volatile_store32(_Mem, _As_bytes);
            return;
        default:
        case memory_order_consume:
        case memory_order_acquire:
        case memory_order_acq_rel:
            ;
            
        case memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<int>(_Storage);
        auto _As_bytes  = __iso_volatile_load32(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<int>(_Storage);
        auto _As_bytes  = __iso_volatile_load32(_Mem);
        _Load_barrier(_Order);
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        long _As_bytes;
        _Check_memory_order(_Order); _As_bytes = _InterlockedExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Value));
#line 1011 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        long _Expected_bytes = _Atomic_reinterpret_as<long>(_Expected); 
        long _Prev_bytes;



















#line 1038 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Check_memory_order(_Order); _Prev_bytes = _InterlockedCompareExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Desired), _Expected_bytes);
#line 1040 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
        return false;
    }













#line 1061 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 8> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem           = _Atomic_address_as<long long>(_Storage);
        const long long _As_bytes = _Atomic_reinterpret_as<long long>(_Value);




#line 1085 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"



#line 1089 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        (void) _InterlockedExchange64(_Mem, _As_bytes);
#line 1091 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem           = _Atomic_address_as<long long>(_Storage);
        const long long _As_bytes = _Atomic_reinterpret_as<long long>(_Value);
        switch (_Order) {
        case memory_order_relaxed:
            __iso_volatile_store64(_Mem, _As_bytes);
            return;
        case memory_order_release:
            __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
            __iso_volatile_store64(_Mem, _As_bytes);
            return;
        default:
        case memory_order_consume:
        case memory_order_acquire:
        case memory_order_acq_rel:
            ;
            
        case memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<long long>(_Storage);
        long long _As_bytes;




        _As_bytes = __iso_volatile_load64(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
#line 1126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<long long>(_Storage);



        long long _As_bytes = __iso_volatile_load64(_Mem);
#line 1136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Load_barrier(_Order);
        return reinterpret_cast<_TVal&>(_As_bytes);
    }











    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        long long _As_bytes;
        _Check_memory_order(_Order); _As_bytes = _InterlockedExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Value));
#line 1155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }
#line 1158 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        long long _Expected_bytes = _Atomic_reinterpret_as<long long>(_Expected); 
        long long _Prev_bytes;





















#line 1185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Check_memory_order(_Order); _Prev_bytes = _InterlockedCompareExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Desired), _Expected_bytes);
#line 1187 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
        return false;
    }













#line 1208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};


template <class _Ty>
struct _Atomic_storage<_Ty&, 16> { 
    
    using _TVal = remove_reference_t<_Ty&>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty&>, _Ty&, const _TVal> _Value) noexcept
        : _Storage{_Value} {} 

    void store(const _TVal _Value) noexcept { 
        (void) exchange(_Value);
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        _Check_store_memory_order(_Order);
        (void) exchange(_Value, _Order);
    }

    [[nodiscard]] _TVal load() const noexcept { 
        long long* const _Storage_ptr = const_cast<long long*>(_Atomic_address_as<const long long>(_Storage));
        _Int128 _Result{}; 
        (void) __std_atomic_compare_exchange_128(_Storage_ptr, 0, 0, &_Result._Low);
        return reinterpret_cast<_TVal&>(_Result);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 






















#line 1263 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Check_load_memory_order(_Order);
        return load();
#line 1266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
    }

    _TVal exchange(const _TVal _Value) noexcept { 
        _TVal _Result{_Value};
        while (!compare_exchange_strong(_Result, _Value)) { 
        }

        return _Result;
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order) noexcept { 
        _TVal _Result{_Value};
        while (!compare_exchange_strong(_Result, _Value, _Order)) { 
        }

        return _Result;
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        _Int128 _Desired_bytes{};
        :: memcpy(&_Desired_bytes, ::std:: addressof(_Desired), sizeof(_TVal));
        _Int128 _Expected_temp{};
        :: memcpy(&_Expected_temp, ::std:: addressof(_Expected), sizeof(_TVal));
        unsigned char _Result;


































#line 1326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"



#line 1330 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        (void) _Order;
        _Result = __std_atomic_compare_exchange_128(
            &reinterpret_cast<long long&>(_Storage), _Desired_bytes._High, _Desired_bytes._Low, &_Expected_temp._Low);
#line 1334 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        if (_Result == 0) {
            :: memcpy(::std:: addressof(_Expected), &_Expected_temp, sizeof(_TVal));
        }

        return _Result != 0;
    }







































#line 1380 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    struct _Int128 {
        alignas(16) long long _Low;
        long long _High;
    };

    typename _Atomic_storage_types<_Ty&>::_TStorage _Storage;
};
#line 1389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

template <class _Ty, size_t = sizeof(_Ty)>
struct _Atomic_integral; 

template <class _Ty>
struct _Atomic_integral<_Ty, 1> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;






    using _Base::_Base;
#line 1405 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1410 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(_Order); _Result = _InterlockedAnd8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(_Order); _Result = _InterlockedOr8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1424 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(_Order); _Result = _InterlockedXor8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1431 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        return static_cast<_TVal>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), 1));
    }

    _TVal operator++() noexcept {
        unsigned char _Before =
            static_cast<unsigned char>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), 1));
        ++_Before;
        return static_cast<_TVal>(_Before);
    }

    _TVal operator--(int) noexcept {
        return static_cast<_TVal>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), -1));
    }

    _TVal operator--() noexcept {
        unsigned char _Before =
            static_cast<unsigned char>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), -1));
        --_Before;
        return static_cast<_TVal>(_Before);
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 2> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;






    using _Base::_Base;
#line 1469 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1474 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(_Order); _Result = _InterlockedAnd16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(_Order); _Result = _InterlockedOr16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1488 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(_Order); _Result = _InterlockedXor16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1495 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned short _After =
            static_cast<unsigned short>(_InterlockedIncrement16(_Atomic_address_as<short>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement16(_Atomic_address_as<short>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned short _After =
            static_cast<unsigned short>(_InterlockedDecrement16(_Atomic_address_as<short>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement16(_Atomic_address_as<short>(this->_Storage)));
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 4> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;






    using _Base::_Base;
#line 1533 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1538 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedAnd(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1545 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedOr(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1552 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedXor(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1559 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned long _After =
            static_cast<unsigned long>(_InterlockedIncrement(_Atomic_address_as<long>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement(_Atomic_address_as<long>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned long _After =
            static_cast<unsigned long>(_InterlockedDecrement(_Atomic_address_as<long>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement(_Atomic_address_as<long>(this->_Storage)));
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 8> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;






    using _Base::_Base;
#line 1597 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"























































    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1656 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedAnd64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1663 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedOr64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1670 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedXor64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1677 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned long long _After =
            static_cast<unsigned long long>(_InterlockedIncrement64(_Atomic_address_as<long long>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement64(_Atomic_address_as<long long>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned long long _After =
            static_cast<unsigned long long>(_InterlockedDecrement64(_Atomic_address_as<long long>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement64(_Atomic_address_as<long long>(this->_Storage)));
    }
#line 1702 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
};


template <size_t _TypeSize>
 constexpr bool _Is_always_lock_free = _TypeSize <= 8 && (_TypeSize & (_TypeSize - 1)) == 0;








#line 1716 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

template <class _Ty, bool _Is_lock_free = _Is_always_lock_free<sizeof(_Ty)>>
 constexpr bool _Deprecate_non_lock_free_volatile = true;

template <class _Ty>
  constexpr bool _Deprecate_non_lock_free_volatile<_Ty, false> = true;

template <class _Ty>
struct _Atomic_integral_facade : _Atomic_integral<_Ty> {
    
    using _Base           = _Atomic_integral<_Ty>;
    using difference_type = _Ty;





    using _Base::_Base;
#line 1735 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    

    
    
    
    using _Base::fetch_add;
    _Ty fetch_add(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand);
    }

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand, _Order);
    }

    [[nodiscard]] static _Ty _Negate(const _Ty _Value) noexcept { 
        return static_cast<_Ty>(0U - static_cast<make_unsigned_t<_Ty>>(_Value));
    }

    _Ty fetch_sub(const _Ty _Operand) noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand) volatile noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    using _Base::fetch_and;
    _Ty fetch_and(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand);
    }

    _Ty fetch_and(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand, _Order);
    }

    using _Base::fetch_or;
    _Ty fetch_or(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand);
    }

    _Ty fetch_or(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand, _Order);
    }

    using _Base::fetch_xor;
    _Ty fetch_xor(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand);
    }

    _Ty fetch_xor(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand, _Order);
    }

    using _Base::operator++;
    _Ty operator++(int) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++(0);
    }

    _Ty operator++() volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++();
    }

    using _Base::operator--;
    _Ty operator--(int) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--(0);
    }

    _Ty operator--() volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--();
    }

    _Ty operator+=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_add(_Operand) + _Operand);
    }

    _Ty operator+=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand) + _Operand);
    }

    _Ty operator-=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(fetch_sub(_Operand) - _Operand);
    }

    _Ty operator-=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->fetch_sub(_Operand) - _Operand);
    }

    _Ty operator&=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_and(_Operand) & _Operand);
    }

    _Ty operator&=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand) & _Operand);
    }

    _Ty operator|=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_or(_Operand) | _Operand);
    }

    _Ty operator|=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand) | _Operand);
    }

    _Ty operator^=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_xor(_Operand) ^ _Operand);
    }

    _Ty operator^=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand) ^ _Operand);
    }
};

template <class _Ty>
struct _Atomic_integral_facade<_Ty&> : _Atomic_integral<_Ty&> {
    
    using _Base           = _Atomic_integral<_Ty&>;
    using difference_type = _Ty;





    using _Base::_Base;
#line 1868 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    [[nodiscard]] static _Ty _Negate(const _Ty _Value) noexcept { 
        return static_cast<_Ty>(0U - static_cast<make_unsigned_t<_Ty>>(_Value));
    }

    _Ty fetch_add(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand);
    }

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand, _Order);
    }

    _Ty fetch_sub(const _Ty _Operand) const noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) const noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    _Ty operator++(int) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++(0);
    }

    _Ty operator++() const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++();
    }

    _Ty operator--(int) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--(0);
    }

    _Ty operator--() const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--();
    }

    _Ty operator+=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_add(_Operand) + _Operand);
    }

    _Ty operator-=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_sub(_Operand) - _Operand);
    }

    _Ty fetch_and(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand);
    }

    _Ty fetch_and(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand, _Order);
    }

    _Ty fetch_or(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand);
    }

    _Ty fetch_or(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand, _Order);
    }

    _Ty fetch_xor(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand);
    }

    _Ty fetch_xor(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand, _Order);
    }

    _Ty operator&=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_and(_Operand) & _Operand);
    }

    _Ty operator|=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_or(_Operand) | _Operand);
    }

    _Ty operator^=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_xor(_Operand) ^ _Operand);
    }
};




































































































#line 2050 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

template <class _Ty>
struct _Atomic_pointer : _Atomic_storage<_Ty> {
    using _Base           = _Atomic_storage<_Ty>;
    using difference_type = ptrdiff_t;





    using _Base::_Base;
#line 2062 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst) noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast<ptrdiff_t>(static_cast<size_t>(_Diff) * sizeof(remove_pointer_t<_Ty>));
        ptrdiff_t _Result;



#line 2071 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), _Shift_bytes);
#line 2073 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#line 2074 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return reinterpret_cast<_Ty>(_Result);
    }

    

    _Ty fetch_add(const ptrdiff_t _Diff) volatile noexcept {
        return const_cast<_Atomic_pointer*>(this)->fetch_add(_Diff);
    }

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_pointer*>(this)->fetch_add(_Diff, _Order);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty operator++(int) volatile noexcept {
        return fetch_add(1);
    }

    _Ty operator++(int) noexcept {
        return fetch_add(1);
    }

    _Ty operator++() volatile noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator++() noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator--(int) volatile noexcept {
        return fetch_add(-1);
    }

    _Ty operator--(int) noexcept {
        return fetch_add(-1);
    }

    _Ty operator--() volatile noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator--() noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator+=(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator+=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }
};


template <class _Ty>
struct _Atomic_pointer<_Ty&> : _Atomic_storage<_Ty&> {
    using _Base           = _Atomic_storage<_Ty&>;
    using difference_type = ptrdiff_t;





    using _Base::_Base;
#line 2164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst) const noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast<ptrdiff_t>(static_cast<size_t>(_Diff) * sizeof(remove_pointer_t<_Ty>));
        ptrdiff_t _Result;



#line 2173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), _Shift_bytes);
#line 2175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#line 2176 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
        return reinterpret_cast<_Ty>(_Result);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty operator++(int) const noexcept {
        return fetch_add(1);
    }

    _Ty operator++() const noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator--(int) const noexcept {
        return fetch_add(-1);
    }

    _Ty operator--() const noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator+=(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }
};





template <class _TVal, class _Ty = _TVal>
using _Choose_atomic_base2_t =
    typename _Select<is_integral_v<_TVal> && !is_same_v<bool, _TVal>>::template _Apply<_Atomic_integral_facade<_Ty>,
        typename _Select<is_pointer_v<_TVal> && is_object_v<remove_pointer_t<_TVal>>>::template _Apply<
            _Atomic_pointer<_Ty>, _Atomic_storage<_Ty>>>;





#line 2227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
template <class _TVal, class _Ty = _TVal>
using _Choose_atomic_base_t = _Choose_atomic_base2_t<_TVal, _Ty>;
#line 2230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

template <class _Ty>
struct atomic : _Choose_atomic_base_t<_Ty> { 
private:
    using _Base = _Choose_atomic_base_t<_Ty>;

public:
    
    static_assert(is_trivially_copyable_v<_Ty> && is_copy_constructible_v<_Ty> && is_move_constructible_v<_Ty>
        && is_copy_assignable_v<_Ty> && is_move_assignable_v<_Ty>,
        "atomic<T> requires T to be trivially copyable, copy constructible, move constructible, copy assignable, "
        "and move assignable.");
    

    using value_type = _Ty;




    using _Base::_Base;
#line 2251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    constexpr atomic() noexcept(is_nothrow_default_constructible_v<_Ty>) : _Base() {}

    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;



#line 2260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"


    [[nodiscard]] bool is_lock_free() const volatile noexcept {
        constexpr bool _Result = sizeof(_Ty) <= 8 && (sizeof(_Ty) & sizeof(_Ty) - 1) == 0;
        return _Result;
    }










#line 2277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    [[nodiscard]] bool is_lock_free() const noexcept {
        return static_cast<const volatile atomic*>(this)->is_lock_free();
    }

    _Ty operator=(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        this->store(_Value);
        return _Value;
    }

    _Ty operator=(const _Ty _Value) noexcept {
        this->store(_Value);
        return _Value;
    }

    
    
    
    
    
    using _Base::store;
    void store(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        const_cast<atomic*>(this)->_Base::store(_Value);
    }

    void store(const _Ty _Value, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        const_cast<atomic*>(this)->_Base::store(_Value, _Order);
    }

    using _Base::load;
    [[nodiscard]] _Ty load() const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<const atomic*>(this)->_Base::load();
    }

    [[nodiscard]] _Ty load(const memory_order _Order) const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<const atomic*>(this)->_Base::load(_Order);
    }

    using _Base::exchange;
    _Ty exchange(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::exchange(_Value);
    }

    _Ty exchange(const _Ty _Value, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::exchange(_Value, _Order);
    }

    using _Base::compare_exchange_strong;
    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) volatile noexcept {
        
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }
















#line 2399 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    operator _Ty() const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->load();
    }

    operator _Ty() const noexcept {
        return this->load();
    }
};




#line 2414 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"













































































































#line 2524 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

template <class _Ty>
[[nodiscard]] bool atomic_is_lock_free(const volatile atomic<_Ty>* _Mem) noexcept {
    return _Mem->is_lock_free();
}

template <class _Ty>
[[nodiscard]] bool atomic_is_lock_free(const atomic<_Ty>* _Mem) noexcept {
    return _Mem->is_lock_free();
}

template <class _Ty>
void atomic_store(volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    _Mem->store(_Value);
}

template <class _Ty>
void atomic_store(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    _Mem->store(_Value);
}

template <class _Ty>
void atomic_store_explicit(
    volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    _Mem->store(_Value, _Order);
}

template <class _Ty>
void atomic_store_explicit(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    _Mem->store(_Value, _Order);
}

template <class _Ty>
 void atomic_init(
    volatile atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    ::std:: atomic_store_explicit(_Mem, _Value, memory_order_relaxed);
}

template <class _Ty>
 void atomic_init(
    atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    ::std:: atomic_store_explicit(_Mem, _Value, memory_order_relaxed);
}

template <class _Ty>
[[nodiscard]] _Ty atomic_load(const volatile atomic<_Ty>* const _Mem) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->load();
}

template <class _Ty>
[[nodiscard]] _Ty atomic_load(const atomic<_Ty>* const _Mem) noexcept {
    return _Mem->load();
}

template <class _Ty>
[[nodiscard]] _Ty atomic_load_explicit(const volatile atomic<_Ty>* const _Mem, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->load(_Order);
}

template <class _Ty>
[[nodiscard]] _Ty atomic_load_explicit(const atomic<_Ty>* const _Mem, const memory_order _Order) noexcept {
    return _Mem->load(_Order);
}

template <class _Ty>
_Ty atomic_exchange(volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->exchange(_Value);
}

template <class _Ty>
_Ty atomic_exchange(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    return _Mem->exchange(_Value);
}

template <class _Ty>
_Ty atomic_exchange_explicit(
    volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->exchange(_Value, _Order);
}

template <class _Ty>
_Ty atomic_exchange_explicit(
    atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    return _Mem->exchange(_Value, _Order);
}

template <class _Ty>
bool atomic_compare_exchange_strong(
    volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

template <class _Ty>
bool atomic_compare_exchange_strong(
    atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

template <class _Ty>
bool atomic_compare_exchange_strong_explicit(volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

template <class _Ty>
bool atomic_compare_exchange_strong_explicit(atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

template <class _Ty>
bool atomic_compare_exchange_weak(
    volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

template <class _Ty>
bool atomic_compare_exchange_weak(
    atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

template <class _Ty>
bool atomic_compare_exchange_weak_explicit(volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

template <class _Ty>
bool atomic_compare_exchange_weak_explicit(atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

template <class _Ty>
_Ty atomic_fetch_add(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_add(_Value);
}

template <class _Ty>
_Ty atomic_fetch_add(atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    return _Mem->fetch_add(_Value);
}

template <class _Ty>
_Ty atomic_fetch_add_explicit(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value,
    const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_add(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_add_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_add(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_sub(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_sub(_Value);
}

template <class _Ty>
_Ty atomic_fetch_sub(atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    return _Mem->fetch_sub(_Value);
}

template <class _Ty>
_Ty atomic_fetch_sub_explicit(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value,
    const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_sub(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_sub_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_sub(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_and(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_and(_Value);
}

template <class _Ty>
_Ty atomic_fetch_and(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_and(_Value);
}

template <class _Ty>
_Ty atomic_fetch_and_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_and(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_and_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_and(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_or(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_or(_Value);
}

template <class _Ty>
_Ty atomic_fetch_or(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_or(_Value);
}

template <class _Ty>
_Ty atomic_fetch_or_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_or(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_or_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_or(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_xor(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_xor(_Value);
}

template <class _Ty>
_Ty atomic_fetch_xor(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_xor(_Value);
}

template <class _Ty>
_Ty atomic_fetch_xor_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_xor(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_xor_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_xor(_Value, _Order);
}













































#line 2834 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

using atomic_bool = atomic<bool>;

using atomic_char   = atomic<char>;
using atomic_schar  = atomic<signed char>;
using atomic_uchar  = atomic<unsigned char>;
using atomic_short  = atomic<short>;
using atomic_ushort = atomic<unsigned short>;
using atomic_int    = atomic<int>;
using atomic_uint   = atomic<unsigned int>;
using atomic_long   = atomic<long>;
using atomic_ulong  = atomic<unsigned long>;
using atomic_llong  = atomic<long long>;
using atomic_ullong = atomic<unsigned long long>;




using atomic_char16_t = atomic<char16_t>;
using atomic_char32_t = atomic<char32_t>;
using atomic_wchar_t  = atomic<wchar_t>;

using atomic_int8_t   = atomic<int8_t>;
using atomic_uint8_t  = atomic<uint8_t>;
using atomic_int16_t  = atomic<int16_t>;
using atomic_uint16_t = atomic<uint16_t>;
using atomic_int32_t  = atomic<int32_t>;
using atomic_uint32_t = atomic<uint32_t>;
using atomic_int64_t  = atomic<int64_t>;
using atomic_uint64_t = atomic<uint64_t>;

using atomic_int_least8_t   = atomic<int_least8_t>;
using atomic_uint_least8_t  = atomic<uint_least8_t>;
using atomic_int_least16_t  = atomic<int_least16_t>;
using atomic_uint_least16_t = atomic<uint_least16_t>;
using atomic_int_least32_t  = atomic<int_least32_t>;
using atomic_uint_least32_t = atomic<uint_least32_t>;
using atomic_int_least64_t  = atomic<int_least64_t>;
using atomic_uint_least64_t = atomic<uint_least64_t>;

using atomic_int_fast8_t   = atomic<int_fast8_t>;
using atomic_uint_fast8_t  = atomic<uint_fast8_t>;
using atomic_int_fast16_t  = atomic<int_fast16_t>;
using atomic_uint_fast16_t = atomic<uint_fast16_t>;
using atomic_int_fast32_t  = atomic<int_fast32_t>;
using atomic_uint_fast32_t = atomic<uint_fast32_t>;
using atomic_int_fast64_t  = atomic<int_fast64_t>;
using atomic_uint_fast64_t = atomic<uint_fast64_t>;

using atomic_intptr_t  = atomic<intptr_t>;
using atomic_uintptr_t = atomic<uintptr_t>;
using atomic_size_t    = atomic<size_t>;
using atomic_ptrdiff_t = atomic<ptrdiff_t>;
using atomic_intmax_t  = atomic<intmax_t>;
using atomic_uintmax_t = atomic<uintmax_t>;






#line 2896 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"



struct atomic_flag { 








#line 2909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

    bool test_and_set(const memory_order _Order = memory_order_seq_cst) noexcept {
        return _Storage.exchange(true, _Order) != 0;
    }

    bool test_and_set(const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        return _Storage.exchange(true, _Order) != 0;
    }

    void clear(const memory_order _Order = memory_order_seq_cst) noexcept {
        _Storage.store(false, _Order);
    }

    void clear(const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        _Storage.store(false, _Order);
    }

    constexpr atomic_flag() noexcept = default;

























#line 2953 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"


    atomic<long> _Storage;


#line 2959 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
};



















#line 2980 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

inline bool atomic_flag_test_and_set(atomic_flag* const _Flag) noexcept {
    return _Flag->test_and_set();
}

inline bool atomic_flag_test_and_set(volatile atomic_flag* const _Flag) noexcept {
    return _Flag->test_and_set();
}

inline bool atomic_flag_test_and_set_explicit(atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test_and_set(_Order);
}

inline bool atomic_flag_test_and_set_explicit(volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test_and_set(_Order);
}

inline void atomic_flag_clear(atomic_flag* const _Flag) noexcept {
    _Flag->clear();
}

inline void atomic_flag_clear(volatile atomic_flag* const _Flag) noexcept {
    _Flag->clear();
}

inline void atomic_flag_clear_explicit(atomic_flag* const _Flag, const memory_order _Order) noexcept {
    _Flag->clear(_Order);
}

inline void atomic_flag_clear_explicit(volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    _Flag->clear(_Order);
}


































































































#line 3111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"

}














#pragma warning(pop)
#pragma pack(pop)
#line 3130 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#line 3131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\atomic"
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"



#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
enum class io_errc { 
    stream = 1
};

template <class _Enum>
struct is_error_code_enum : false_type {};

template <>
struct is_error_code_enum<io_errc> : true_type {};

template <class _Ty>
 constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

template <class _Enum>
struct is_error_condition_enum : false_type {};

template <>
struct is_error_condition_enum<errc> : true_type {};

template <class _Ty>
 constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

class error_code;
class error_condition;
[[nodiscard]] error_code make_error_code(errc) noexcept;
[[nodiscard]] error_code make_error_code(io_errc) noexcept;
[[nodiscard]] error_condition make_error_condition(errc) noexcept;
[[nodiscard]] error_condition make_error_condition(io_errc) noexcept;

class error_category;

[[nodiscard]] const error_category& generic_category() noexcept;
[[nodiscard]] const error_category& iostream_category() noexcept;
[[nodiscard]] const error_category& system_category() noexcept;

class __declspec(novtable) error_category { 
public:
     error_category() noexcept { 
        _Addr = reinterpret_cast<uintptr_t>(this);
    }




        virtual ~error_category() noexcept = default;

    [[nodiscard]] virtual const char* name() const noexcept = 0;

    [[nodiscard]] virtual string message(int _Errval) const = 0;

    [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept;

    [[nodiscard]] virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;

    [[nodiscard]] virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;

    [[nodiscard]] bool operator==(const error_category& _Right) const noexcept {
        return _Addr == _Right._Addr;
    }


    [[nodiscard]] bool operator!=(const error_category& _Right) const noexcept {
        return !(*this == _Right);
    }
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"






    [[nodiscard]] bool operator<(const error_category& _Right) const noexcept {
        return _Addr < _Right._Addr;
    }
#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

protected:
    uintptr_t _Addr;

    constexpr explicit error_category(const uintptr_t _Addr_) noexcept : _Addr(_Addr_) {}

    enum : uintptr_t { 
        _Future_addr   = 1,
        _Generic_addr  = 3,
        _Iostream_addr = 5,
        _System_addr   = 7
    };
};


[[nodiscard]] inline bool _System_error_equal(const error_code&, const error_condition&) noexcept;
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

class error_code { 
public:
    error_code() noexcept : _Myval(0), _Mycat(&::std:: system_category()) {} 

    error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        *this = make_error_code(_Errcode); 
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code& operator=(_Enum _Errcode) noexcept {
        *this = make_error_code(_Errcode); 
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &::std:: system_category();
    }

    [[nodiscard]] int value() const noexcept {
        return _Myval;
    }

    [[nodiscard]] const error_category& category() const noexcept {
        return *_Mycat;
    }

    [[nodiscard]] error_condition default_error_condition() const noexcept;

    [[nodiscard]] string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }


    friend bool operator==(const error_code& _Left, const error_code& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }

    friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept {
        return _System_error_equal(_Left, _Right);
    }









    friend bool operator<(const error_code& _Left, const error_code& _Right) noexcept {
        return _Left.category() < _Right.category()
            || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
    }
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

    friend bool operator==(const error_condition& _Left, const error_code& _Right) noexcept {
        return _System_error_equal(_Right, _Left);
    }

    friend bool operator!=(const error_code& _Left, const error_code& _Right) noexcept {
        return !(_Left == _Right);
    }

    friend bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept {
        return !_System_error_equal(_Left, _Right);
    }

    friend bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept {
        return !_System_error_equal(_Right, _Left);
    }
#line 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

private:
    int _Myval; 
    const error_category* _Mycat; 
};

class error_condition { 
public:
    error_condition() noexcept : _Myval(0), _Mycat(&::std:: generic_category()) {} 

    error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        *this = make_error_condition(_Errcode); 
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition& operator=(_Enum _Errcode) noexcept {
        *this = make_error_condition(_Errcode); 
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &::std:: generic_category();
    }

    [[nodiscard]] int value() const noexcept {
        return _Myval;
    }

    [[nodiscard]] const error_category& category() const noexcept {
        return *_Mycat;
    }

    [[nodiscard]] string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }


    friend bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }










    friend bool operator<(const error_condition& _Left, const error_condition& _Right) noexcept {
        return _Left.category() < _Right.category()
            || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
    }
#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

    friend bool operator!=(const error_condition& _Left, const error_condition& _Right) noexcept {
        return !(_Left == _Right);
    }
#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

    
    
    
    friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept;

    friend bool operator==(const error_condition& _Left, const error_code& _Right) noexcept;
    friend bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept;
    friend bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept;
#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#line 298 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

private:
    int _Myval; 
    const error_category* _Mycat; 
};


[[nodiscard]] inline bool _System_error_equal(const error_code& _Left, const error_condition& _Right) noexcept {
    return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
}




























































#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

[[nodiscard]] inline error_condition error_category::default_error_condition(int _Errval) const noexcept {
    
    return error_condition(_Errval, *this);
}

[[nodiscard]] inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {
    return default_error_condition(_Errval) == _Cond;
}

[[nodiscard]] inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {
    return *this == _Code.category() && _Code.value() == _Errval;
}

[[nodiscard]] inline error_condition error_code::default_error_condition() const noexcept {
    
    return category().default_error_condition(value());
}

[[nodiscard]] inline error_code make_error_code(errc _Errno) noexcept {
    return error_code(static_cast<int>(_Errno), ::std:: generic_category());
}

[[nodiscard]] inline error_code make_error_code(io_errc _Errno) noexcept {
    return error_code(static_cast<int>(_Errno), ::std:: iostream_category());
}

[[nodiscard]] inline error_condition make_error_condition(errc _Errno) noexcept {
    return error_condition(static_cast<int>(_Errno), ::std:: generic_category());
}

[[nodiscard]] inline error_condition make_error_condition(io_errc _Errno) noexcept {
    return error_condition(static_cast<int>(_Errno), ::std:: iostream_category());
}

template <>
struct hash<error_code> {
     typedef error_code argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const error_code& _Keyval) const noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

template <>
struct hash<error_condition> {
     typedef error_condition argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const error_condition& _Keyval) const noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

class _System_error : public runtime_error { 
private:
    static string _Makestr(error_code _Errcode, string _Message) { 
        if (!_Message.empty()) {
            _Message.append(": ");
        }

        _Message.append(_Errcode.message());
        return _Message;
    }

protected:
    _System_error(error_code _Errcode, const string& _Message)
        : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

    error_code _Mycode; 
};

class system_error : public _System_error { 
private:
    using _Mybase = _System_error;

public:
    system_error(error_code _Errcode) : _Mybase(_Errcode, "") {}

    system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

    system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

    system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat), "") {}

    system_error(int _Errval, const error_category& _Errcat, const string& _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    system_error(int _Errval, const error_category& _Errcat, const char* _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    [[nodiscard]] const error_code& code() const noexcept {
        return _Mycode;
    }






#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
};

[[noreturn]] inline void _Throw_system_error(const errc _Errno) {
    throw system_error{::std:: make_error_code(_Errno)};
}

 const char* __cdecl _Syserror_map(int);
 int __cdecl _Winerror_map(int);

struct _System_error_message {
    char* _Str;
    size_t _Length;

    explicit _System_error_message(const unsigned long _Ec) noexcept
        : _Str(nullptr), _Length(:: __std_system_error_allocate_message(_Ec, &_Str)) {}

    _System_error_message(const _System_error_message&) = delete;
    _System_error_message& operator=(const _System_error_message&) = delete;

    ~_System_error_message() {
        :: __std_system_error_deallocate_message(_Str);
    }
};

class _Generic_error_category : public error_category { 
public:
    constexpr _Generic_error_category() noexcept : error_category(_Generic_addr) {}

    [[nodiscard]] virtual const char* name() const noexcept override {
        return "generic";
    }

    [[nodiscard]] virtual string message(int _Errcode) const override {
        return _Syserror_map(_Errcode);
    }
};

class _Iostream_error_category2 : public error_category { 
public:
    constexpr _Iostream_error_category2() noexcept : error_category(_Iostream_addr) {}

    [[nodiscard]] virtual const char* name() const noexcept override {
        return "iostream";
    }

    [[nodiscard]] virtual string message(int _Errcode) const override {
        if (_Errcode == static_cast<int>(io_errc::stream)) {
            static constexpr char _Iostream_error[] = "iostream stream error";
            constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; 
            return string(_Iostream_error, _Iostream_error_length);
        } else {
            return _Syserror_map(_Errcode);
        }
    }
};

class _System_error_category : public error_category { 
public:
    constexpr _System_error_category() noexcept : error_category(_System_addr) {}

    [[nodiscard]] virtual const char* name() const noexcept override {
        return "system";
    }

    [[nodiscard]] virtual string message(int _Errcode) const override {
        const _System_error_message _Msg(static_cast<unsigned long>(_Errcode));
        if (_Msg._Length == 0) {
            static constexpr char _Unknown_error[] = "unknown error";
            constexpr size_t _Unknown_error_length = sizeof(_Unknown_error) - 1; 
            return string(_Unknown_error, _Unknown_error_length);
        } else {
            return string(_Msg._Str, _Msg._Length);
        }
    }

    [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept override {
        
        const int _Posv = _Winerror_map(_Errval);
        if (_Posv == 0) {
            return error_condition(_Errval, ::std:: system_category());
        } else {
            return error_condition(_Posv, ::std:: generic_category());
        }
    }
};





































#line 594 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"





#line 600 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"





#line 606 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
template <class _Ty>
struct _Constexpr_immortalize_impl {
    union {
        _Ty _Storage;
    };

    constexpr _Constexpr_immortalize_impl() noexcept : _Storage{} {}

    _Constexpr_immortalize_impl(const _Constexpr_immortalize_impl&) = delete;
    _Constexpr_immortalize_impl& operator=(const _Constexpr_immortalize_impl&) = delete;

    [[msvc::noop_dtor]] ~_Constexpr_immortalize_impl() {
        
    }
};

template <class _Ty>
[[nodiscard]] const _Ty& _Immortalize_memcpy_image() noexcept {
    static _Constexpr_immortalize_impl<_Ty> _Static;
    return _Static._Storage;
}



















#line 647 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"

[[nodiscard]] inline const error_category& generic_category() noexcept {
    return _Immortalize_memcpy_image<_Generic_error_category>();
}

[[nodiscard]] inline const error_category& iostream_category() noexcept {
    return _Immortalize_memcpy_image<_Iostream_error_category2>();
}

[[nodiscard]] inline const error_category& system_category() noexcept {
    return _Immortalize_memcpy_image<_System_error_category>();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 665 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#line 666 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\system_error"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"





#pragma once







#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




#pragma warning(disable : 4275) 

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"







#pragma once






#pragma warning(push)
#pragma warning(disable:   4514 4820 )

#pragma pack(push, 8)





#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"



__pragma(pack(push, 8)) extern "C" {

struct __std_type_info_data
{
    const char * _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;

    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

 int __cdecl __std_type_info_compare(
      const __std_type_info_data* _Lhs,
      const __std_type_info_data* _Rhs
    );

 size_t __cdecl __std_type_info_hash(
      const __std_type_info_data* _Data
    );

 const char* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))


#pragma warning(push)
#pragma warning(disable: 4577) 
class type_info
{
public:

    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;

    size_t hash_code() const noexcept
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }


    bool operator!=(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }
#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"

    bool before(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    const char* name() const noexcept
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
    }

    const char* raw_name() const noexcept
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() noexcept;

private:

    mutable __std_type_info_data _Data;
};
#pragma warning(pop)

namespace std {
    using ::type_info;
}



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class bad_cast
    : public exception
{
public:

    bad_cast() noexcept
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() noexcept
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(const char* const _Message, int) noexcept
        : bad_typeid(_Message, 1)
    {
    }
};

#pragma warning(pop)
} 

#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#pragma warning(pop) 
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_typeinfo.h"
#pragma external_header(pop)
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"

namespace std {


constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void*);































#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"

[[noreturn]] inline void _Throw_bad_cast() {
    throw bad_cast{};
}

}



#pragma pack(pop)
#pragma warning(pop)
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"
#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\typeinfo"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"




#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
















































































template <class _InIt, class _Diff, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _Dest;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
    if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
        _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
    } else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};

        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }

        _UDest = _Backout._Release();
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}








































































































































#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"


















































































































template <class _NoThrowFwdIt, class _Diff, class _Tval>
_NoThrowFwdIt uninitialized_fill_n(_NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_Count));
        _UFirst += _Count;
    } else {
        if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                _Seek_wrapped(_First, _UFirst + _Count);
                return _First;
            }
        }

        _Uninitialized_backout<decltype(_UFirst)> _Backout{_UFirst};

        for (; _Count > 0; --_Count) {
            _Backout._Emplace_back(_Val);
        }

        _UFirst = _Backout._Release();
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}





































































































































































































































































































































































































































































#line 872 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"



template <class _OutIt, class _Ty>
class  raw_storage_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;



    using difference_type = void;
#line 885 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
    using pointer   = void;
    using reference = void;

    explicit raw_storage_iterator(_OutIt _First) : _Next(_First) {}

    [[nodiscard]] raw_storage_iterator& operator*() { 
        return *this;
    }

    raw_storage_iterator& operator=(const _Ty& _Val) { 
        _Construct_in_place(*_Next, _Val);
        return *this;
    }

    raw_storage_iterator& operator=(_Ty&& _Val) { 
        _Construct_in_place(*_Next, ::std:: move(_Val));
        return *this;
    }

    raw_storage_iterator& operator++() {
        ++_Next;
        return *this;
    }

    raw_storage_iterator operator++(int) {
        raw_storage_iterator _Ans = *this;
        ++_Next;
        return _Ans;
    }

    [[nodiscard]] _OutIt base() const {
        return _Next;
    }

private:
    _OutIt _Next;
};
#line 923 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"



template <class _Ty>
class auto_ptr;

template <class _Ty>
struct auto_ptr_ref { 
    explicit auto_ptr_ref(_Ty* _Right) : _Ref(_Right) {}

    _Ty* _Ref; 
};

template <class _Ty>
class auto_ptr { 
public:
    using element_type = _Ty;

    explicit auto_ptr(_Ty* _Ptr = nullptr) noexcept : _Myptr(_Ptr) {}

    auto_ptr(auto_ptr& _Right) noexcept : _Myptr(_Right.release()) {}

    auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept {
        _Ty* _Ptr   = _Right._Ref;
        _Right._Ref = nullptr; 
        _Myptr      = _Ptr; 
    }

    template <class _Other>
    operator auto_ptr<_Other>() noexcept { 
        return auto_ptr<_Other>(*this);
    }

    template <class _Other>
    operator auto_ptr_ref<_Other>() noexcept { 
        _Other* _Cvtptr = _Myptr; 
        auto_ptr_ref<_Other> _Ans(_Cvtptr);
        _Myptr = nullptr; 
        return _Ans;
    }

    template <class _Other>
    auto_ptr& operator=(auto_ptr<_Other>& _Right) noexcept {
        reset(_Right.release());
        return *this;
    }

    template <class _Other>
    auto_ptr(auto_ptr<_Other>& _Right) noexcept : _Myptr(_Right.release()) {}

    auto_ptr& operator=(auto_ptr& _Right) noexcept {
        reset(_Right.release());
        return *this;
    }

    auto_ptr& operator=(auto_ptr_ref<_Ty> _Right) noexcept {
        _Ty* _Ptr   = _Right._Ref;
        _Right._Ref = 0; 
        reset(_Ptr); 
        return *this;
    }

    ~auto_ptr() noexcept {
        delete _Myptr;
    }

    [[nodiscard]] _Ty& operator*() const noexcept {


#line 993 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

        return *get();
    }

    [[nodiscard]] _Ty* operator->() const noexcept {


#line 1001 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

        return get();
    }

    [[nodiscard]] _Ty* get() const noexcept {
        return _Myptr;
    }

    _Ty* release() noexcept {
        _Ty* _Tmp = _Myptr;
        _Myptr    = nullptr;
        return _Tmp;
    }

    void reset(_Ty* _Ptr = nullptr) noexcept { 
        if (_Ptr != _Myptr) {
            delete _Myptr;
        }

        _Myptr = _Ptr;
    }

private:
    _Ty* _Myptr; 
};

template <>
class auto_ptr<void> {
public:
    using element_type = void;
};
#line 1033 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"


class bad_weak_ptr : public exception { 
public:
    bad_weak_ptr() noexcept {}

    [[nodiscard]] virtual const char*  what() const noexcept override {
        
        return "bad_weak_ptr";
    }
};

[[noreturn]] inline void _Throw_bad_weak_ptr() {
    throw bad_weak_ptr{};
}

class __declspec(novtable) _Ref_count_base { 
private:










    virtual void _Destroy() noexcept     = 0; 
    virtual void _Delete_this() noexcept = 0; 
#line 1064 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    _Atomic_counter_t _Uses  = 1;
    _Atomic_counter_t _Weaks = 1;

protected:
    constexpr _Ref_count_base() noexcept = default; 

public:
    _Ref_count_base(const _Ref_count_base&) = delete;
    _Ref_count_base& operator=(const _Ref_count_base&) = delete;

    virtual ~_Ref_count_base() noexcept {} 

    bool _Incref_nz() noexcept { 
        auto& _Volatile_uses = reinterpret_cast<volatile long&>(_Uses);



        long _Count = __iso_volatile_load32(reinterpret_cast<volatile int*>(&_Volatile_uses));
#line 1084 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
        while (_Count != 0) {
            const long _Old_value = _InterlockedCompareExchange(&_Volatile_uses, _Count + 1, _Count);
            if (_Old_value == _Count) {
                return true;
            }

            _Count = _Old_value;
        }

        return false;
    }

    void _Incref() noexcept { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Uses));
    }

    void _Incwref() noexcept { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Weaks));
    }

    void _Decref() noexcept { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Uses)) == 0) {
            _Destroy();
            _Decwref();
        }
    }

    void _Decwref() noexcept { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Weaks)) == 0) {
            _Delete_this();
        }
    }

    long _Use_count() const noexcept {
        return static_cast<long>(_Uses);
    }

    virtual void* _Get_deleter(const type_info&) const noexcept {
        return nullptr;
    }
};

template <class _Ty>
class _Ref_count : public _Ref_count_base { 
public:
    explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) {}

private:
    virtual void _Destroy() noexcept override { 
        delete _Ptr;
    }

    virtual void _Delete_this() noexcept override { 
        delete this;
    }

    _Ty* _Ptr;
};

template <class _Resource, class _Dx>
class _Ref_count_resource : public _Ref_count_base { 
public:
    _Ref_count_resource(_Resource _Px, _Dx _Dt)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Px) {}




    virtual ~_Ref_count_resource() noexcept override = default; 
#line 1154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    virtual void* _Get_deleter(const type_info& _Typeid) const noexcept override {

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 1163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

        return nullptr;
    }

private:
    virtual void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Myval2);
    }

    virtual void _Delete_this() noexcept override { 
        delete this;
    }

    _Compressed_pair<_Dx, _Resource> _Mypair;
};

template <class _Resource, class _Dx, class _Alloc>
class _Ref_count_resource_alloc : public _Ref_count_base {
    
public:
    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
        : _Ref_count_base(),
          _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _One_then_variadic_args_t{}, _Ax, _Px) {}




    virtual ~_Ref_count_resource_alloc() noexcept override = default; 
#line 1192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    virtual void* _Get_deleter(const type_info& _Typeid) const noexcept override {

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 1201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

        return nullptr;
    }

private:
    using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

    virtual void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Myval2._Myval2);
    }

    virtual void _Delete_this() noexcept override { 
        _Myalty _Al = _Mypair._Myval2._Get_first();
        this->~_Ref_count_resource_alloc();
        _Deallocate_plain(_Al, this);
    }

    _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
};

template <class _Ty>
struct default_delete;

template <class _Ty, class _Dx = default_delete<_Ty>>
class unique_ptr;

template <class _Ty>
class shared_ptr;

template <class _Ty>
class weak_ptr;

template <class _Yty, class = void>
struct _Can_enable_shared : false_type {}; 

template <class _Yty>
struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
    : is_convertible<remove_cv_t<_Yty>*, typename _Yty::_Esft_type*>::type {
    
};

struct _Exception_ptr_access;

template <class _Ty>
class _Ptr_base { 
public:
    using element_type = remove_extent_t<_Ty>;

    [[nodiscard]] long use_count() const noexcept {
        return _Rep ? _Rep->_Use_count() : 0;
    }

    template <class _Ty2>
    [[nodiscard]] bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept { 
        return _Rep < _Right._Rep;
    }

    _Ptr_base(const _Ptr_base&) = delete;
    _Ptr_base& operator=(const _Ptr_base&) = delete;

protected:
    [[nodiscard]] element_type* get() const noexcept {
        return _Ptr;
    }

    constexpr _Ptr_base() noexcept = default;

    ~_Ptr_base() = default;

    template <class _Ty2>
    void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {
        
        _Ptr = _Right._Ptr;
        _Rep = _Right._Rep;

        _Right._Ptr = nullptr;
        _Right._Rep = nullptr;
    }

    template <class _Ty2>
    void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {
        
        _Other._Incref();

        _Ptr = _Other._Ptr;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept {
        
        _Other._Incref();

        _Ptr = _Px;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept {
        
        _Ptr = _Px;
        _Rep = _Other._Rep;

        _Other._Ptr = nullptr;
        _Other._Rep = nullptr;
    }

    template <class _Ty0>
    friend class weak_ptr; 

    template <class _Ty2>
    bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept {
        
        if (_Other._Rep && _Other._Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            return true;
        }

        return false;
    }

    void _Incref() const noexcept {
        if (_Rep) {
            _Rep->_Incref();
        }
    }

    void _Decref() noexcept { 
        if (_Rep) {
            _Rep->_Decref();
        }
    }

    void _Swap(_Ptr_base& _Right) noexcept { 
        ::std:: swap(_Ptr, _Right._Ptr);
        ::std:: swap(_Rep, _Right._Rep);
    }

    template <class _Ty2>
    void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept { 
        if (_Other._Rep) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            _Rep->_Incwref();
        } else {
            ;
        }
    }

    template <class _Ty2>
    void _Weakly_convert_lvalue_avoiding_expired_conversions(const _Ptr_base<_Ty2>& _Other) noexcept {
        
        if (_Other._Rep) {
            _Rep = _Other._Rep; 
            _Rep->_Incwref();

            if (_Rep->_Incref_nz()) {
                _Ptr = _Other._Ptr; 
                _Rep->_Decref();
            } else {
                ;
            }
        } else {
            ;
        }
    }

    template <class _Ty2>
    void _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base<_Ty2>&& _Other) noexcept {
        
        _Rep        = _Other._Rep; 
        _Other._Rep = nullptr;

        if (_Rep && _Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr; 
            _Rep->_Decref();
        } else {
            ;
        }

        _Other._Ptr = nullptr;
    }

    void _Incwref() const noexcept {
        if (_Rep) {
            _Rep->_Incwref();
        }
    }

    void _Decwref() noexcept { 
        if (_Rep) {
            _Rep->_Decwref();
        }
    }

private:
    element_type* _Ptr{nullptr};
    _Ref_count_base* _Rep{nullptr};

    template <class _Ty0>
    friend class _Ptr_base;

    friend shared_ptr<_Ty>;

    template <class _Ty0>
    friend struct atomic;

    friend _Exception_ptr_access;


    template <class _Dx, class _Ty0>
    friend _Dx* get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;
#line 1415 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
};

template <class _Yty, class = void>
struct _Can_scalar_delete : false_type {};
template <class _Yty>
struct _Can_scalar_delete<_Yty, void_t<decltype(delete ::std:: declval<_Yty*>())>> : true_type {};

template <class _Yty, class = void>
struct _Can_array_delete : false_type {};
template <class _Yty>
struct _Can_array_delete<_Yty, void_t<decltype(delete[] ::std:: declval<_Yty*>())>> : true_type {};

template <class _Fx, class _Arg, class = void>
struct _Can_call_function_object : false_type {};
template <class _Fx, class _Arg>
struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(::std:: declval<_Fx>()(::std:: declval<_Arg>()))>> : true_type {};

template <class _Yty, class _Ty>
struct _SP_convertible : is_convertible<_Yty*, _Ty*>::type {};
template <class _Yty, class _Uty>
struct _SP_convertible<_Yty, _Uty[]> : is_convertible<_Yty (*)[], _Uty (*)[]>::type {};
template <class _Yty, class _Uty, size_t _Ext>
struct _SP_convertible<_Yty, _Uty[_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type {};

template <class _Yty, class _Ty>
struct _SP_pointer_compatible : is_convertible<_Yty*, _Ty*>::type {
    
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]> : true_type {
    
};

template <class _Ux>
struct _Temporary_owner {
    _Ux* _Ptr;

    explicit _Temporary_owner(_Ux* const _Ptr_) noexcept : _Ptr(_Ptr_) {}
    _Temporary_owner(const _Temporary_owner&) = delete;
    _Temporary_owner& operator=(const _Temporary_owner&) = delete;
    ~_Temporary_owner() {
        delete _Ptr;
    }
};

template <class _UxptrOrNullptr, class _Dx>
struct _Temporary_owner_del {
    _UxptrOrNullptr _Ptr;
    _Dx& _Dt;
    bool _Call_deleter = true;

    explicit _Temporary_owner_del(const _UxptrOrNullptr _Ptr_, _Dx& _Dt_) noexcept : _Ptr(_Ptr_), _Dt(_Dt_) {}
    _Temporary_owner_del(const _Temporary_owner_del&) = delete;
    _Temporary_owner_del& operator=(const _Temporary_owner_del&) = delete;
    ~_Temporary_owner_del() {
        if (_Call_deleter) {
            _Dt(_Ptr);
        }
    }
};

template <class _Ty>
class shared_ptr : public _Ptr_base<_Ty> { 
private:
    using _Mybase = _Ptr_base<_Ty>;

public:
    using typename _Mybase::element_type;



#line 1500 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    constexpr shared_ptr() noexcept = default;

    constexpr shared_ptr(nullptr_t) noexcept {} 

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    explicit shared_ptr(_Ux* _Px) { 
        if constexpr (is_array_v<_Ty>) {
            _Setpd(_Px, default_delete<_Ux[]>{});
        } else {
            _Temporary_owner<_Ux> _Owner(_Px);
            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, new _Ref_count<_Ux>(_Owner._Ptr));
            _Owner._Ptr = nullptr;
        }
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt) { 
        _Setpd(_Px, ::std:: move(_Dt));
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(_Px, ::std:: move(_Dt), _Ax);
    }

    template <class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt) { 
        _Setpd(nullptr, ::std:: move(_Dt));
    }

    template <class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(nullptr, ::std:: move(_Dt), _Ax);
    }

    template <class _Ty2>
    shared_ptr(const shared_ptr<_Ty2>& _Right, element_type* _Px) noexcept {
        
        this->_Alias_construct_from(_Right, _Px);
    }

    template <class _Ty2>
    shared_ptr(shared_ptr<_Ty2>&& _Right, element_type* _Px) noexcept {
        
        this->_Alias_move_construct_from(::std:: move(_Right), _Px);
    }

    shared_ptr(const shared_ptr& _Other) noexcept { 
        this->_Copy_construct_from(_Other);
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        
        this->_Copy_construct_from(_Other);
    }

    shared_ptr(shared_ptr&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    explicit shared_ptr(const weak_ptr<_Ty2>& _Other) { 
        if (!this->_Construct_from_weak(_Other)) {
            _Throw_bad_weak_ptr();
        }
    }


    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    shared_ptr(auto_ptr<_Ty2>&& _Other) { 
        _Ty2* _Px = _Other.get();
        _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ty2>(_Px));
        _Other.release();
    }
#line 1593 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
                        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
            int> = 0>
    shared_ptr(unique_ptr<_Ux, _Dx>&& _Other) {
        using _Fancy_t   = typename unique_ptr<_Ux, _Dx>::pointer;
        using _Raw_t     = typename unique_ptr<_Ux, _Dx>::element_type*;
        using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std:: ref(_Other.get_deleter())), _Dx>;

        const _Fancy_t _Fancy = _Other.get();

        if (_Fancy) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx    = new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, _Other.get_deleter());
            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
            _Other.release();
        }
    }

    ~shared_ptr() noexcept { 
        this->_Decref();
    }

    shared_ptr& operator=(const shared_ptr& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2>
    shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }


    template <class _Ty2>
    shared_ptr& operator=(auto_ptr<_Ty2>&& _Right) {
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }
#line 1646 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    template <class _Ux, class _Dx>
    shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right) { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    void swap(shared_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    void reset() noexcept { 
        shared_ptr().swap(*this);
    }

    template <class _Ux>
    void reset(_Ux* _Px) { 
        shared_ptr(_Px).swap(*this);
    }

    template <class _Ux, class _Dx>
    void reset(_Ux* _Px, _Dx _Dt) { 
        shared_ptr(_Px, _Dt).swap(*this);
    }

    template <class _Ux, class _Dx, class _Alloc>
    void reset(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        shared_ptr(_Px, _Dt, _Ax).swap(*this);
    }

    using _Mybase::get;

    template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
    [[nodiscard]] _Ty2& operator*() const noexcept {
        return *get();
    }

    template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Ty2* operator->() const noexcept {
        return get();
    }

    template <class _Ty2 = _Ty, class _Elem = element_type, enable_if_t<is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Elem& operator[](ptrdiff_t _Idx) const noexcept  {
        return get()[_Idx];
    }


     [[nodiscard]] bool unique() const noexcept {
        
        return this->use_count() == 1;
    }
#line 1699 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    explicit operator bool() const noexcept {
        return get() != nullptr;
    }

private:
    template <class _UxptrOrNullptr, class _Dx>
    void _Setpd(const _UxptrOrNullptr _Px, _Dx _Dt) { 
        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Set_ptr_rep_and_enable_shared(
            _Owner._Ptr, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Owner._Ptr, ::std:: move(_Dt)));
        _Owner._Call_deleter = false;
    }

    template <class _UxptrOrNullptr, class _Dx, class _Alloc>
    void _Setpda(const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) { 
        using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>>;

        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Alref_alloc _Alref(_Ax);
        _Alloc_construct_ptr<_Alref_alloc> _Constructor(_Alref);
        _Constructor._Allocate();
        _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, ::std:: move(_Dt), _Ax);
        _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _Unfancy(_Constructor._Ptr));
        _Constructor._Ptr    = nullptr;
        _Owner._Call_deleter = false;
    }


































#line 1761 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
    template <class _Ty0, class... _Types>
    friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);

    template <class _Ty0, class _Alloc, class... _Types>
    friend shared_ptr<_Ty0> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);
#line 1767 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { 
        this->_Ptr = _Px;
        this->_Rep = _Rx;
        if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
            if (_Px && _Px->_Wptr.expired()) {
                _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
            }
        }
    }

    void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base* const _Rx) noexcept { 
        this->_Ptr = nullptr;
        this->_Rep = _Rx;
    }
};







#line 1792 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() == _Right.get();
}






#line 1804 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() != _Right.get();
}

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() < _Right.get();
}

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() >= _Right.get();
}

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() > _Right.get();
}

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() <= _Right.get();
}
#line 1829 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty>
[[nodiscard]] bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() == nullptr;
}






#line 1841 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
template <class _Ty>
[[nodiscard]] bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr == _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() != nullptr;
}

template <class _Ty>
[[nodiscard]] bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr != _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() < static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
[[nodiscard]] bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) < _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
[[nodiscard]] bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) >= _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() > static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
[[nodiscard]] bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) > _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
[[nodiscard]] bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) <= _Right.get();
}
#line 1896 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px) {
    
    return _Out << _Px.get();
}

template <class _Ty>
void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}


template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    return {};
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
    }

    return {};
}





#line 1980 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"


template <class _Dx, class _Ty>
[[nodiscard]] _Dx* get_deleter(const shared_ptr<_Ty>& _Sx) noexcept {
    
    if (_Sx._Rep) {
        return static_cast<_Dx*>(_Sx._Rep->_Get_deleter(typeid(_Dx)));
    }

    return nullptr;
}



#line 1995 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"





#line 2001 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty>
class _Ref_count_obj2 : public _Ref_count_base { 
public:
    template <class... _Types>
    explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {





#line 2013 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
        {
            _Construct_in_place(_Storage._Value, ::std:: forward<_Types>(_Args)...);
        }
    }

    virtual ~_Ref_count_obj2() noexcept override { 
        

        
        
        
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    virtual void _Destroy() noexcept override { 
        _Destroy_in_place(_Storage._Value);
    }

    virtual void _Delete_this() noexcept override { 
        delete this;
    }
};






















































































































































































































































































































































#line 2382 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty,
    bool = is_empty_v<_Ty> && !is_final_v<_Ty>>
class _Ebco_base : private _Ty { 
private:
    using _Mybase = _Ty; 

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Ty(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return *this;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return *this;
    }
};

template <class _Ty>
class _Ebco_base<_Ty, false> { 
private:
    _Ty _Myval;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return _Myval;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return _Myval;
    }
};

template <class _Ty, class _Alloc>
class _Ref_count_obj_alloc3 : public _Ebco_base<_Rebind_alloc_t<_Alloc, _Ty>>, public _Ref_count_base {
    
private:
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Rebound = _Rebind_alloc_t<_Alloc, _Ty>;

public:
    template <class... _Types>
    explicit _Ref_count_obj_alloc3(const _Alloc& _Al_arg, _Types&&... _Args)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() {





#line 2440 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
        {
            allocator_traits<_Rebound>::construct(
                this->_Get_val(), ::std:: addressof(_Storage._Value), ::std:: forward<_Types>(_Args)...);
        }
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    virtual ~_Ref_count_obj_alloc3() noexcept override { 
        

        
    }

    virtual void _Destroy() noexcept override { 
        allocator_traits<_Rebound>::destroy(this->_Get_val(), ::std:: addressof(_Storage._Value));
    }

    virtual void _Delete_this() noexcept override { 
        _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc3> _Al(this->_Get_val());
        this->~_Ref_count_obj_alloc3();
        _Deallocate_plain(_Al, this);
    }
};

























































































































































































































































#line 2717 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty, class... _Types>
[[nodiscard]]


#line 2723 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
    shared_ptr<_Ty>
#line 2725 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
    make_shared(_Types&&... _Args) { 
    const auto _Rx = new _Ref_count_obj2<_Ty>(::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(::std:: addressof(_Rx->_Storage._Value), _Rx);
    return _Ret;
}














































































#line 2810 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty, class _Alloc, class... _Types>
[[nodiscard]]


#line 2816 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
    shared_ptr<_Ty>
#line 2818 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
    allocate_shared(const _Alloc& _Al, _Types&&... _Args) { 
    
    
    using _Refoa   = _Ref_count_obj_alloc3<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr<_Alblock> _Constructor{_Rebound};
    _Constructor._Allocate();
    _Construct_in_place(*_Constructor._Ptr, _Al, ::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = reinterpret_cast<_Ty*>(::std:: addressof(_Constructor._Ptr->_Storage._Value));
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    return _Ret;
}




















































































































#line 2949 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty>
class weak_ptr : public _Ptr_base<_Ty> { 
public:
    constexpr weak_ptr() noexcept {}

    weak_ptr(const weak_ptr& _Other) noexcept {
        this->_Weakly_construct_from(_Other); 
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        this->_Weakly_construct_from(_Other); 
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept {
        this->_Weakly_convert_lvalue_avoiding_expired_conversions(_Other);
    }

    weak_ptr(weak_ptr&& _Other) noexcept {
        this->_Move_construct_from(::std:: move(_Other));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept {
        this->_Weakly_convert_rvalue_avoiding_expired_conversions(::std:: move(_Other));
    }

    ~weak_ptr() noexcept {
        this->_Decwref();
    }

    weak_ptr& operator=(const weak_ptr& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    weak_ptr& operator=(weak_ptr&& _Right) noexcept {
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept {
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    void reset() noexcept { 
        weak_ptr{}.swap(*this);
    }

    void swap(weak_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    [[nodiscard]] bool expired() const noexcept {
        return this->use_count() == 0;
    }

    [[nodiscard]] shared_ptr<_Ty> lock() const noexcept { 
        shared_ptr<_Ty> _Ret;
        (void) _Ret._Construct_from_weak(*this);
        return _Ret;
    }
};




#line 3033 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty>
void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

template <class _Ty>
class enable_shared_from_this { 
public:
    using _Esft_type = enable_shared_from_this;

    [[nodiscard]] shared_ptr<_Ty> shared_from_this() {
        return shared_ptr<_Ty>(_Wptr);
    }

    [[nodiscard]] shared_ptr<const _Ty> shared_from_this() const {
        return shared_ptr<const _Ty>(_Wptr);
    }

    [[nodiscard]] weak_ptr<_Ty> weak_from_this() noexcept {
        return _Wptr;
    }

    [[nodiscard]] weak_ptr<const _Ty> weak_from_this() const noexcept {
        return _Wptr;
    }

protected:
    constexpr enable_shared_from_this() noexcept : _Wptr() {}

    enable_shared_from_this(const enable_shared_from_this&) noexcept : _Wptr() {
        
    }

    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { 
        return *this;
    }

    ~enable_shared_from_this() = default;

private:
    template <class _Yty>
    friend class shared_ptr;

    mutable weak_ptr<_Ty> _Wptr;
};


template <class _Ty>
struct default_delete { 
    constexpr default_delete() noexcept = default;

    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    default_delete(const default_delete<_Ty2>&) noexcept {}

    void operator()(_Ty* _Ptr) const noexcept  { 
        static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
        delete _Ptr;
    }
};

template <class _Ty>
struct default_delete<_Ty[]> { 
    constexpr default_delete() noexcept = default;

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    default_delete(const default_delete<_Uty[]>&) noexcept {}

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    void operator()(_Uty* _Ptr) const noexcept  { 
        static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
        delete[] _Ptr;
    }
};

template <class _Ty, class _Dx_noref, class = void>
struct _Get_deleter_pointer_type { 
    using type = _Ty*;
};

template <class _Ty, class _Dx_noref>
struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>> { 
    using type = typename _Dx_noref::pointer;
};

template <class _Dx2>
using _Unique_ptr_enable_default_t =
    enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>, is_default_constructible<_Dx2>>, int>;

template <class _Ty, class _Dx >
class unique_ptr { 
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
    unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Dx2                                                                            = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0>
    unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Ptr) {}

    template <class _Dx2                                                                                      = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Ty2, class _Dx2,
        enable_if_t<
            conjunction_v<negation<is_array<_Ty2>>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
                conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>>,
            int> = 0>
    unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}


    template <class _Ty2,
        enable_if_t<conjunction_v<is_convertible<_Ty2*, _Ty*>, is_same<_Dx, default_delete<_Ty>>>, int> = 0>
    unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Right.release()) {}
#line 3171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

    template <class _Ty2, class _Dx2,
        enable_if_t<conjunction_v<negation<is_array<_Ty2>>, is_assignable<_Dx&, _Dx2>,
                        is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>>,
            int> = 0>
    unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Dx2>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: forward<_Dx>(_Right._Mypair._Get_first());
        }
        return *this;
    }

    void swap(unique_ptr& _Right) noexcept {
        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
    }

    ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    [[nodiscard]] _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] add_lvalue_reference_t<_Ty> operator*() const noexcept  {
        return *_Mypair._Myval2;
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return _Mypair._Myval2;
    }

    [[nodiscard]] pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, nullptr);
    }

    void reset(pointer _Ptr = nullptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};

template <class _Ty, class _Dx>
class unique_ptr<_Ty[], _Dx> { 
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Uty, class _Is_nullptr = is_same<_Uty, nullptr_t>>
    using _Enable_ctor_reset =
        enable_if_t<is_same_v<_Uty, pointer> 
                    || _Is_nullptr::value 
                    || (is_same_v<pointer, element_type*> 
                        && is_pointer_v<_Uty> 
                        && is_convertible_v<remove_pointer_t<_Uty> (*)[], element_type (*)[]>)>; 

    template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, class = _Enable_ctor_reset<_Uty>>
    explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
        class = _Enable_ctor_reset<_Uty>>
    unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0,
        class = _Enable_ctor_reset<_Uty>>
    unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: move(_Right._Mypair._Get_first());
        }

        return *this;
    }

    template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
        class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
    using _Enable_conversion = enable_if_t<
        conjunction_v<is_array<_Uty>, is_same<pointer, element_type*>, is_same<_UP_pointer, _UP_element_type*>,
            is_convertible<_UP_element_type (*)[], element_type (*)[]>, _More>>; 

    template <class _Uty, class _Ex,
        class = _Enable_conversion<_Uty, _Ex,
            conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>>>
    unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Ex>(_Right.get_deleter()), _Right.release()) {}

    template <class _Uty, class _Ex, class = _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>>>
    unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Ex>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    void reset(nullptr_t = nullptr) noexcept {
        reset(pointer());
    }

    void swap(unique_ptr& _Right) noexcept {
        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
    }

    ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    [[nodiscard]] _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] _Ty& operator[](size_t _Idx) const noexcept  {
        return _Mypair._Myval2[_Idx];
    }

    [[nodiscard]] pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, nullptr);
    }

    template <class _Uty, class = _Enable_ctor_reset<_Uty, false_type>>
    void reset(_Uty _Ptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};


template <class _Ty, class... _Types, enable_if_t<!is_array_v<_Ty>, int> = 0>
[[nodiscard]] unique_ptr<_Ty> make_unique(_Types&&... _Args) { 
    return unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...));
}

template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0>
[[nodiscard]] unique_ptr<_Ty> make_unique(const size_t _Size) { 
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]());
}

template <class _Ty, class... _Types, enable_if_t<extent_v<_Ty> != 0, int> = 0>
void make_unique(_Types&&...) = delete;
















#line 3410 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) noexcept {
    _Left.swap(_Right);
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Left.get() == _Right.get();
}


template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Left == _Right);
}
#line 3427 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    using _Ptr1   = typename unique_ptr<_Ty1, _Dx1>::pointer;
    using _Ptr2   = typename unique_ptr<_Ty2, _Dx2>::pointer;
    using _Common = common_type_t<_Ptr1, _Ptr2>;
    return less<_Common>{}(_Left.get(), _Right.get());
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Left < _Right);
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Right < _Left;
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Right < _Left);
}














template <class _Ty, class _Dx>
[[nodiscard]] bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept {
    return !_Left;
}


template <class _Ty, class _Dx>
[[nodiscard]] bool operator==(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) noexcept {
    return !_Right;
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator!=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) noexcept {
    return !(_Left == _Right);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator!=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) noexcept {
    return !(_Left == _Right);
}
#line 3485 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

template <class _Ty, class _Dx>
[[nodiscard]] bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left.get(), _Right);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left, _Right.get());
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return !(_Left < _Right);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Left < _Right);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return _Right < _Left;
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return _Right < _Left;
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return !(_Right < _Left);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Right < _Left);
}












template <class _OutTy, class _PxTy, class = void>
struct _Can_stream_unique_ptr : false_type {};
template <class _OutTy, class _PxTy>
struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<decltype(::std:: declval<_OutTy>() << ::std:: declval<_PxTy>().get())>>
    : true_type {};

template <class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px) {
    
    _Out << _Px.get();
    return _Out;
}

enum class pointer_safety { relaxed, preferred, strict };

inline void declare_reachable(void*) {}

template <class _Ty>
_Ty* undeclare_reachable(_Ty* _Ptr) {
    return _Ptr;
}

inline void declare_no_pointers(char*, size_t) {}

inline void undeclare_no_pointers(char*, size_t) {}

inline pointer_safety get_pointer_safety() noexcept {
    return pointer_safety::relaxed;
}

template <class _Ty = void>
struct owner_less; 

template <class _Ty>
struct owner_less<shared_ptr<_Ty>> {
     typedef shared_ptr<_Ty> first_argument_type;
     typedef shared_ptr<_Ty> second_argument_type;
     typedef bool result_type;

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <class _Ty>
struct owner_less<weak_ptr<_Ty>> {
     typedef weak_ptr<_Ty> first_argument_type;
     typedef weak_ptr<_Ty> second_argument_type;
     typedef bool result_type;

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <>
struct owner_less<void> {
    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    using is_transparent = int;
};

template <class _Ty, class _Dx>
struct hash<unique_ptr<_Ty, _Dx>> : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
                                        is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>> {
    static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval) noexcept(
        _Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) {
        return hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get());
    }
};

template <class _Ty>
struct hash<shared_ptr<_Ty>> {
     typedef shared_ptr<_Ty> argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const shared_ptr<_Ty>& _Keyval) const noexcept {
        return hash<typename shared_ptr<_Ty>::element_type*>()(_Keyval.get());
    }
};

inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept  {
    
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off; 
    }

    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }

    
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}











#line 3683 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

extern "C" {
 void __cdecl _Lock_shared_ptr_spin_lock();
 void __cdecl _Unlock_shared_ptr_spin_lock();
}

struct _Shared_ptr_spin_lock { 
    _Shared_ptr_spin_lock() { 
        _Lock_shared_ptr_spin_lock();
    }

    ~_Shared_ptr_spin_lock() noexcept { 
        _Unlock_shared_ptr_spin_lock();
    }
};

template <class _Ty>
 [[nodiscard]] bool atomic_is_lock_free(const shared_ptr<_Ty>*) {
    
    return false;
}

template <class _Ty>
 [[nodiscard]] shared_ptr<_Ty> atomic_load_explicit(
    const shared_ptr<_Ty>* _Ptr, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    shared_ptr<_Ty> _Result = *_Ptr;
    return _Result;
}

template <class _Ty>
 [[nodiscard]] shared_ptr<_Ty> atomic_load(
    const shared_ptr<_Ty>* _Ptr) { 
    return ::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst);
}

template <class _Ty>
 void atomic_store_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
}

template <class _Ty>
 void atomic_store(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) { 
    ::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

template <class _Ty>
 shared_ptr<_Ty> atomic_exchange_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
    return _Other;
}

template <class _Ty>
 shared_ptr<_Ty> atomic_exchange(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) {
    
    return ::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

template <class _Ty>
 bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    shared_ptr<_Ty> _Old_exp; 
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
    if (_Success) {
        _Ptr->swap(_Value);
    } else { 
        _Exp->swap(_Old_exp);
        *_Exp = *_Ptr;
    }
    return _Success;
}

template <class _Ty>
 bool atomic_compare_exchange_weak(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

template <class _Ty>
 bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

template <class _Ty>
 bool atomic_compare_exchange_strong(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    
    return ::std:: atomic_compare_exchange_strong_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}











































































































































































































































































#line 4055 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: allocate_shared;
    using ::std:: bad_weak_ptr;
    using ::std:: const_pointer_cast;
    using ::std:: dynamic_pointer_cast;
    using ::std:: enable_shared_from_this;
    using ::std:: get_deleter;
    using ::std:: make_shared;
    using ::std:: shared_ptr;
    using ::std:: static_pointer_cast;
    using ::std:: swap;
    using ::std:: weak_ptr;
} 
#line 4071 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"

}


#pragma warning(pop)
#pragma pack(pop)
#line 4078 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
#line 4079 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\memory"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"





#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )









namespace std {
class  _Facet_base { 
public:
    virtual  ~_Facet_base() noexcept {} 

    
    virtual void  _Incref() noexcept = 0;

    
    virtual _Facet_base*  _Decref() noexcept = 0;
};




#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base*);
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"
}


#pragma warning(pop)
#pragma pack(pop)
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xfacet"
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cctype"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {









   int __cdecl _isctype(  int _C,   int _Type);
   int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
    int __cdecl isalpha(  int _C);
   int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
    int __cdecl isupper(  int _C);
   int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
    int __cdecl islower(  int _C);
   int __cdecl _islower_l(  int _C,   _locale_t _Locale);


    int __cdecl isdigit(  int _C);

   int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
   int __cdecl isxdigit(  int _C);
   int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


    int __cdecl isspace(  int _C);

   int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
   int __cdecl ispunct(  int _C);
   int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
   int __cdecl isblank(  int _C);
   int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
    int __cdecl isalnum(  int _C);
   int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
   int __cdecl isprint(  int _C);
   int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
   int __cdecl isgraph(  int _C);
   int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
   int __cdecl iscntrl(  int _C);
   int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


    int __cdecl toupper(  int _C);


    int __cdecl tolower(  int _C);

    int __cdecl _tolower(  int _C);
   int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
    int __cdecl _toupper(  int _C);
   int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

   int __cdecl __isascii(  int _C);
   int __cdecl __toascii(  int _C);
   int __cdecl __iscsymf(  int _C);
   int __cdecl __iscsym(  int _C);








__inline int __cdecl __acrt_locale_get_ctype_array_value(
      unsigned short const * const _Locale_pctype_array,
              int                    const _Char_value,
                             int                    const _Mask
    )
{
    
    
    
    
    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}



    
    
    




















    
    
    




        
    #line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"



    
    

    







        __forceinline int __cdecl __ascii_tolower(int const _C)
        {
            if (_C >= 'A' && _C <= 'Z')
            {
                return _C - ('A' - 'a');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_toupper(int const _C)
        {
            if (_C >= 'a' && _C <= 'z')
            {
                return _C - ('a' - 'A');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_iswalpha(int const _C)
        {
            return (_C >= 'A' && _C <= 'Z') || (_C >= 'a' && _C <= 'z');
        }

        __forceinline int __cdecl __ascii_iswdigit(int const _C)
        {
            return _C >= '0' && _C <= '9';
        }

        __forceinline int __cdecl __ascii_towlower(int const _C)
        {
            return __ascii_tolower(_C);
        }

        __forceinline int __cdecl __ascii_towupper(int const _C)
        {
            return __ascii_toupper(_C);
        }
    #line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"



    












#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    



    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        


        if (_Locale)
        {
            return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask);
        }

        return (__acrt_locale_get_ctype_array_value(__pctype_func(), (_C), (_Mask)));
        #line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale) {
            if (_C >= -1 && _C <= 255)
            {
                return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
            }

            if (__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
            {
                return _isctype_l(_C, _Mask, _Locale);
            }

            return 0; 
        }

        return _chvalidchk_l(_C, _Mask, 0);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    
    
    
    
    

    
    
    
    

#line 293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"



    
    
    
    
#line 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"



#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
} __pragma(pack(pop))

#pragma warning(pop) 
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cctype"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




















namespace std {
using :: isalnum;
using :: isalpha;
using :: iscntrl;
using :: isdigit;
using :: isgraph;
using :: islower;
using :: isprint;
using :: ispunct;
using :: isspace;
using :: isupper;
using :: isxdigit;
using :: tolower;
using :: toupper;

using :: isblank;
}



#pragma warning(pop)
#pragma pack(pop)

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cctype"
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cctype"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\clocale"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {















struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;























     void __cdecl _lock_locales(void);
     void __cdecl _unlock_locales(void);

    
     int __cdecl _configthreadlocale(
          int _Flag
        );

        
     char* __cdecl setlocale(
                int         _Category,
          char const* _Locale
        );

    
     struct lconv* __cdecl localeconv(void);

    
     _locale_t __cdecl _get_current_locale(void);

    
     _locale_t __cdecl _create_locale(
            int         _Category,
          char const* _Locale
        );

     void __cdecl _free_locale(
          _locale_t _Locale
        );

    
        
     wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
     _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



     wchar_t**    __cdecl ___lc_locale_name_func(void);
     unsigned int __cdecl ___lc_codepage_func   (void);
     unsigned int __cdecl ___lc_collate_cp_func (void);




    
     
     
     char*    __cdecl _Getdays(void);

     
     
     char*    __cdecl _Getmonths(void);

     void*    __cdecl _Gettnames(void);

     
     
     wchar_t* __cdecl _W_Getdays(void);

     
     
     wchar_t* __cdecl _W_Getmonths(void);

     void*    __cdecl _W_Gettnames(void);

     
     size_t __cdecl _Strftime(
          char*           _Buffer,
                              size_t           _Max_size,
                            char const*      _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg);

     
     size_t __cdecl _Wcsftime(
          wchar_t*        _Buffer,
                              size_t           _Max_size,
                            wchar_t const*   _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg
        );

#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\clocale"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
using :: lconv;
using :: localeconv;
using :: setlocale;
}



#pragma warning(pop)
#pragma pack(pop)

#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\clocale"
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\clocale"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"



#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




extern "C" {





















struct _Collvec { 
    unsigned int _Page; 
    wchar_t* _LocaleName;
};

struct _Ctypevec { 
    unsigned int _Page; 
    const short* _Table;
    int _Delfl;
    wchar_t* _LocaleName;
};

struct _Cvtvec { 
    unsigned int _Page; 
    unsigned int _Mbcurmax;
    int _Isclocale; 
    unsigned char _Isleadbyte[32]; 
};


 _Collvec __cdecl _Getcoll();
 _Ctypevec __cdecl _Getctype();
 _Cvtvec __cdecl _Getcvt();
 int __cdecl _Getdateorder();







   int __cdecl _Mbrtowc(
     wchar_t*, const char*, size_t _Max_multibyte, mbstate_t*, const _Cvtvec*);
#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"

 float __cdecl _Stof(const char*,     char**, long);
 double __cdecl _Stod(const char*,     char**, long);
 long double __cdecl _Stold(const char*,     char**, long);

 int __cdecl _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*);
 size_t __cdecl _Strxfrm( 
                                                            char* _String1,
      char* _End1, const char*, const char*, const _Collvec*);
 int __cdecl _Tolower(int, const _Ctypevec*);
 int __cdecl _Toupper(int, const _Ctypevec*);
   int __cdecl
    _Wcrtomb(  char*, wchar_t, mbstate_t*, const _Cvtvec*);
 int __cdecl _Wcscoll(
    const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*);
 size_t __cdecl _Wcsxfrm(   
                                                          wchar_t* _String1,
      wchar_t* _End1, const wchar_t*, const wchar_t*, const _Collvec*);

 short __cdecl _Getwctype(wchar_t, const _Ctypevec*);
 const wchar_t* __cdecl _Getwctypes(
    const wchar_t*, const wchar_t*, short*, const _Ctypevec*);
 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec*);
 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec*);

}

extern "C" {
     char* __cdecl _Getdays();

     char* __cdecl _Getmonths();

 void* __cdecl _Gettnames();

   size_t __cdecl _Strftime(
      char*,   size_t _Maxsize,   const char*,   const tm*,   void*);

     wchar_t* __cdecl _W_Getdays();

     wchar_t* __cdecl _W_Getmonths();

 void* __cdecl _W_Gettnames();

   size_t __cdecl _Wcsftime(
      wchar_t*,   size_t _Maxsize,   const wchar_t*,   const tm*,   void*);
}






 _locale_t __cdecl _GetLocaleForCP(unsigned int);
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"



#pragma warning(pop)
#pragma pack(pop)
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"



#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
class  _Timevec { 
public:
    explicit  _Timevec(void* _Ptr = nullptr) : _Timeptr(_Ptr) {}

     _Timevec(const _Timevec& _Right) : _Timeptr(nullptr) {
        *this = _Right;
    }

     ~_Timevec() noexcept {
        :: free(_Timeptr);
    }

    _Timevec&  operator=(const _Timevec& _Right) { 
        if (this != &_Right) {
            :: free(_Timeptr);
            _Timeptr                               = _Right._Timeptr;
            const_cast<_Timevec&>(_Right)._Timeptr = nullptr; 
        }

        return *this;
    }

    void*  _Getptr() const {
        return _Timeptr;
    }

private:
    void* _Timeptr; 
};

template <class _Elem>
class  _Yarn { 
public:
     _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

     _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

     _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

    _Yarn&  operator=(const _Yarn& _Right) noexcept {
        return *this = _Right._Myptr;
    }

    _Yarn&  operator=(const _Elem* _Right) noexcept {
        if (_Myptr != _Right) { 
            _Tidy();

            if (_Right) { 
                const _Elem* _Ptr = _Right;
                while (*_Ptr != _Elem{}) {
                    ++_Ptr;
                }

                const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);




                _Myptr = static_cast<_Elem*>(:: malloc(_Count));
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"

                if (_Myptr) {
                    :: memcpy(_Myptr, _Right, _Count);
                }
            }
        }

        return *this;
    }

     ~_Yarn() noexcept {
        _Tidy();
    }

    [[nodiscard]] bool  empty() const noexcept {
        return _Myptr == nullptr;
    }

      const _Elem*  c_str() const noexcept {
        return _Myptr ? _Myptr : &_Nul;
    }

    [[nodiscard]] bool  _Empty() const noexcept {
        return _Myptr == nullptr;
    }

      const _Elem*  _C_str() const noexcept {
        return _Myptr ? _Myptr : &_Nul;
    }

private:
    void  _Tidy() noexcept {
        if (_Myptr) {



            :: free(_Myptr);
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
        }

        _Myptr = nullptr;
    }

    _Elem* _Myptr; 
    _Elem _Nul; 
};

class  _Locinfo { 
public:
    using _Collvec  = ::_Collvec;
    using _Ctypevec = ::_Ctypevec;
    using _Cvtvec   = ::_Cvtvec;
    using _Timevec  = ::std:: _Timevec;

    static void __cdecl _Locinfo_ctor(_Locinfo*, const char*);
    static void __cdecl _Locinfo_ctor(_Locinfo*, int, const char*);
    static void __cdecl _Locinfo_dtor(_Locinfo*);
    static _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo*, int, const char*);

     _Locinfo(const char* _Pch = "C")

        : _Lock(0)
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"

    {
        if (_Pch) {
            _Locinfo_ctor(this, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

     _Locinfo(int _Cat, const char* _Pch)

        : _Lock(0)
#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"

    {
        if (_Pch) {
            _Locinfo_ctor(this, _Cat, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

     ~_Locinfo() noexcept {
        _Locinfo_dtor(this);
    }

    _Locinfo&  _Addcats(int _Cat, const char* _Pch) { 
        if (_Pch) {
            return _Locinfo_Addcats(this, _Cat, _Pch);
        }

        _Xruntime_error("bad locale name");
    }

    const char*  _Getname() const {
        return _Newlocname._C_str();
    }

    _Collvec  _Getcoll() const {
        return ::_Getcoll();
    }

    _Ctypevec  _Getctype() const {
        return ::_Getctype();
    }

    _Cvtvec  _Getcvt() const {
        return ::_Getcvt();
    }

    const lconv*  _Getlconv() const {
        return localeconv();
    }

    _Timevec  _Gettnames() const {
        return _Timevec(::_Gettnames());
    }

    const char*  _Getdays() const {
        const char* _Ptr = ::_Getdays();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_Days = _Ptr;
            :: free(const_cast<char*>(_Ptr));
        }

        return !_Days._Empty() ? _Days._C_str()
                               : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
                                 ":Thu:Thursday:Fri:Friday:Sat:Saturday";
    }

    const char*  _Getmonths() const {
        const char* _Ptr = ::_Getmonths();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_Months = _Ptr;
            :: free(const_cast<char*>(_Ptr));
        }

        return !_Months._Empty() ? _Months._C_str()
                                 : ":Jan:January:Feb:February:Mar:March"
                                   ":Apr:April:May:May:Jun:June"
                                   ":Jul:July:Aug:August:Sep:September"
                                   ":Oct:October:Nov:November:Dec:December";
    }

    const char*  _Getfalse() const {
        return "false";
    }

    const char*  _Gettrue() const {
        return "true";
    }

    int  _Getdateorder() const {
        return ::_Getdateorder();
    }

    _Timevec  _W_Gettnames() const {
        return _Timevec(::_W_Gettnames());
    }

    const unsigned short*  _W_Getdays() const {
        const wchar_t* _Ptr = ::_W_Getdays();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_W_Days = _Ptr;
            :: free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Days._Empty()) {
            _Ret = L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
        } else {
            _Ret = _W_Days._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    const unsigned short*  _W_Getmonths() const {
        const wchar_t* _Ptr = ::_W_Getmonths();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_W_Months = _Ptr;
            :: free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Months._Empty()) {
            _Ret = L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June"
                   L":Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
        } else {
            _Ret = _W_Months._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    _Locinfo(const _Locinfo&) = delete;
    _Locinfo& operator=(const _Locinfo&) = delete;

private:




    _Lockit _Lock; 
#line 300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"

    _Yarn<char> _Days; 
    _Yarn<char> _Months; 
    _Yarn<wchar_t> _W_Days; 
    _Yarn<wchar_t> _W_Months; 
    _Yarn<char> _Oldlocname; 
    _Yarn<char> _Newlocname; 
};

template <class _Elem>
int __cdecl _LStrcoll(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { 
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2) {
        if (*_First1 < *_First2) {
            return -1; 
        } else if (*_First2 < *_First1) {
            return +1; 
        }
    }

    return _First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0;
}

template <>
inline int __cdecl _LStrcoll(const char* _First1, const char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline int __cdecl _LStrcoll(const wchar_t* _First1, const wchar_t* _Last1, const wchar_t* _First2,
    const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <class _Elem>
size_t __cdecl _LStrxfrm(_Elem* _First1, _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { 
    const ptrdiff_t _Count = _Last2 - _First2;
    if (_Count <= _Last1 - _First1) {
        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
    }

    return _Count;
}

template <>
inline size_t __cdecl _LStrxfrm(    char* _First1,
      char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline size_t __cdecl _LStrxfrm(    wchar_t* _First1,
      wchar_t* _Last1, const wchar_t* _First2, const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 366 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
#line 367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocinfo"
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Dummy>
class _Locbase { 
public:
     static const int collate  = ((1 << (1)) >> 1);
     static const int ctype    = ((1 << (2)) >> 1);
     static const int monetary = ((1 << (3)) >> 1);
     static const int numeric  = ((1 << (4)) >> 1);
     static const int time     = ((1 << (5)) >> 1);
     static const int messages = ((1 << (6)) >> 1);
     static const int all      = (((1 << ((6 + 1))) >> 1) - 1);
     static const int none     = 0;
};

template <class _Dummy>
const int _Locbase<_Dummy>::collate;
template <class _Dummy>
const int _Locbase<_Dummy>::ctype;
template <class _Dummy>
const int _Locbase<_Dummy>::monetary;
template <class _Dummy>
const int _Locbase<_Dummy>::numeric;
template <class _Dummy>
const int _Locbase<_Dummy>::time;
template <class _Dummy>
const int _Locbase<_Dummy>::messages;
template <class _Dummy>
const int _Locbase<_Dummy>::all;
template <class _Dummy>
const int _Locbase<_Dummy>::none;

template <class _Elem>
class collate;

struct  _Crt_new_delete { 




























};

class locale : public _Locbase<int>, public _Crt_new_delete { 
public:
    using category = int;

    class  id { 
    public:
         id(size_t _Val = 0) : _Id(_Val) {}

        id(const id&) = delete;
        id& operator=(const id&) = delete;

         operator size_t() { 
            if (_Id == 0) { 
                { ::std:: _Lockit _Lock(0);
                if (_Id == 0) {
                    _Id = static_cast<size_t>(++_Id_cnt);
                }
                }
            }
            return _Id;
        }

    private:
        size_t _Id; 

         static int _Id_cnt;
    };

    class _Locimp;

    class  facet : public _Facet_base, public _Crt_new_delete {
        
    private:
        friend struct _Facet_guard;

    public:
        static size_t __cdecl _Getcat(const facet** = nullptr, const locale* = nullptr) {
            
            return static_cast<size_t>(-1);
        }

        virtual void  _Incref() noexcept override { 
            _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Myrefs));
        }

        virtual _Facet_base*  _Decref() noexcept override { 
            if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Myrefs)) == 0) {
                return this;
            }

            return nullptr;
        }

    private:
        _Atomic_counter_t _Myrefs; 

    protected:
        explicit  facet(size_t _Initrefs = 0)
            : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) 
        {}

        virtual  ~facet() noexcept override {}

    public:
         facet(const facet&) = delete;
        facet&  operator=(const facet&) = delete;
    };

    struct [[nodiscard]] _Facet_guard {
        facet* _Target;
        ~_Facet_guard() {
            if (_Target) {
                delete _Target->_Decref();
            }
        }
    };

    class  _Locimp : public facet { 
    protected:
         ~_Locimp() noexcept {
            _Locimp_dtor(this);
        }

    private:
        static _Locimp* __cdecl _New_Locimp(bool _Transparent = false);
        static _Locimp* __cdecl _New_Locimp(const _Locimp& _Right);

        static void __cdecl _Locimp_dtor(_Locimp*);
        static void __cdecl _Locimp_Addfac(_Locimp*, facet*, size_t); 
        static void __cdecl _Locimp_ctor(_Locimp*, const _Locimp&);

        friend locale;

         _Locimp(bool _Transparent)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*") {
        }

         _Locimp(const _Locimp& _Right)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
              _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) {
            _Locimp_ctor(this, _Right);
        }

        void  _Addfac(facet* _Pfacet, size_t _Id) { 
            _Locimp_Addfac(this, _Pfacet, _Id);
        }

        static _Locimp* __cdecl _Makeloc(
            const _Locinfo&, category, _Locimp*, const locale*); 

        static void __cdecl _Makewloc(
            const _Locinfo&, category, _Locimp*, const locale*); 


        static void __cdecl _Makeushloc(
            const _Locinfo&, category, _Locimp*, const locale*); 
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

        static void __cdecl _Makexloc(
            const _Locinfo&, category, _Locimp*, const locale*); 

        facet** _Facetvec; 
        size_t _Facetcount; 
        category _Catmask; 
        bool _Xparent; 
        _Yarn<char> _Name; 

         static _Locimp* _Clocptr;

    public:
        _Locimp&  operator=(const _Locimp&) = delete;
    };

    template <class _Elem, class _Traits, class _Alloc>
    bool operator()(
        const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const {
        
        const auto& _Coll_fac = ::std:: use_facet<::std:: collate<_Elem>>(*this);

        const _Elem* const _Left_data  = _Left.data();
        const _Elem* const _Right_data = _Right.data();
        return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
    }

    template <class _Facet>
    locale combine(const locale& _Loc) const { 
        _Facet* _Facptr;

        try {
        _Facptr = const_cast<_Facet*>(::std:: addressof(::std:: use_facet<_Facet>(_Loc)));
        } catch (...) {
        _Xruntime_error("locale::combine facet missing");
        }

        _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
        _Newimp->_Addfac(_Facptr, _Facet::id);
        _Newimp->_Catmask = none;
        _Newimp->_Name    = "*";
        return locale(_Newimp);
    }

    template <class _Facet>
    locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        if (_Facptr) { 
            _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id);
            _Ptr->_Catmask = none;
            _Ptr->_Name    = "*";
        }
    }

    locale(_Uninitialized) {} 

    locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {
        _Ptr->_Incref();
    }

    locale() noexcept : _Ptr(_Init(true)) {}


    locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        if (_Cat != none) { 
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj;
            _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
            _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
            _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
            _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
            _Ptr->_Name    = _Lobj._Getname();
            }
            _Guard._Target = nullptr;
        }
    }

private:
    void _Construct(const string& _Str, category _Cat) {
        
        bool _Bad = false;
        _Init();
        if (_Cat != none) { 
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj(_Cat, _Str.c_str());
            if (_Badname(_Lobj)) {
                _Bad = true;
            } else { 
                _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
                _Ptr->_Catmask = _Cat;
                _Ptr->_Name    = _Str.c_str();
            }
            }
            _Guard._Target = nullptr;
        }

        if (_Bad) { 
            delete _Ptr->_Decref();
            _Xruntime_error("bad locale name");
        }
    }

public:
    explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        
        
        
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        
        
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        
        _Construct(_Str, _Cat);
    }

    locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        _Construct(_Str, _Cat);
    }
#line 344 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

    ~locale() noexcept {
        if (_Ptr) {
            delete _Ptr->_Decref();
        }
    }

    const locale& operator=(const locale& _Right) noexcept {
        if (_Ptr != _Right._Ptr) { 
            delete _Ptr->_Decref();
            _Ptr = _Right._Ptr;
            _Ptr->_Incref();
        }
        return *this;
    }

    string name() const {
        return _Ptr ? _Ptr->_Name.c_str() : string();
    }

      const char* c_str() const {
        return _Ptr ? _Ptr->_Name.c_str() : "";
    }

    const facet* _Getfacet(size_t _Id) const { 
        const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; 
        if (_Facptr || !_Ptr->_Xparent) {
            return _Facptr; 
        }

        
        locale::_Locimp* _Ptr0 = _Getgloballocale();
        if (_Id < _Ptr0->_Facetcount) {
            return _Ptr0->_Facetvec[_Id]; 
        }

        return nullptr; 
    }

    [[nodiscard]] bool operator==(const locale& _Loc) const { 
        return _Ptr == _Loc._Ptr || (name().compare("*") != 0 && name().compare(_Loc.name()) == 0);
    }


    [[nodiscard]] bool operator!=(const locale& _Right) const {
        return !(*this == _Right);
    }
#line 392 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

    static  const locale& __cdecl classic(); 

    static  locale __cdecl global(const locale&); 

    static  locale __cdecl empty(); 

private:
    locale(_Locimp* _Ptrimp) : _Ptr(_Ptrimp) {}

    static  _Locimp* __cdecl _Init(bool _Do_incref = false); 
    static  _Locimp* __cdecl _Getgloballocale();
    static  void __cdecl _Setgloballocale(void*);

    bool _Badname(const _Locinfo& _Lobj) { 
        return :: strcmp(_Lobj._Getname(), "*") == 0;
    }

    _Locimp* _Ptr; 
};

template <class _Facet>
struct _Facetptr { 
     static const locale::facet* _Psave;
};

template <class _Facet>
 const locale::facet* _Facetptr<_Facet>::_Psave = nullptr;

template <class _Facet>
const _Facet& __cdecl use_facet(const locale& _Loc) { 
    { ::std:: _Lockit _Lock(0); 
    const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; 

    const size_t _Id         = _Facet::id;
    const locale::facet* _Pf = _Loc._Getfacet(_Id);

    if (!_Pf) {
        if (_Psave) {
            _Pf = _Psave; 
        } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

            _Throw_bad_cast(); 


#line 438 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
        } else { 
            auto _Pfmod = const_cast<locale::facet*>(_Psave);
            unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));



#line 445 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
            _Facet_Register(_Pfmod);
#line 447 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

            _Pfmod->_Incref();
            _Facetptr<_Facet>::_Psave = _Psave;
            _Pf                       = _Psave;

            (void) _Psave_guard.release();
        }
    }

    return static_cast<const _Facet&>(*_Pf); 
    }
} 

template <class _Elem>
char __cdecl _Maklocbyte(_Elem _Char, const _Locinfo::_Cvtvec&) {
    
    return static_cast<char>(static_cast<unsigned char>(_Char));
}

template <>
inline char __cdecl _Maklocbyte(wchar_t _Char, const _Locinfo::_Cvtvec& _Cvt) {
    
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
    return _Byte;
}


template <>
inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec& _Cvt) {
    
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, static_cast<wchar_t>(_Char), &_Mbst1, &_Cvt);
    return _Byte;
}
#line 485 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

template <class _Elem>
_Elem __cdecl _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {
    
    return static_cast<_Elem>(static_cast<unsigned char>(_Byte));
}

template <>
inline wchar_t __cdecl _Maklocchr(char _Byte, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    
    wchar_t _Wc      = L'\0';
    mbstate_t _Mbst1 = {};
    _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}


template <>
inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    
    unsigned short _Wc = 0;
    mbstate_t _Mbst1   = {};
    _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}
#line 511 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

template <class _Elem>
_Elem* __cdecl _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {
    
    size_t _Count = :: strlen(_Ptr) + 1;

    _Elem* _Ptrdest = static_cast<_Elem*>(calloc(_Count, sizeof(_Elem)));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {
        *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));
    }

    return _Ptrdest;
}

template <>
inline wchar_t* __cdecl _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    wchar_t _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; 

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Wchars, sizeof(wchar_t)));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};

    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';

    return _Ptrdest;
}


template <>
inline unsigned short* __cdecl _Maklocstr(const char* _Ptr, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    unsigned short _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; 

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Wchars, sizeof(wchar_t)));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};
    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';
    return reinterpret_cast<unsigned short*>(_Ptrdest);
}
#line 609 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

class  codecvt_base : public locale::facet { 
public:
    enum { 
        ok,
        partial,
        error,
        noconv
    };
    using result = int;

     codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) {}

    bool  always_noconv() const noexcept {
        
        return do_always_noconv();
    }

    int  max_length() const noexcept {
        
        return do_max_length();
    }

    int  encoding() const noexcept {
        return do_encoding();
    }

     ~codecvt_base() noexcept {}

protected:
    virtual bool  do_always_noconv() const noexcept {
        
        return false;
    }

    virtual int  do_max_length() const noexcept {
        
        return 1;
    }

    virtual int  do_encoding() const noexcept {
        return 1; 
    }
};

template <class _Elem, class _Byte, class _Statype>
class codecvt : public codecvt_base { 
public:
    
    
    
    
    
    
    

    static_assert(!0 || is_same_v<codecvt, codecvt<char, char, mbstate_t>>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;

    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id; 

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Locinfo());
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo&) {} 

    virtual bool  do_always_noconv() const noexcept override {
        
        return is_same_v<_Byte, _Elem>;
    }

    virtual result  do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr (is_same_v<_Byte, _Elem>) {
            return noconv; 
        } else {
            
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Elem>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result  do_out(_Statype&, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr (is_same_v<_Byte, _Elem>) {
            return noconv; 
        } else {
            
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Byte>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result  do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const {
        
        _Mid2 = _First2;
        return noconv; 
    }

    virtual int  do_length(
        _Statype&, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        
        
        
        const auto _Dist = static_cast<size_t>((::std:: min)(_Last1 - _First1, ptrdiff_t{2147483647}));
        return static_cast<int>((::std:: min)(_Count, _Dist));
    }
};






template <class _Elem, class _Byte, class _Statype>
 locale::id codecvt<_Elem, _Byte, _Statype>::id;





template <class _CvtTy, class _Byte, class _Statype>
[[nodiscard]] int _Codecvt_do_length(
    const _CvtTy& _Cvt, _Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) {
    
    

    __pragma(warning(push)) __pragma(warning(disable : 4996))
    using _Elem = typename _CvtTy::intern_type;
    __pragma(warning(pop))

    _Adl_verify_range(_First1, _Last1);
    const auto _Old_first1 = _First1;

    while (_Count > 0 && _First1 != _Last1) { 
        const _Byte* _Mid1;
        _Elem* _Mid2;
        _Elem _Ch;

        

        __pragma(warning(push)) __pragma(warning(disable : 4996))
        const auto _Result = _Cvt._CvtTy::do_in(_State, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
        __pragma(warning(pop))

        if (_Result != codecvt_base::ok) {
            if (_Result == codecvt_base::noconv) {
                _First1 += (::std:: min)(static_cast<size_t>(_Last1 - _First1), _Count);
            }

            break; 
        }

        if (_Mid2 == &_Ch + 1) {
            --_Count; 
        }

        _First1 = _Mid1;
    }

    return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647}));
}

enum _Codecvt_mode { _Consume_header = 4, _Generate_header = 2 };

template <>
class  
    codecvt<char16_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char16_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) {
        _Init(_Lobj);
    }

     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            __pragma(warning(push)) __pragma(warning(disable : 4996))
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
            __pragma(warning(pop))
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo&) {} 

    virtual result  do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1                   = _First1;
        _Mid2                   = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;
            int _Nskip;

            if (*_Pstate > 1) {
                if (_By < 0x80 || 0xc0 <= _By) {
                    return codecvt::error; 
                }

                
                ++_Mid1;
                *_Mid2++ = static_cast<char16_t>(*_Pstate | (_By & 0x3f));
                *_Pstate = 1;
                continue;
            }

            if (_By < 0x80u) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0u) { 
                ++_Mid1;
                return codecvt::error;
            } else if (_By < 0xe0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8u) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }

            _Nskip  = _Nextra < 3 ? 0 : 1; 
            _First1 = _Mid1; 

            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip) {
                break; 
            } else {
                for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
                        return codecvt::error; 
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }

            if (0 < _Nskip) {
                _Ch <<= 6; 
            }

            if ((_Maxcode < 0x10ffffu ? _Maxcode : 0x10ffffu) < _Ch) {
                return codecvt::error; 
            }

            if (0xffffu < _Ch) { 
                unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | (_Ch >> 10) - 0x0040);

                *_Mid2++ = static_cast<char16_t>(_Ch0);
                *_Pstate = static_cast<unsigned short>(0xdc00 | (_Ch & 0x03ff));
                continue;
            }

            if (_Nskip != 0) {
                if (_Mid1 == _Last1) { 
                    _Mid1 = _First1;
                    break;
                }

                if ((_By = static_cast<unsigned char>(*_Mid1++)) < 0x80u || 0xc0u <= _By) {
                    return codecvt::error; 
                }

                _Ch |= _By & 0x3f; 
            }

            if (*_Pstate == 0u) { 
                *_Pstate = 1;

                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { 
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                    if (_Ans == codecvt::partial) { 
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }

                    return _Ans;
                }
            }

            *_Mid2++ = static_cast<char16_t>(_Ch);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1                   = _First1;
        _Mid2                   = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned long _Ch;
            const unsigned short _Ch1 = static_cast<unsigned short>(*_Mid1);
            bool _Save                = false;

            if (1 < *_Pstate) { 
                if (_Ch1 < 0xdc00u || 0xe000u <= _Ch1) {
                    return codecvt::error; 
                }

                _Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
            } else if (0xd800u <= _Ch1 && _Ch1 < 0xdc00u) { 
                _Ch   = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
                _Save = true; 
            } else {
                _Ch = _Ch1; 
            }

            char _By;
            int _Nextra;

            if (_Ch < 0x0080u) {
                _By     = static_cast<char>(_Ch);
                _Nextra = 0;
            } else if (_Ch < 0x0800u) {
                _By     = static_cast<char>(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x10000u) {
                _By     = static_cast<char>(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else {
                _By     = static_cast<char>(0xf0 | _Ch >> 18);
                _Nextra = 3;
            }

            int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

            if (_Last2 - _Mid2 < _Nput) {
                break; 
            }

            if (*_Pstate == 0u && (_Mode & _Generate_header) != 0) {
                if (_Last2 - _Mid2 < 3 + _Nput) {
                    break; 
                }

                
                *_Mid2++ = '\xef';
                *_Mid2++ = '\xbb';
                *_Mid2++ = '\xbf';
            }

            ++_Mid1;
            if (_Save || _Nextra < 3) { 
                *_Mid2++ = _By;
                --_Nput;
            }

            for (; 0 < _Nput; --_Nput) {
                *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }

            *_Pstate = static_cast<unsigned short>(_Save ? _Ch >> 10 : 1);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char*, char*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid2                   = _First2;

        return 1u < *_Pstate ? codecvt::error : codecvt::ok; 
    }

    friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
    }

    virtual bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    virtual int  do_max_length() const noexcept override {
        

        if ((_Mode & _Consume_header) != 0) {
            return 9; 
        }

        if ((_Mode & _Generate_header) != 0) {
            return 7; 
        }

        return 6; 
    }

    virtual int do_encoding() const noexcept override {
        return 0; 
    }

private:
    unsigned long _Maxcode; 
    _Codecvt_mode _Mode; 
};

template <>
class  
    codecvt<char32_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char32_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) {
        _Init(_Lobj);
    }

     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            __pragma(warning(push)) __pragma(warning(disable : 4996))
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
            __pragma(warning(pop))
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo&) {} 

    virtual result  do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1         = _First1;
        _Mid2         = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;

            if (_By < 0x80u) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0u) { 
                ++_Mid1;
                return codecvt::error;
            } else if (_By < 0xe0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8u) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }

            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1) {
                break; 
            } else {
                for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
                        return codecvt::error; 
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }

            if (*_Pstate == 0) { 
                *_Pstate = 1;

                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { 
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                    if (_Ans == codecvt::partial) { 
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }
                    return _Ans;
                }
            }

            if (_Maxcode < _Ch) {
                return codecvt::error; 
            }

            *_Mid2++ = static_cast<char32_t>(_Ch);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1         = _First1;
        _Mid2         = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            char _By;
            int _Nextra;
            unsigned long _Ch = static_cast<unsigned long>(*_Mid1);

            if (_Maxcode < _Ch) {
                return codecvt::error;
            }

            if (_Ch < 0x0080u) {
                _By     = static_cast<char>(_Ch);
                _Nextra = 0;
            } else if (_Ch < 0x0800u) {
                _By     = static_cast<char>(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x00010000u) {
                _By     = static_cast<char>(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else if (_Ch < 0x00200000u) {
                _By     = static_cast<char>(0xf0 | _Ch >> 18);
                _Nextra = 3;
            } else if (_Ch < 0x04000000u) {
                _By     = static_cast<char>(0xf8 | _Ch >> 24);
                _Nextra = 4;
            } else {
                _By     = static_cast<char>(0xfc | (_Ch >> 30 & 0x03));
                _Nextra = 5;
            }

            if (*_Pstate == 0) { 
                *_Pstate = 1;
                if ((_Mode & _Generate_header) != 0) {
                    if (_Last2 - _Mid2 < 3 + 1 + _Nextra) {
                        return codecvt::partial; 
                    }

                    
                    *_Mid2++ = '\xef';
                    *_Mid2++ = '\xbb';
                    *_Mid2++ = '\xbf';
                }
            }

            if (_Last2 - _Mid2 < 1 + _Nextra) {
                break; 
            }

            ++_Mid1;
            for (*_Mid2++ = _By; 0 < _Nextra;) {
                *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }
        }
        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_unshift(mbstate_t&, char* _First2, char*, char*& _Mid2) const {
        
        _Mid2 = _First2;
        return codecvt::noconv;
    }

    friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
    }

    virtual bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    virtual int  do_max_length() const noexcept override {
        
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? 9 : 6;
    }

    virtual int  do_encoding() const noexcept override {
        
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? -1
                                                                   : 0; 
    }

private:
    unsigned long _Maxcode; 
    _Codecvt_mode _Mode; 
};































































































































































































































































































































































































































































































































































#line 1907 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

template <>
class  codecvt<wchar_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = wchar_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();
    }

    virtual result  do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: 
                return partial;

            case -1: 
                return error;

            case 0: 
                _Bytes = 1;
                

            default: 
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result  do_out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { 
                char _Buf[5];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else if (_Last2 - _Mid2 < _Bytes) { 
                    _State = _Stsave;
                    break;
                } else { 
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[5];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; 
        } else if (_Last2 - _Mid2 < --_Bytes) { 
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { 
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }
        return _Ans;
    }

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { 
                break;
            }

            if (_Bytes == 0) { 
                _Bytes = 1;
            }

            
            _First1 += _Bytes;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647}));
    }

    virtual bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    virtual int  do_max_length() const noexcept override {
        
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    virtual int  do_encoding() const noexcept override {
        
        return _Cvt._Mbcurmax == 1; 
    }

private:
    _Locinfo::_Cvtvec _Cvt; 
};


template <>
class  codecvt<unsigned short, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = unsigned short;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const unsigned short* _First1, const unsigned short* _Last1,
        const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();
    }

    virtual result  do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(
                reinterpret_cast<wchar_t*>(_Mid2), _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: 
                return partial;

            case -1: 
                return error;

            case 0: 
                _Bytes = 1;
                

            default: 
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result  do_out(mbstate_t& _State, const unsigned short* _First1,
        const unsigned short* _Last1, const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { 
                char _Buf[5];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else if (_Last2 - _Mid2 < _Bytes) { 
                    _State = _Stsave;
                    break;
                } else { 
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[5];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; 
        } else if (_Last2 - _Mid2 < --_Bytes) { 
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { 
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }

        return _Ans;
    }

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { 
                break;
            }

            if (_Bytes == 0) { 
                _Bytes = 1;
            }

            
            _First1 += _Bytes;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647}));
    }

    virtual bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    virtual int  do_max_length() const noexcept override {
        
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    virtual int  do_encoding() const noexcept override {
        
        return _Cvt._Mbcurmax == 1u; 
    }

private:
    _Locinfo::_Cvtvec _Cvt; 
};
#line 2307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

template <class _Elem, class _Byte, class _Statype>
class codecvt_byname : public codecvt<_Elem, _Byte, _Statype> { 
public:
    static_assert(!0
                      || _Is_any_of_v<codecvt_byname,



                          codecvt_byname<char, char, mbstate_t>, codecvt_byname<wchar_t, char, mbstate_t>>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    explicit  codecvt_byname(const char* _Locname, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs) {} 

    explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs) {} 

protected:
    virtual  ~codecvt_byname() noexcept {}
};











struct  ctype_base : locale::facet { 
    enum { 
        alnum  = 0x04 | 0x02 | 0x01 | 0x100,
        alpha  = 0x02 | 0x01 | 0x100,
        cntrl  = 0x20,
        digit  = 0x04,
        graph  = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
        lower  = 0x02,
        print  = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
        punct  = 0x10,
        space  = 0x08 | 0x40,
        upper  = 0x01,
        xdigit = 0x80,
        blank  = 0x08 | 0x40
    };
    using mask = short; 

     ctype_base(size_t _Refs = 0) : locale::facet(_Refs) {}

     ~ctype_base() noexcept {}
};











template <class _Elem>
class ctype : public ctype_base { 
public:
    
    static_assert(!0 || _Always_false<_Elem>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~ctype() noexcept {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (_Ctype._Table[static_cast<unsigned char>(narrow(_Ch))] & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(narrow(*_First))];
        }

        return _First;
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Tolower(_Byte, &_Ctype)));
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { 
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Tolower(_Byte, &_Ctype))));
            }
        }
        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Toupper(_Byte, &_Ctype)));
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { 
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Toupper(_Byte, &_Ctype))));
            }
        }

        return _First;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Maklocchr(_Byte, static_cast<_Elem*>(nullptr), _Cvt);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Maklocchr(*_First, static_cast<_Elem*>(nullptr), _Cvt);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Byte;
        if (_Ch == _Elem{}) {
            return '\0';
        }

        if ((_Byte = _Maklocbyte(_Ch, _Cvt)) == '\0') {
            return _Dflt;
        }

        return _Byte;
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};






template <class _Elem>
locale::id ctype<_Elem>::id;





template <>
class  ctype<char> : public ctype_base { 
public:
    using _Elem     = char;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(*_First)];
        }

        return _First;
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const _Elem*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    _Elem  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(const mask* _Table = nullptr, bool _Deletetable = false,
        size_t _Refs = 0)
        : ctype_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }

        _Tidy(); 
        if (_Table) { 
            _Ctype._Table = _Table;
            _Ctype._Delfl = _Deletetable ? -1 : 0;
        } else { 
            _Ctype._Table = classic_table();
            _Ctype._Delfl = 0;
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

    const mask*  table() const noexcept {
        return _Ctype._Table;
    }

    static const mask* __cdecl classic_table() noexcept {
        return ::std:: use_facet<ctype>(locale::classic()).table();
    }

     static const size_t table_size = 1 << 8; 

protected:
    virtual  ~ctype() noexcept {
        _Tidy();
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
    }

    void  _Tidy() noexcept { 
        if (0 < _Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        } else if (_Ctype._Delfl < 0) {
            delete[] _Ctype._Table;
        }

        :: free(_Ctype._LocaleName);
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Byte;
    }

    virtual const _Elem*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

    virtual _Elem  do_narrow(_Elem _Ch, char) const { 
        return _Ch;
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
};

template <>
class  ctype<wchar_t>
    : public ctype_base { 
public:
    using _Elem     = wchar_t;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~ctype() noexcept {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        return :: _Getwctypes(_First, _Last, _Dest, &_Ctype);
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem  _Dowiden(char _Byte) const { 
        mbstate_t _Mbst = {};
        wchar_t _Wc;
        return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(((wint_t)(0xFFFF))) : _Wc;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Dowiden(_Byte);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Buf[5];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};


template <>
class  ctype<unsigned short>
    : public ctype_base { 
public:
    using _Elem     = unsigned short;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~ctype() noexcept {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        return reinterpret_cast<const _Elem*>(:: _Getwctypes(
            reinterpret_cast<const wchar_t*>(_First), reinterpret_cast<const wchar_t*>(_Last), _Dest, &_Ctype));
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem  _Dowiden(char _Byte) const { 
        mbstate_t _Mbst = {};
        unsigned short _Wc;

        if (_Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst, &_Cvt) < 0) {
            return static_cast<unsigned short>(((wint_t)(0xFFFF)));
        }

        return _Wc;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Dowiden(_Byte);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Buf[5];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};
#line 3201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"

template <class _Elem>
class ctype_byname : public ctype<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    explicit  ctype_byname(const char* _Locname, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Locname), _Refs) {} 

    explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs) {} 

protected:
    virtual  ~ctype_byname() noexcept {}
};

enum class _Case_sensitive : bool { _Nope, _Yes };

template <class _InIt, class _Elem>
int __cdecl _Getloctxt(
    _InIt& _First, _InIt& _Last, size_t _Numfields, const _Elem* _Ptr, const _Case_sensitive _Matching) {
    
    for (size_t _Off = 0; _Ptr[_Off] != _Elem{}; ++_Off) {
        if (_Ptr[_Off] == _Ptr[0]) {
            ++_Numfields; 
        }
    }

    string _Str(_Numfields, '\0'); 
    const ctype<_Elem>& _CType = ::std:: use_facet<ctype<_Elem>>(locale{});

    int _Ans = -2; 
    for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { 
        bool _Prefix  = false; 
        size_t _Off   = 0; 
        size_t _Field = 0; 

        for (; _Field < _Numfields; ++_Field) { 
            while (_Ptr[_Off] != _Elem{} && _Ptr[_Off] != _Ptr[0]) { 
                ++_Off;
            }

            if (_Str[_Field] != '\0') {
                _Off += _Str[_Field]; 
            } else if (_Ptr[_Off += _Column] == _Ptr[0]
                       || _Ptr[_Off] == _Elem{}) { 
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); 
                _Ans         = static_cast<int>(_Field); 
            } else if (_First == _Last
                       || (_Matching == _Case_sensitive::_Yes
                               ? _Ptr[_Off] != *_First
                               : _CType.tolower(_Ptr[_Off]) != _CType.tolower(static_cast<_Elem>(*_First)))) {
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); 
            } else {
                _Prefix = true; 
            }
        }

        if (!_Prefix || _First == _Last) {
            break; 
        }
    }
    return _Ans; 
}





#line 3271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
}


#pragma warning(pop)
#pragma pack(pop)
#line 3277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
#line 3278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocale"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Dummy>
class _Iosb { 
public:
    enum _Dummy_enum { _Dummy_enum_val = 1 }; 
    enum _Fmtflags { 
        _Fmtmask = 0xffff,
        _Fmtzero = 0
    };

    static constexpr _Fmtflags skipws     = static_cast<_Fmtflags>(0x0001);
    static constexpr _Fmtflags unitbuf    = static_cast<_Fmtflags>(0x0002);
    static constexpr _Fmtflags uppercase  = static_cast<_Fmtflags>(0x0004);
    static constexpr _Fmtflags showbase   = static_cast<_Fmtflags>(0x0008);
    static constexpr _Fmtflags showpoint  = static_cast<_Fmtflags>(0x0010);
    static constexpr _Fmtflags showpos    = static_cast<_Fmtflags>(0x0020);
    static constexpr _Fmtflags left       = static_cast<_Fmtflags>(0x0040);
    static constexpr _Fmtflags right      = static_cast<_Fmtflags>(0x0080);
    static constexpr _Fmtflags internal   = static_cast<_Fmtflags>(0x0100);
    static constexpr _Fmtflags dec        = static_cast<_Fmtflags>(0x0200);
    static constexpr _Fmtflags oct        = static_cast<_Fmtflags>(0x0400);
    static constexpr _Fmtflags hex        = static_cast<_Fmtflags>(0x0800);
    static constexpr _Fmtflags scientific = static_cast<_Fmtflags>(0x1000);
    static constexpr _Fmtflags fixed      = static_cast<_Fmtflags>(0x2000);

    static constexpr _Fmtflags hexfloat = static_cast<_Fmtflags>(0x3000); 

    static constexpr _Fmtflags boolalpha   = static_cast<_Fmtflags>(0x4000);
    static constexpr _Fmtflags _Stdio      = static_cast<_Fmtflags>(0x8000);
    static constexpr _Fmtflags adjustfield = static_cast<_Fmtflags>(0x01C0); 
    static constexpr _Fmtflags basefield   = static_cast<_Fmtflags>(0x0E00); 
    static constexpr _Fmtflags floatfield  = static_cast<_Fmtflags>(0x3000); 

    enum _Iostate { 
        _Statmask = 0x17
    };

    static constexpr _Iostate goodbit = static_cast<_Iostate>(0x0);
    static constexpr _Iostate eofbit  = static_cast<_Iostate>(0x1);
    static constexpr _Iostate failbit = static_cast<_Iostate>(0x2);
    static constexpr _Iostate badbit  = static_cast<_Iostate>(0x4);

    enum _Openmode { 
        _Openmask = 0xff
    };

    static constexpr _Openmode in         = static_cast<_Openmode>(0x01);
    static constexpr _Openmode out        = static_cast<_Openmode>(0x02);
    static constexpr _Openmode ate        = static_cast<_Openmode>(0x04);
    static constexpr _Openmode app        = static_cast<_Openmode>(0x08);
    static constexpr _Openmode trunc      = static_cast<_Openmode>(0x10);
    static constexpr _Openmode _Nocreate  = static_cast<_Openmode>(0x40);
    static constexpr _Openmode _Noreplace = static_cast<_Openmode>(0x80);
    static constexpr _Openmode binary     = static_cast<_Openmode>(0x20);

    enum _Seekdir { 
        _Seekbeg,
        _Seekcur,
        _Seekend
    };

    static constexpr _Seekdir beg = _Seekbeg;
    static constexpr _Seekdir cur = _Seekcur;
    static constexpr _Seekdir end = _Seekend;

    enum { 
        _Openprot = 0x40
    };

    static constexpr int _Default_open_prot = 0x40; 
};

template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hexfloat; 

template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

class  ios_base : public _Iosb<int> { 
public:
    using fmtflags = int;
    using iostate  = int;
    using openmode = int;
    using seekdir  = int;


    using streamoff = ::std:: streamoff;
    using streampos = ::std:: streampos;
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"

    enum event { 
        erase_event,
        imbue_event,
        copyfmt_event
    };

    using event_callback = void(__cdecl*)(event, ios_base&, int);


    using io_state  = unsigned int;
    using open_mode = unsigned int;
    using seek_dir  = unsigned int;
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"

    class failure : public system_error { 
    public:
        explicit failure(const string& _Message, const error_code& _Errcode = make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) {} 

        explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) {} 






#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
    };

    class  Init { 
    public:
         Init() { 
            _Init_ctor(this);
        }

         ~Init() noexcept { 
            _Init_dtor(this);
        }

    private:
        static void __cdecl _Init_ctor(Init*);
        static void __cdecl _Init_dtor(Init*);

         static int _Init_cnt; 

        static int& __cdecl _Init_cnt_func();
    };

    explicit  operator bool() const {
        return !fail();
    }

    [[nodiscard]] bool  operator!() const {
        return fail();
    }

    void  clear(iostate _State, bool _Reraise) { 
        _State &= _Statmask;
        _Mystate             = _State;
        const auto _Filtered = _State & _Except;
        if (_Filtered) {
            if (_Reraise) {
                throw;
            }

            const char* _Msg;
            if (_Filtered & ios_base::badbit) {
                _Msg = "ios_base::badbit set";
            } else if (_Filtered & ios_base::failbit) {
                _Msg = "ios_base::failbit set";
            } else {
                _Msg = "ios_base::eofbit set";
            }

            throw failure(_Msg);
        }
    }

    void  clear(iostate _State = goodbit) { 
        clear(_State, false);
    }


    void  clear(io_state _State) { 
        clear(static_cast<iostate>(_State));
    }
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"

    [[nodiscard]] iostate  rdstate() const {
        return _Mystate;
    }

    void  setstate(
        iostate _State, bool _Exreraise) { 
        clear(rdstate() | _State, _Exreraise);
    }

    void  setstate(iostate _State) { 
        clear(rdstate() | _State, false);
    }


    void  setstate(io_state _State) { 
        setstate(static_cast<iostate>(_State));
    }
#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"

    [[nodiscard]] bool  good() const {
        return rdstate() == ios_base::goodbit;
    }

    [[nodiscard]] bool  eof() const {
        return rdstate() & ios_base::eofbit;
    }

    [[nodiscard]] bool  fail() const {
        return rdstate() & (ios_base::badbit | ios_base::failbit);
    }

    [[nodiscard]] bool  bad() const {
        return rdstate() & ios_base::badbit;
    }

    [[nodiscard]] iostate  exceptions() const {
        return _Except;
    }

    void  exceptions(iostate _Newexcept) { 
        _Except = _Newexcept & _Statmask;
        clear(rdstate());
    }


    void  exceptions(io_state _State) { 
        exceptions(static_cast<iostate>(_State));
    }
#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"

    [[nodiscard]] fmtflags  flags() const {
        return _Fmtfl;
    }

    fmtflags  flags(fmtflags _Newfmtflags) { 
        const fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                      = _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags  setf(fmtflags _Newfmtflags) { 
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl |= _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags  setf(
        fmtflags _Newfmtflags, fmtflags _Mask) { 
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                                = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);
        return _Oldfmtflags;
    }

    void  unsetf(fmtflags _Mask) { 
        _Fmtfl &= ~_Mask;
    }

    [[nodiscard]] streamsize  precision() const {
        return _Prec;
    }

    streamsize  precision(streamsize _Newprecision) { 
        const streamsize _Oldprecision = _Prec;
        _Prec                          = _Newprecision;
        return _Oldprecision;
    }

    [[nodiscard]] streamsize  width() const {
        return _Wide;
    }

    streamsize  width(streamsize _Newwidth) { 
        const streamsize _Oldwidth = _Wide;
        _Wide                      = _Newwidth;
        return _Oldwidth;
    }

    [[nodiscard]] locale  getloc() const { 
        return *_Ploc;
    }

    locale  imbue(const locale& _Loc) { 
        locale _Oldlocale = *_Ploc;
        *_Ploc            = _Loc;
        _Callfns(imbue_event);
        return _Oldlocale;
    }

    [[nodiscard]] static int __cdecl xalloc() { 
        { ::std:: _Lockit _Lock(2); 
        return _Index++;
        }
    }

    [[nodiscard]] long&  iword(int _Idx) {
        return _Findarr(_Idx)._Lo;
    }

    [[nodiscard]] void*&  pword(int _Idx) {
        return _Findarr(_Idx)._Vp;
    }

    void  register_callback(event_callback _Pfn,
        int _Idx) { 
        _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
    }

    ios_base&  copyfmt(const ios_base& _Other) { 
        if (this != ::std:: addressof(_Other)) { 
            _Tidy();
            *_Ploc          = *_Other._Ploc;
            _Fmtfl          = _Other._Fmtfl;
            _Prec           = _Other._Prec;
            _Wide           = _Other._Wide;
            _Iosarray* _Ptr = _Other._Arr;

            for (_Arr = nullptr; _Ptr; _Ptr = _Ptr->_Next) {
                if (_Ptr->_Lo != 0 || _Ptr->_Vp) { 
                    iword(_Ptr->_Index) = _Ptr->_Lo;
                    pword(_Ptr->_Index) = _Ptr->_Vp;
                }
            }

            for (_Fnarray* _Pfa = _Other._Calls; _Pfa; _Pfa = _Pfa->_Next) {
                register_callback(_Pfa->_Pfn, _Pfa->_Index);
            }

            _Callfns(copyfmt_event); 
            exceptions(_Other._Except); 
        }
        return *this;
    }

    static bool __cdecl sync_with_stdio(
        bool _Newsync = true) { 
        { ::std:: _Lockit _Lock(2); 
        const bool _Oldsync = _Sync;
        _Sync               = _Newsync;
        return _Oldsync;
        }
    }

    void  swap(ios_base& _Right) {
        if (this != ::std:: addressof(_Right)) {
            ::std:: swap(_Mystate, _Right._Mystate);
            ::std:: swap(_Except, _Right._Except);
            ::std:: swap(_Fmtfl, _Right._Fmtfl);
            ::std:: swap(_Prec, _Right._Prec);
            ::std:: swap(_Wide, _Right._Wide);

            ::std:: swap(_Arr, _Right._Arr);
            ::std:: swap(_Calls, _Right._Calls);
            ::std:: swap(_Ploc, _Right._Ploc);
        }
    }

    virtual  ~ios_base() noexcept {
        _Ios_base_dtor(this);
    }

    static void __cdecl _Addstd(ios_base*); 

    size_t _Stdstr{0}; 

protected:
     ios_base() {}

    void  _Init() { 
        _Ploc   = nullptr;
        _Stdstr = 0;
        _Except = goodbit;
        _Fmtfl  = skipws | dec;
        _Prec   = 6;
        _Wide   = 0;
        _Arr    = nullptr;
        _Calls  = nullptr;
        clear(goodbit);
        _Ploc = new locale;
    }

private:
    struct _Iosarray : _Crt_new_delete { 
    public:
         _Iosarray(int _Idx, _Iosarray* _Link)
            : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr) {} 

        _Iosarray* _Next; 
        int _Index; 
        long _Lo; 
        void* _Vp; 
    };

    struct _Fnarray : _Crt_new_delete { 
         _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link)
            : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) {} 

        _Fnarray* _Next; 
        int _Index; 
        event_callback _Pfn; 
    };

    void  _Callfns(event _Ev) { 
        for (_Fnarray* _Pfa = _Calls; _Pfa; _Pfa = _Pfa->_Next) {
            (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
        }
    }

    _Iosarray&  _Findarr(int _Idx) { 
        _Iosarray* _Ptr1;
        _Iosarray* _Ptr2;

        for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1; _Ptr1 = _Ptr1->_Next) {
            if (_Ptr1->_Index == _Idx) {
                return *_Ptr1; 
            } else if (!_Ptr2 && _Ptr1->_Lo == 0 && !_Ptr1->_Vp) {
                _Ptr2 = _Ptr1; 
            }
        }

        if (_Ptr2) { 
            _Ptr2->_Index = _Idx;
            return *_Ptr2;
        }

        _Arr = new _Iosarray(_Idx, _Arr); 
        return *_Arr;
    }

    void  _Tidy() noexcept { 
        _Callfns(erase_event);
        _Iosarray* _Ptr1;
        _Iosarray* _Ptr2;

        for (_Ptr1 = _Arr; _Ptr1; _Ptr1 = _Ptr2) { 
            _Ptr2 = _Ptr1->_Next;
            delete _Ptr1;
        }
        _Arr = nullptr;

        _Fnarray* _Pfa1;
        _Fnarray* _Pfa2;
        for (_Pfa1 = _Calls; _Pfa1; _Pfa1 = _Pfa2) { 
            _Pfa2 = _Pfa1->_Next;
            delete _Pfa1;
        }
        _Calls = nullptr;
    }

    iostate _Mystate; 
    iostate _Except; 
    fmtflags _Fmtfl; 
    streamsize _Prec; 
    streamsize _Wide; 
    _Iosarray* _Arr{nullptr}; 
    _Fnarray* _Calls{nullptr}; 
    locale* _Ploc{nullptr}; 

     static int _Index;
     static bool _Sync;

    static void __cdecl _Ios_base_dtor(ios_base*);

public:
    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;
};
}


#pragma warning(pop)
#pragma pack(pop)
#line 563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#line 564 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xiosbase"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Elem, class _Traits>
class basic_streambuf { 
protected:
     basic_streambuf() : _Plocale(new locale) {
        _Init();
    }

     basic_streambuf(_Uninitialized) {}

     basic_streambuf(const basic_streambuf& _Right) : _Plocale(new locale(_Right.getloc())) {
        _Init();
        setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
        setg(_Right.eback(), _Right.gptr(), _Right.egptr());
    }

    basic_streambuf&  operator=(const basic_streambuf& _Right) {
        if (this != ::std:: addressof(_Right)) {
            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            pubimbue(_Right.getloc());
        }
        return *this;
    }

    void  swap(basic_streambuf& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Elem* _Pfirst0 = pbase();
            _Elem* _Pnext0  = pptr();
            _Elem* _Pend    = epptr();
            _Elem* _Gfirst0 = eback();
            _Elem* _Gnext0  = gptr();
            _Elem* _Gend    = egptr();

            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            _Right.setp(_Pfirst0, _Pnext0, _Pend);

            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            _Right.setg(_Gfirst0, _Gnext0, _Gend);

            ::std:: swap(_Plocale, _Right._Plocale);
        }
    }

public:
    using char_type   = _Elem;
    using traits_type = _Traits;

    virtual  ~basic_streambuf() noexcept {
        delete _Plocale;
    }

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    pos_type  pubseekoff(off_type _Off, ios_base::seekdir _Way,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { 
        return seekoff(_Off, _Way, _Mode);
    }


    pos_type  pubseekoff(off_type _Off, ios_base::seek_dir _Way,
        ios_base::open_mode _Mode) { 
        return pubseekoff(_Off, static_cast<ios_base::seekdir>(_Way), static_cast<ios_base::openmode>(_Mode));
    }
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"

    pos_type  pubseekpos(pos_type _Pos,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { 
        return seekpos(_Pos, _Mode);
    }


    pos_type  pubseekpos(pos_type _Pos,
        ios_base::open_mode _Mode) { 
        return seekpos(_Pos, static_cast<ios_base::openmode>(_Mode));
    }
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"

    basic_streambuf*  pubsetbuf(_Elem* _Buffer,
        streamsize _Count) { 
        return setbuf(_Buffer, _Count);
    }

    locale  pubimbue(const locale& _Newlocale) { 
        locale _Oldlocale = *_Plocale;
        imbue(_Newlocale);
        *_Plocale = _Newlocale;
        return _Oldlocale;
    }

    locale  getloc() const { 
        return *_Plocale;
    }

    streamsize  in_avail() {
        streamsize _Res = _Gnavail();
        return 0 < _Res ? _Res : showmanyc();
    }

    int  pubsync() { 
        return sync();
    }

    int_type  sbumpc() { 
        return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();
    }

    int_type  sgetc() { 
        return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();
    }

    streamsize  sgetn(_Elem* _Ptr,
        streamsize _Count) { 
        return xsgetn(_Ptr, _Count);
    }

    int_type  snextc() { 
        return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())
             : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof()
                                                              : sgetc();
    }

    int_type  sputbackc(_Elem _Ch) { 
        if (gptr() && eback() < gptr() && _Traits::eq(_Ch, gptr()[-1])) {
            return _Traits::to_int_type(*_Gndec());
        }

        return pbackfail(_Traits::to_int_type(_Ch));
    }


    void  stossc() { 
        if (0 < _Gnavail()) {
            _Gninc();
        } else {
            uflow();
        }
    }
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"

    int_type  sungetc() { 
        return gptr() && eback() < gptr() ? _Traits::to_int_type(*_Gndec()) : pbackfail();
    }

    int_type  sputc(_Elem _Ch) { 
        return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));
    }

    streamsize  sputn(const _Elem* _Ptr,
        streamsize _Count) { 
        return xsputn(_Ptr, _Count);
    }

    virtual void  _Lock() {} 

    virtual void  _Unlock() {} 

protected:
    _Elem*  eback() const {
        return *_IGfirst;
    }

    _Elem*  gptr() const {
        return *_IGnext;
    }

    _Elem*  pbase() const {
        return *_IPfirst;
    }

    _Elem*  pptr() const {
        return *_IPnext;
    }

    _Elem*  egptr() const {
        return *_IGnext + *_IGcount;
    }

    void  gbump(int _Off) { 
        *_IGcount -= _Off;
        *_IGnext += _Off;
    }

    void  setg(_Elem* _First, _Elem* _Next, _Elem* _Last) { 
        *_IGfirst = _First;
        *_IGnext  = _Next;
        *_IGcount = static_cast<int>(_Last - _Next);
    }

    _Elem*  epptr() const {
        return *_IPnext + *_IPcount;
    }

    _Elem*  _Gndec() { 
        ++*_IGcount;
        return --*_IGnext;
    }

    _Elem*  _Gninc() { 
        --*_IGcount;
        return (*_IGnext)++;
    }

    _Elem*  _Gnpreinc() { 
        --*_IGcount;
        return ++(*_IGnext);
    }

    streamsize  _Gnavail() const { 
        return *_IGnext ? *_IGcount : 0;
    }

    void  pbump(int _Off) { 
        *_IPcount -= _Off;
        *_IPnext += _Off;
    }

    void  setp(_Elem* _First, _Elem* _Last) { 
        *_IPfirst = _First;
        *_IPnext  = _First;
        *_IPcount = static_cast<int>(_Last - _First);
    }

    void  setp(
        _Elem* _First, _Elem* _Next, _Elem* _Last) { 
        *_IPfirst = _First;
        *_IPnext  = _Next;
        *_IPcount = static_cast<int>(_Last - _Next);
    }

    _Elem*  _Pninc() { 
        --*_IPcount;
        return (*_IPnext)++;
    }

    streamsize  _Pnavail() const { 
        return *_IPnext ? *_IPcount : 0;
    }

    void  _Init() { 
        _IGfirst = &_Gfirst;
        _IPfirst = &_Pfirst;
        _IGnext  = &_Gnext;
        _IPnext  = &_Pnext;
        _IGcount = &_Gcount;
        _IPcount = &_Pcount;
        setp(nullptr, nullptr);
        setg(nullptr, nullptr, nullptr);
    }

    void  _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn, int* _Pc) {
        
        _IGfirst = _Gf;
        _IPfirst = _Pf;
        _IGnext  = _Gn;
        _IPnext  = _Pn;
        _IGcount = _Gc;
        _IPcount = _Pc;
    }

    virtual int_type  overflow(int_type = _Traits::eof()) { 
        return _Traits::eof();
    }

    virtual int_type  pbackfail(int_type = _Traits::eof()) {
        
        return _Traits::eof();
    }

    virtual streamsize  showmanyc() {
        return 0;
    }

    virtual int_type  underflow() { 
        return _Traits::eof();
    }

    virtual int_type  uflow() { 
        return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
    }

    virtual streamsize  xsgetn(_Elem* _Ptr, streamsize _Count) { 
        const streamsize _Start_count = _Count;

        while (0 < _Count) {
            streamsize _Size = _Gnavail();
            if (0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                gbump(static_cast<int>(_Size));
            } else {
                const int_type _Meta = uflow();
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; 
                }

                
                *_Ptr++ = _Traits::to_char_type(_Meta);
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual streamsize  xsputn(const _Elem* _Ptr, streamsize _Count) {
        
        const streamsize _Start_count = _Count;
        while (0 < _Count) {
            streamsize _Size = _Pnavail();
            if (0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                pbump(static_cast<int>(_Size));
            } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {
                break; 
            } else { 
                ++_Ptr;
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual pos_type  seekoff(
        off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {
        
        return streampos(-1);
    }

    virtual pos_type  seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {
        
        return streampos(-1);
    }

    virtual basic_streambuf*  setbuf(_Elem*, streamsize) {
        
        return this;
    }

    virtual int  sync() { 
        return 0;
    }

    virtual void  imbue(const locale&) {} 

private:
    _Elem* _Gfirst; 
    _Elem* _Pfirst; 
    _Elem** _IGfirst; 
    _Elem** _IPfirst; 
    _Elem* _Gnext; 
    _Elem* _Pnext; 
    _Elem** _IGnext; 
    _Elem** _IPnext; 

    int _Gcount; 
    int _Pcount; 
    int* _IGcount; 
    int* _IPcount; 

protected:
    locale* _Plocale; 
};











#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"
}



#pragma warning(pop)
#pragma pack(pop)
#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"
#line 417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\streambuf"
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




extern "C" {

extern  float __cdecl _Stofx(
    const char*,     char**, long, int*);
extern  double __cdecl _Stodx(
    const char*,     char**, long, int*);
extern  long double __cdecl _Stoldx(
    const char*,     char**, long, int*);
extern  long __cdecl _Stolx(
    const char*,     char**, int, int*);
extern  unsigned long __cdecl _Stoulx(
    const char*,     char**, int, int*);
extern  long long __cdecl _Stollx(
    const char*,     char**, int, int*);
extern  unsigned long long __cdecl _Stoullx(
    const char*,     char**, int, int*);

}

namespace std {

inline double _Stodx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr) { 
    int& _Errno_ref = (*_errno()); 
    const int _Orig = _Errno_ref;

    _Errno_ref  = 0;
    double _Val = :: strtod(_Str, _Endptr);
    *_Perr      = _Errno_ref;
    _Errno_ref  = _Orig;

    if (_Pten != 0) {
        _Val *= :: pow(10.0, static_cast<double>(_Pten));
    }

    return _Val;
}

inline float _Stofx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr) { 
    int& _Errno_ref = (*_errno()); 
    const int _Orig = _Errno_ref;

    _Errno_ref = 0;
    float _Val = :: strtof(_Str, _Endptr);
    *_Perr     = _Errno_ref;
    _Errno_ref = _Orig;

    if (_Pten != 0) {
        _Val *= :: powf(10.0f, static_cast<float>(_Pten));
    }

    return _Val;
}

template <class _Elem, size_t _Base_size>
size_t _Find_elem(const _Elem (&_Base)[_Base_size],
    const _Elem _Ch) { 
                       
    return static_cast<size_t>(_Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);
}

inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { 
    const size_t _Count = :: wcslen(_Ptr) + 1;

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Count, sizeof(wchar_t)));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    :: wmemcpy(_Ptrdest, _Ptr, _Count);
    return _Ptrdest;
}

template <class _Elem>
class numpunct : public locale::facet { 
private:
    friend _Tidy_guard<numpunct>;

public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;
    using char_type   = _Elem;

      static locale::id id; 

    _Elem decimal_point() const {
        return do_decimal_point();
    }

    _Elem thousands_sep() const {
        return do_thousands_sep();
    }

    string grouping() const {
        return do_grouping();
    }

    string_type falsename() const {
        return do_falsename();
    }

    string_type truename() const {
        return do_truename();
    }

    explicit numpunct(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        if (_Kseparator == 0) {
            _Kseparator = 
                _Maklocchr(',', static_cast<_Elem*>(nullptr), _Lobj._Getcvt());
        }
        }
    }

    numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {
        _Init(_Lobj, _Isdef);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);
        }
        return 4;
    }

protected:
    virtual  ~numpunct() noexcept {
        _Tidy();
    }

    numpunct(const char* _Locname, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj, _Isdef);
        }
    }

    template <class _Elem2>
    void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt) { 
        _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
        _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
    }

    void _Getvals(wchar_t, const lconv* _Ptr, _Locinfo::_Cvtvec) { 
        _Dp         = static_cast<_Elem>(_Ptr->_W_decimal_point[0]);
        _Kseparator = static_cast<_Elem>(_Ptr->_W_thousands_sep[0]);
    }

    void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { 
        const lconv* _Ptr      = _Lobj._Getlconv();
        _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); 

        _Grouping  = nullptr;
        _Falsename = nullptr;
        _Truename  = nullptr;

        _Tidy_guard<numpunct> _Guard{this};
        _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());
        _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);
        _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);
        _Guard._Target = nullptr;

        if (_Isdef) { 
            
            _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
            _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);
        } else {
            _Getvals(_Elem{}, _Ptr, _Cvt);
        }
    }

    virtual _Elem  do_decimal_point() const {
        return _Dp;
    }

    virtual _Elem  do_thousands_sep() const {
        return _Kseparator;
    }

    virtual string  do_grouping() const {
        return string(_Grouping);
    }

    virtual string_type  do_falsename() const {
        return string_type(_Falsename);
    }

    virtual string_type  do_truename() const {
        return string_type(_Truename);
    }

private:
    void _Tidy() noexcept { 
        :: free(const_cast<char*>(_Grouping));
        :: free(const_cast<_Elem*>(_Falsename));
        :: free(const_cast<_Elem*>(_Truename));
    }

    const char* _Grouping; 
    _Elem _Dp; 
    _Elem _Kseparator; 
    const _Elem* _Falsename; 
    const _Elem* _Truename; 
};

template <class _Elem>
class numpunct_byname : public numpunct<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    explicit numpunct_byname(const char* _Locname, size_t _Refs = 0)
        : numpunct<_Elem>(_Locname, _Refs) {} 

    explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
        : numpunct<_Elem>(_Str.c_str(), _Refs) {} 

protected:
    virtual  ~numpunct_byname() noexcept {}
};







template <class _Elem>
 locale::id numpunct<_Elem>::id;




#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"

template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_get : public locale::facet { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->c_str()));
        }

        return 4;
    }

     static locale::id id; 

protected:
    virtual  ~num_get() noexcept {}

    void _Init(const _Locinfo&) {} 

public:
    explicit  num_get(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     num_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _InIt;

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

protected:
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { 
        _Adl_verify_range(_First, _Last);
        if (_Iosbase.flags() & ios_base::boolalpha) { 
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});
            _Str += _Punct_fac.falsename();
            _Str.push_back(_Elem{});
            _Str += _Punct_fac.truename(); 
            switch (_Getloctxt(_First, _Last, 2, _Str.c_str(), _Case_sensitive::_Yes)) {
            case 0:
                _Val = false;
                break;
            case 1:
                _Val = true;
                break;
            default:
                _Val   = false;
                _State = ios_base::failbit;
                break;
            }
        } else { 
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
            if (_Ac[0] == '\0') { 
                                  
                                  
                                  
                                  
                                  
                _Val   = false;
                _State = ios_base::failbit;
            } else {
                char* _Ep;
                int _Errno;
                const long _Ans = :: _Stolx(_Ac, &_Ep, _Base, &_Errno); 
                if (_Ep == _Ac || _Errno != 0) {
                    _Val   = true;
                    _State = ios_base::failbit;
                } else {
                    _Val = _Ans != 0;
                    if (_Ans != 0 && _Ans != 1) {
                        _State = ios_base::failbit;
                    }
                }
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            const bool _Minus   = _Ac[0] == '-';
            const char* _Digits = _Ac;
            
            
            if (_Minus) { 
                ++_Digits;
            }

            char* _Ep;
            int _Errno;
            const unsigned long _Tmp = :: _Stoulx(_Digits, &_Ep, _Base, &_Errno); 
            _Val                     = static_cast<unsigned short>(_Tmp);
            if (_Ep == _Digits || _Errno != 0 || _Tmp > 0xffff) {
                _State = ios_base::failbit;
                _Val   = 0xffff;
            } else if (_Minus) { 
                                 
                _Val = static_cast<unsigned short>(0 - _Val);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { 
        static_assert(sizeof(unsigned int) == sizeof(unsigned long),
            "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
        unsigned long _Tmp;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); 
        _Val   = _Tmp;
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stolx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stoulx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stollx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = :: _Stoullx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }








    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16)];
        int _Hexexp     = 1000000000;
        const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0.0f;
        } else {
            int _Errno;
            char* _Ep;
            _Val = _Stofx_v2(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = 0.0f;
            } else if (_Hexexp != 1000000000 && _Hexexp != 0) {
                _Val = :: ldexpf(_Val, 4 * _Hexexp);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16)];
        int _Hexexp     = 1000000000;
        const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0.0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = _Stodx_v2(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = 0.0;
            } else if (_Hexexp != 1000000000 && _Hexexp != 0) {
                _Val = :: ldexp(_Val, 4 * _Hexexp);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }


    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        static_assert(sizeof(double) == sizeof(long double), "Bad assumption: sizeof(double) == sizeof(long double).");
        double _Result;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); 
        _Val   = _Result;
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = nullptr;
        } else {
            int _Errno;
            char* _Ep;

            _Val = reinterpret_cast<void*>(:: _Stoullx(_Ac, &_Ep, _Base, &_Errno));


#line 641 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = nullptr;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

private:
    int __cdecl _Getifld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
        const locale& _Loc) const { 
        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Loc);
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff    = 24;
        static constexpr char _Src[]  = "0123456789ABCDEFabcdef-+Xx";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Loc);
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        char* _Ptr = _Ac;

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }

        _Basefield &= ios_base::basefield;

        int _Base;
        if (_Basefield == ios_base::oct) {
            _Base = 8;
        } else if (_Basefield == ios_base::hex) {
            _Base = 16;
        } else if (_Basefield == ios_base::_Fmtzero) {
            _Base = 0;
        } else {
            _Base = 10;
        }

        bool _Seendigit = false; 
        bool _Nonzero   = false; 

        if (_First != _Last && *_First == _Atoms[0]) { 
            _Seendigit = true;
            ++_First;
            if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])
                && (_Base == 0 || _Base == 16)) {
                _Base      = 16;
                _Seendigit = false;
                ++_First;
            } else if (_Base == 0) {
                _Base = 8;
            }
        }

        const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);
        string _Groups(1, static_cast<char>(_Seendigit));
        size_t _Group = 0;

        for (char* const _Pe = &_Ac[32 - 1]; _First != _Last; ++_First) { 
            size_t _Idx = _Find_elem(_Atoms, *_First);
            if (_Idx < _Dlen) { 
                *_Ptr = _Src[_Idx];
                if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe) {
                    ++_Ptr;
                    _Nonzero = true;
                }

                _Seendigit = true;
                if (_Groups[_Group] != 127) {
                    ++_Groups[_Group];
                }
            } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                break; 
            } else { 
                _Groups.push_back('\0');
                ++_Group;
            }
        }

        if (_Group != 0) {
            if ('\0' < _Groups[_Group]) {
                ++_Group; 
            } else {
                _Seendigit = false; 
            }
        }

        for (const char* _Pg = &_Grouping[0]; _Seendigit && 0 < _Group;) {
            if (*_Pg == 127) {
                break; 
            } else if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                _Seendigit = false; 
            } else if ('\0' < _Pg[1]) {
                ++_Pg; 
            }
        }

        if (_Seendigit && !_Nonzero) {
            *_Ptr++ = '0'; 
        } else if (!_Seendigit) {
            _Ptr = _Ac; 
        }

        *_Ptr = '\0';
        return _Base;
    }

    int __cdecl _Getffld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase,
        int* _Phexexp) const { 
        if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat) {
            return _Getffldx(_Ac, _First, _Last, _Iosbase, _Phexexp); 
        }

        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        char* _Ptr             = _Ac;
        bool _Bad              = false;
        bool _Sticky           = false;

        constexpr int _Numget_signoff = 10;
        constexpr int _Numget_eoff    = 12;
        static constexpr char _Src[]  = "0123456789-+Ee";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }

        char* _Leading = _Ptr; 
        *_Ptr++        = '0'; 

        bool _Seendigit  = false; 
        int _Significant = 0; 
        int _Pten        = 0; 
        size_t _Idx;

        const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

        const char* _Pg = &_Grouping[0];
        if (*_Pg == 127 || *_Pg <= '\0') {
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
                if (_Max_sig_dig <= _Significant) { 
                    ++_Pten;
                    if (0 < _Idx) {
                        _Sticky = true;
                    }
                } else if (_Idx != 0 || _Significant != 0) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else { 
            const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();
            string _Groups(1, '\0');
            size_t _Group = 0;

            for (; _First != _Last; ++_First) {
                if ((_Idx = _Find_elem(_Atoms, *_First)) < 10) { 
                    _Seendigit = true;
                    if (_Max_sig_dig <= _Significant) { 
                        ++_Pten;
                        if (0 < _Idx) {
                            _Sticky = true;
                        }
                    } else if (_Idx != 0 || _Significant != 0) { 
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }

                    if (_Groups[_Group] != 127) {
                        ++_Groups[_Group];
                    }
                } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                    break; 
                } else { 
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }

            if (_Group != 0) {
                if ('\0' < _Groups[_Group]) {
                    ++_Group; 
                } else {
                    _Bad = true; 
                }
            }

            while (!_Bad && 0 < _Group) {
                if (*_Pg == 127) {
                    break; 
                }

                if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                    _Bad = true; 
                } else if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { 
            *_Ptr++ = localeconv()->decimal_point[0];
            ++_First;
        }

        if (*_Phexexp != 1000000000 && _Significant == 0) { 
            for (; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void) ++_First) {
                --_Pten; 
            }

            if (_Pten < 0) { 
                *_Ptr++ = '0';
                ++_Pten;
            }
        }

        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { 
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            } else if (0 < _Idx) {
                _Sticky = true; 
            }
        }

        if (_Sticky) { 
            char* _Px = _Ptr;
            while (--_Px != _Leading) { 
                if (*_Px != localeconv()->decimal_point[0]) { 
                    if (*_Px != '9') { 
                        ++*_Px;
                        break;
                    }

                    *_Px = '0'; 
                }
            }

            if (_Px == _Leading) { 
                *_Px = '1';
                ++_Pten;
            }
        }

        if (_Seendigit && _First != _Last
            && (*_First == _Atoms[_Numget_eoff + 1]
                || *_First == _Atoms[_Numget_eoff])) { 
            *_Ptr++ = 'e';
            ++_First;
            _Seendigit   = false;
            _Significant = 0;

            if (_First != _Last) {
                if (*_First == _Atoms[_Numget_signoff + 1]) { 
                    *_Ptr++ = '+';
                    ++_First;
                } else if (*_First == _Atoms[_Numget_signoff]) { 
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            for (; _First != _Last && *_First == _Atoms[0]; ++_First) { 
                _Seendigit = true;
            }

            if (_Seendigit) {
                *_Ptr++ = '0'; 
            }

            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
                if (_Significant < 8) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }

        if (_Bad || !_Seendigit) {
            _Ptr = _Ac; 
        }

        *_Ptr = '\0';
        return _Pten;
    }

    int __cdecl _Getffldx(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase,
        int* _Phexexp) const { 
        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff    = 24;
        constexpr int _Numget_poff    = 26;
        static constexpr char _Src[]  = "0123456789ABCDEFabcdef-+XxPp";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        char* _Ptr = _Ac;
        bool _Bad  = false;
        size_t _Idx;

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }

        *_Ptr++ = '0';
        *_Ptr++ = 'x';

        bool _Seendigit  = false; 
        int _Significant = 0; 
        int _Phex        = 0; 

        if (_First != _Last && *_First == _Atoms[0]) {
            if (++_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])) {
                ++_First; 
            } else {
                _Seendigit = true; 
            }
        }

        const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

        const char* _Pg = &_Grouping[0];
        if (*_Pg == 127 || *_Pg <= '\0') {
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
                 _Seendigit = true, (void) ++_First) {
                if (_Max_sig_dig <= _Significant) {
                    ++_Phex; 
                } else if (_Idx != 0 || _Significant != 0) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else { 
            const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();
            string _Groups(1, '\0');
            size_t _Group = 0;

            for (; _First != _Last; ++_First) {
                if ((_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff) { 
                    _Seendigit = true;
                    if (_Max_sig_dig <= _Significant) {
                        ++_Phex; 
                    } else if (_Idx != 0 || _Significant != 0) { 
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }

                    if (_Groups[_Group] != 127) {
                        ++_Groups[_Group];
                    }
                } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                    break; 
                } else { 
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }

            if (_Group != 0) {
                if ('\0' < _Groups[_Group]) {
                    ++_Group; 
                } else {
                    _Bad = true; 
                }
            }

            while (!_Bad && 0 < _Group) {
                if (*_Pg == 127) {
                    break; 
                }

                if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                    _Bad = true; 
                } else if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        if (_Seendigit && _Significant == 0) {
            *_Ptr++ = '0'; 
        }

        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { 
            *_Ptr++ = localeconv()->decimal_point[0];
            ++_First;
        }

        if (_Significant == 0) { 
            for (; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void) ++_First) {
                --_Phex; 
            }

            if (_Phex < 0) { 
                *_Ptr++ = '0';
                ++_Phex;
            }
        }

        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
             _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { 
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            }
        }

        if (_Seendigit && _First != _Last
            && (*_First == _Atoms[_Numget_poff + 1]
                || *_First == _Atoms[_Numget_poff])) { 
            *_Ptr++ = 'p';
            ++_First;
            _Seendigit   = false;
            _Significant = 0;

            if (_First != _Last) {
                if (*_First == _Atoms[_Numget_signoff + 1]) { 
                    *_Ptr++ = '+';
                    ++_First;
                } else if (*_First == _Atoms[_Numget_signoff]) { 
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            for (; _First != _Last && *_First == _Atoms[0]; ++_First) { 
                _Seendigit = true;
            }

            if (_Seendigit) {
                *_Ptr++ = '0'; 
            }

            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
                 _Seendigit = true, (void) ++_First) {
                if (_Significant < 8) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }

        if (_Bad || !_Seendigit) {
            _Ptr = _Ac; 
        }

        *_Ptr     = '\0';
        *_Phexexp = _Phex; 
        return 0; 
    }


};






template <class _Elem, class _InIt>
 locale::id num_get<_Elem, _InIt>::id;





template <class _Ty>
struct _Hex_float_precision;

template <>
struct _Hex_float_precision<double> {
    
    static constexpr int value = ((53 - 1) + 3) / 4;
};

template <>
struct _Hex_float_precision<long double> {
    
    static constexpr int value = ((53 - 1) + 3) / 4;
};

template <class _Ty>
int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {
    const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);
    if (_Is_hex) {
        return _Hex_float_precision<_Ty>::value;
    }

    if (_Precision > 0) {
        return static_cast<int>(_Precision);
    } else if (_Precision == 0) {
        const bool _Is_default_float = _Float_flags == 0;
        if (_Is_default_float) {
            return 1;
        } else {
            return 0;
        }
    } else {
        constexpr int _Default_precision = 6;
        return _Default_precision;
    }
}

template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_put : public locale::facet { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
        }

        return 4;
    }

     static locale::id id; 

protected:
    virtual  ~num_put() noexcept {}

    void  _Init(const _Locinfo&) {} 

public:
    explicit  num_put(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _OutIt;

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

protected:
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { 
        if (!(_Iosbase.flags() & ios_base::boolalpha)) {
            return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));
        } else { 
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str;
            if (_Val) {
                _Str.assign(_Punct_fac.truename());
            } else {
                _Str.assign(_Punct_fac.falsename());
            }

            size_t _Fillcount;
            if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {
                _Fillcount = 0;
            } else {
                _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();
            }

            if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { 
                _Dest      = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }
            _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); 
            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount); 
        }
    }

#pragma warning(push)
#pragma warning(disable : 4774) 
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { 
        char _Buf[2 * 32];
        char _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { 
        char _Buf[2 * 32];
        char _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { 
        char _Buf[2 * 32];
        char _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { 
        char _Buf[2 * 32];
        char _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { 
        string _Buf;
        char _Fmt[8];
        const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;
        const bool _Is_fixed        = _Float_flags == ios_base::fixed;
        const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);
        const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); 
        const int _Desired_precision =
            _Float_put_desired_precision<double>(_Precision, _Float_flags); 
        size_t _Bufsize = static_cast<size_t>(_Desired_precision);
        if (_Is_fixed && 1e10 < :: fabs(_Val)) { 
            int _Ptwo;
            (void) :: frexp(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); 
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Iosbase.flags()), static_cast<int>(_Precision), _Val));

        return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { 
        string _Buf;
        char _Fmt[8];
        const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;
        const bool _Is_fixed        = _Float_flags == ios_base::fixed;
        const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);
        const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); 
        const int _Desired_precision =
            _Float_put_desired_precision<long double>(_Precision, _Float_flags); 
        size_t _Bufsize = static_cast<size_t>(_Desired_precision);
        if (_Is_fixed && 1e10 < :: fabsl(_Val)) { 
            int _Ptwo;
            (void) :: frexpl(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); 
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Iosbase.flags()), static_cast<int>(_Precision), _Val));

        return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
    }
#pragma warning(pop)

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { 
        char _Buf[2 * 32];

        return _Iput(
            _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
    }

private:
    char* __cdecl _Ffmt(
        char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { 
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showpoint) {
            *_Ptr++ = '#';
        }

        *_Ptr++ = '.';
        *_Ptr++ = '*'; 
        if (_Spec != '\0') {
            *_Ptr++ = _Spec; 
        }

        char _Ch; 
        ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
        if (_Flags & ios_base::uppercase) {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            } else if (_Ffl == ios_base::hexfloat) {
                _Ch = 'A'; 
            } else if (_Ffl == ios_base::scientific) {
                _Ch = 'E';
            } else {
                _Ch = 'G';
            }
        } else {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            } else if (_Ffl == ios_base::hexfloat) {
                _Ch = 'a'; 
            } else if (_Ffl == ios_base::scientific) {
                _Ch = 'e';
            } else {
                _Ch = 'g';
            }
        }
        *_Ptr++ = _Ch;

        *_Ptr = '\0';
        return _Fmt;
    }

    _OutIt __cdecl _Fput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf,
        size_t _Count) const { 
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        const char* _Exps;
        if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {
            _Exps = "eE";
        } else { 
            _Exps = "pP";
            if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
                && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
                _Prefix += 2;
            }
        }
        const size_t _Eoff = :: strcspn(&_Buf[0], _Exps); 
        char _Dp[2]        = {"."};
        _Dp[0]             = :: localeconv()->decimal_point[0];
        const size_t _Poff = :: strcspn(&_Buf[0], &_Dp[0]); 

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); 
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Punct_fac.thousands_sep();

        if (_Poff != _Count) {
            _Groupstring[_Poff] = _Punct_fac.decimal_point();
        }

        size_t _Off     = _Poff == _Count ? _Eoff : _Poff;
        const char* _Pg = &_Grouping[0];
        while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {
            
            _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);
            if ('\0' < _Pg[1]) {
                ++_Pg; 
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { 
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }

    char* __cdecl _Ifmt(
        char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { 
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showbase) {
            *_Ptr++ = '#';
        }

        if (_Spec[0] != 'L') {
            *_Ptr++ = _Spec[0]; 
        } else { 
            *_Ptr++ = 'I';
            *_Ptr++ = '6';
            *_Ptr++ = '4';
        }

        ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
        *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'
                                      : _Basefield != ios_base::hex  ? _Spec[1] 
                                      : _Flags & ios_base::uppercase ? 'X'
                                                                     : 'x';
        *_Ptr                         = '\0';
        return _Fmt;
    }

    _OutIt __cdecl _Iput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, char* _Buf,
        size_t _Count) const { 
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
            && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
            _Prefix += 2;
        }

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); 
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        const char* _Pg        = &_Grouping[0];
        if (*_Pg != 127 && '\0' < *_Pg) { 
            const _Elem _Kseparator = _Punct_fac.thousands_sep();
            while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {
                
                _Count -= *_Pg;
                _Groupstring.insert(_Count, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { 
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }

    _OutIt __cdecl _Put(
        _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { 
        for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {
            *_Dest = *_Ptr;
        }

        return _Dest;
    }

    _OutIt __cdecl _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { 
        for (; 0 < _Count; --_Count, (void) ++_Dest) {
            *_Dest = _Ch;
        }

        return _Dest;
    }
};






template <class _Elem, class _OutIt>
 locale::id num_put<_Elem, _OutIt>::id;




















#line 1624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"




}


#pragma warning(pop)
#pragma pack(pop)
#line 1634 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#line 1635 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xlocnum"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Elem, class _Traits>
class basic_ios : public ios_base { 
public:
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Mysb       = basic_streambuf<_Elem, _Traits>;
    using _Ctype      = ctype<_Elem>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit  basic_ios(_Mysb* _Strbuf) {
        init(_Strbuf);
    }

    virtual  ~basic_ios() noexcept {}

    void  clear(iostate _State = goodbit, bool _Reraise = false) {
        
        ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);
    }


    void  clear(io_state _State) { 
        clear(static_cast<iostate>(_State));
    }
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"

    void  setstate(
        iostate _State, bool _Reraise = false) { 
        clear(rdstate() | _State, _Reraise);
    }


    void  setstate(io_state _State) { 
        setstate(static_cast<iostate>(_State));
    }
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"

    basic_ios&  copyfmt(const basic_ios& _Right) { 
        _Tiestr = _Right.tie();
        _Fillch = _Right.fill();
        ios_base::copyfmt(_Right);
        return *this;
    }

    _Myos*  tie() const {
        return _Tiestr;
    }

    _Myos*  tie(_Myos* _Newtie) { 
        _Myos* _Oldtie = _Tiestr;
        _Tiestr        = _Newtie;
        return _Oldtie;
    }

    [[nodiscard]] _Mysb*  rdbuf() const {
        return _Mystrbuf;
    }

    _Mysb*  rdbuf(_Mysb* _Strbuf) { 
        _Mysb* _Oldstrbuf = _Mystrbuf;
        _Mystrbuf         = _Strbuf;
        clear();
        return _Oldstrbuf;
    }

    locale  imbue(const locale& _Loc) { 
        locale _Oldlocale = ios_base::imbue(_Loc);
        const auto _Rdbuf = rdbuf();
        if (_Rdbuf) {
            _Rdbuf->pubimbue(_Loc);
        }

        return _Oldlocale;
    }

    _Elem  fill() const {
        return _Fillch;
    }

    _Elem  fill(_Elem _Newfill) { 
        _Elem _Oldfill = _Fillch;
        _Fillch        = _Newfill;
        return _Oldfill;
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return ::std:: use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt);
    }

    _Elem  widen(char _Byte) const { 
        return ::std:: use_facet<_Ctype>(getloc()).widen(_Byte);
    }

    void  move(basic_ios& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void  move(basic_ios&& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void  swap(basic_ios& _Right) noexcept { 
        ios_base::swap(_Right);
        ::std:: swap(_Fillch, _Right._Fillch);
        ::std:: swap(_Tiestr, _Right._Tiestr);
    }

    void  set_rdbuf(_Mysb* _Strbuf) { 
        _Mystrbuf = _Strbuf;
    }

protected:
    void  init(_Mysb* _Strbuf = nullptr,
        bool _Isstd                             = false) { 
        _Init(); 
        _Mystrbuf = _Strbuf;
        _Tiestr   = nullptr;
        _Fillch   = widen(' ');

        if (!_Mystrbuf) {
            setstate(badbit);
        }

        if (_Isstd) {
            _Addstd(this); 
        }
    }

     basic_ios() {}

private:
    _Mysb* _Mystrbuf; 
    _Myos* _Tiestr; 
    _Elem _Fillch; 

public:
     basic_ios(const basic_ios&) = delete;
    basic_ios&  operator=(const basic_ios&) = delete;
};











#line 183 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"

inline ios_base& __cdecl boolalpha(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::boolalpha);
    return _Iosbase;
}

inline ios_base& __cdecl dec(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::dec, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __cdecl fixed(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __cdecl hex(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::hex, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __cdecl internal(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __cdecl left(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::left, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::boolalpha);
    return _Iosbase;
}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showbase);
    return _Iosbase;
}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showpoint);
    return _Iosbase;
}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showpos);
    return _Iosbase;
}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::skipws);
    return _Iosbase;
}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::unitbuf);
    return _Iosbase;
}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::uppercase);
    return _Iosbase;
}

inline ios_base& __cdecl oct(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::oct, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __cdecl right(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::right, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __cdecl scientific(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __cdecl showbase(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showbase);
    return _Iosbase;
}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showpoint);
    return _Iosbase;
}

inline ios_base& __cdecl showpos(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showpos);
    return _Iosbase;
}

inline ios_base& __cdecl skipws(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::skipws);
    return _Iosbase;
}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::unitbuf);
    return _Iosbase;
}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::uppercase);
    return _Iosbase;
}


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: hexfloat;
}
#line 309 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"

}



#pragma warning(pop)
#pragma pack(pop)
#line 317 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"
#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ios"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
#pragma vtordisp(push, 2) 

template <class _Elem, class _Traits>
class basic_ostream : virtual public basic_ios<_Elem, _Traits> { 
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = ostreambuf_iterator<_Elem, _Traits>;
    using _Nput  = num_put<_Elem, _Iter>;

    explicit  basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf, bool _Isstd = false) {
        _Myios::init(_Strbuf, _Isstd);
    }

     basic_ostream(_Uninitialized, bool _Addit = true) {
        if (_Addit) {
            this->_Addstd(this); 
        }
    }

protected:
     basic_ostream(basic_ostream&& _Right) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }

    basic_ostream&  operator=(basic_ostream&& _Right) {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_ostream& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
     basic_ostream(const basic_ostream&) = delete;
    basic_ostream&  operator=(const basic_ostream&) = delete;

    virtual  ~basic_ostream() noexcept {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base { 
    public:
         _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { 
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

         ~_Sentry_base() noexcept { 
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_ostream& _Myostr; 

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base {
    public:
        explicit  sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {
            if (!_Ostr.good()) {
                _Ok = false;
                return;
            }

            const auto _Tied = _Ostr.tie();
            if (!_Tied || _Tied == &_Ostr) {
                _Ok = true;
                return;
            }

            _Tied->flush();
            _Ok = _Ostr.good(); 
        }

        __pragma(warning(push)) __pragma(warning(disable : 4996))
         ~sentry() noexcept {


#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
            const bool _Zero_uncaught_exceptions = !::std:: uncaught_exception(); 


#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"

            if (_Zero_uncaught_exceptions) {
                this->_Myostr._Osfx();
            }
        }
        __pragma(warning(pop))

        explicit  operator bool() const {
            return _Ok;
        }

         sentry(const sentry&) = delete;
        sentry&  operator=(const sentry&) = delete;

    private:
        bool _Ok; 
    };

    
    bool  opfx() { 
        if (!this->good()) {
            return false;
        }

        const auto _Tied = _Myios::tie();
        if (!_Tied || _Myios::tie() == this) {
            return true;
        }

        _Tied->flush();
        return this->good();
    }

    
    void  osfx() { 
        _Osfx();
    }

    void  _Osfx() { 
        try {
        if (this->good() && this->flags() & ios_base::unitbuf) {
            if (_Myios::rdbuf()->pubsync() == -1) { 
                _Myios::setstate(ios_base::badbit);
            }
        }
        } catch (...) {
        }
    }


















    basic_ostream&  operator<<(
        basic_ostream&(__cdecl* _Pfn)(basic_ostream&) ) { 
        return _Pfn(*this);
    }

    basic_ostream&  operator<<(_Myios&(__cdecl* _Pfn)(_Myios&) ) { 
        _Pfn(*this);
        return *this;
    }

    basic_ostream&  operator<<(ios_base&(__cdecl* _Pfn)(ios_base&) ) { 
        _Pfn(*this);
        return *this;
    }

    basic_ostream&  operator<<(bool _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(short _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned short>(_Val));
            } else {
                _Tmp = static_cast<long>(_Val);
            }

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    
    
    
    

    
    

    basic_ostream&  operator<<(unsigned short _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(int _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned int>(_Val));
            } else {
                _Tmp = static_cast<long>(_Val);
            }

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned int _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned long long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(float _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<double>(_Val)).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(double _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long double _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(const void* _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }






#line 463 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"

    basic_ostream&  operator<<(_Mysb* _Strbuf) { 
        ios_base::iostate _State = ios_base::goodbit;
        bool _Copied             = false;
        const sentry _Ok(*this);

        if (_Ok && _Strbuf) {
            for (int_type _Meta = _Traits::eof();; _Copied = true) { 
                try {
                _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta) ? _Strbuf->sgetc() : _Strbuf->snextc();
                } catch (...) {
                _Myios::setstate(ios_base::failbit);
                throw;
                }

                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; 
                }

                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta)))) {
                    _State |= ios_base::badbit; 
                    break;
                }
                } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            }
        }

        this->width(0);
        int _Setstate_with;
        if (_Strbuf) {
            if (_Copied) {
                _Setstate_with = _State;
            } else {
                _Setstate_with = _State | ios_base::failbit;
            }
        } else {
            _Setstate_with = ios_base::badbit;
        }

        _Myios::setstate(_Setstate_with);
        return *this;
    }

    basic_ostream&  put(_Elem _Ch) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  write(const _Elem* _Str,
        streamsize _Count) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else if (0 < _Count) { 
            try {
            if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  flush() { 
        const auto _Rdbuf = _Myios::rdbuf();
        if (_Rdbuf) { 
            const sentry _Ok(*this);

            if (_Ok && _Rdbuf->pubsync() == -1) {
                _Myios::setstate(ios_base::badbit); 
            }
        }
        return *this;
    }

    basic_ostream&  seekp(pos_type _Pos) { 
        const sentry _Ok(*this);

        if (!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::out)) == -1) {
            _Myios::setstate(ios_base::failbit);
        }

        return *this;
    }

    basic_ostream&  seekp(
        off_type _Off, ios_base::seekdir _Way) { 
        const sentry _Ok(*this);

        if (!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out)) == -1) {
            _Myios::setstate(ios_base::failbit);
        }

        return *this;
    }

    pos_type  tellp() {
        const sentry _Ok(*this);

        if (!this->fail()) {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        } else {
            return pos_type(-1);
        }
    }
};

#pragma vtordisp(pop) 


























































#line 648 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val) { 
    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(:: strlen(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {
                _State |= ios_base::badbit;
            }
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, char _Ch) { 
    ios_base::iostate _State = ios_base::goodbit;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (_Ok) { 
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        streamsize _Pad                = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit
            && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch)))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr,
    const char* _Val) { 
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, char _Ch) { 
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { 
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val) { 
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch) { 
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { 
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, const signed char* _Val) { 
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, signed char _Ch) { 
    return _Ostr << static_cast<char>(_Ch);
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, const unsigned char* _Val) { 
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch) { 
    return _Ostr << static_cast<char>(_Ch);
}











































#line 957 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"

template <class _Ostr, class _Ty, class = void>
struct _Can_stream_out : false_type {};

template <class _Ostr, class _Ty>
struct _Can_stream_out<_Ostr, _Ty, void_t<decltype(::std:: declval<_Ostr&>() << ::std:: declval<const _Ty&>())>> : true_type {
};

template <class _Ostr, class _Ty,
    enable_if_t<conjunction_v<is_convertible<_Ostr*, ios_base*>, _Can_stream_out<_Ostr, _Ty>>, int> = 0>
_Ostr&& operator<<(_Ostr&& _Os, const _Ty& _Val) { 
    _Os << _Val;
    return ::std:: move(_Os);
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl endl(
    basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.put(_Ostr.widen('\n'));
    _Ostr.flush();
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.put(_Elem());
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.flush();
    return _Ostr;
}






































#line 1030 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const error_code& _Errcode) { 
    return _Ostr << _Errcode.category().name() << ':' << _Errcode.value();
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 1043 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
#line 1044 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ostream"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
#pragma vtordisp(push, 2) 

template <class _Elem, class _Traits>
class basic_istream : virtual public basic_ios<_Elem, _Traits> { 
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = istreambuf_iterator<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    using _Nget  = num_get<_Elem, _Iter>;







#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"

    explicit  basic_istream(_Mysb* _Strbuf, bool _Isstd = false)

        : _Chcount(0) {
        _Myios::init(_Strbuf, _Isstd);
    }

     basic_istream(_Uninitialized) {
        this->_Addstd(this);
    }

protected:
     basic_istream(basic_istream&& _Right) : _Chcount(_Right._Chcount) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
        _Right._Chcount = 0;
    }

    basic_istream&  operator=(basic_istream&& _Right) {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_istream& _Right) {
        _Myios::swap(_Right);
        ::std:: swap(_Chcount, _Right._Chcount);
    }

public:
     basic_istream(const basic_istream&) = delete;
    basic_istream&  operator=(const basic_istream&) = delete;

    virtual  ~basic_istream() noexcept {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base {
    public:
         _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

         ~_Sentry_base() noexcept {
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_istream& _Myistr;

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base {
    public:
        explicit  sentry(basic_istream& _Istr, bool _Noskip = false)
            : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

        explicit  operator bool() const {
            return _Ok;
        }

         sentry(const sentry&) = delete;
        sentry&  operator=(const sentry&) = delete;

    private:
        bool _Ok; 
    };

    bool  _Ipfx(bool _Noskip = false) { 
        if (!this->good()) {
            _Myios::setstate(ios_base::failbit);
            return false;
        }

        
        const auto _Tied = _Myios::tie();
        if (_Tied) {
            _Tied->flush();
        }

        bool _Eof = false;
        if (!_Noskip && this->flags() & ios_base::skipws) { 
            const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(this->getloc());

            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _Eof = true;
                    break;
                } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                    break; 
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Eof) {
            _Myios::setstate(ios_base::eofbit | ios_base::failbit);
        }

        return this->good();
    }

    
    bool  ipfx(bool _Noskip = false) { 
        return _Ipfx(_Noskip);
    }

    
    void  isfx() {} 


















    basic_istream&  operator>>(basic_istream&(__cdecl* _Pfn)(basic_istream&) ) {
        
        return _Pfn(*this);
    }

    basic_istream&  operator>>(_Myios&(__cdecl* _Pfn)(_Myios&) ) { 
        _Pfn(*this);
        return *this;
    }

    basic_istream&  operator>>(ios_base&(__cdecl* _Pfn)(ios_base&) ) { 
        _Pfn(*this);
        return *this;
    }

private:
    template <class _Ty>
    basic_istream& _Common_extract_with_num_get(_Ty& _Val) { 
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            try {
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Err);
        return *this;
    }

    template <class = void>
    void _Increment_gcount() {
        if (_Chcount != (numeric_limits<streamsize>::max)()) {
            ++_Chcount;
        }
    }

public:
    basic_istream&  operator>>(bool& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(short& _Val) { 
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            try {
            long _Lval;
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Lval);
            if (_Lval < (-32768)) {
                _Err |= ios_base::failbit;
                _Val = (-32768);
            } else if (_Lval > 32767) {
                _Err |= ios_base::failbit;
                _Val = 32767;
            } else {
                _Val = static_cast<short>(_Lval);
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Err);
        return *this;
    }

    
    
    
    

    
    

    basic_istream&  operator>>(unsigned short& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(int& _Val) { 
        static_assert(sizeof(int) == sizeof(long), "Bad overflow assumptions due to sizeof(int) != sizeof(long)");
        long _Result = _Val;
        _Common_extract_with_num_get(_Result);
        _Val = _Result;
        return *this;
    }

    basic_istream&  operator>>(unsigned int& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(unsigned long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(unsigned long long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(float& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(double& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long double& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(void*& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(_Mysb* _Strbuf) { 
        _Chcount = 0; 
        const sentry _Ok(*this, true);
        ios_base::iostate _State = ios_base::goodbit;
        if (_Ok && _Strbuf) { 
            try {
            for (int_type _Meta = _Myios::rdbuf()->sgetc();; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                }
                
                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta)))) {
                    break;
                }

                } catch (...) {
                break;
                }

                _Increment_gcount();
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Chcount == 0) { 
            _State |= ios_base::failbit;
        }

        _Myios::setstate(_State);
        return *this;
    }

    int_type  get() { 
        int_type _Meta           = 0;
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); 
        } else { 
            try {
            _Meta = _Myios::rdbuf()->sgetc();

            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                _State |= ios_base::eofbit | ios_base::failbit; 
            } else { 
                _Myios::rdbuf()->sbumpc();
                _Chcount = 1;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream&  get(_Elem* _Str, streamsize _Count) { 
        return get(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream&  get(
        _Elem* _Str, streamsize _Count, _Elem _Delim) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Traits::to_char_type(_Meta) == _Delim) {
                    break; 
                } else { 
                    *_Str++ = _Traits::to_char_type(_Meta);
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        *_Str = _Elem(); 
        return *this;
    }

    basic_istream&  get(_Elem& _Ch) { 
        int_type _Meta = get();
        if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _Ch = _Traits::to_char_type(_Meta);
        }

        return *this;
    }

    basic_istream&  get(_Mysb& _Strbuf) { 
        return get(_Strbuf, _Myios::widen('\n'));
    }

    basic_istream&  get(
        _Mysb& _Strbuf, _Elem _Delim) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else { 
                    try {
                    _Elem _Ch = _Traits::to_char_type(_Meta);
                    if (_Ch == _Delim || _Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch))) {
                        break;
                    }
                    } catch (...) {
                    break;
                    }
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Chcount == 0) {
            _State |= ios_base::failbit;
        }
        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  getline(
        _Elem* _Str, streamsize _Count) { 
        return getline(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream&  getline(
        _Elem* _Str, streamsize _Count, _Elem _Delim) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            int_type _Metadelim = _Traits::to_int_type(_Delim);

            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Meta == _Metadelim) { 
                    _Increment_gcount();
                    _Myios::rdbuf()->sbumpc();
                    break;
                } else if (--_Count <= 0) { 
                    _State |= ios_base::failbit;
                    break;
                } else { 
                    *_Str++ = _Traits::to_char_type(_Meta);
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        *_Str = _Elem(); 
        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        return *this;
    }

    basic_istream&  ignore(streamsize _Count = 1,
        int_type _Metadelim = _Traits::eof()) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            for (;;) { 
                int_type _Meta;
                if (_Count != (numeric_limits<streamsize>::max)() && --_Count < 0) {
                    break; 
                } else if (_Traits::eq_int_type(_Traits::eof(),
                               _Meta = _Myios::rdbuf()->sbumpc())) { 
                    _State |= ios_base::eofbit;
                    break;
                } else { 
                    _Increment_gcount();
                    if (_Meta == _Metadelim) {
                        break; 
                    }
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  read(_Elem* _Str, streamsize _Count) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
            _Chcount              = _Num;

            if (_Num != _Count) {
                _State |= ios_base::eofbit | ios_base::failbit; 
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    streamsize  readsome(_Elem* _Str,
        streamsize _Count) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        streamsize _Num;

        if (!_Ok) {
            _State |= ios_base::failbit; 
        } else if ((_Num = _Myios::rdbuf()->in_avail()) < 0) {
            _State |= ios_base::eofbit; 
        } else if (0 < _Count && 0 < _Num) { 
            read(_Str, _Num < _Count ? _Num : _Count);
        }

        _Myios::setstate(_State);
        return gcount();
    }

    int_type  peek() {
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        int_type _Meta           = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); 
        } else { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Myios::rdbuf()->sgetc())) {
                _State |= ios_base::eofbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream&  putback(_Elem _Ch) { 
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch))) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  unget() { 
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc())) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    [[nodiscard]] streamsize  gcount() const { 
        return _Chcount;
    }

    int  sync() { 
        const sentry _Ok(*this, true);

        const auto _Rdbuf = _Myios::rdbuf();
        if (!_Rdbuf) {
            return -1;
        }

        bool _Sync_failed = true; 
        try {
        _Sync_failed = _Rdbuf->pubsync() == -1;
        } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        if (_Sync_failed) {
            _Myios::setstate(ios_base::badbit);
            return -1;
        }

        return 0;
    }

    basic_istream&  seekg(pos_type _Pos) { 
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::in)) == -1) {
            _Myios::setstate(_State | ios_base::failbit);
        }

        return *this;
    }

    basic_istream&  seekg(
        off_type _Off, ios_base::seekdir _Way) { 
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)) == -1) {
            _Myios::setstate(_State | ios_base::failbit);
        }

        return *this;
    }

    pos_type  tellg() {
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
        } else {
            return pos_type(-1);
        }
    }

private:
    streamsize _Chcount; 
};

#pragma vtordisp(pop) 






























#line 705 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"

template <class _Elem, class _Traits>
class basic_iostream : public basic_istream<_Elem, _Traits>,
                       public basic_ostream<_Elem, _Traits> { 
public:
    using _Myis       = basic_istream<_Elem, _Traits>;
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Myios      = basic_ios<_Elem, _Traits>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit  basic_iostream(basic_streambuf<_Elem, _Traits>* _Strbuf)
        : _Myis(_Strbuf, false), _Myos(_Noinit, false) {}

protected:
     basic_iostream(basic_iostream&& _Right) : _Myis(_Right.rdbuf(), false), _Myos(_Noinit, false) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }

    basic_iostream&  operator=(basic_iostream&& _Right) {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_iostream& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
     basic_iostream(const basic_iostream&) = delete;
    basic_iostream&  operator=(const basic_iostream&) = delete;

    virtual  ~basic_iostream() noexcept {}
};











#line 757 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& _Istream_extract_into_buffer(
    basic_istream<_Elem, _Traits>& _Istr, size_t _Size, _Elem* _Str) {
    using _Myis              = basic_istream<_Elem, _Traits>;
    using _Ctype             = ctype<_Elem>;
    ios_base::iostate _State = ios_base::goodbit;
    size_t _Current          = 0;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());

        try {
        size_t _Count       = _Size;
        const size_t _Width = static_cast<size_t>(_Istr.width());
        if (_Width > 0 && _Width < _Size) {
            _Count = _Width;
        }

        typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
        _Elem _Ch;

        for (; _Current < _Count - 1; _Meta = _Istr.rdbuf()->snextc(), (void) ++_Current) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= ios_base::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Ch = _Traits::to_char_type(_Meta)) || _Ch == _Elem()) {
                break; 
            } else {
                _Str[_Current] = _Traits::to_char_type(_Meta); 
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }
    ; 
    _Str[_Current] = _Elem(); 
    _Istr.width(0);
    if (_Current == 0) {
        _State |= ios_base::failbit;
    }
    _Istr.setstate(_State);
    return _Istr;
}






















#line 824 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem* _Str) {
    return _Istream_extract_into_buffer(_Istr, 0xffffffffffffffffui64, _Str);
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, signed char* _Str) {
    return _Istream_extract_into_buffer(_Istr, 0xffffffffffffffffui64, reinterpret_cast<char*>(_Str));
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, unsigned char* _Str) {
    return _Istream_extract_into_buffer(_Istr, 0xffffffffffffffffui64, reinterpret_cast<char*>(_Str));
}
#line 839 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch) { 
    using _Myis = basic_istream<_Elem, _Traits>;

    typename _Myis::int_type _Meta;
    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        try {
        _Meta = _Istr.rdbuf()->sbumpc();
        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _State |= ios_base::eofbit | ios_base::failbit; 
        } else {
            _Ch = _Traits::to_char_type(_Meta); 
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }

    _Istr.setstate(_State);
    return _Istr;
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, signed char& _Ch) { 
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, unsigned char& _Ch) { 
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

template <class _Istr, class _Ty, class = void>
struct _Can_stream_in : false_type {};

template <class _Istr, class _Ty>
struct _Can_stream_in<_Istr, _Ty, void_t<decltype(::std:: declval<_Istr&>() >> ::std:: declval<_Ty>())>> : true_type {};

template <class _Istr, class _Ty,
    enable_if_t<conjunction_v<is_convertible<_Istr*, ios_base*>, _Can_stream_in<_Istr, _Ty>>, int> = 0>
_Istr&& operator>>(_Istr&& _Is, _Ty&& _Val) { 
    _Is >> ::std:: forward<_Ty>(_Val);
    return ::std:: move(_Is);
}

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& __cdecl ws(basic_istream<_Elem, _Traits>& _Istr) { 
    const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

    if (_Ok) { 
        ios_base::iostate _State = ios_base::goodbit;
        const auto& _Ctype_fac   = ::std:: use_facet<ctype<_Elem>>(_Istr.getloc());

        try {
        for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();; _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= ios_base::eofbit;
                break;
            } else if (!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta))) {
                break; 
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
        _Istr.setstate(_State);
    }

    return _Istr;
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 918 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
#line 919 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\istream"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )



namespace std {



















 extern  istream cin;
 extern  ostream cout;
 extern  ostream cerr;
 extern  ostream clog;
 extern  istream* _Ptr_cin;
 extern  ostream* _Ptr_cout;
 extern  ostream* _Ptr_cerr;
 extern  ostream* _Ptr_clog;

 extern  wistream wcin;
 extern  wostream wcout;
 extern  wostream wcerr;
 extern  wostream wclog;
 extern  wistream* _Ptr_wcin;
 extern  wostream* _Ptr_wcout;
 extern  wostream* _Ptr_wcerr;
 extern  wostream* _Ptr_wclog;

class  _Winit {
public:
    __thiscall _Winit();
    __thiscall ~_Winit() noexcept;

private:
     static int _Init_cnt;
};
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"
}


#pragma warning(pop)
#pragma pack(pop)
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\iostream"
#pragma external_header(pop)
#line 17 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"





#pragma once








#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Myvec>
class _Vector_const_iterator : public _Iterator_base {
public:



    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::const_pointer;
    using reference         = const value_type&;

    using _Tptr = typename _Myvec::pointer;

    inline _Vector_const_iterator() noexcept : _Ptr() {}

    inline _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {
        this->_Adopt(_Pvector);
    }

    [[nodiscard]] inline reference operator*() const noexcept {





#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return *_Ptr;
    }

    [[nodiscard]] inline pointer operator->() const noexcept {





#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return _Ptr;
    }

    inline _Vector_const_iterator& operator++() noexcept {




#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        ++_Ptr;
        return *this;
    }

    inline _Vector_const_iterator operator++(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    inline _Vector_const_iterator& operator--() noexcept {




#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        --_Ptr;
        return *this;
    }

    inline _Vector_const_iterator operator--(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    inline void _Verify_offset(const difference_type _Off) const noexcept {

        (void) _Off;










#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }

    inline _Vector_const_iterator& operator+=(const difference_type _Off) noexcept {
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }

    [[nodiscard]] inline _Vector_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp += _Off; 
        return _Tmp;
    }

    inline _Vector_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] inline _Vector_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp -= _Off; 
        return _Tmp;
    }

    [[nodiscard]] inline difference_type operator-(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] inline bool operator==(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }






#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    [[nodiscard]] bool operator!=(const _Vector_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }

    [[nodiscard]] bool operator>(const _Vector_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _Vector_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _Vector_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

    inline void _Compat(const _Vector_const_iterator& _Right) const noexcept {
        

        (void) _Right;


#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }







#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

    using _Prevent_inheriting_unwrap = _Vector_const_iterator;

    [[nodiscard]] inline const value_type* _Unwrapped() const noexcept {
        return _Unfancy(_Ptr);
    }

    inline void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));
    }

    _Tptr _Ptr; 
};

template <class _Myvec>
[[nodiscard]] inline _Vector_const_iterator<_Myvec> operator+(
    typename _Vector_const_iterator<_Myvec>::difference_type _Off, _Vector_const_iterator<_Myvec> _Next) noexcept {
    return _Next += _Off;
}


























#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

template <class _Myvec>
class _Vector_iterator : public _Vector_const_iterator<_Myvec> {
public:
    using _Mybase = _Vector_const_iterator<_Myvec>;




    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::pointer;
    using reference         = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] inline reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] inline pointer operator->() const noexcept {





#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return this->_Ptr;
    }

    inline _Vector_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    inline _Vector_iterator operator++(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _Vector_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    inline _Vector_iterator operator--(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _Vector_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] inline _Vector_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp += _Off; 
        return _Tmp;
    }

    inline _Vector_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] inline _Vector_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp -= _Off; 
        return _Tmp;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _Vector_iterator;

    [[nodiscard]] inline value_type* _Unwrapped() const noexcept {
        return _Unfancy(this->_Ptr);
    }
};

template <class _Myvec>
[[nodiscard]] inline _Vector_iterator<_Myvec> operator+(
    typename _Vector_iterator<_Myvec>::difference_type _Off, _Vector_iterator<_Myvec> _Next) noexcept {
    return _Next += _Off;
}


























#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference>
struct _Vec_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

struct _Value_init_tag { 
    explicit _Value_init_tag() = default;
};

template <class _Val_types>
class _Vector_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    inline _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

    inline _Vector_val(pointer _First, pointer _Last, pointer _End) noexcept
        : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

    inline void _Swap_val(_Vector_val& _Right) noexcept {
        this->_Swap_proxy_and_iterators(_Right);
        _Swap_adl(_Myfirst, _Right._Myfirst);
        _Swap_adl(_Mylast, _Right._Mylast);
        _Swap_adl(_Myend, _Right._Myend);
    }

    inline void _Take_contents(_Vector_val& _Right) noexcept {
        this->_Swap_proxy_and_iterators(_Right);
        _Myfirst = _Right._Myfirst;
        _Mylast  = _Right._Mylast;
        _Myend   = _Right._Myend;

        _Right._Myfirst = nullptr;
        _Right._Mylast  = nullptr;
        _Right._Myend   = nullptr;
    }

    pointer _Myfirst; 
    pointer _Mylast; 
    pointer _Myend; 
};

template <class _Ptrty>
constexpr auto _Unfancy_maybe_null(_Ptrty _Ptr) noexcept {
    
    return _Ptr ? ::std:: addressof(*_Ptr) : nullptr;
}

template <class _Ty>
constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { 
    return _Ptr;
}

template <class _Ty, class _Alloc = allocator<_Ty>>
class vector { 
private:
    template <class>
    friend class _Vb_val;
    friend _Tidy_guard<vector>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Ty>;
    using _Alty_traits = allocator_traits<_Alty>;

public:
    static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>,
        "vector<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

    using value_type      = _Ty;
    using allocator_type  = _Alloc;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = _Ty&;
    using const_reference = const _Ty&;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;

private:
    using _Scary_val = _Vector_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Ty>,
        _Vec_iter_types<_Ty, size_type, difference_type, pointer, const_pointer, _Ty&, const _Ty&>>>;

public:
    using iterator               = _Vector_iterator<_Scary_val>;
    using const_iterator         = _Vector_const_iterator<_Scary_val>;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    inline vector() noexcept(is_nothrow_default_constructible_v<_Alty>)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
    }

    inline explicit vector(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
    }

private:
    template <class _Ty2>
    inline void _Construct_n_copies_of_ty( const size_type _Count, const _Ty2& _Val) {
        auto&& _Alproxy = _Fake_alloc;
        auto& _My_data  = _Mypair._Myval2;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);
            _Guard._Target   = nullptr;
        }

        _Proxy._Release();
    }

public:
    inline explicit vector( const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
    }

    inline vector(
         const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n_copies_of_ty(_Count, _Val);
    }

private:
    template <class _Iter>
    inline void _Range_construct_or_tidy(_Iter _First, _Iter _Last, input_iterator_tag) {
        _Tidy_guard<vector> _Guard{this};
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); 
        }

        _Guard._Target = nullptr;
    }

    template <class _Iter>
    inline void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {
        const auto _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            auto& _My_data   = _Mypair._Myval2;
            _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);
            _Guard._Target   = nullptr;
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Adl_verify_range(_First, _Last);
        _Range_construct_or_tidy(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        _Proxy._Release();
    }

    inline vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        _Proxy._Release();
    }

    inline vector(const vector& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        auto&& _Alproxy           = _Fake_alloc;
        auto& _My_data            = _Mypair._Myval2;
        const auto& _Right_data   = _Right._Mypair._Myval2;
        const pointer _Rightfirst = _Right_data._Myfirst;
        const pointer _Rightlast  = _Right_data._Mylast;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        if (_Rightfirst != _Rightlast) {
            _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));
            _Tidy_guard<vector> _Guard{this};
            _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);
            _Guard._Target   = nullptr;
        }

        _Proxy._Release();
    }

    inline vector(const vector& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy           = _Fake_alloc;
        auto& _My_data            = _Mypair._Myval2;
        const auto& _Right_data   = _Right._Mypair._Myval2;
        const pointer _Rightfirst = _Right_data._Myfirst;
        const pointer _Rightlast  = _Right_data._Mylast;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        if (_Rightfirst != _Rightlast) {
            _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));
            _Tidy_guard<vector> _Guard{this};
            _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);
            _Guard._Target   = nullptr;
        }

        _Proxy._Release();
    }

private:
    inline void _Move_construct(vector& _Right, true_type) noexcept {
        
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
    }

    inline void _Move_construct(vector& _Right, false_type) {
        
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                const auto& _Right_data   = _Right._Mypair._Myval2;
                const pointer _Rightfirst = _Right_data._Myfirst;
                const pointer _Rightlast  = _Right_data._Mylast;
                if (_Rightfirst != _Rightlast) {
                    _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));
                    _Tidy_guard<vector> _Guard{this};
                    auto& _My_data   = _Mypair._Myval2;
                    _My_data._Mylast = _Umove(_Rightfirst, _Rightlast, _My_data._Myfirst);
                    _Guard._Target   = nullptr;
                }
                return;
            }
        }

        _Move_construct(_Right, true_type{});
    }

public:
    inline vector(vector&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal()),
            ::std:: exchange(_Right._Mypair._Myval2._Myfirst, nullptr),
            ::std:: exchange(_Right._Mypair._Myval2._Mylast, nullptr),
            ::std:: exchange(_Right._Mypair._Myval2._Myend, nullptr)) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    inline vector(vector&& _Right, const _Alloc& _Al) noexcept(
        _Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Move_construct(_Right, typename _Alty_traits::is_always_equal::type{});
        _Proxy._Release();
    }

private:
    inline void _Move_assign(vector& _Right, _Equal_allocators) noexcept {
        _Tidy();
        _Pocma(_Getal(), _Right._Getal());
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
    }

    inline void _Move_assign(vector& _Right, _Propagate_allocators) noexcept  {
        _Tidy();






#line 638 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        _Pocma(_Getal(), _Right._Getal());
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
    }

    inline void _Move_assign(vector& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            auto& _Right_data    = _Right._Mypair._Myval2;
            const pointer _First = _Right_data._Myfirst;
            const pointer _Last  = _Right_data._Mylast;
            const auto _Newsize  = static_cast<size_type>(_Last - _First);

            auto& _My_data    = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast  = _My_data._Mylast;

            _My_data._Orphan_all();

            const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
            if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Ty*, _Ty*>::_Trivially_copyable>,
                              _Uses_default_construct<_Alty, _Ty*, _Ty>, _Uses_default_destroy<_Alty, _Ty*>>) {
                if (_Newsize > _Oldcapacity) {
                    _Clear_and_reserve_geometric(_Newsize);
                }

                _Mylast = _Refancy<pointer>(_Copy_memmove(_Unfancy(_First), _Unfancy(_Last), _Unfancy(_Myfirst)));
            } else {
                auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

                if (_Newsize > _Oldsize) {
                    if (_Newsize > _Oldcapacity) { 
                        _Clear_and_reserve_geometric(_Newsize);
                        _Oldsize = 0;
                    }

                    const pointer _Mid = _First + _Oldsize;
                    _Move_unchecked(_First, _Mid, _Myfirst);
                    _Mylast = _Umove(_Mid, _Last, _Mylast);
                } else {
                    const pointer _Newlast = _Myfirst + _Newsize;
                    _Move_unchecked(_First, _Last, _Myfirst);
                    _Destroy(_Newlast, _Mylast);
                    _Mylast = _Newlast;
                }
            }
        }
    }

public:
    inline vector& operator=(vector&& _Right) noexcept(
        noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
        if (this != ::std:: addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }

        return *this;
    }

    inline ~vector() noexcept {
        _Tidy();



#line 704 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }

private:
    template <class... _Valty>
    inline decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {
        
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;
        ; 
        _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), ::std:: forward<_Valty>(_Val)...);
        _Orphan_range(_Mylast, _Mylast);
        _Ty& _Result = *_Mylast;
        ++_Mylast;


#line 720 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
        (void) _Result;
#line 722 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }

public:
    template <class... _Valty>
    inline decltype(auto) emplace_back(_Valty&&... _Val) {
        
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;
        if (_Mylast != _My_data._Myend) {
            return _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
        }

        _Ty& _Result = *_Emplace_reallocate(_Mylast, ::std:: forward<_Valty>(_Val)...);


#line 738 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
        (void) _Result;
#line 740 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }

    inline void push_back(const _Ty& _Val) { 
        emplace_back(_Val);
    }

    inline void push_back(_Ty&& _Val) {
        
        emplace_back(::std:: move(_Val));
    }

    template <class... _Valty>
    inline pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {
        
        _Alty& _Al        = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        ; 

        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
        const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

        if (_Oldsize == max_size()) {
            _Xlength();
        }

        const size_type _Newsize     = _Oldsize + 1;
        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec           = _Al.allocate(_Newcapacity);
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;
        pointer _Constructed_first      = _Constructed_last;

        try {
        _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), ::std:: forward<_Valty>(_Val)...);
        _Constructed_first = _Newvec + _Whereoff;

        if (_Whereptr == _Mylast) { 
            _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
        } else { 
            _Umove(_Myfirst, _Whereptr, _Newvec);
            _Constructed_first = _Newvec;
            _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
        }
        } catch (...) {
        _Destroy(_Constructed_first, _Constructed_last);
        _Al.deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Newsize, _Newcapacity);
        return _Newvec + _Whereoff;
    }

    template <class... _Valty>
    inline iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldlast  = _My_data._Mylast;




#line 807 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        if (_Oldlast != _My_data._Myend) {
            if (_Whereptr == _Oldlast) { 
                _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
            } else {
                auto& _Al = _Getal();
                _Alloc_temporary2<_Alty> _Obj(_Al, ::std:: forward<_Valty>(_Val)...); 
                
                _Orphan_range(_Whereptr, _Oldlast);
                _Alty_traits::construct(_Al, _Unfancy(_Oldlast), ::std:: move(_Oldlast[-1]));
                ++_My_data._Mylast;
                _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                *_Whereptr = ::std:: move(_Obj._Get_value());
            }

            return _Make_iterator(_Whereptr);
        }

        return _Make_iterator(_Emplace_reallocate(_Whereptr, ::std:: forward<_Valty>(_Val)...));
    }

    inline iterator insert(const_iterator _Where, const _Ty& _Val) { 
        return emplace(_Where, _Val);
    }

    inline iterator insert(const_iterator _Where, _Ty&& _Val) { 
        return emplace(_Where, ::std:: move(_Val));
    }

    inline iterator insert(
        const_iterator _Where,  const size_type _Count, const _Ty& _Val) {
        
        const pointer _Whereptr = _Where._Ptr;

        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst = _My_data._Myfirst;
        const pointer _Oldlast  = _Mylast;



#line 850 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        const auto _Whereoff        = static_cast<size_type>(_Whereptr - _Oldfirst);
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
        const bool _One_at_back     = _Count == 1 && _Whereptr == _Oldlast;
        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Getal().allocate(_Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            try {
            _Ufill(_Newvec + _Whereoff, _Count, _Val);
            _Constructed_first = _Newvec + _Whereoff;

            if (_One_at_back) { 
                _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
            } else { 
                _Umove(_Oldfirst, _Whereptr, _Newvec);
                _Constructed_first = _Newvec;
                _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
            }
            } catch (...) {
            _Destroy(_Constructed_first, _Constructed_last);
            _Getal().deallocate(_Newvec, _Newcapacity);
            throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else if (_One_at_back) { 
            _Emplace_back_with_unused_capacity(_Val);
        } else { 
            const _Alloc_temporary2<_Alty> _Tmp_storage(_Getal(), _Val); 
            const auto& _Tmp              = _Tmp_storage._Get_value();
            const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
            _Orphan_range(_Whereptr, _Oldlast);

            if (_Count > _Affected_elements) { 
                _Mylast = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
                _Mylast = _Umove(_Whereptr, _Oldlast, _Mylast);
                ::std:: fill(_Whereptr, _Oldlast, _Tmp);
            } else { 
                _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                ::std:: fill(_Whereptr, _Whereptr + _Count, _Tmp);
            }
        }

        return _Make_iterator_offset(_Whereoff);
    }

private:
    template <class _Iter>
    inline void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag) {
        
        if (_First == _Last) {
            return; 
        }

        auto& _My_data       = _Mypair._Myval2;
        pointer& _Myfirst    = _My_data._Myfirst;
        pointer& _Mylast     = _My_data._Mylast;
        const auto _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst);
        const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

        
        
        

        for (; _First != _Last; ++_First) {
            emplace_back(*_First);
        }

        _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);

        ::std:: rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
    }

    template <class _Iter>
    inline void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {
        
        const pointer _Whereptr = _Where._Ptr;
        const auto _Count       = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));

        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst     = _My_data._Myfirst;
        const pointer _Oldlast      = _Mylast;
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);

        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Getal().allocate(_Newcapacity);
            const auto _Whereoff            = static_cast<size_type>(_Whereptr - _Oldfirst);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            try {
            _Ucopy(_First, _Last, _Newvec + _Whereoff);
            _Constructed_first = _Newvec + _Whereoff;

            if (_Count == 1 && _Whereptr == _Oldlast) { 
                _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
            } else { 
                _Umove(_Oldfirst, _Whereptr, _Newvec);
                _Constructed_first = _Newvec;
                _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
            }
            } catch (...) {
            _Destroy(_Constructed_first, _Constructed_last);
            _Getal().deallocate(_Newvec, _Newcapacity);
            throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { 
                 
                 

            const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);

            if (_Count < _Affected_elements) { 
                _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                _Destroy(_Whereptr, _Whereptr + _Count);

                try {
                _Ucopy(_First, _Last, _Whereptr);
                } catch (...) {
                

                try {
                _Umove(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr);
                } catch (...) {
                
                _Orphan_range(_Whereptr, _Oldlast);
                _Destroy(_Whereptr + _Count, _Mylast);
                _Mylast = _Whereptr;
                throw;
                }

                _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
                _Destroy(_Oldlast, _Mylast);
                _Mylast = _Oldlast;
                throw;
                }
            } else { 
                const pointer _Relocated = _Whereptr + _Count;
                _Mylast                  = _Umove(_Whereptr, _Oldlast, _Relocated);
                _Destroy(_Whereptr, _Oldlast);

                try {
                _Ucopy(_First, _Last, _Whereptr);
                } catch (...) {
                

                try {
                _Umove(_Relocated, _Mylast, _Whereptr);
                } catch (...) {
                
                _Orphan_range(_Whereptr, _Oldlast);
                _Destroy(_Relocated, _Mylast);
                _Mylast = _Whereptr;
                throw;
                }

                _Destroy(_Relocated, _Mylast);
                _Mylast = _Oldlast;
                throw;
                }
            }

            _Orphan_range(_Whereptr, _Oldlast);
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;




#line 1055 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        _Adl_verify_range(_First, _Last);
        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
        _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        return _Make_iterator_offset(_Whereoff);
    }

    inline iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    inline void assign( const size_type _Newsize, const _Ty& _Val) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize > _Oldsize) {
            const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
            if (_Newsize > _Oldcapacity) { 
                _Clear_and_reserve_geometric(_Newsize);
                _Oldsize = 0;
            } else {
                ::std:: fill(_Myfirst, _Mylast, _Val);
            }

            _Mylast = _Ufill(_Mylast, _Newsize - _Oldsize, _Val);
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            ::std:: fill(_Myfirst, _Newlast, _Val);
            _Destroy(_Newlast, _Mylast);
            _Mylast = _Newlast;
        }
    }

private:
    template <class _Iter>
    inline void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        pointer _Next = _Myfirst;

        for (; _First != _Last && _Next != _Mylast; ++_First, (void) ++_Next) {
            *_Next = *_First;
        }

        
        
        
        

        
        _Destroy(_Next, _Mylast);
        _Mylast = _Next;

        
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); 
        }
    }

    template <class _Iter>
    inline void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {
        
        const auto _Newsize = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        auto& _My_data      = _Mypair._Myval2;
        pointer& _Myfirst   = _My_data._Myfirst;
        pointer& _Mylast    = _My_data._Mylast;
        pointer& _Myend     = _My_data._Myend;

        _My_data._Orphan_all();

        if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
                          _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
                          _Uses_default_destroy<_Alty, _Ty*>>) {



            {
                const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
                if (_Newsize > _Oldcapacity) {
                    _Clear_and_reserve_geometric(_Newsize);
                }

                _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));
                return;
            }
        }
        auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

        if (_Newsize > _Oldsize) {
            const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
            if (_Newsize > _Oldcapacity) { 
                _Clear_and_reserve_geometric(_Newsize);
                _Oldsize = 0;
            }

            
            const _Iter _Mid = ::std:: next(_First, static_cast<difference_type>(_Oldsize));
            _Copy_unchecked(_First, _Mid, _Myfirst);
            _Mylast = _Ucopy(_Mid, _Last, _Mylast);
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _Copy_unchecked(_First, _Last, _Myfirst);
            _Destroy(_Newlast, _Mylast);
            _Mylast = _Newlast;
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline void assign(_Iter _First, _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
    }

    inline void assign(initializer_list<_Ty> _Ilist) {
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
    }

private:
    inline void _Copy_assign(const vector& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        auto& _Right_data = _Right._Mypair._Myval2;
        assign(_Right_data._Myfirst, _Right_data._Mylast);
    }

    inline void _Copy_assign(const vector& _Right, true_type) {
        if (_Getal() != _Right._Getal()) {
            _Tidy();
            _Mypair._Myval2._Reload_proxy(
                _Fake_alloc, _Fake_alloc);
        }

        _Copy_assign(_Right, false_type{});
    }

public:
    inline vector& operator=(const vector& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }

        return *this;
    }

    inline vector& operator=(initializer_list<_Ty> _Ilist) {
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        return *this;
    }

private:
    template <class _Ty2>
    inline void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {
        if (_Newsize > max_size()) {
            _Xlength();
        }

        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);
        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec         = _Getal().allocate(_Newcapacity);
        const pointer _Appended_first = _Newvec + _Oldsize;
        pointer _Appended_last        = _Appended_first;

        try {
        _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);
        _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
        } catch (...) {
        _Destroy(_Appended_first, _Appended_last);
        _Getal().deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Newsize, _Newcapacity);
    }

    template <class _Ty2>
    inline void _Resize(const size_type _Newsize, const _Ty2& _Val) {
        
        auto& _My_data      = _Mypair._Myval2;
        pointer& _Myfirst   = _My_data._Myfirst;
        pointer& _Mylast    = _My_data._Mylast;
        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize < _Oldsize) { 
            const pointer _Newlast = _Myfirst + _Newsize;
            _Orphan_range(_Newlast, _Mylast);
            _Destroy(_Newlast, _Mylast);
            _Mylast = _Newlast;
            return;
        }

        if (_Newsize > _Oldsize) { 
            const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
            if (_Newsize > _Oldcapacity) { 
                _Resize_reallocate(_Newsize, _Val);
                return;
            }

            const pointer _Oldlast = _Mylast;
            _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);
            _Orphan_range(_Oldlast, _Oldlast);
        }

        
    }

public:
    inline void resize( const size_type _Newsize) {
        
        _Resize(_Newsize, _Value_init_tag{});
    }

    inline void resize( const size_type _Newsize, const _Ty& _Val) {
        
        _Resize(_Newsize, _Val);
    }

private:
    inline void _Reallocate_exactly(const size_type _Newcapacity) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

        const pointer _Newvec = _Getal().allocate(_Newcapacity);

        try {
        _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
        } catch (...) {
        _Getal().deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Size, _Newcapacity);
    }



















#line 1325 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

    inline void _Clear_and_reserve_geometric(const size_type _Newsize) {
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;




#line 1336 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        if (_Newsize > max_size()) {
            _Xlength();
        }

        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        if (_Myfirst) { 
            _Destroy(_Myfirst, _Mylast);
            _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }

        _Buy_raw(_Newcapacity);
    }

public:
    inline void reserve( const size_type _Newcapacity) {
        
        if (_Newcapacity > capacity()) { 
            if (_Newcapacity > max_size()) {
                _Xlength();
            }

            _Reallocate_exactly(_Newcapacity);
        }
    }

    inline void shrink_to_fit() { 
        auto& _My_data         = _Mypair._Myval2;
        const pointer _Oldlast = _My_data._Mylast;
        if (_Oldlast != _My_data._Myend) { 
            const pointer _Oldfirst = _My_data._Myfirst;
            if (_Oldfirst == _Oldlast) {
                _Tidy();
            } else {
                _Reallocate_exactly(static_cast<size_type>(_Oldlast - _Oldfirst));
            }
        }
    }

    inline void pop_back() noexcept  {
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;



#line 1387 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        _Orphan_range(_Mylast - 1, _Mylast);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        --_Mylast;
    }

    inline iterator erase(const_iterator _Where) noexcept(
        is_nothrow_move_assignable_v<value_type>)  {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        pointer& _Mylast        = _My_data._Mylast;





#line 1404 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        _Orphan_range(_Whereptr, _Mylast);
        _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        --_Mylast;
        return iterator(_Whereptr, ::std:: addressof(_My_data));
    }

    inline iterator erase(const_iterator _First, const_iterator _Last) noexcept(
        is_nothrow_move_assignable_v<value_type>)  {
        const pointer _Firstptr = _First._Ptr;
        const pointer _Lastptr  = _Last._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        pointer& _Mylast        = _My_data._Mylast;





#line 1424 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        if (_Firstptr != _Lastptr) { 
            _Orphan_range(_Firstptr, _Mylast);

            const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);
            _Destroy(_Newlast, _Mylast);
            _Mylast = _Newlast;
        }

        return iterator(_Firstptr, ::std:: addressof(_My_data));
    }

    inline void clear() noexcept { 
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();
        _Destroy(_Myfirst, _Mylast);
        _Mylast = _Myfirst;
    }

    inline void swap(vector& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Mypair._Myval2._Swap_val(_Right._Mypair._Myval2);
        }
    }

    [[nodiscard]] inline _Ty* data() noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] inline const _Ty* data() const noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] inline iterator begin() noexcept {
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline const_iterator begin() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Myfirst, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline iterator end() noexcept {
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Mylast, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline const_iterator end() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Mylast, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] inline reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] inline const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] inline const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] inline const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] inline const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] inline pointer _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myfirst;
    }

    [[nodiscard]] inline const_pointer _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myfirst;
    }

    [[nodiscard]] inline pointer _Unchecked_end() noexcept {
        return _Mypair._Myval2._Mylast;
    }

    [[nodiscard]] inline const_pointer _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Mylast;
    }

    [[nodiscard]] inline bool empty() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return _My_data._Myfirst == _My_data._Mylast;
    }

    [[nodiscard]] inline size_type size() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);
    }

    [[nodiscard]] inline size_type max_size() const noexcept {
        return (::std:: min)(
            static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
    }

    [[nodiscard]] inline size_type capacity() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);
    }

    [[nodiscard]] inline _Ty& operator[](const size_type _Pos) noexcept  {
        auto& _My_data = _Mypair._Myval2;



#line 1555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline const _Ty& operator[](const size_type _Pos) const noexcept  {
        auto& _My_data = _Mypair._Myval2;



#line 1565 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline _Ty& at(const size_type _Pos) {
        auto& _My_data = _Mypair._Myval2;
        if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline const _Ty& at(const size_type _Pos) const {
        auto& _My_data = _Mypair._Myval2;
        if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline _Ty& front() noexcept  {
        auto& _My_data = _Mypair._Myval2;


#line 1592 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return *_My_data._Myfirst;
    }

    [[nodiscard]] inline const _Ty& front() const noexcept  {
        auto& _My_data = _Mypair._Myval2;


#line 1601 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return *_My_data._Myfirst;
    }

    [[nodiscard]] inline _Ty& back() noexcept  {
        auto& _My_data = _Mypair._Myval2;


#line 1610 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return _My_data._Mylast[-1];
    }

    [[nodiscard]] inline const _Ty& back() const noexcept  {
        auto& _My_data = _Mypair._Myval2;


#line 1619 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return _My_data._Mylast[-1];
    }

    [[nodiscard]] inline allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    inline pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val) {
        
        return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());
    }

    inline pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {
        
        return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());
    }

    template <class _Iter>
    inline pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {
        
        return _Uninitialized_copy(_First, _Last, _Dest, _Getal());
    }

    inline pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {
        
        return _Uninitialized_move(_First, _Last, _Dest, _Getal());
    }

    inline void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {
        
        _Uninitialized_move(_First, _Last, _Dest, _Getal());
    }

    inline void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, false_type) {
        
        _Uninitialized_copy(_First, _Last, _Dest, _Getal());
    }

    inline void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {
        
        _Umove_if_noexcept1(_First, _Last, _Dest,
            bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
    }

    inline void _Destroy(pointer _First, pointer _Last) {
        
        _Destroy_range(_First, _Last, _Getal());
    }

    inline size_type _Calculate_growth(const size_type _Newsize) const {
        
        const size_type _Oldcapacity = capacity();
        const auto _Max              = max_size();

        if (_Oldcapacity > _Max - _Oldcapacity / 2) {
            return _Max; 
        }

        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

        if (_Geometric < _Newsize) {
            return _Newsize; 
        }

        return _Geometric; 
    }

    inline void _Buy_raw(const size_type _Newcapacity) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        ; 
        ;

        const auto _Newvec = _Getal().allocate(_Newcapacity);
        _Myfirst           = _Newvec;
        _Mylast            = _Newvec;
        _Myend             = _Newvec + _Newcapacity;
    }

    inline void _Buy_nonzero(const size_type _Newcapacity) {
        









        if (_Newcapacity > max_size()) {
            _Xlength();
        }

        _Buy_raw(_Newcapacity);
    }

    inline void _Change_array(
        const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        _My_data._Orphan_all();

        if (_Myfirst) { 
            _Destroy(_Myfirst, _Mylast);
            _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));
        }

        _Myfirst = _Newvec;
        _Mylast  = _Newvec + _Newsize;
        _Myend   = _Newvec + _Newcapacity;
    }

    inline void _Tidy() noexcept { 
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        _My_data._Orphan_all();

        if (_Myfirst) { 
            _Destroy(_Myfirst, _Mylast);
            _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }
    }

    [[noreturn]] static void _Xlength() {
        _Xlength_error("vector too long");
    }

    [[noreturn]] static void _Xrange() {
        _Xout_of_range("invalid vector subscript");
    }

































#line 1801 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    inline void _Orphan_range(pointer, pointer) const {}
#line 1803 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

    [[nodiscard]] inline _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline iterator _Make_iterator(const pointer _Ptr) noexcept {
        return iterator(_Ptr, ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline iterator _Make_iterator_offset(const size_type _Offset) noexcept {
        
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst + _Offset, ::std:: addressof(_My_data));
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};





#line 1830 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

template <class _Alloc>
class vector<bool, _Alloc>;

using _Vbase         = unsigned int; 
constexpr int _VBITS = 8 * sizeof(_Vbase); 

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator==(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    if (_Left.size() != _Right.size()) {
        return false;
    }

    if constexpr (is_same_v<_Ty, bool>) {
        return ::std:: equal(
            _Left._Myvec._Unchecked_begin(), _Left._Myvec._Unchecked_end(), _Right._Myvec._Unchecked_begin());
    } else {
        return ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
    }
}


template <class _Ty, class _Alloc>
[[nodiscard]] bool operator!=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Left == _Right);
}
#line 1857 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
















template <class _Ret>
struct _Vbase_compare_three_way {
    [[nodiscard]] constexpr _Ret operator()(const _Vbase _Left, const _Vbase _Right) const noexcept {
        const _Vbase _Differing_bits = _Left ^ _Right;

        if (_Differing_bits == 0) { 



            return 0;
#line 1884 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
        }

        const int _Bit_index = _Countr_zero(_Differing_bits); 
        ; 

        const _Vbase _Mask = _Vbase{1} << _Bit_index; 

        



        return (_Left & _Mask) == 0 ? -1 : 1;
#line 1897 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }
};



























template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    if constexpr (is_same_v<_Ty, bool>) {
        
        auto _First = _Left._Myvec._Unchecked_begin();
        auto _Other = _Right._Myvec._Unchecked_begin();

        const auto _Last = _First + (::std:: min)(_Left._Myvec.size(), _Right._Myvec.size());

        for (; _First != _Last; ++_First, (void) ++_Other) {
            using _Comp = _Vbase_compare_three_way<signed char>;
            const auto _Result = _Comp{}(*_First, *_Other);

            if (_Result < 0) {
                return true;
            } else if (_Result > 0) {
                return false;
            }
        }

        return _Left.size() < _Right.size();
    } else {
        return ::std:: lexicographical_compare(
            _Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin(), _Right._Unchecked_end());
    }
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return _Right < _Left;
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Right < _Left);
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Left < _Right);
}
#line 1968 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

template <class _Ty, class _Alloc>
inline void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}











#line 1985 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

template <class _Alloc0>
struct _Wrap_alloc { 
    using _Alloc = _Alloc0;
};

template <class _Alvbase_wrapped>
class _Vb_iter_base : public _Iterator_base {
    
public:
    using _Alvbase         = typename _Alvbase_wrapped::_Alloc;
    using _Size_type       = typename allocator_traits<_Alvbase>::size_type;
    using _Difference_type = typename allocator_traits<_Alvbase>::difference_type;
    using _Mycont          = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;

    inline _Vb_iter_base() = default;

    inline _Vb_iter_base(const _Vbase* _Ptr, _Size_type _Off, const _Container_base* _Mypvbool) noexcept
        : _Myptr(_Ptr), _Myoff(_Off) {
        this->_Adopt(_Mypvbool);
    }

    inline void _Advance(_Size_type _Off) noexcept {
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }





#line 2018 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

    const _Vbase* _Myptr = nullptr;
    _Size_type _Myoff    = 0;
};

template <class _Alvbase_wrapped>
class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped> {
    
    using _Mybase          = _Vb_iter_base<_Alvbase_wrapped>;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

    
    inline _Vb_reference() = default;

public:
    inline _Vb_reference(const _Vb_reference&) = default;

    inline _Vb_reference(const _Mybase& _Right) noexcept
        : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

    inline _Vb_reference& operator=(const _Vb_reference& _Right) noexcept {
        return *this = static_cast<bool>(_Right);
    }

    inline _Vb_reference& operator=(bool _Val) noexcept {
        if (_Val) {
            *const_cast<_Vbase*>(_Getptr()) |= _Mask();
        } else {
            *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();
        }

        return *this;
    }

    inline void flip() noexcept {
        *const_cast<_Vbase*>(_Getptr()) ^= _Mask();
    }

    inline operator bool() const noexcept {
        return (*_Getptr() & _Mask()) != 0;
    }

    inline const _Vbase* _Getptr() const noexcept {





#line 2068 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return this->_Myptr;
    }

    friend inline void swap(_Vb_reference _Left, _Vb_reference _Right) noexcept {
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }

protected:
    inline _Vbase _Mask() const noexcept {
        return static_cast<_Vbase>(1) << this->_Myoff;
    }
};

template <class _Alvbase_wrapped>
class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped> {
private:
    using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;

public:
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;
    using _Size_type       = typename _Mybase::_Size_type;
    using _Reft            = _Vb_reference<_Alvbase_wrapped>;
    using const_reference  = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::_Difference_type;
    using pointer           = const_reference*;
    using reference         = const_reference;

    inline _Vb_const_iterator() = default;

    inline _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept
        : _Mybase(_Ptr, 0, _Mypvbool) {}

    [[nodiscard]] inline const_reference operator*() const noexcept {





#line 2114 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return _Reft(*this);
    }

    inline _Vb_const_iterator& operator++() noexcept {
        _Inc();
        return *this;
    }

    inline _Vb_const_iterator operator++(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Inc();
        return _Tmp;
    }

    inline _Vb_const_iterator& operator--() noexcept {
        _Dec();
        return *this;
    }

    inline _Vb_const_iterator operator--(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Dec();
        return _Tmp;
    }

    inline _Vb_const_iterator& operator+=(const difference_type _Off) noexcept {












#line 2154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        if (_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off)) { 
            this->_Myoff += static_cast<_Size_type>(_Off);
            this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
            this->_Myoff %= _VBITS;
        } else { 
            this->_Myoff += static_cast<_Size_type>(_Off);
            this->_Myptr += this->_Myoff / _VBITS;
            this->_Myoff %= _VBITS;
        }
        return *this;
    }

    [[nodiscard]] inline _Vb_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp += _Off; 
        return _Tmp;
    }

    inline _Vb_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] inline _Vb_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp -= _Off; 
        return _Tmp;
    }

    [[nodiscard]] inline difference_type operator-(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return static_cast<difference_type>(_VBITS * (this->_Myptr - _Right._Myptr))
             + static_cast<difference_type>(this->_Myoff) - static_cast<difference_type>(_Right._Myoff);
    }

    [[nodiscard]] inline const_reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] inline bool operator==(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myptr == _Right._Myptr && this->_Myoff == _Right._Myoff;
    }









#line 2207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    [[nodiscard]] bool operator!=(const _Vb_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myptr < _Right._Myptr || (this->_Myptr == _Right._Myptr && this->_Myoff < _Right._Myoff);
    }

    [[nodiscard]] bool operator>(const _Vb_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _Vb_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _Vb_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 2228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

    inline void _Compat(const _Vb_const_iterator& _Right) const noexcept {
        

        (void) _Right;


#line 2236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }









#line 2247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

    inline void _Dec() noexcept { 




#line 2254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        if (this->_Myoff != 0) {
            --this->_Myoff;
        } else { 
            this->_Myoff = _VBITS - 1;
            --this->_Myptr;
        }
    }

    inline void _Inc() noexcept { 





#line 2270 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        if (this->_Myoff < _VBITS - 1) {
            ++this->_Myoff;
        } else { 
            this->_Myoff = 0;
            ++this->_Myptr;
        }
    }
};

template <class _Alvbase_wrapped>
[[nodiscard]] inline _Vb_const_iterator<_Alvbase_wrapped> operator+(
    typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off,
    _Vb_const_iterator<_Alvbase_wrapped> _Right) noexcept {
    return _Right += _Off;
}

template <class _Alvbase_wrapped>
class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped> {
public:
    using _Mybase          = _Vb_const_iterator<_Alvbase_wrapped>;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::difference_type;
    using pointer           = _Reft*;
    using reference         = _Reft;

    using _Mybase::_Mybase;

    [[nodiscard]] inline reference operator*() const noexcept {





#line 2312 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return _Reft(*this);
    }

    inline _Vb_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    inline _Vb_iterator operator++(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _Vb_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    inline _Vb_iterator operator--(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _Vb_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] inline _Vb_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp += _Off; 
        return _Tmp;
    }

    inline _Vb_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] inline _Vb_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp -= _Off; 
        return _Tmp;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    using _Prevent_inheriting_unwrap = _Vb_iterator;
};

template <class _Alvbase_wrapped>
[[nodiscard]] inline _Vb_iterator<_Alvbase_wrapped> operator+(
    typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off, _Vb_iterator<_Alvbase_wrapped> _Right) noexcept {
    return _Right += _Off;
}

template <class _Alloc>
class _Vb_val : public _Container_base {
public:
    using _Alvbase         = _Rebind_alloc_t<_Alloc, _Vbase>;
    using _Alvbase_traits  = allocator_traits<_Alvbase>;
    using _Vectype         = vector<_Vbase, _Alvbase>;
    using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
    using size_type        = typename _Alvbase_traits::size_type;

    inline _Vb_val() noexcept(is_nothrow_default_constructible_v<_Vectype>) : _Myvec(), _Mysize(0) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    inline _Vb_val(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Vectype, _Alvbase>)
        : _Myvec(static_cast<_Alvbase>(_Al)), _Mysize(0) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    inline _Vb_val(size_type _Count, const bool& _Val)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0)), _Mysize(0) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    inline _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)), _Mysize(0) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    inline _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    inline _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
        : _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    inline _Vb_val(_Vb_val&& _Right) noexcept(is_nothrow_move_constructible_v<_Vectype>)
        : _Myvec(::std:: move(_Right._Myvec)), _Mysize(::std:: exchange(_Right._Mysize, size_type{0})) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    inline _Vb_val(_Vb_val&& _Right, const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
        : _Myvec(::std:: move(_Right._Myvec), static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) {
        if (_Right._Myvec.empty()) {
            
            _Right._Mysize = 0;
        }

        this->_Alloc_proxy(_Fake_alloc);
    }

    inline ~_Vb_val() noexcept {




#line 2434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }

    inline _Alvbase& _Getal() noexcept {
        return _Myvec._Getal();
    }

    inline const _Alvbase& _Getal() const noexcept {
        return _Myvec._Getal();
    }

    static inline size_type _Nw(size_type _Count) noexcept {
        return (_Count + _VBITS - 1) / _VBITS;
    }

    _Vectype _Myvec; 
    size_type _Mysize; 
};

template <class _Alloc>
class vector<bool, _Alloc> : public _Vb_val<_Alloc> {
public:
    static_assert(!0 || is_same_v<bool, typename _Alloc::value_type>,
        "vector<bool, Allocator>" " requires that Allocator's value_type match " "bool" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

    using _Mybase          = _Vb_val<_Alloc>;
    using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
    using _Alvbase         = typename _Mybase::_Alvbase;
    using _Alvbase_traits  = typename _Mybase::_Alvbase_traits;

    using size_type       = typename _Alvbase_traits::size_type;
    using difference_type = typename _Alvbase_traits::difference_type;
    using allocator_type  = _Alloc;

    using reference       = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;
    using value_type      = bool;

    using _Reft          = reference;
    using iterator       = _Vb_iterator<_Alvbase_wrapped>;
    using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;

    using pointer                = iterator;
    using const_pointer          = const_iterator;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    static const int _VBITS = ::std:: _VBITS;
    enum { _EEN_VBITS = _VBITS }; 

    inline vector() noexcept(is_nothrow_default_constructible_v<_Mybase>) 
        : _Mybase() {}

    inline explicit vector(const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Mybase, const _Alloc&>) 
        : _Mybase(_Al) {}

    inline explicit vector( size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, false, _Al) {
        _Trim(_Count);
    }

    inline vector( size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, _Val, _Al) {
        _Trim(_Count);
    }

    inline vector(const vector& _Right) : _Mybase(_Right) {}

    inline vector(const vector& _Right, const _Alloc& _Al) : _Mybase(_Right, _Al) {}

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mybase(_Al) {
        _BConstruct(_First, _Last);
    }

    template <class _Iter>
    inline void _BConstruct(_Iter _First, _Iter _Last) {
        insert(begin(), _First, _Last);
    }

    inline vector(vector&& _Right) noexcept(is_nothrow_move_constructible_v<_Mybase>) 
        : _Mybase(::std:: move(_Right)) {
        this->_Swap_proxy_and_iterators(_Right);
    }

    inline vector(vector&& _Right, const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>)
        : _Mybase(::std:: move(_Right), _Al) {
        if constexpr (!_Alvbase_traits::is_always_equal::value) {
            if (this->_Getal() != _Right._Getal()) {
                return;
            }
        }

        this->_Swap_proxy_and_iterators(_Right);
    }

private:






































#line 2571 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

public:
    inline vector& operator=(vector&& _Right) noexcept(is_nothrow_move_assignable_v<_Mybase>) {
        if (this != ::std:: addressof(_Right)) {

            this->_Myvec  = ::std:: move(_Right._Myvec);
            this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});



#line 2582 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
        }
        return *this;
    }

    template <class... _Valty>
    inline decltype(auto) emplace_back(_Valty&&... _Val) {
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        push_back(_Tmp);



#line 2594 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
    }

    template <class... _Valty>
    inline iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        return insert(_Where, _Tmp);
    }

    inline vector(initializer_list<bool> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mybase(0, false, _Al) {
        insert(begin(), _Ilist.begin(), _Ilist.end());
    }

    inline vector& operator=(initializer_list<bool> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    inline void assign(initializer_list<bool> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
    }

    inline iterator insert(const_iterator _Where, initializer_list<bool> _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    inline ~vector() noexcept {}

private:




















#line 2644 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

public:
    inline vector& operator=(const vector& _Right) {
        if (this != ::std:: addressof(_Right)) {

            this->_Myvec  = _Right._Myvec;
            this->_Mysize = _Right._Mysize;



#line 2655 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
        }

        return *this;
    }

    inline void reserve( size_type _Count) {
        this->_Myvec.reserve(this->_Nw(_Count));
    }

    [[nodiscard]] inline size_type capacity() const noexcept {
        return this->_Myvec.capacity() * _VBITS;
    }

    [[nodiscard]] inline iterator begin() noexcept {
        return iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline const_iterator begin() const noexcept {
        return const_iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline iterator end() noexcept {
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator end() const noexcept {
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] inline const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] inline const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] inline iterator _Unchecked_begin() noexcept {
        return iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline const_iterator _Unchecked_begin() const noexcept {
        return const_iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline iterator _Unchecked_end() noexcept {
        return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator _Unchecked_end() const noexcept {
        return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
    }

    inline void shrink_to_fit() {
        if (this->_Myvec.capacity() != this->_Myvec.size()) {
            this->_Orphan_all();
            this->_Myvec.shrink_to_fit();
        }
    }

    inline iterator _Make_iter(const_iterator _Where) noexcept {
        iterator _Tmp = begin();
        if (0 < this->_Mysize) {
            _Tmp += _Where - begin();
        }

        return _Tmp;
    }

    [[nodiscard]] inline reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] inline reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] inline const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    inline void resize( size_type _Newsize, bool _Val = false) {
        if (size() < _Newsize) {
            _Insert_n(end(), _Newsize - size(), _Val);
        } else if (_Newsize < size()) {
            erase(begin() + static_cast<difference_type>(_Newsize), end());
        }
    }

    [[nodiscard]] inline size_type size() const noexcept {
        return this->_Mysize;
    }

    [[nodiscard]] inline size_type max_size() const noexcept {
        constexpr auto _Diff_max  = static_cast<size_type>((numeric_limits<difference_type>::max)());
        const size_type _Ints_max = this->_Myvec.max_size();
        if (_Ints_max > _Diff_max / _VBITS) { 
            return _Diff_max;
        }

        
        return _Ints_max * _VBITS;
    }

    [[nodiscard]] inline bool empty() const noexcept {
        return size() == 0;
    }

    [[nodiscard]] inline allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(this->_Myvec.get_allocator());
    }

    [[nodiscard]] inline const_reference at(size_type _Off) const {
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    [[nodiscard]] inline reference at(size_type _Off) {
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    [[nodiscard]] inline const_reference operator[](size_type _Off) const noexcept  {


#line 2799 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        const_iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    [[nodiscard]] inline reference operator[](size_type _Off) noexcept  {


#line 2809 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    [[nodiscard]] inline reference front() noexcept  {


#line 2819 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return *begin();
    }

    [[nodiscard]] inline const_reference front() const noexcept  {


#line 2827 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return *begin();
    }

    [[nodiscard]] inline reference back() noexcept  {


#line 2835 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return *(end() - 1);
    }

    [[nodiscard]] inline const_reference back() const noexcept  {


#line 2843 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        return *(end() - 1);
    }

    inline void push_back(const bool& _Val) {
        insert(end(), _Val);
    }

    inline void pop_back() noexcept  {
        erase(end() - 1);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline void assign(_Iter _First, _Iter _Last) {
        clear();
        insert(begin(), _First, _Last);
    }

    inline void assign( size_type _Count, const bool& _Val) {
        clear();
        _Insert_n(begin(), _Count, _Val);
    }

    inline iterator insert(const_iterator _Where, const bool& _Val) {
        return _Insert_n(_Where, static_cast<size_type>(1), _Val);
    }

    inline iterator insert(
        const_iterator _Where,  size_type _Count, const bool& _Val) {
        return _Insert_n(_Where, _Count, _Val);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        difference_type _Off = _Where - begin();
        _Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>{});
        return begin() + _Off;
    }

    template <class _Iter>
    inline void _Insert(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag) {
        difference_type _Off = _Where - begin();

        for (; _First != _Last; ++_First, (void) ++_Off) {
            insert(begin() + _Off, *_First);
        }
    }

    template <class _Iter>
    inline void _Insert(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {
        _Adl_verify_range(_First, _Last);
        auto _Count    = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        size_type _Off = _Insert_x(_Where, _Count);
        _Copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), begin() + static_cast<difference_type>(_Off));
    }

    inline iterator erase(const_iterator _Where_arg) noexcept  {
        iterator _Where      = _Make_iter(_Where_arg);
        difference_type _Off = _Where - begin();






#line 2909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
        ::std:: copy(_Next_iter(_Where), end(), _Where);
#line 2911 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        _Trim(this->_Mysize - 1);
        return begin() + _Off;
    }

    inline iterator erase(const_iterator _First_arg, const_iterator _Last_arg) noexcept
     {
        iterator _First      = _Make_iter(_First_arg);
        iterator _Last       = _Make_iter(_Last_arg);
        difference_type _Off = _First - begin();

        if (_First != _Last) { 







#line 2931 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
            iterator _Next = ::std:: copy(_Last, end(), _First);
            _Trim(static_cast<size_type>(_Next - begin()));
#line 2934 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
        }
        return begin() + _Off;
    }

    inline void clear() noexcept {
        this->_Orphan_all();
        this->_Myvec.clear();
        this->_Mysize = 0;
    }

    inline void flip() noexcept { 
        for (auto& _Elem : this->_Myvec) {
            _Elem = ~_Elem;
        }

        _Trim(this->_Mysize);
    }

    inline void swap(vector& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            this->_Swap_proxy_and_iterators(_Right);
            this->_Myvec.swap(_Right._Myvec);
            ::std:: swap(this->_Mysize, _Right._Mysize);
        }
    }

    static inline void swap(reference _Left, reference _Right) noexcept {
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }

    friend hash<vector<bool, _Alloc>>;

    inline iterator _Insert_n(const_iterator _Where, size_type _Count, const bool& _Val) {
        size_type _Off     = _Insert_x(_Where, _Count);
        const auto _Result = begin() + static_cast<difference_type>(_Off);
        ::std:: fill(_Result, _Result + static_cast<difference_type>(_Count), _Val);
        return _Result;
    }

    inline size_type _Insert_x(const_iterator _Where, size_type _Count) {
        difference_type _Off = _Where - begin();




#line 2982 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

        if (_Count != 0) {
            if (max_size() - size() < _Count) {
                _Xlen(); 
            }

            
            this->_Myvec.resize(this->_Nw(size() + _Count), 0);
            if (empty()) {
                this->_Mysize += _Count;
            } else { 
                iterator _Oldend = end();
                this->_Mysize += _Count;
                ::std:: copy_backward(begin() + _Off, _Oldend, end());
            }



#line 3001 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
        }

        return static_cast<size_type>(_Off);
    }







































#line 3045 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

    inline void _Trim(size_type _Size) {
        if (max_size() < _Size) {
            _Xlen(); 
        }

        const size_type _Words = this->_Nw(_Size);
        if (_Words < this->_Myvec.size()) {
            this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());
        }

        this->_Mysize = _Size;
        _Size %= _VBITS;
        if (0 < _Size) {
            this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
        }
    }

    [[noreturn]] void _Xlen() const {
        _Xlength_error("vector<bool> too long");
    }

    [[noreturn]] void _Xran() const {
        _Xout_of_range("invalid vector<bool> subscript");
    }
};

template <class _Alloc>
struct hash<vector<bool, _Alloc>> {
     typedef vector<bool, _Alloc> argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const vector<bool, _Alloc>& _Keyval) const noexcept {
        return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
    }
};






#line 3088 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"

template <class _Alloc, bool _RequiresMutable>
 constexpr bool _Is_vb_iterator<_Vb_iterator<_Alloc>, _RequiresMutable> = true;

template <class _Alloc>
 constexpr bool _Is_vb_iterator<_Vb_const_iterator<_Alloc>, false> = true;

template <class _FwdIt, class _Ty>
inline void _Fill_vbool(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    if (_First == _Last) {
        return;
    }

    _Vbase* _VbFirst      = const_cast<_Vbase*>(_First._Myptr);
    _Vbase* const _VbLast = const_cast<_Vbase*>(_Last._Myptr);

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;
    const auto _FirstDestMask   = ~_FirstSourceMask;
    const auto _FillVal         = static_cast<_Vbase>(_Val ? -1 : 0);

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _DestMask       = _FirstDestMask | _LastDestMask;
        *_VbFirst                  = (*_VbFirst & _DestMask) | (_FillVal & _SourceMask);
        return;
    }

    *_VbFirst = (*_VbFirst & _FirstDestMask) | (_FillVal & _FirstSourceMask);
    ++_VbFirst;








    {
        const auto _VbFirst_ch = reinterpret_cast<const char*>(_VbFirst);
        const auto _VbLast_ch  = reinterpret_cast<const char*>(_VbLast);
        const auto _Count_ch   = static_cast<size_t>(_VbLast_ch - _VbFirst_ch);
        const auto _ValChar    = static_cast<unsigned char>(_Val ? -1 : 0);
        :: memset(_VbFirst, _ValChar, _Count_ch);
        _VbFirst = _VbLast;
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        *_VbFirst                  = (*_VbFirst & _LastDestMask) | (_FillVal & _LastSourceMask);
    }
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 3151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
#line 3152 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vector"
#pragma external_header(pop)
#line 19 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    














#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\cassert"
#pragma external_header(pop)
#line 20 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"





#pragma once






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )





extern "C" {







__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_1(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_2(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_4(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_8(
    const void* _First, const void* _Last, void* _Dest) noexcept;
}
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

namespace std {
 constexpr int _ISORT_MAX = 32; 

template <class _It>
 constexpr auto _Isort_max = _Iter_diff_t<_It>{_ISORT_MAX};

template <class _Diff>
constexpr ptrdiff_t _Temporary_buffer_size(const _Diff _Value) noexcept {
    
    using _CT = common_type_t<ptrdiff_t, _Diff>;
    return static_cast<ptrdiff_t>((::std:: min)(static_cast<_CT>(9223372036854775807i64), static_cast<_CT>(_Value)));
}

template <class _Ty>
struct _Optimistic_temporary_buffer { 
    static constexpr size_t _Optimistic_size  = 4096; 
    static constexpr size_t _Optimistic_count = (::std:: max)(static_cast<size_t>(1), _Optimistic_size / sizeof(_Ty));

    template <class _Diff>
    explicit _Optimistic_temporary_buffer(const _Diff _Requested_size) noexcept { 
        const auto _Attempt = _Temporary_buffer_size(_Requested_size);
        
        
        if (static_cast<size_t>(_Requested_size) <= _Optimistic_count) { 
            _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
            _Capacity = static_cast<ptrdiff_t>(_Requested_size); 
            return;
        }

        const pair<_Ty*, ptrdiff_t> _Raw = _Get_temporary_buffer<_Ty>(_Attempt);
        if (static_cast<size_t>(_Raw.second) > _Optimistic_count) { 
            _Data     = _Raw.first;
            _Capacity = _Raw.second;
            return;
        }

        
        _Return_temporary_buffer(_Raw.first);
        _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
        _Capacity = _Optimistic_count;
    }

    _Optimistic_temporary_buffer(const _Optimistic_temporary_buffer&) = delete;
    _Optimistic_temporary_buffer& operator=(const _Optimistic_temporary_buffer&) = delete;

    ~_Optimistic_temporary_buffer() noexcept {
        if (static_cast<size_t>(_Capacity) > _Optimistic_count) {
            _Return_temporary_buffer(_Data);
        }
    }

    _Ty* _Data; 
    ptrdiff_t _Capacity;
    aligned_union_t<0, _Ty> _Stack_space[_Optimistic_count];
};




































































































































template <class _InIt, class _Fn>
inline _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        _Func(*_UFirst);
    }

    return _Func;
}

























#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"





















































































#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt, class _Pr>
[[nodiscard]] inline _InIt find_if_not(_InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}




#line 371 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt adjacent_find(const _FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UNext = _UFirst; ++_UNext != _ULast; _UFirst = _UNext) {
            if (_Pred(*_UFirst, *_UNext)) {
                _ULast = _UFirst;
                break;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

template <class _FwdIt>
[[nodiscard]] inline _FwdIt adjacent_find(const _FwdIt _First, const _FwdIt _Last) { 
    return ::std:: adjacent_find(_First, _Last, equal_to<>{});
}










#line 406 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

































































































template <class _InIt, class _Pr>
[[nodiscard]] inline _Iter_diff_t<_InIt> count_if(_InIt _First, _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst               = _Get_unwrapped(_First);
    const auto _ULast          = _Get_unwrapped(_Last);
    _Iter_diff_t<_InIt> _Count = 0;
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            ++_Count;
        }
    }

    return _Count;
}





#line 524 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"












































template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
        ++_UFirst1;
        ++_UFirst2;
    }

    _Seek_wrapped(_First2, _UFirst2);
    _Seek_wrapped(_First1, _UFirst1);
    return {_First1, _First2};
}





#line 590 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: mismatch(_First1, _Last1, _First2, equal_to<>{});
}










#line 607 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    auto _ULast1       = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_InIt1> && _Is_random_iter_v<_InIt2>) {
        using _CT         = _Common_diff_t<_InIt1, _InIt2>;
        const _CT _Count1 = _ULast1 - _UFirst1;
        const _CT _Count2 = _ULast2 - _UFirst2;
        const auto _Count = static_cast<_Iter_diff_t<_InIt1>>((::std:: min)(_Count1, _Count2));
        _ULast1           = _UFirst1 + _Count;
        while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst1;
            ++_UFirst2;
        }
    } else {
        while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2 && _Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _Seek_wrapped(_First2, _UFirst2);
    _Seek_wrapped(_First1, _UFirst1);
    return {_First1, _First2};
}





#line 645 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    
    return ::std:: mismatch(_First1, _Last1, _First2, _Last2, equal_to<>{});
}










#line 662 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"



































































































template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));

    for (;; ++_UFirst1, (void) ++_UFirst2) { 
        if (_UFirst1 == _ULast1) { 
            return true;
        }

        if (!_Pred(*_UFirst1, *_UFirst2)) { 
            break;
        }
    }

    
    
    const auto _Dist2 = static_cast<_Iter_diff_t<_FwdIt2>>(::std:: distance(_UFirst1, _ULast1));
    return _Check_match_counts(_UFirst1, _ULast1, _UFirst2, ::std:: next(_UFirst2, _Dist2), _Pass_fn(_Pred));
}

template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2) {
    
    return ::std:: is_permutation(_First1, _Last1, _First2, equal_to<>{});
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    forward_iterator_tag, forward_iterator_tag) {
    
    for (;; ++_First1, (void) ++_First2) { 
        if (_First1 == _Last1) {
            return _First2 == _Last2;
        }

        if (_First2 == _Last2) {
            return false;
        }

        if (!_Pred(*_First1, *_First2)) { 
            break;
        }
    }

    auto _Next1 = _First1;
    auto _Next2 = _First2;
    for (;; ++_Next1, (void) ++_Next2) { 
        if (_Next1 == _Last1) {
            if (_Next2 == _Last2) {
                return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
            }

            return false; 
        }

        if (_Next2 == _Last2) {
            return false; 
        }
    }
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    random_access_iterator_tag, random_access_iterator_tag) {
    
    if (_Last1 - _First1 != _Last2 - _First2) {
        return false;
    }

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) { 
        if (!_Pred(*_First1, *_First2)) {
            
            return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
        }
    }

    return true;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool is_permutation(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    return _Is_permutation_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1), _Get_unwrapped(_First2),
        _Get_unwrapped(_Last2), _Pass_fn(_Pred), _Iter_cat_t<_FwdIt1>{}, _Iter_cat_t<_FwdIt2>{});
}

template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) {
    
    return ::std:: is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>{});
}










































































































































































































































template <class _InIt, class _Pr>
[[nodiscard]] inline bool all_of(_InIt _First, _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            return false;
        }
    }

    return true;
}




#line 1111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"











































template <class _InIt, class _Pr>
[[nodiscard]] inline bool any_of(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            return true;
        }
    }

    return false;
}




#line 1173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"











































template <class _InIt, class _Pr>
[[nodiscard]] inline bool none_of(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            return false;
        }
    }

    return true;
}




#line 1235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"











































































































template <class _InIt, class _OutIt, class _Pr>
inline _OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}










#line 1369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"






































































































































































template <class _InIt, class _OutIt1, class _OutIt2, class _Pr>
inline pair<_OutIt1, _OutIt2> partition_copy(
    _InIt _First, _InIt _Last, _OutIt1 _Dest_true, _OutIt2 _Dest_false, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest_true  = _Get_unwrapped_unverified(_Dest_true);
    auto _UDest_false = _Get_unwrapped_unverified(_Dest_false);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UDest_true = *_UFirst;
            ++_UDest_true;
        } else {
            *_UDest_false = *_UFirst;
            ++_UDest_false;
        }
    }

    _Seek_wrapped(_Dest_false, _UDest_false);
    _Seek_wrapped(_Dest_true, _UDest_true);
    return {_Dest_true, _Dest_false};
}

















































































#line 1640 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt, class _Pr>
[[nodiscard]] inline bool is_partitioned(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    for (;; ++_UFirst) { 
        if (_UFirst == _ULast) {
            return true;
        }

        if (!_Pred(*_UFirst)) {
            break;
        }
    }

    while (++_UFirst != _ULast) { 
        if (_Pred(*_UFirst)) {
            return false; 
        }
    }

    return true;
}




#line 1671 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"





















































template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _Count       = ::std:: distance(_UFirst, _ULast);
    while (0 < _Count) { 
        const auto _Count2 = static_cast<_Iter_diff_t<_FwdIt>>(_Count / 2);
        const auto _UMid   = ::std:: next(_UFirst, _Count2);

        if (_Pred(*_UMid)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2;
            --_Count;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}



































































































template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool _Equal_rev_pred_unchecked(_InIt1 _First1, _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    if constexpr (_Equal_memcmp_is_safe<_InIt1, _InIt2, _Pr>) {



        {
            return _Memcmp_ranges(_First2, _Last2, _First1) == 0;
        }
    }

    for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
        if (!_Pred(*_First1, *_First2)) {
            return false;
        }
    }

    return true;
}

template <class _FwdItHaystack, class _FwdItPat, class _Pr>
[[nodiscard]] inline _FwdItHaystack search(_FwdItHaystack _First1, _FwdItHaystack _Last1, const _FwdItPat _First2,
    const _FwdItPat _Last2, _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_FwdItHaystack> && _Is_random_iter_v<_FwdItPat>) {
        const _Iter_diff_t<_FwdItPat> _Count2 = _ULast2 - _UFirst2;
        if (_ULast1 - _UFirst1 >= _Count2) {
            const auto _Last_possible = _ULast1 - static_cast<_Iter_diff_t<_FwdItHaystack>>(_Count2);
            for (;; ++_UFirst1) {
                if (_Equal_rev_pred_unchecked(_UFirst1, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
                    _Seek_wrapped(_Last1, _UFirst1);
                    break;
                }

                if (_UFirst1 == _Last_possible) {
                    break;
                }
            }
        }
    } else {
        for (;; ++_UFirst1) { 
            auto _UMid1 = _UFirst1;
            for (auto _UMid2 = _UFirst2;; ++_UMid1, (void) ++_UMid2) {
                if (_UMid2 == _ULast2) {
                    _Seek_wrapped(_Last1, _UFirst1);
                    return _Last1;
                } else if (_UMid1 == _ULast1) {
                    return _Last1;
                } else if (!_Pred(*_UMid1, *_UMid2)) {
                    break;
                }
            }
        }
    }

    return _Last1;
}





#line 1915 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _FwdItHaystack, class _FwdItPat>
[[nodiscard]] inline _FwdItHaystack search(
    const _FwdItHaystack _First1, const _FwdItHaystack _Last1, const _FwdItPat _First2, const _FwdItPat _Last2) {
    
    return ::std:: search(_First1, _Last1, _First2, _Last2, equal_to<>{});
}








#line 1931 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _FwdItHaystack, class _Searcher>
[[nodiscard]] inline _FwdItHaystack search(
    const _FwdItHaystack _First, const _FwdItHaystack _Last, const _Searcher& _Search) {
    
    return _Search(_First, _Last).first;
}

template <class _FwdIt, class _Diff, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt search_n(
    const _FwdIt _First, _FwdIt _Last, const _Diff _Count_raw, const _Ty& _Val, _Pr _Pred) {
    
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    if (static_cast<uintmax_t>(_Count) > static_cast<uintmax_t>((numeric_limits<_Iter_diff_t<_FwdIt>>::max)())) {
        
        return _Last;
    }

    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Is_random_iter_v<_FwdIt>) {
        const auto _Count_diff = static_cast<_Iter_diff_t<_FwdIt>>(_Count);
        auto _UOld_first       = _UFirst;
        for (_Iter_diff_t<_FwdIt> _Inc = 0; _Count_diff <= _ULast - _UOld_first;) { 
            _UFirst = _UOld_first + _Inc;
            if (_Pred(*_UFirst, _Val)) { 
                _Iter_diff_t<_FwdIt> _Count1 = _Count_diff;
                auto _UMid                   = _UFirst;

                while (_UOld_first != _UFirst && _Pred(*_Prev_iter(_UFirst), _Val)) { 
                    --_Count1;
                    --_UFirst;
                }

                if (_Count1 <= _ULast - _UMid) {
                    for (;;) { 
                        if (--_Count1 == 0) {
                            _Seek_wrapped(_Last, _UFirst); 
                            return _Last;
                        } else if (!_Pred(*++_UMid, _Val)) { 
                            break;
                        }
                    }
                }
                _UOld_first = ++_UMid; 
                _Inc        = 0;
            } else { 
                _UOld_first = _Next_iter(_UFirst);
                _Inc        = _Count_diff - 1;
            }
        }
    } else {
        for (; _UFirst != _ULast; ++_UFirst) {
            if (_Pred(*_UFirst, _Val)) { 
                auto _UMid = _UFirst;

                for (_Algorithm_int_t<_Diff> _Count1 = _Count;;) {
                    if (--_Count1 == 0) {
                        _Seek_wrapped(_Last, _UFirst); 
                        return _Last;
                    } else if (++_UMid == _ULast) {
                        return _Last; 
                    } else if (!_Pred(*_UMid, _Val)) { 
                        break;
                    }
                }

                _UFirst = _UMid; 
            }
        }
    }

    return _Last;
}





#line 2016 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _FwdIt, class _Diff, class _Ty>
[[nodiscard]] inline _FwdIt search_n(const _FwdIt _First, const _FwdIt _Last, const _Diff _Count, const _Ty& _Val) {
    
    return ::std:: search_n(_First, _Last, _Count, _Val, equal_to<>{});
}







#line 2030 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"




































































































































































template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline _FwdIt1 find_end(
    _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_FwdIt1> && _Is_random_iter_v<_FwdIt2>) {
        const _Iter_diff_t<_FwdIt2> _Count2 = _ULast2 - _UFirst2;
        if (_Count2 > 0 && _Count2 <= _ULast1 - _UFirst1) {
            for (auto _UCandidate = _ULast1 - static_cast<_Iter_diff_t<_FwdIt1>>(_Count2);; --_UCandidate) {
                if (_Equal_rev_pred_unchecked(_UCandidate, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
                    _Seek_wrapped(_First1, _UCandidate);
                    return _First1;
                }

                if (_UCandidate == _UFirst1) {
                    break;
                }
            }
        }

        return _Last1;
    } else if constexpr (_Is_bidi_iter_v<_FwdIt1> && _Is_bidi_iter_v<_FwdIt2>) {
        for (auto _UCandidate = _ULast1;; --_UCandidate) { 
            auto _UNext1 = _UCandidate;
            auto _UNext2 = _ULast2;
            for (;;) { 
                if (_UFirst2 == _UNext2) { 
                    _Seek_wrapped(_First1, _UNext1);
                    return _First1;
                }

                if (_UFirst1 == _UNext1) {
                    
                    return _Last1;
                }

                --_UNext1;
                --_UNext2;
                if (!_Pred(*_UNext1, *_UNext2)) { 
                    break;
                }
            }
        }
    } else {
        auto _UResult = _ULast1;
        for (;;) { 
            auto _UNext1 = _UFirst1;
            auto _UNext2 = _UFirst2;
            for (;;) { 
                const bool _End_of_needle = static_cast<bool>(_UNext2 == _ULast2);
                if (_End_of_needle) { 
                    _UResult = _UFirst1;
                }

                if (_UNext1 == _ULast1) {
                    
                    _Seek_wrapped(_First1, _UResult);
                    return _First1;
                }

                if (_End_of_needle || !_Pred(*_UNext1, *_UNext2)) {
                    break; 
                }

                ++_UNext1;
                ++_UNext2;
            }

            ++_UFirst1;
        }

        _Seek_wrapped(_First1, _UResult);
        return _First1;
    }
}

template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline _FwdIt1 find_end(
    _FwdIt1 const _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2) {
    
    return ::std:: find_end(_First1, _Last1, _First2, _Last2, equal_to<>{});
}











#line 2293 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"






































































































































































template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline _FwdIt1 find_first_of(
    _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    for (; _UFirst1 != _ULast1; ++_UFirst1) {
        for (auto _UMid2 = _UFirst2; _UMid2 != _ULast2; ++_UMid2) {
            if (_Pred(*_UFirst1, *_UMid2)) {
                _Seek_wrapped(_First1, _UFirst1);
                return _First1;
            }
        }
    }

    _Seek_wrapped(_First1, _UFirst1);
    return _First1;
}

template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline _FwdIt1 find_first_of(const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) { 
    return ::std:: find_first_of(_First1, _Last1, _First2, _Last2, equal_to<>{});
}











#line 2499 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"



























































































































template <class _FwdIt1, class _FwdIt2>
inline _FwdIt2 swap_ranges(const _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    
    _Adl_verify_range(_First1, _Last1);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
    _Seek_wrapped(_First2, _Swap_ranges_unchecked(_UFirst1, _ULast1, _UFirst2));
    return _First2;
}








#line 2641 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt, class _OutIt, class _Fn>
inline _OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        *_UDest = _Func(*_UFirst);
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}





#line 2662 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Fn>
inline _OutIt transform(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest, _Fn _Func) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    const auto _Count  = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Count);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Count);
    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2, ++_UDest) {
        *_UDest = _Func(*_UFirst1, *_UFirst2);
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}





#line 2686 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
















































































































template <class _FwdIt, class _Ty>
inline void replace(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Oldval, const _Ty& _Newval) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (*_UFirst == _Oldval) {
            *_UFirst = _Newval;
        }
    }
}





#line 2816 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"


























































template <class _FwdIt, class _Pr, class _Ty>
inline void replace_if(const _FwdIt _First, const _FwdIt _Last, _Pr _Pred, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UFirst = _Val;
        }
    }
}




#line 2891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

























































template <class _InIt, class _OutIt, class _Ty>
inline _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        if (*_UFirst == _Oldval) {
            *_UDest = _Newval;
        } else {
            *_UDest = *_UFirst;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}











#line 2978 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

































































template <class _InIt, class _OutIt, class _Pr, class _Ty>
inline _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        if (_Pred(*_UFirst)) {
            *_UDest = _Val;
        } else {
            *_UDest = *_UFirst;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}











#line 3073 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"















































































































































































template <class _FwdIt, class _Fn>
inline void generate(_FwdIt _First, _FwdIt _Last, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        *_UFirst = _Func();
    }
}








#line 3266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _OutIt, class _Diff, class _Fn>
inline _OutIt generate_n(_OutIt _Dest, const _Diff _Count_raw, _Fn _Func) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UDest = _Get_unwrapped_n(_Dest, _Count);
        do {
            *_UDest = _Func();
            --_Count;
            ++_UDest;
        } while (0 < _Count);

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}









#line 3294 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt, class _OutIt, class _Ty>
inline _OutIt remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!(*_UFirst == _Val)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}










#line 3323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt, class _OutIt, class _Pr>
inline _OutIt remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}










#line 3352 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"








#line 3361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"







































































































































































































































template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UFirstb = _UFirst; ++_UFirst != _ULast; _UFirstb = _UFirst) {
            if (_Pred(*_UFirstb, *_UFirst)) { 
                while (++_UFirst != _ULast) {
                    if (!_Pred(*_UFirstb, *_UFirst)) {
                        *++_UFirstb = ::std:: move(*_UFirst);
                    }
                }

                _Seek_wrapped(_Last, ++_UFirstb);
                return _Last;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

template <class _FwdIt>
[[nodiscard]] inline _FwdIt unique(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: unique(_First, _Last, equal_to<>{});
}















#line 3637 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"








































































template <class _InIt, class _OutIt>
 constexpr bool _Can_reread_dest =
    _Is_fwd_iter_v<_OutIt> && is_same_v<_Iter_value_t<_InIt>, _Iter_value_t<_OutIt>>;
#line 3713 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"


template <class _InIt, class _OutIt, class _Pr>
inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);

    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    if (_UFirst == _ULast) {
        return _Dest;
    }

    auto _UDest = _Get_unwrapped_unverified(_Dest);

    if constexpr (_Is_fwd_iter_v<_InIt>) { 
        auto _Firstb = _UFirst;

        *_UDest = *_Firstb;
        ++_UDest;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(*_Firstb, *_UFirst))) { 
                _Firstb = _UFirst;
                *_UDest = *_Firstb;
                ++_UDest;
            }
        }
    } else if constexpr (_Can_reread_dest<_InIt, _OutIt>) { 
        *_UDest = *_UFirst;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(*_UDest, *_UFirst))) {
                *++_UDest = *_UFirst;
            }
        }

        ++_UDest;
    } else { 
        _Iter_value_t<_InIt> _Val = *_UFirst;

        *_UDest = _Val;
        ++_UDest;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(_Val, *_UFirst))) { 
                _Val    = *_UFirst;
                *_UDest = _Val;
                ++_UDest;
            }
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}

template <class _InIt, class _OutIt>
inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    return ::std:: unique_copy(_First, _Last, _Dest, equal_to<>{});
}



















#line 3795 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

















































































































































































template <class _BidIt, class _OutIt>
inline _OutIt reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_BidIt>(_UFirst, _ULast));


    using _Elem                         = remove_reference_t<_Iter_ref_t<remove_const_t<decltype(_UFirst)>>>;
    using _DestElem                     = remove_reference_t<_Iter_ref_t<decltype(_UDest)>>;
    constexpr bool _Allow_vectorization = conjunction_v<is_same<remove_const_t<_Elem>, _DestElem>,
        bool_constant<_Iterators_are_contiguous<decltype(_UFirst), decltype(_UDest)>>, is_trivially_copyable<_Elem>,
        negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

#pragma warning(suppress : 6326) 
    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {



        {
            if constexpr (_Nx == 1) {
                __std_reverse_copy_trivially_copyable_1(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else if constexpr (_Nx == 2) {
                __std_reverse_copy_trivially_copyable_2(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else if constexpr (_Nx == 4) {
                __std_reverse_copy_trivially_copyable_4(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else {
                __std_reverse_copy_trivially_copyable_8(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            }

            _UDest += _ULast - _UFirst;
            _Seek_wrapped(_Dest, _UDest);
            return _Dest;
        }
    }
#line 4010 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

    for (; _UFirst != _ULast; ++_UDest) {
        *_UDest = *--_ULast;
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
































































































#line 4115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"















































































































template <class _FwdIt, class _OutIt>
inline _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _UMid   = _Get_unwrapped(_Mid);
    const auto _ULast  = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_FwdIt>(_UFirst, _ULast));
    _UDest             = _Copy_unchecked(_UMid, _ULast, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _UMid, _UDest));
    return _Dest;
}










































































































































































































































































#line 4506 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _RanIt, class _RngFn>
void _Random_shuffle1(_RanIt _First, _RanIt _Last, _RngFn& _RngFunc) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _ULast) {
        return;
    }

    using _Diff         = _Iter_diff_t<_RanIt>;
    auto _UTarget       = _UFirst;
    _Diff _Target_index = 1;
    for (; ++_UTarget != _ULast; ++_Target_index) { 
        _Diff _Off = _RngFunc(static_cast<_Diff>(_Target_index + 1));
        ;
        if (_Off != _Target_index) { 
            ::std:: iter_swap(_UTarget, _UFirst + _Off);
        }
    }
}

template <class _RanIt, class _Urng>
void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func) { 
    using _Urng0 = remove_reference_t<_Urng>;
    _Rng_from_urng<_Iter_diff_t<_RanIt>, _Urng0> _RngFunc(_Func);
    _Random_shuffle1(_First, _Last, _RngFunc);
}





























































template <class _RanIt, class _RngFn>
void random_shuffle(_RanIt _First, _RanIt _Last, _RngFn&& _RngFunc) {
    
    _Random_shuffle1(_First, _Last, _RngFunc);
}

struct _Rand_urng_from_func { 
    using result_type = unsigned int;

    static result_type(min)() { 
        return 0;
    }

    static result_type(max)() { 
        return 0x7fff;
    }

    result_type operator()() { 
        return static_cast<result_type>(:: rand());
    }
};

template <class _RanIt>
void random_shuffle(_RanIt _First, _RanIt _Last) { 
    _Rand_urng_from_func _Func;
    ::std:: shuffle(_First, _Last, _Func);
}
#line 4624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"























































































































#line 4744 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _FwdIt, class _Pr>
inline _FwdIt partition(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if constexpr (_Is_bidi_iter_v<_FwdIt>) {
        for (;;) { 
            for (;;) { 
                if (_UFirst == _ULast) {
                    _Seek_wrapped(_First, _UFirst);
                    return _First;
                }

                if (!_Pred(*_UFirst)) {
                    break;
                }

                ++_UFirst;
            }

            do { 
                --_ULast;
                if (_UFirst == _ULast) {
                    _Seek_wrapped(_First, _UFirst);
                    return _First;
                }
            } while (!_Pred(*_ULast));

            ::std:: iter_swap(_UFirst, _ULast); 
            ++_UFirst;
        }
    } else {
        for (;;) { 
            if (_UFirst == _ULast) {
                _Seek_wrapped(_First, _UFirst);
                return _First;
            }

            if (!_Pred(*_UFirst)) {
                break;
            }

            ++_UFirst;
        }

        for (auto _UNext = _UFirst; ++_UNext != _ULast;) {
            if (_Pred(*_UNext)) {
                ::std:: iter_swap(_UFirst, _UNext); 
                ++_UFirst;
            }
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}























































































#line 4890 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _BidIt>
_BidIt _Buffered_rotate_unchecked(const _BidIt _First, const _BidIt _Mid, const _BidIt _Last,
    const _Iter_diff_t<_BidIt> _Count1, const _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr,
    const ptrdiff_t _Capacity) { 
                                 
                                 
    if (_Count1 == 0) {
        return _Last;
    }

    if (_Count2 == 0) {
        return _First;
    }

    if (_Count1 <= _Count2 && _Count1 <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
            _Temp_ptr, _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
        const _BidIt _New_mid = _Move_unchecked(_Mid, _Last, _First);
        _Move_unchecked(_Backout._First, _Backout._Last, _New_mid);
        return _New_mid; 
    }

    if (_Count2 <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
            _Temp_ptr, _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
        _Move_backward_unchecked(_First, _Mid, _Last);
        return _Move_unchecked(_Backout._First, _Backout._Last, _First); 
    }

    
    return ::std:: rotate(_First, _Mid, _Last);
}

template <class _BidIt, class _Pr>
pair<_BidIt, _Iter_diff_t<_BidIt>> _Stable_partition_unchecked1(_BidIt _First, _BidIt _Last, _Pr _Pred,
    const _Iter_diff_t<_BidIt> _Count, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity) {
    
    
    
    
    
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count - static_cast<_Diff>(1) <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr};
        _BidIt _Next = _First;
        _Backout._Emplace_back(::std:: move(*_First));
        while (++_First != _Last) { 
                                    
            if (_Pred(*_First)) {
                *_Next = ::std:: move(*_First);
                ++_Next;
            } else {
                _Backout._Emplace_back(::std:: move(*_First));
            }
        }

        
        *_Next = ::std:: move(*_Last);
        ++_Next;
        _Move_unchecked(_Backout._First, _Backout._Last, _Next); 
        _Diff _True_distance = static_cast<_Diff>(_Count - static_cast<_Diff>(_Backout._Last - _Backout._First));
        return pair<_BidIt, _Diff>(_Next, _True_distance); 
    }

    const _Diff _Mid_offset = _Count / static_cast<_Diff>(2); 
    const _BidIt _Mid       = ::std:: next(_First, _Mid_offset);

    
    _BidIt _Left           = _Mid;
    _Diff _Left_true_count = _Mid_offset;
    for (;;) { 
        --_Left;
        if (_First == _Left) { 
            --_Left_true_count; 
            break;
        }

        if (_Pred(*_Left)) { 
            const pair<_BidIt, _Diff> _Low =
                _Stable_partition_unchecked1(_First, _Left, _Pred, _Left_true_count, _Temp_ptr, _Capacity);
            _Left            = _Low.first;
            _Left_true_count = _Low.second;
            break;
        }

        --_Left_true_count;
    }

    
    _BidIt _Right           = _Mid;
    _Diff _Right_true_count = 0;
    for (;;) { 
        if (_Right == _Last) { 
            ++_Right; 
            ++_Right_true_count;
            break;
        }

        if (!_Pred(*_Right)) { 
            const _Diff _Right_count = _Count - _Mid_offset;
            const _Diff _Remaining   = _Right_count - _Right_true_count;
            const pair<_BidIt, _Diff> _High =
                _Stable_partition_unchecked1(_Right, _Last, _Pred, _Remaining, _Temp_ptr, _Capacity);
            _Right = _High.first;
            _Right_true_count += _High.second;
            break;
        }

        ++_Right;
        ++_Right_true_count;
    }

    
    const _BidIt _Partition_point = _Buffered_rotate_unchecked(_Left, _Mid, _Right,
        static_cast<_Diff>(_Mid_offset - _Left_true_count), _Right_true_count, _Temp_ptr, _Capacity);
    return pair<_BidIt, _Diff>(_Partition_point, static_cast<_Diff>(_Left_true_count + _Right_true_count));
}

template <class _BidIt, class _Pr>
_BidIt _Stable_partition_unchecked(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    for (;;) {
        if (_First == _Last) { 
            return _First;
        }

        if (!_Pred(*_First)) { 
            break;
        }

        ++_First;
    }

    for (;;) {
        --_Last;
        if (_First == _Last) { 
            return _First;
        }

        if (_Pred(*_Last)) { 
            break;
        }
    }

    using _Diff              = _Iter_diff_t<_BidIt>;
    const _Diff _Temp_count  = ::std:: distance(_First, _Last); 
    const _Diff _Total_count = _Temp_count + static_cast<_Diff>(1);
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Temp_count};
    return _Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity).first;
}

template <class _BidIt, class _Pr>
_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Stable_partition_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}








#line 5059 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"











































































































































































































template <class _RanIt, class _Ty, class _Pr>
inline void _Push_heap_by_index(
    _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {
    
    using _Diff = _Iter_diff_t<_RanIt>;
    for (_Diff _Idx = (_Hole - 1) >> 1; 
         _Top < _Hole && static_cast<bool>(_Pred(*(_First + _Idx), _Val)); 
         _Idx = (_Hole - 1) >> 1) { 
        
        *(_First + _Hole) = ::std:: move(*(_First + _Idx));
        _Hole             = _Idx;
    }

    *(_First + _Hole) = ::std:: forward<_Ty>(_Val); 
}

template <class _RanIt, class _Pr>
inline void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    using _Diff        = _Iter_diff_t<_RanIt>;
    _Diff _Count       = _ULast - _UFirst;
    if (2 <= _Count) {
        _Iter_value_t<_RanIt> _Val = ::std:: move(*--_ULast);
        _Push_heap_by_index(_UFirst, --_Count, _Diff(0), ::std:: move(_Val), _Pass_fn(_Pred));
    }
}

template <class _RanIt>
inline void push_heap(_RanIt _First, _RanIt _Last) {
    
    ::std:: push_heap(_First, _Last, less<>{});
}












































































template <class _RanIt, class _Ty, class _Pr>
inline void _Pop_heap_hole_by_index(
    _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {
    
    ;

    using _Diff      = _Iter_diff_t<_RanIt>;
    const _Diff _Top = _Hole;
    _Diff _Idx       = _Hole;

    
    
    const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; 
    while (_Idx < _Max_sequence_non_leaf) { 
        _Idx = 2 * _Idx + 2;
        if (static_cast<bool>(_Pred(*(_First + _Idx), *(_First + (_Idx - 1))))) {
            --_Idx;
        }
        *(_First + _Hole) = ::std:: move(*(_First + _Idx));
        _Hole             = _Idx;
    }

    if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { 
        *(_First + _Hole) = ::std:: move(*(_First + (_Bottom - 1)));
        _Hole             = _Bottom - 1;
    }

    _Push_heap_by_index(_First, _Hole, _Top, ::std:: forward<_Ty>(_Val), _Pred);
}

template <class _RanIt, class _Ty, class _Pr>
inline void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {
    
    
    
    *_Dest      = ::std:: move(*_First);
    using _Diff = _Iter_diff_t<_RanIt>;
    _Pop_heap_hole_by_index(
        _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), ::std:: forward<_Ty>(_Val), _Pred);
}

template <class _RanIt, class _Pr>
inline void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    if (2 <= _Last - _First) {
        --_Last;
        _Iter_value_t<_RanIt> _Val = ::std:: move(*_Last);
        _Pop_heap_hole_unchecked(_First, _Last, _Last, ::std:: move(_Val), _Pred);
    }
}

template <class _RanIt, class _Pr>
inline void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
}

template <class _RanIt>
inline void pop_heap(_RanIt _First, _RanIt _Last) {
    
    ::std:: pop_heap(_First, _Last, less<>{});
}











































































































template <class _RanIt, class _Pr>
inline void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    using _Diff   = _Iter_diff_t<_RanIt>;
    _Diff _Bottom = _Last - _First;
    for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { 
        
        --_Hole;
        _Iter_value_t<_RanIt> _Val = ::std:: move(*(_First + _Hole));
        _Pop_heap_hole_by_index(_First, _Hole, _Bottom, ::std:: move(_Val), _Pred);
    }
}

template <class _RanIt, class _Pr>
inline void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Make_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
}

template <class _RanIt>
inline void make_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: make_heap(_First, _Last, less<>{});
}

























































template <class _RanIt, class _Pr>
inline _RanIt _Is_heap_until_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    using _Diff       = _Iter_diff_t<_RanIt>;
    const _Diff _Size = _Last - _First;
    for (_Diff _Off = 1; _Off < _Size; ++_Off) {
        if (static_cast<bool>(_Pred(*(_First + ((_Off - 1) >> 1)), *(_First + _Off)))) { 
            return _First + _Off;
        }
    }

    return _Last;
}

template <class _RanIt, class _Pr>
[[nodiscard]] inline _RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Is_heap_until_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

template <class _RanIt, class _Pr>
[[nodiscard]] inline bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    return _Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast;
}

template <class _RanIt>
[[nodiscard]] inline _RanIt is_heap_until(_RanIt _First, _RanIt _Last) {
    
    return ::std:: is_heap_until(_First, _Last, less<>{});
}

template <class _RanIt>
[[nodiscard]] inline bool is_heap(_RanIt _First, _RanIt _Last) { 
    return ::std:: is_heap(_First, _Last, less<>{});
}









































































































#line 5770 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _RanIt, class _Pr>
inline void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    for (; _Last - _First >= 2; --_Last) {
        _Pop_heap_unchecked(_First, _Last, _Pred);
    }
}

template <class _RanIt, class _Pr>
inline void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);





#line 5790 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
    _Sort_heap_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
}

template <class _RanIt>
inline void sort_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: sort_heap(_First, _Last, less<>{});
}










































































































template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid             = ::std:: next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: upper_bound(_First, _Last, _Val, less<>{});
}


























































template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    using _Diff  = _Iter_diff_t<_FwdIt>;
    _Diff _Count = ::std:: distance(_UFirst, _ULast);

    for (;;) { 
        if (_Count <= 0) {
            _Seek_wrapped(_Last, _UFirst); 
            _Seek_wrapped(_First, _UFirst);
            break;
        }

        _Diff _Count2    = _Count / 2;
        const auto _UMid = ::std:: next(_UFirst, _Count2);
        if (static_cast<bool>(_Pred(*_UMid, _Val))) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else if (_Pred(_Val, *_UMid)) {
            _Count = _Count2; 
        } else { 
            auto _UFirst2 = ::std:: lower_bound(_UFirst, _UMid, _Val, _Pass_fn(_Pred));
            ::std:: advance(_UFirst, _Count);
            auto _ULast2 = ::std:: upper_bound(_Next_iter(_UMid), _UFirst, _Val, _Pass_fn(_Pred));
            _Seek_wrapped(_Last, _ULast2);
            _Seek_wrapped(_First, _UFirst2);
            break;
        }
    }

    return {_First, _Last};
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: equal_range(_First, _Last, _Val, less<>{});
}
































































template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));
    return _UFirst != _ULast && !_Pred(_Val, *_UFirst);
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: binary_search(_First, _Last, _Val, less<>{});
}


































[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Distance_unknown, _Distance_unknown) {
    return {};
}

template <class _Diff1>
[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Diff1, _Distance_unknown) {
    return {};
}

template <class _Diff2>
[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Distance_unknown, _Diff2) {
    return {};
}

template <class _Diff1, class _Diff2>
[[nodiscard]] constexpr auto _Idl_dist_add(_Diff1 _Lhs, _Diff2 _Rhs) {
    return _Lhs + _Rhs;
}

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    const auto _Count1 = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
    const auto _Count2 = _Idl_distance<_InIt2>(_UFirst2, _ULast2);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_dist_add(_Count1, _Count2));
    if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        for (;;) {
            if (static_cast<bool>(_Pred(*_UFirst2, *_UFirst1))) {
                *_UDest = *_UFirst2;
                ++_UDest;
                ++_UFirst2;

                if (_UFirst2 == _ULast2) {
                    break;
                }
            } else {
                *_UDest = *_UFirst1;
                ++_UDest;
                ++_UFirst1;

                if (_UFirst1 == _ULast1) {
                    break;
                }
            }
        }
    }

    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest); 
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}









































































































#line 6314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"









template <class _BidIt>
void _Rotate_one_right(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    
    _Iter_value_t<_BidIt> _Temp(::std:: move(*_Mid));
    _Move_backward_unchecked(_First, _Mid, _Last);
    *_First = ::std:: move(_Temp);
}

template <class _BidIt>
void _Rotate_one_left(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    
    _Iter_value_t<_BidIt> _Temp(::std:: move(*_First));
    *_Move_unchecked(_Mid, _Last, _First) = ::std:: move(_Temp);
}

template <class _BidIt, class _Pr>
void _Inplace_merge_buffer_left(
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    using _Ptr_ty = _Iter_value_t<_BidIt>*;
    _Uninitialized_backout<_Ptr_ty> _Backout{_Temp_ptr, _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
    _Ptr_ty _Left_first      = _Temp_ptr;
    const _Ptr_ty _Left_last = _Backout._Last - 1; 
    *_First                  = ::std:: move(*_Mid); 
    ++_First;
    ++_Mid;
    for (;;) {
        if (_Pred(*_Mid, *_Left_first)) { 
            *_First = ::std:: move(*_Mid);
            ++_First;
            ++_Mid;
            if (_Mid == _Last) {
                _Move_unchecked(_Left_first, _Backout._Last, _First); 
                return;
            }
        } else { 
            *_First = ::std:: move(*_Left_first);
            ++_First;
            ++_Left_first;
            if (_Left_first == _Left_last) {
                
                *_Move_unchecked(_Mid, _Last, _First) = ::std:: move(*_Left_last);
                return;
            }
        }
    }
}

template <class _BidIt, class _Pr>
void _Inplace_merge_buffer_right(
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    using _Ptr_ty = _Iter_value_t<_BidIt>*;
    _Uninitialized_backout<_Ptr_ty> _Backout{_Temp_ptr, _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
    *--_Last                   = ::std:: move(*--_Mid); 
    const _Ptr_ty _Right_first = _Temp_ptr;
    _Ptr_ty _Right_last        = _Backout._Last - 1;
    --_Mid;
    for (;;) {
        if (_Pred(*_Right_last, *_Mid)) { 
            *--_Last = ::std:: move(*_Mid);
            if (_First == _Mid) {
                *--_Last = ::std:: move(*_Right_last); 
                _Move_backward_unchecked(_Right_first, _Right_last, _Last); 
                return;
            }

            --_Mid;
        } else { 
            *--_Last = ::std:: move(*_Right_last);
            --_Right_last;
            if (_Right_first == _Right_last) { 
                *--_Last = ::std:: move(*_Mid); 
                _Move_backward_unchecked(_First, _Mid, _Last);
                *_First = ::std:: move(*_Right_first);
                return;
            }
        }
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred);

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_divide_and_conquer2(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred,
    _BidIt _Firstn, _BidIt _Lastn, _Iter_diff_t<_BidIt> _Count1n, _Iter_diff_t<_BidIt> _Count2n) {
    
    using _Diff  = _Iter_diff_t<_BidIt>;
    _BidIt _Midn = _Buffered_rotate_unchecked(_Firstn, _Mid, _Lastn, static_cast<_Diff>(_Count1 - _Count1n), _Count2n,
        _Temp_ptr, _Capacity); 
    _Buffered_inplace_merge_unchecked(
        _First, _Firstn, _Midn, _Count1n, _Count2n, _Temp_ptr, _Capacity, _Pred); 
    _Buffered_inplace_merge_unchecked(_Midn, _Lastn, _Last, static_cast<_Diff>(_Count1 - _Count1n),
        static_cast<_Diff>(_Count2 - _Count2n), _Temp_ptr, _Capacity, _Pred);
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_divide_and_conquer(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count1 <= _Count2) {
        const _Diff _Count1n = _Count1 >> 1; 
        const _BidIt _Firstn = ::std:: next(_First, _Count1n);
        const _BidIt _Lastn  = ::std:: lower_bound(_Mid, _Last, *_Firstn, _Pred);
        _Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred,
            _Firstn, _Lastn, _Count1n, ::std:: distance(_Mid, _Lastn));
    } else {
        const _Diff _Count2n = _Count2 >> 1; 
        const _BidIt _Lastn  = ::std:: next(_Mid, _Count2n);
        const _BidIt _Firstn = ::std:: upper_bound(_First, _Mid, *_Lastn, _Pred);
        _Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred,
            _Firstn, _Lastn, ::std:: distance(_First, _Firstn), _Count2n);
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked_impl(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    if (_Count1 <= _Count2 && _Count1 <= _Capacity) {
        _Inplace_merge_buffer_left(_First, _Mid, _Last, _Temp_ptr, _Pred);
    } else if (_Count2 <= _Capacity) {
        _Inplace_merge_buffer_right(_First, _Mid, _Last, _Temp_ptr, _Pred);
    } else {
        _Buffered_inplace_merge_divide_and_conquer(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred);
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    
    if (_Mid == _Last) {
        return;
    }

    for (;;) {
        if (_First == _Mid) {
            return;
        }

        if (_Pred(*_Mid, *_First)) {
            break;
        }

        ++_First;
        --_Count1;
    }

    const auto _Highest = _Prev_iter(_Mid);
    do {
        --_Last;
        --_Count2;
        if (_Mid == _Last) {
            _Rotate_one_right(_First, _Mid, ++_Last);
            return;
        }
    } while (!_Pred(*_Last, *_Highest));

    ++_Last;
    ++_Count2;

    if (_Count1 == 1) {
        _Rotate_one_left(_First, _Mid, _Last);
        return;
    }

    _Buffered_inplace_merge_unchecked_impl(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred);
}

template <class _BidIt, class _Pr>
void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _UMid   = _Get_unwrapped(_Mid);
    auto _ULast  = _Get_unwrapped(_Last);
    ;

    
    if (_UMid == _ULast) {
        return;
    }

    for (;;) {
        if (_UFirst == _UMid) {
            return;
        }

        if (_Pred(*_UMid, *_UFirst)) { 
            break;
        }

        ++_UFirst;
    }

    const auto _Highest = _Prev_iter(_UMid);
    do {
        --_ULast;
        if (_UMid == _ULast) { 
            _Rotate_one_right(_UFirst, _UMid, ++_ULast);
            return;
        }
    } while (!_Pred(*_ULast, *_Highest)); 

    ++_ULast;

    using _Diff         = _Iter_diff_t<_BidIt>;
    const _Diff _Count1 = ::std:: distance(_UFirst, _UMid);
    if (_Count1 == 1) { 
        _Rotate_one_left(_UFirst, _UMid, _ULast);
        return;
    }

    const _Diff _Count2 = ::std:: distance(_UMid, _ULast);
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{(::std:: min)(_Count1, _Count2)};
    _Buffered_inplace_merge_unchecked_impl(
        _UFirst, _UMid, _ULast, _Count1, _Count2, _Temp_buf._Data, _Temp_buf._Capacity, _Pass_fn(_Pred));
}

template <class _BidIt>
void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    ::std:: inplace_merge(_First, _Mid, _Last, less<>{});
}















#line 6577 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"





















































































































































































































































































































































template <class _BidIt, class _Pr>
inline _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {
    
    if (_First != _Last) {
        for (_BidIt _Mid = _First; ++_Mid != _Last;) { 
            _BidIt _Hole               = _Mid;
            _Iter_value_t<_BidIt> _Val = ::std:: move(*_Mid);

            if (static_cast<bool>(_Pred(_Val, *_First))) { 
                _Move_backward_unchecked(_First, _Mid, ++_Hole);
                *_First = ::std:: move(_Val);
            } else { 
                for (_BidIt _Prev = _Hole; static_cast<bool>(_Pred(_Val, *--_Prev)); _Hole = _Prev) {
                    *_Hole = ::std:: move(*_Prev); 
                }

                *_Hole = ::std:: move(_Val); 
            }
        }
    }

    return _Last;
}

template <class _RanIt, class _Pr>
inline void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    if (static_cast<bool>(_Pred(*_Mid, *_First))) {
        ::std:: iter_swap(_Mid, _First);
    }

    if (static_cast<bool>(_Pred(*_Last, *_Mid))) { 
        ::std:: iter_swap(_Last, _Mid);

        if (static_cast<bool>(_Pred(*_Mid, *_First))) {
            ::std:: iter_swap(_Mid, _First);
        }
    }
}

template <class _RanIt, class _Pr>
inline void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    using _Diff        = _Iter_diff_t<_RanIt>;
    const _Diff _Count = _Last - _First;
    if (40 < _Count) { 
        const _Diff _Step     = (_Count + 1) >> 3; 
        const _Diff _Two_step = _Step << 1; 
        _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);
        _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
        _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);
        _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
    } else {
        _Med3_unchecked(_First, _Mid, _Last, _Pred);
    }
}

template <class _RanIt, class _Pr>
inline pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _RanIt _Mid = _First + ((_Last - _First) >> 1); 
    _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);
    _RanIt _Pfirst = _Mid;
    _RanIt _Plast  = _Next_iter(_Pfirst);

    while (_First < _Pfirst && !static_cast<bool>(_Pred(*_Prev_iter(_Pfirst), *_Pfirst))
           && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {
        --_Pfirst;
    }

    while (_Plast < _Last && !static_cast<bool>(_Pred(*_Plast, *_Pfirst)) && !_Pred(*_Pfirst, *_Plast)) {
        ++_Plast;
    }

    _RanIt _Gfirst = _Plast;
    _RanIt _Glast  = _Pfirst;

    for (;;) { 
        for (; _Gfirst < _Last; ++_Gfirst) {
            if (static_cast<bool>(_Pred(*_Pfirst, *_Gfirst))) {
                continue;
            } else if (_Pred(*_Gfirst, *_Pfirst)) {
                break;
            } else if (_Plast != _Gfirst) {
                ::std:: iter_swap(_Plast, _Gfirst);
                ++_Plast;
            } else {
                ++_Plast;
            }
        }

        for (; _First < _Glast; --_Glast) {
            if (static_cast<bool>(_Pred(*_Prev_iter(_Glast), *_Pfirst))) {
                continue;
            } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {
                break;
            } else if (--_Pfirst != _Prev_iter(_Glast)) {
                ::std:: iter_swap(_Pfirst, _Prev_iter(_Glast));
            }
        }

        if (_Glast == _First && _Gfirst == _Last) {
            return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
        }

        if (_Glast == _First) { 
            if (_Plast != _Gfirst) {
                ::std:: iter_swap(_Pfirst, _Plast);
            }

            ++_Plast;
            ::std:: iter_swap(_Pfirst, _Gfirst);
            ++_Pfirst;
            ++_Gfirst;
        } else if (_Gfirst == _Last) { 
            if (--_Glast != --_Pfirst) {
                ::std:: iter_swap(_Glast, _Pfirst);
            }

            ::std:: iter_swap(_Pfirst, --_Plast);
        } else {
            ::std:: iter_swap(_Gfirst, --_Glast);
            ++_Gfirst;
        }
    }
}

template <class _RanIt, class _Pr>
inline void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {
    
    for (;;) {
        if (_Last - _First <= _ISORT_MAX) { 
            _Insertion_sort_unchecked(_First, _Last, _Pred);
            return;
        }

        if (_Ideal <= 0) { 
            _Make_heap_unchecked(_First, _Last, _Pred);
            _Sort_heap_unchecked(_First, _Last, _Pred);
            return;
        }

        
        auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

        _Ideal = (_Ideal >> 1) + (_Ideal >> 2); 

        if (_Mid.first - _First < _Last - _Mid.second) { 
            _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);
            _First = _Mid.second;
        } else { 
            _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);
            _Last = _Mid.first;
        }
    }
}

template <class _RanIt, class _Pr>
inline void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));
}

template <class _RanIt>
inline void sort(const _RanIt _First, const _RanIt _Last) { 
    ::std:: sort(_First, _Last, less<>{});
}










#line 7098 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"






































































































































































































































template <class _FwdIt, class _Ty, class _Pr>
_Ty* _Uninitialized_merge_move(_FwdIt _First, const _FwdIt _Mid, const _FwdIt _Last, _Ty* const _Dest, _Pr _Pred) {
    
    
    _Uninitialized_backout<_Ty*> _Backout{_Dest};
    _FwdIt _Next = _Mid;
    for (;;) {
        if (static_cast<bool>(_Pred(*_Next, *_First))) {
            _Backout._Emplace_back(::std:: move(*_Next));
            ++_Next;

            if (_Next == _Last) {
                _Backout._Last = _Uninitialized_move_unchecked(_First, _Mid, _Backout._Last);
                return _Backout._Release();
            }
        } else {
            _Backout._Emplace_back(::std:: move(*_First));
            ++_First;

            if (_First == _Mid) {
                _Backout._Last = _Uninitialized_move_unchecked(_Next, _Last, _Backout._Last);
                return _Backout._Release();
            }
        }
    }
}

template <class _InIt, class _OutIt, class _Pr>
_OutIt _Merge_move(_InIt _First, const _InIt _Mid, const _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    
    _InIt _Next = _Mid;
    for (;;) {
        if (static_cast<bool>(_Pred(*_Next, *_First))) {
            *_Dest = ::std:: move(*_Next);
            ++_Dest;
            ++_Next;

            if (_Next == _Last) {
                return _Move_unchecked(_First, _Mid, _Dest);
            }
        } else {
            *_Dest = ::std:: move(*_First);
            ++_Dest;
            ++_First;

            if (_First == _Mid) {
                return _Move_unchecked(_Next, _Last, _Dest);
            }
        }
    }
}

template <class _BidIt, class _Ty, class _Pr>
void _Uninitialized_chunked_merge_unchecked2(
    _BidIt _First, const _BidIt _Last, _Ty* _Dest, _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    
    _Uninitialized_backout<_Ty*> _Backout{_Dest};
    while (_Count > _Isort_max<_BidIt>) {
        _Count -= _Isort_max<_BidIt>;
        const _BidIt _Mid1 = ::std:: next(_First, _Isort_max<_BidIt>);
        const auto _Chunk2 = (::std:: min)(_Isort_max<_BidIt>, _Count);
        _Count -= _Chunk2;
        const _BidIt _Mid2 = ::std:: next(_Mid1, _Chunk2);
        _Backout._Last     = _Uninitialized_merge_move(_First, _Mid1, _Mid2, _Backout._Last, _Pred);
        _First             = _Mid2;
    }

    _Uninitialized_move_unchecked(_First, _Last, _Backout._Last); 
    _Backout._Release();
}

template <class _BidIt, class _OutIt, class _Pr>
void _Chunked_merge_unchecked(_BidIt _First, const _BidIt _Last, _OutIt _Dest, const _Iter_diff_t<_BidIt> _Chunk,
    _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    
    while (_Chunk < _Count) {
        _Count -= _Chunk;
        const _BidIt _Mid1 = ::std:: next(_First, _Chunk);
        const auto _Chunk2 = (::std:: min)(_Chunk, _Count);
        _Count -= _Chunk2;
        const _BidIt _Mid2 = ::std:: next(_Mid1, _Chunk2);
        _Dest              = _Merge_move(_First, _Mid1, _Mid2, _Dest, _Pred);
        _First             = _Mid2;
    }

    _Move_unchecked(_First, _Last, _Dest); 
}

template <class _BidIt, class _Pr>
void _Insertion_sort_isort_max_chunks(_BidIt _First, const _BidIt _Last, _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    for (; _Isort_max<_BidIt> < _Count; _Count -= _Isort_max<_BidIt>) { 
        _First = _Insertion_sort_unchecked(_First, ::std:: next(_First, _Isort_max<_BidIt>), _Pred);
    }

    _Insertion_sort_unchecked(_First, _Last, _Pred); 
}

template <class _BidIt, class _Pr>
void _Buffered_merge_sort_unchecked(const _BidIt _First, const _BidIt _Last, const _Iter_diff_t<_BidIt> _Count,
    _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    
    _Insertion_sort_isort_max_chunks(_First, _Last, _Count, _Pred);
    
    if (_Count <= _Isort_max<_BidIt>) {
        return;
    }

    
    _Uninitialized_chunked_merge_unchecked2(_First, _Last, _Temp_ptr, _Count, _Pred);
    _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr, _Temp_ptr + _Count};
    auto _Chunk = _Isort_max<_BidIt>;
    for (;;) {
        
        _Chunk <<= 1;
        _Chunked_merge_unchecked(_Temp_ptr, _Temp_ptr + _Count, _First, static_cast<ptrdiff_t>(_Chunk),
            static_cast<ptrdiff_t>(_Count), _Pred);
        _Chunk <<= 1;
        if (_Count <= _Chunk) { 
            return;
        }

        
        _Chunked_merge_unchecked(_First, _Last, _Temp_ptr, _Chunk, _Count, _Pred);
    }
}

template <class _BidIt, class _Pr>
void _Stable_sort_unchecked(const _BidIt _First, const _BidIt _Last, const _Iter_diff_t<_BidIt> _Count,
    _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count <= _ISORT_MAX) {
        _Insertion_sort_unchecked(_First, _Last, _Pred); 
    } else { 
        const auto _Half_count      = static_cast<_Diff>(_Count >> 1); 
        const auto _Half_count_ceil = static_cast<_Diff>(_Count - _Half_count);
        const _BidIt _Mid           = ::std:: next(_First, _Half_count_ceil);
        if (_Half_count_ceil <= _Capacity) { 
            _Buffered_merge_sort_unchecked(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Pred);
            _Buffered_merge_sort_unchecked(_Mid, _Last, _Half_count, _Temp_ptr, _Pred);
        } else { 
            _Stable_sort_unchecked(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Capacity, _Pred);
            _Stable_sort_unchecked(_Mid, _Last, _Half_count, _Temp_ptr, _Capacity, _Pred);
        }

        _Buffered_inplace_merge_unchecked(
            _First, _Mid, _Last, _Half_count_ceil, _Half_count, _Temp_ptr, _Capacity, _Pred); 
    }
}

template <class _BidIt, class _Pr>
void stable_sort(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _Count  = ::std:: distance(_UFirst, _ULast);
    if (_Count <= _ISORT_MAX) {
        _Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
        return;
    }

    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Count - _Count / 2};
    _Stable_sort_unchecked(_UFirst, _ULast, _Count, _Temp_buf._Data, _Temp_buf._Capacity, _Pass_fn(_Pred));
}




#line 7507 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _BidIt>
void stable_sort(const _BidIt _First, const _BidIt _Last) { 
    ::std:: stable_sort(_First, _Last, less<>{});
}







#line 7520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"



































































































































































































































































template <class _RanIt, class _Pr>
inline void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _UMid  = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);

    if (_UFirst == _UMid) {
        return; 
    }

    _Make_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
    for (auto _UNext = _UMid; _UNext < _ULast; ++_UNext) {
        if (static_cast<bool>(_Pred(*_UNext, *_UFirst))) { 
            _Iter_value_t<_RanIt> _Val = ::std:: move(*_UNext);
            _Pop_heap_hole_unchecked(_UFirst, _UMid, _UNext, ::std:: move(_Val), _Pass_fn(_Pred));
        }
    }

    _Sort_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
}

template <class _RanIt>
inline void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last) {
    
    ::std:: partial_sort(_First, _Mid, _Last, less<>{});
}





























































































#line 7902 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt, class _RanIt, class _Pr>
inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    auto _UMid2        = _UFirst2;
    if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        for (; _UFirst1 != _ULast1 && _UMid2 != _ULast2; ++_UFirst1, (void) ++_UMid2) {
            *_UMid2 = *_UFirst1; 
        }

        _Make_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
        for (; _UFirst1 != _ULast1; ++_UFirst1) {
            if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) {
                
                using _Diff = _Iter_diff_t<_RanIt>;
                _Pop_heap_hole_by_index(
                    _UFirst2, static_cast<_Diff>(0), static_cast<_Diff>(_UMid2 - _UFirst2), *_UFirst1, _Pass_fn(_Pred));
            }
        }

        _Sort_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
    }

    _Seek_wrapped(_First2, _UMid2);
    return _First2;
}

template <class _InIt, class _RanIt>
inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2) {
    
    return ::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2, less<>{});
}

















































































































#line 8054 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _RanIt, class _Pr>
inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Nth);
    _Adl_verify_range(_Nth, _Last);
    auto _UFirst     = _Get_unwrapped(_First);
    const auto _UNth = _Get_unwrapped(_Nth);
    auto _ULast      = _Get_unwrapped(_Last);
    if (_UNth == _ULast) {
        return; 
    }

    while (_ISORT_MAX < _ULast - _UFirst) { 
        auto _UMid = _Partition_by_median_guess_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));

        if (_UMid.second <= _UNth) {
            _UFirst = _UMid.second;
        } else if (_UMid.first <= _UNth) {
            return; 
        } else {
            _ULast = _UMid.first;
        }
    }

    _Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)); 
}

template <class _RanIt>
inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last) { 
    ::std:: nth_element(_First, _Nth, _Last, less<>{});
}


























































































#line 8177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1) {
        if (static_cast<bool>(_Pred(*_UFirst2, *_UFirst1))) {
            return false;
        }

        if (!_Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst2;
        }
    }

    return _UFirst2 == _ULast2;
}

template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    
    return ::std:: includes(_First1, _Last1, _First2, _Last2, less<>{});
}





























































































#line 8301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UDest) {
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) { 
            *_UDest = *_UFirst1;
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) { 
            *_UDest = *_UFirst2;
            ++_UFirst2;
        } else { 
            *_UDest = *_UFirst1;
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}



































































































#line 8438 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_intersection(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) {
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            ++_UFirst2;
        } else {
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}































































































#line 8570 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) { 
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
        } else {
            if (!_Pred(*_UFirst2, *_UFirst1)) {
                ++_UFirst1;
            }

            ++_UFirst2;
        }
    }

    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst1, _ULast1, _UDest));
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}



























































































#line 8699 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_symmetric_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) { 
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) { 
            *_UDest = *_UFirst2;
            ++_UDest;
            ++_UFirst2;
        } else { 
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_symmetric_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}














































































































#line 8850 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (static_cast<bool>(_Pred(*_Found, *_First))) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Max_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: max_element(_First, _Last, less<>{});
}
































































#line 8941 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (static_cast<bool>(_Pred(*_First, *_Found))) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Min_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: min_element(_First, _Last, less<>{});
}
































































#line 9032 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _FwdIt, class _Pr>
constexpr pair<_FwdIt, _FwdIt> _Minmax_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    pair<_FwdIt, _FwdIt> _Found(_First, _First);

    if (_First != _Last) {
        while (++_First != _Last) { 
            _FwdIt _Next = _First;
            if (++_Next == _Last) { 
                if (static_cast<bool>(_Pred(*_First, *_Found.first))) {
                    _Found.first = _First;
                } else if (!static_cast<bool>(_Pred(*_First, *_Found.second))) {
                    _Found.second = _First;
                }
            } else { 
                if (static_cast<bool>(_Pred(*_Next, *_First))) { 
                    if (static_cast<bool>(_Pred(*_Next, *_Found.first))) {
                        _Found.first = _Next;
                    }
                    if (!static_cast<bool>(_Pred(*_First, *_Found.second))) {
                        _Found.second = _First;
                    }
                } else { 
                    if (static_cast<bool>(_Pred(*_First, *_Found.first))) {
                        _Found.first = _First;
                    }
                    if (!static_cast<bool>(_Pred(*_Next, *_Found.second))) {
                        _Found.second = _Next;
                    }
                }
                _First = _Next;
            }
        }
    }

    return _Found;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _Result = _Minmax_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
    _Seek_wrapped(_Last, _Result.second);
    _Seek_wrapped(_First, _Result.first);
    return {_First, _Last};
}

template <class _FwdIt>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> minmax_element(_FwdIt _First, _FwdIt _Last) {
    
    return ::std:: minmax_element(_First, _Last, less<>{});
}








































































































#line 9191 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: max)(_Ilist, less<>{});
}


































































template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: min)(_Ilist, less<>{});
}


























































template <class _Ty, class _Pr>
[[nodiscard]] constexpr pair<const _Ty&, const _Ty&> minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(static_cast<bool>(_Pred(_Right, _Left))))  {
    
    if (static_cast<bool>(_Pred(_Right, _Left))) {
        return {_Right, _Left};
    }

    return {_Left, _Right};
}

template <class _Ty, class _Pr>
[[nodiscard]] constexpr pair<_Ty, _Ty> minmax(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    pair<const _Ty*, const _Ty*> _Res = _Minmax_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return pair<_Ty, _Ty>(*_Res.first, *_Res.second);
}

template <class _Ty>
[[nodiscard]] constexpr pair<const _Ty&, const _Ty&> minmax(const _Ty& _Left, const _Ty& _Right) noexcept(
    noexcept(_Right < _Left))  {
    
    if (_Right < _Left) {
        ;
        return {_Right, _Left};
    }

    return {_Left, _Right};
}

template <class _Ty>
[[nodiscard]] constexpr pair<_Ty, _Ty> minmax(initializer_list<_Ty> _Ilist) {
    
    return ::std:: minmax(_Ilist, less<>{});
}































































































template <class _BidIt, class _Pr>
inline bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UNext       = _ULast;
    if (_UFirst == _ULast || _UFirst == --_UNext) {
        return false;
    }

    for (;;) { 
        auto _UNext1 = _UNext;
        if (static_cast<bool>(_Pred(*--_UNext, *_UNext1))) { 
            auto _UMid = _ULast;
            do {
                --_UMid;
            } while (!static_cast<bool>(_Pred(*_UNext, *_UMid)));

            ::std:: iter_swap(_UNext, _UMid);
            ::std:: reverse(_UNext1, _ULast);
            return true;
        }

        if (_UNext == _UFirst) { 
            ::std:: reverse(_UFirst, _ULast);
            return false;
        }
    }
}

template <class _BidIt>
inline bool next_permutation(_BidIt _First, _BidIt _Last) {
    
    return ::std:: next_permutation(_First, _Last, less<>{});
}








































































template <class _BidIt, class _Pr>
inline bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UNext       = _ULast;
    if (_UFirst == _ULast || _UFirst == --_UNext) {
        return false;
    }

    for (;;) { 
        auto _UNext1 = _UNext;
        if (static_cast<bool>(_Pred(*_UNext1, *--_UNext))) { 
            auto _UMid = _ULast;
            do {
                --_UMid;
            } while (!static_cast<bool>(_Pred(*_UMid, *_UNext)));

            ::std:: iter_swap(_UNext, _UMid);
            ::std:: reverse(_UNext1, _ULast);
            return true;
        }

        if (_UNext == _UFirst) { 
            ::std:: reverse(_UFirst, _ULast);
            return false;
        }
    }
}

template <class _BidIt>
inline bool prev_permutation(_BidIt _First, _BidIt _Last) {
    
    return ::std:: prev_permutation(_First, _Last, less<>{});
}








































































template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt is_sorted_until(const _FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UNext = _UFirst; ++_UNext != _ULast; ++_UFirst) {
            if (static_cast<bool>(_Pred(*_UNext, *_UFirst))) {
                _ULast = _UNext;
                break;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] inline bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    return ::std:: is_sorted_until(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast;
}

template <class _FwdIt>
[[nodiscard]] inline _FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last) {
    
    return ::std:: is_sorted_until(_First, _Last, less<>{});
}

template <class _FwdIt>
[[nodiscard]] inline bool is_sorted(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: is_sorted(_First, _Last, less<>{});
}
























































































































































































































#line 9941 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"

}


#pragma warning(pop)
#pragma pack(pop)
#line 9948 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
#line 9949 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\algorithm"
#pragma external_header(pop)
#line 21 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"





#pragma once










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"





#pragma once








#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {

[[nodiscard]] inline unsigned long _Floor_of_log_2(size_t _Value) noexcept { 
    _Value |= size_t{1}; 
    unsigned long _Result;














    _BitScanReverse64(&_Result, _Value);


#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"

    return _Result;
}

[[nodiscard]] inline unsigned long _Ceiling_of_log_2(const size_t _Value) noexcept { 
                                                                                  
    return 1 + _Floor_of_log_2(_Value - 1);
}

[[nodiscard]] inline uint32_t _Bit_scan_reverse(const uint32_t _Value) noexcept {
    unsigned long _Index; 

    if (_BitScanReverse(&_Index, _Value)) {
        return _Index + 1;
    }

    return 0;
}

[[nodiscard]] inline uint32_t _Bit_scan_reverse(const uint64_t _Value) noexcept {
    unsigned long _Index; 


    if (_BitScanReverse64(&_Index, _Value)) {
        return _Index + 1;
    }












#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"

    return 0;
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"
#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\xbit_ops.h"
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




#pragma warning(disable : 4127) 

namespace std {






















template <class _Seed_seq, class _Self, class _Engine = _Self>
using _Enable_if_seed_seq_t = enable_if_t<
    !is_convertible_v<remove_cv_t<_Seed_seq>,
        typename _Self::
            result_type> && !is_same_v<remove_cv_t<_Seed_seq>, _Self> && !is_same_v<remove_cv_t<_Seed_seq>, _Engine>,
    int>;

 constexpr long double _Pi    = 3.14159265358979323846264338327950288L;
 constexpr long double _Exp1  = 2.71828182845904523536028747135266250L;
 constexpr long double _Two32 = 4294967296.0L;
 constexpr long double _Two31 = 2147483648.0L;

 float __cdecl _XLgamma(float);
 double __cdecl _XLgamma(double);
 long double __cdecl _XLgamma(long double);

 constexpr int _Nwords = 4;

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& _Write(
    basic_ostream<_Elem, _Traits>& _Os, long double _Dx) { 
    int _Ex;
    long double _Frac = :: frexpl(_Dx, &_Ex);
    for (int _Nw = 0; _Nw < _Nwords; ++_Nw) { 
        _Frac *= _Two31;
        long _Digits = static_cast<long>(_Frac);
        _Frac -= _Digits;
        _Os << ' ' << _Digits;
    }
    _Os << ' ' << _Ex;
    return _Os;
}

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& _Read(
    basic_istream<_Elem, _Traits>& _Is, long double& _Dx) { 
    long double _Frac = 0.0;
    long _Digits;
    for (int _Nw = 0; _Nw < _Nwords; ++_Nw) { 
        _Is >> _Digits;
        long double _Temp = _Digits / _Two31;
        for (int _Idx = 0; _Idx < _Nw; ++_Idx) {
            _Temp /= _Two31;
        }

        _Frac += _Temp;
    }
    _Is >> _Digits;
    _Dx = :: ldexpl(_Frac, _Digits);
    return _Is;
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& _In(basic_istream<_Elem, _Traits>& _Is, _Ty& _Dx) { 
    long double _Vx;
    _Ty _Max = (numeric_limits<_Ty>::max)();
    _Read(_Is, _Vx);
    if (:: fabsl(_Vx) <= _Max) {
        _Dx = static_cast<_Ty>(_Vx);
    } else if (_Vx < 0) {
        _Dx = -_Max;
    } else {
        _Dx = _Max;
    }

    return _Is;
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& _Out(basic_ostream<_Elem, _Traits>& _Os, _Ty _Dx) { 
    return _Write(_Os, _Dx);
}

template <class _Elem, class _Traits, class _Ty>
class _Wrap_istream { 
public:
    _Wrap_istream(basic_istream<_Elem, _Traits>& _Is) : _Str(_Is) {}

    _Ty operator()() { 
        _Ty _Data;
        _Str >> _Data;
        if (!_Str) {
            _Xinvalid_argument("input stream corrupted");
        }

        return _Data;
    }

    _Wrap_istream& operator=(const _Wrap_istream&) = delete;

private:
    basic_istream<_Elem, _Traits>& _Str;
};

class seed_seq { 
public:
    using result_type = unsigned int;

    seed_seq() {}

    template <class _Ty>
    seed_seq(initializer_list<_Ty> _Ilist) {
        _Construct(_Ilist.begin(), _Ilist.end());
    }

    template <class _InIt>
    seed_seq(_InIt _First, _InIt _Last) {
        _Construct(_First, _Last);
    }

    template <class _RanIt>
    void generate(_RanIt _First, _RanIt _Last) const { 
        _Adl_verify_range(_First, _Last);
        auto _UFirst   = _Get_unwrapped(_First);
        const auto _Nx = static_cast<size_t>(_Get_unwrapped(_Last) - _UFirst);

        if (0 < _Nx) { 
            const size_t _Sx = _Myvec.size();
            const size_t _Tx = 623 <= _Nx ? 11 : 68 <= _Nx ? 7 : 39 <= _Nx ? 5 : 7 <= _Nx ? 3 : (_Nx - 1) / 2;
            const size_t _Px = (_Nx - _Tx) / 2;
            const size_t _Qx = _Px + _Tx;
            const size_t _Mx = _Nx <= _Sx ? _Sx + 1 : _Nx;
            size_t _Kx;

            _Iter_value_t<_RanIt> _Mask = _Iter_value_t<_RanIt>(1) << 31;
            _Mask <<= 1; 
            _Mask -= 1;

            for (_Kx = 0; _Kx < _Nx; ++_Kx) {
                _UFirst[_Kx] = 0x8b8b8b8b;
            }

            for (_Kx = 0; _Kx < _Mx; ++_Kx) { 
                result_type _Rx1 =
                    1664525 * _Xor27(_UFirst[_Kx % _Nx] ^ _UFirst[(_Kx + _Px) % _Nx] ^ _UFirst[(_Kx - 1) % _Nx]);

                size_t _Off;
                if (_Kx == 0) {
                    _Off = _Sx;
                } else if (_Kx <= _Sx) {
                    _Off = _Kx % _Nx + _Myvec[_Kx - 1];
                } else {
                    _Off = _Kx % _Nx;
                }
                result_type _Rx2 = static_cast<result_type>((_Rx1 + _Off) & _Mask);

                _UFirst[(_Kx + _Px) % _Nx] = (_UFirst[(_Kx + _Px) % _Nx] + _Rx1) & _Mask;
                _UFirst[(_Kx + _Qx) % _Nx] = (_UFirst[(_Kx + _Qx) % _Nx] + _Rx2) & _Mask;
                _UFirst[_Kx % _Nx]         = _Rx2;
            }
            for (; _Kx < _Mx + _Nx; ++_Kx) { 
                result_type _Rx3 =
                    1566083941 * _Xor27(_UFirst[_Kx % _Nx] + _UFirst[(_Kx + _Px) % _Nx] + _UFirst[(_Kx - 1) % _Nx]);
                result_type _Rx4 = static_cast<result_type>((_Rx3 - _Kx % _Nx) & _Mask);

                _UFirst[(_Kx + _Px) % _Nx] = (_UFirst[(_Kx + _Px) % _Nx] ^ _Rx3) & _Mask;
                _UFirst[(_Kx + _Qx) % _Nx] = (_UFirst[(_Kx + _Qx) % _Nx] ^ _Rx4) & _Mask;
                _UFirst[_Kx % _Nx]         = _Rx4;
            }
        }
    }

    template <class _OutIt>
    void param(_OutIt _Dest) const { 
        ::std:: copy(_Myvec.begin(), _Myvec.end(), _Dest);
    }

    [[nodiscard]] size_t size() const noexcept { 
        return _Myvec.size();
    }

    seed_seq(const seed_seq&) = delete;
    void operator=(const seed_seq&) = delete;

private:
    template <class _InIt>
    void _Construct(_InIt _First, _InIt _Last) {
        for (; _First != _Last; ++_First) {
            _Myvec.push_back(static_cast<unsigned int>(*_First));
        }
    }

    result_type _Xor27(result_type _Val) const { 
        return _Val ^ (_Val >> 27);
    }

    vector<result_type> _Myvec;
};

template <class _Real, size_t _Bits, class _Gen>
[[nodiscard]] _Real generate_canonical(_Gen& _Gx) { 
    static_assert(_Is_any_of_v<_Real, float, double, long double>, "invalid template argument for " "generate_canonical" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    const size_t _Digits  = static_cast<size_t>(numeric_limits<_Real>::digits);
    const size_t _Minbits = _Digits < _Bits ? _Digits : _Bits;

    const _Real _Gxmin = static_cast<_Real>((_Gx.min)());
    const _Real _Gxmax = static_cast<_Real>((_Gx.max)());
    const _Real _Rx    = (_Gxmax - _Gxmin) + _Real{1};

    const int _Ceil = static_cast<int>(::std:: ceil(static_cast<_Real>(_Minbits) / ::std:: log2(_Rx)));
    const int _Kx   = _Ceil < 1 ? 1 : _Ceil;

    _Real _Ans{0};
    _Real _Factor{1};

    for (int _Idx = 0; _Idx < _Kx; ++_Idx) { 
        _Ans += (static_cast<_Real>(_Gx()) - _Gxmin) * _Factor;
        _Factor *= _Rx;
    }

    return _Ans / _Factor;
}



 constexpr int _MP_len = 5;
using _MP_arr                     = uint64_t[_MP_len];

[[nodiscard]]  uint64_t __cdecl _MP_Get(_MP_arr) noexcept;
 void __cdecl _MP_Add(_MP_arr, uint64_t) noexcept;
 void __cdecl _MP_Mul(_MP_arr, uint64_t, uint64_t) noexcept;
 void __cdecl _MP_Rem(_MP_arr, uint64_t) noexcept;

template <class _Uint, _Uint _Ax, _Uint _Cx, _Uint _Mx>
[[nodiscard]] _Uint _Next_linear_congruential_value(_Uint _Prev) noexcept {
    
    
    
    
    
    
    
    
    
    if constexpr (_Ax == 0) { 
        return static_cast<_Uint>(_Cx); 
    } else if constexpr (_Mx == 0) {
        
        
        
        
        return static_cast<_Uint>(static_cast<_Uint>(_Ax * _Prev) + _Cx);
    } else if constexpr (_Cx <= 0xffffffff && static_cast<_Uint>(_Mx - 1) <= (0xffffffff - _Cx) / _Ax) {
        
        const auto _Mul =
            static_cast<unsigned int>(_Prev) * static_cast<unsigned int>(_Ax) + static_cast<unsigned int>(_Cx);
        return static_cast<_Uint>(_Mul % _Mx);
    } else if constexpr (_Cx <= 0xffffffffffffffffui64 && static_cast<_Uint>(_Mx - 1) <= (0xffffffffffffffffui64 - _Cx) / _Ax) {
        
        const auto _Mul = static_cast<unsigned long long>(_Prev) * _Ax + _Cx;
        return static_cast<_Uint>(_Mul % _Mx);
    } else { 
        _MP_arr _Wx;
        _MP_Mul(_Wx, _Prev, _Ax);
        _MP_Add(_Wx, _Cx);
        _MP_Rem(_Wx, _Mx);
        return static_cast<_Uint>(_MP_Get(_Wx));
    }
}

template <class _Seed_seq>
[[nodiscard]] constexpr unsigned int _Seed_seq_to_uint(_Seed_seq& _Seq) {
    unsigned int _Arr[4]{};
    _Seq.generate(_Arr, _Arr + 4);
    return _Arr[3];
}

template <class _Seed_seq>
[[nodiscard]] constexpr unsigned long long _Seed_seq_to_ull(_Seed_seq& _Seq) {
    unsigned int _Arr[5]{};
    _Seq.generate(_Arr, _Arr + 5);
    unsigned long long _Result = _Arr[4];
    _Result <<= 32;
    _Result |= _Arr[3];
    return _Result;
}

template <class _Uint, _Uint _Cx, _Uint _Mx>
[[nodiscard]] constexpr _Uint _Get_linear_congruential_seed(_Uint _Sx) noexcept { 
    if constexpr (_Mx != 0) {
        _Sx %= _Mx;
    }

    if constexpr (_Cx == 0) {
        if (_Sx == 0) {
            _Sx = _Uint{1};
        }
    }

    return _Sx;
}

template <class _Uint, _Uint _Cx, _Uint _Mx, class _Seed_seq>
[[nodiscard]] _Uint _Get_linear_congruential_seed_from_seq(_Seed_seq& _Seq) { 
    _Uint _Sx;
    if constexpr (_Mx == 0) {
        if constexpr (sizeof(_Uint) <= sizeof(unsigned int)) {
            _Sx = static_cast<_Uint>(_Seed_seq_to_uint(_Seq));
        } else {
            _Sx = static_cast<_Uint>(_Seed_seq_to_ull(_Seq));
        }
    } else if constexpr (_Mx <= 0xffffffff) {
        _Sx = static_cast<_Uint>(_Seed_seq_to_uint(_Seq) % _Mx);
    } else {
        _Sx = static_cast<_Uint>(_Seed_seq_to_ull(_Seq) % _Mx);
    }

    return _Get_linear_congruential_seed<_Uint, _Cx, _Mx>(_Sx);
}

template <class _Uint, _Uint _Ax, _Uint _Cx, _Uint _Mx>
class linear_congruential_engine { 
public:
    static_assert(_Is_any_of_v<_Uint, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "linear_congruential_engine" ": N4659 29.6.1.1 [rand.req.genl]/1f requires one of " "unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Uint>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    static_assert(0 == _Mx || (_Ax < _Mx && _Cx < _Mx), "invalid template argument for linear_congruential_engine");

    using result_type                       = _Uint;
    static constexpr result_type multiplier = _Ax;
    static constexpr result_type increment  = _Cx;
    static constexpr result_type modulus    = _Mx;

    [[nodiscard]] static constexpr result_type(min)() noexcept  {
        
        return _Cx == 0;
    }

#pragma warning(push)
#pragma warning(disable : 4309) 
    [[nodiscard]] static constexpr result_type(max)() noexcept  {
        
        return static_cast<result_type>(_Mx - 1u); 
    }
#pragma warning(pop)

    static constexpr result_type default_seed = 1u;

    linear_congruential_engine() noexcept 
        : _Prev(_Get_linear_congruential_seed<result_type, _Cx, _Mx>(default_seed)) {}

    explicit linear_congruential_engine(result_type _Sx) noexcept 
        : _Prev(_Get_linear_congruential_seed<result_type, _Cx, _Mx>(_Sx)) {}

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, linear_congruential_engine> = 0>
    explicit linear_congruential_engine(_Seed_seq& _Seq)
        : _Prev(_Get_linear_congruential_seed_from_seq<result_type, _Cx, _Mx>(_Seq)) {}

    void seed(result_type _Sx = default_seed) noexcept  {
        
        _Prev = _Get_linear_congruential_seed<result_type, _Cx, _Mx>(_Sx);
    }

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, linear_congruential_engine> = 0>
    void seed(_Seed_seq& _Seq) { 
        _Prev = _Get_linear_congruential_seed_from_seq<result_type, _Cx, _Mx>(_Seq);
    }

    [[nodiscard]] _Uint operator()() noexcept {
        _Prev = _Next_linear_congruential_value<result_type, _Ax, _Cx, _Mx>(_Prev);
        return _Prev;
    }

    void discard(unsigned long long _Nskip) noexcept  {
        
        auto _Temp = _Prev;
        for (; 0 < _Nskip; --_Nskip) {
            _Temp = _Next_linear_congruential_value<_Uint, _Ax, _Cx, _Mx>(_Temp);
        }

        _Prev = _Temp;
    }




    friend bool operator==(const linear_congruential_engine& _Lhs, const linear_congruential_engine& _Rhs) noexcept
     {
        return _Lhs._Prev == _Rhs._Prev;
    }




    friend bool operator!=(const linear_congruential_engine& _Lhs, const linear_congruential_engine& _Rhs) noexcept
     {
        return _Lhs._Prev != _Rhs._Prev;
    }

    template <class _Elem, class _Traits>
    friend basic_istream<_Elem, _Traits>& operator>>(
        basic_istream<_Elem, _Traits>& _Istr, linear_congruential_engine& _Eng) {
        return _Istr >> _Eng._Prev;
    }

    template <class _Elem, class _Traits>
    friend basic_ostream<_Elem, _Traits>& operator<<(
        basic_ostream<_Elem, _Traits>& _Ostr, const linear_congruential_engine& _Eng) {
        return _Ostr << _Eng._Prev;
    }

private:
    result_type _Prev;
};

template <class _Uint, _Uint _Ax, _Uint _Cx, _Uint _Mx>
class linear_congruential { 
public:
    static_assert(_Is_any_of_v<_Uint, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "linear_congruential" ": N4659 29.6.1.1 [rand.req.genl]/1f requires one of " "unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Uint>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    static_assert(0 == _Mx || (_Ax < _Mx && _Cx < _Mx), "invalid template argument for linear_congruential");

    using result_type = _Uint;

    static constexpr _Uint multiplier = _Ax;
    static constexpr _Uint increment  = _Cx;
    static constexpr _Uint modulus    = _Mx;

    linear_congruential() noexcept 
        : _Prev(_Get_linear_congruential_seed<_Uint, _Cx, _Mx>(1u)) {}

    explicit linear_congruential(_Uint _Xx0) noexcept 
        : _Prev(_Get_linear_congruential_seed<_Uint, _Cx, _Mx>(_Xx0)) {}

    template <class _Gen, _Enable_if_seed_seq_t<_Gen, linear_congruential> = 0>
    linear_congruential(_Gen& _Seq) : _Prev(_Get_linear_congruential_seed<_Uint, _Cx, _Mx>(_Seq())) {}

    void seed(_Uint _Xx0 = 1u) noexcept  {
        
        _Prev = _Get_linear_congruential_seed<_Uint, _Cx, _Mx>(_Xx0);
    }

    template <class _Gen, _Enable_if_seed_seq_t<_Gen, linear_congruential> = 0>
    void seed(_Gen& _Seq) { 
        _Prev = _Get_linear_congruential_seed<_Uint, _Cx, _Mx>(_Seq());
    }

    [[nodiscard]] _Uint(min)() const noexcept  {
        
        return _Cx == 0;
    }

#pragma warning(push)
#pragma warning(disable : 4309) 
    [[nodiscard]] _Uint(max)() const noexcept  {
        
        return static_cast<_Uint>(_Mx - 1u); 
    }
#pragma warning(pop)

    [[nodiscard]] _Uint operator()() noexcept  {
        
        _Prev = _Next_linear_congruential_value<_Uint, _Ax, _Cx, _Mx>(_Prev);
        return _Prev;
    }

    void discard(unsigned long long _Nskip) noexcept  {
        
        auto _Temp = _Prev;
        for (; 0 < _Nskip; --_Nskip) {
            _Temp = _Next_linear_congruential_value<_Uint, _Ax, _Cx, _Mx>(_Temp);
        }

        _Prev = _Temp;
    }




    friend bool operator==(const linear_congruential& _Lhs, const linear_congruential& _Rhs) noexcept
     {
        return _Lhs._Prev == _Rhs._Prev;
    }




    friend bool operator!=(const linear_congruential& _Lhs, const linear_congruential& _Rhs) noexcept
     {
        return _Lhs._Prev != _Rhs._Prev;
    }

    template <class _Elem, class _Traits>
    friend basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, linear_congruential& _Eng) {
        return _Istr >> _Eng._Prev;
    }

    template <class _Elem, class _Traits>
    friend basic_ostream<_Elem, _Traits>& operator<<(
        basic_ostream<_Elem, _Traits>& _Ostr, const linear_congruential& _Eng) {
        return _Ostr << _Eng._Prev;
    }

private:
    _Uint _Prev;
};

template <class _Ty, size_t _Nw>
struct _Circ_buf { 
    _Ty _At(size_t _Ix) const {
        return _Ax[_Base(_Ix)];
    }

    bool _Equals(const _Circ_buf& _Right) const {
        const _Ty* _Last1 = _Ax + _Idx;
        const _Ty* _Last2 = _Right._Ax + _Right._Idx;
        const _Ty* _First;
        const _Ty* _Last;
        const _Ty* _Other;
        bool _Use2 = _Base() < _Right._Base();

        if (_Use2) { 
                     
            _First = _Right._Ax + _Right._Base();
            _Last  = _Last2;
            _Other = _Ax + _Base();
        } else { 
                 
            _First = _Ax + _Base();
            _Last  = _Last1;
            _Other = _Right._Ax + _Right._Base();
        }

        ptrdiff_t _Nx0 = _Nw;
        while (0 < _Nx0) { 
                           
                           
                           
                           
            const _Ty* _Limit = _First < _Last ? _Last : _Use2 ? _Right._Ax + 2 * _Nw : _Ax + 2 * _Nw;
            _Nx0 -= _Limit - _First;
            while (_First != _Limit) {
                if (*_First++ != *_Other++) {
                    return false;
                }
            }

            _First = _Other;
            _Last  = _Use2 ? _Last1 : _Last2;
            _Other = _Use2 ? _Right._Ax : _Ax;
            _Use2  = !_Use2;
        }
        return true;
    }

    size_t _Base(size_t _Ix = 0) const {
        return (_Ix += _Idx) < _Nw ? (_Ix + _Nw) : (_Ix - _Nw);
    }

    unsigned int _Idx;
    _Ty _Ax[2 * _Nw];
};

template <class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits>
class _Swc_base : public _Circ_buf<_Ty, _Rx> { 
public:
    using result_type = _Ty;
    using _Traits     = _Swc_Traits;
    using _Mybase     = _Circ_buf<_Ty, _Rx>;
    using _Seed_t     = typename _Swc_Traits::_Seed_t;

    static constexpr size_t short_lag     = _Sx;
    static constexpr size_t long_lag      = _Rx;
    static constexpr _Seed_t default_seed = static_cast<_Seed_t>(19780503U);

    _Swc_base() {
        seed();
    }

    _Swc_base(_Seed_t _Xx0) {
        seed(_Xx0);
    }

    template <class _Gen, _Enable_if_seed_seq_t<_Gen, _Swc_base> = 0>
    _Swc_base(_Gen& _Gx) {
        seed(_Gx);
    }

    void seed(_Seed_t _Value = default_seed) { 
        _Seed(_Value, false, true_type{});
    }

    template <class _Gen>
    void seed(_Gen& _Gx, bool _Readcy = false) { 
        _Seed(_Gx, _Readcy, is_arithmetic<_Gen>{});
    }

    [[nodiscard]] result_type(min)() const {
        return 0;
    }

    [[nodiscard]] result_type(max)() const {
        return _Swc_Traits::_Max;
    }

    [[nodiscard]] result_type operator()() {
        const auto _Ix = 2 * _Rx <= this->_Idx ? 0 : this->_Idx;
        if (_Ix < _Sx) {
            _Setx(_Ix, this->_Ax[_Ix + 2 * _Rx - _Sx], this->_Ax[_Ix + _Rx]);
        } else if (_Ix < _Rx) {
            _Setx(_Ix, this->_Ax[_Ix - _Sx], this->_Ax[_Ix + _Rx]);
        } else {
            _Setx(_Ix, this->_Ax[_Ix - _Sx], this->_Ax[_Ix - _Rx]);
        }

        this->_Idx = _Ix + 1;
        return this->_Ax[_Ix];
    }

    void discard(unsigned long long _Nskip) { 
        for (; 0 < _Nskip; --_Nskip) {
            (void) (*this)();
        }
    }

    bool _Equals(const _Swc_base& _Right) const {
        return _Mybase::_Equals(_Right) && _Carry == _Right._Carry;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Swc_Traits::_Write(_Ostr, *this, _Carry);
        return _Ostr;
    }

protected:
    template <class _Gen>
    void _Seed(_Gen& _Gx, bool _Readcy, true_type) { 
        linear_congruential<_Seed_t, 40014U, 0U, 2147483563U> _Lc(_Gx == 0U ? default_seed : _Gx);
        _Reset(_Lc, _Readcy);
    }

    template <class _Gen>
    void _Seed(_Gen& _Gx, bool _Readcy, false_type) { 
        _Reset(_Gx, _Readcy);
    }

    template <class _Gen>
    void _Reset(_Gen& _Gx, bool _Readcy) { 
        _Carry     = _Swc_Traits::_Reset(_Gx, this->_Ax, _Readcy);
        this->_Idx = _Rx;
    }

    void _Setx(size_t _Ix, _Ty _Xis, _Ty _Xir) { 
        bool _Underflowed = false;
        _Ty _Newx         = _Xis;
        if (_Newx < _Xir) {
            _Underflowed = true;
        }

        _Newx -= _Xir;
        if (_Newx < static_cast<typename _Swc_Traits::_UCy_t>(_Carry)) {
            _Underflowed = true;
        }

        _Newx -= _Carry;
        if (_Underflowed) { 
            _Newx += _Swc_Traits::_Mod;
            _Carry = _Swc_Traits::_Cy;
        } else {
            _Carry = 0;
        }

        this->_Ax[_Ix] = _Newx;
    }

    typename _Swc_Traits::_Cy_t _Carry;
};

template <class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits>
[[nodiscard]] bool operator==(
    const _Swc_base<_Ty, _Sx, _Rx, _Swc_Traits>& _Left, const _Swc_base<_Ty, _Sx, _Rx, _Swc_Traits>& _Right) {
    return _Left._Equals(_Right);
}

template <class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits>
[[nodiscard]] bool operator!=(
    const _Swc_base<_Ty, _Sx, _Rx, _Swc_Traits>& _Left, const _Swc_base<_Ty, _Sx, _Rx, _Swc_Traits>& _Right) {
    return !_Left._Equals(_Right);
}

template <class _Elem, class _Traits, class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, _Swc_base<_Ty, _Sx, _Rx, _Swc_Traits>& _Eng) { 
    _Wrap_istream<_Elem, _Traits, typename _Swc_Traits::_Seed_t> _Gen(_Istr);
    _Eng.seed(_Gen, true);
    return _Istr;
}

template <class _Elem, class _Traits, class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const _Swc_base<_Ty, _Sx, _Rx, _Swc_Traits>& _Eng) { 
    return _Eng._Write(_Ostr);
}

template <class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits>
const size_t _Swc_base<_Ty, _Sx, _Rx, _Swc_Traits>::short_lag;

template <class _Ty, size_t _Sx, size_t _Rx, class _Swc_Traits>
const size_t _Swc_base<_Ty, _Sx, _Rx, _Swc_Traits>::long_lag;

template <class _Ty, _Ty _Mx, size_t _Nw>
struct _Swc_traits { 
    using _Cy_t   = int;
    using _UCy_t  = unsigned int;
    using _Mod_t  = _Ty;
    using _Seed_t = _Ty;

    static constexpr _Cy_t _Cy   = 1;
    static constexpr _Mod_t _Mod = _Mx;
    static constexpr _Ty _Max    = _Mx - 1;

    static int _Get_wc() { 
        int _Kx;

        if constexpr (_Mx == 0) {
            _Kx = (8 * sizeof(_Ty) + 31) / 32;
        } else { 
            unsigned long long _Val = 1ULL << 32;
            for (_Kx = 1; 0 < _Val && _Val < _Mx; ++_Kx) {
                _Val = _Val << 32;
            }
        }

        return _Kx;
    }

    template <class _Gen>
    static _Cy_t _Reset(_Gen& _Gx, _Ty* _Ax, bool _Readcy) { 
                                                             
                                                             
        int _Kx = _Get_wc();

        for (size_t _Ix = 0; _Ix < _Nw; ++_Ix) { 
            _Ax[_Ix] = _Gx();
            for (int _Jx = 1; _Jx < _Kx; ++_Jx) {
                _Ax[_Ix] |= static_cast<_Ty>(_Gx()) << (32 * _Jx);
            }
        }

        _Cy_t _Ans = _Reduce(_Ax);
        if (!_Readcy) {
            return _Ans;
        } else {
            return static_cast<_Cy_t>(_Gx()); 
        }
    }

#pragma warning(push)
#pragma warning(disable : 4724) 
    static _Cy_t _Reduce(_Ty* _Ax) { 
        if constexpr (_Mx != 0) {
            for (size_t _Ix = 0; _Ix < _Nw; ++_Ix) {
                _Ax[_Ix] = _Ax[_Ix] % _Mx;
            }
        }

        return _Ax[_Nw - 1] == 0;
    }
#pragma warning(pop)

    template <class _Elem, class _Traits>
    static void _Write(
        basic_ostream<_Elem, _Traits>& _Ostr, const _Circ_buf<_Ty, _Nw>& _Buf, _Cy_t _Cy) { 
        int _Kx = _Get_wc();

        for (size_t _Ix = 0; _Ix < _Nw; ++_Ix) {
            for (int _Jx = 1; _Jx <= _Kx; ++_Jx) { 
                unsigned int _Word = static_cast<unsigned int>(_Buf._At(_Ix) >> ((_Kx - _Jx) * 32));
                _Ostr << _Word << ' ';
            }
        }

        _Ostr << _Cy;
    }
};

template <class _Ty, _Ty _Mx, size_t _Sx, size_t _Rx>
class subtract_with_carry
    : public _Swc_base<_Ty, _Sx, _Rx, _Swc_traits<_Ty, _Mx, _Rx>> { 
public:
    using _Mybase = _Swc_base<_Ty, _Sx, _Rx, _Swc_traits<_Ty, _Mx, _Rx>>;

    static constexpr _Ty modulus = _Mx;

    using _Mybase::default_seed;

    subtract_with_carry() : _Mybase(default_seed) {}

    explicit subtract_with_carry(_Ty _Xx0) : _Mybase(_Xx0) {}

    template <class _Gen, _Enable_if_seed_seq_t<_Gen, subtract_with_carry> = 0>
    subtract_with_carry(_Gen& _Gx) : _Mybase(_Gx) {}
};

template <class _Ty, size_t _Wx, size_t _Sx, size_t _Rx>
class subtract_with_carry_engine : public subtract_with_carry<_Ty, (_Ty{1} << (_Wx - 1)) << 1, _Sx, _Rx> {
    
public:
    static_assert(_Is_any_of_v<_Ty, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "subtract_with_carry_engine" ": N4659 29.6.1.1 [rand.req.genl]/1f requires one of " "unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Ty>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    static_assert(0U < _Sx && _Sx < _Rx && 0 < _Wx && _Wx <= numeric_limits<_Ty>::digits,
        "invalid template argument for subtract_with_carry_engine");

    static constexpr _Ty _Mx          = (_Ty{1} << (_Wx - 1)) << 1;
    static constexpr size_t word_size = _Wx;
    static constexpr size_t short_lag = _Sx;
    static constexpr size_t long_lag  = _Rx;

    using _Mybase     = subtract_with_carry<_Ty, _Mx, _Sx, _Rx>;
    using _Traits     = typename _Mybase::_Traits;
    using result_type = _Ty;

    using _Mybase::default_seed;

    subtract_with_carry_engine() : _Mybase(default_seed) {}

    explicit subtract_with_carry_engine(_Ty _Xx0) : _Mybase(_Xx0) {}

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, subtract_with_carry_engine> = 0>
    explicit subtract_with_carry_engine(_Seed_seq& _Seq) : _Mybase() {
        seed(_Seq);
    }

    void seed(_Ty _Value = default_seed) { 
        this->_Seed(_Value, false, true_type{});
    }

    static constexpr int _Kx = (8 * sizeof(_Ty) + 31) / 32;

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, subtract_with_carry_engine> = 0>
    void seed(_Seed_seq& _Seq) { 
        unsigned long _Arr[_Kx * _Rx];
        _Seq.generate(&_Arr[0], &_Arr[_Kx * _Rx]);

        size_t _Idx0 = 0;
        for (size_t _Ix = 0; _Ix < _Rx; ++_Ix, _Idx0 += _Kx) { 
            this->_Ax[_Ix] = _Arr[_Idx0];
            for (int _Jx = 1; _Jx < _Kx; ++_Jx) {
                this->_Ax[_Ix] |= static_cast<_Ty>(_Arr[_Idx0 + _Jx]) << (32 * _Jx);
            }

            constexpr bool _Mod_non_zero = _Traits::_Mod != 0;
            if constexpr (_Mod_non_zero) {
                this->_Ax[_Ix] %= _Traits::_Mod;
            }
        }

        this->_Carry = _Traits::_Reduce(this->_Ax);
        this->_Idx   = _Rx;
    }

    [[nodiscard]] static constexpr _Ty(min)() {
        return 0;
    }

    [[nodiscard]] static constexpr _Ty(max)() {
        return _Mx - 1;
    }
};


template <class _Ty, size_t _Wx, size_t _Rx>
struct _Swc_01_traits { 
    using _Cy_t   = _Ty;
    using _UCy_t  = _Ty;
    using _Mod_t  = _Ty;
    using _Seed_t = unsigned int;

    static const _Cy_t _Cy;
    static const _Mod_t _Mod;
    static const _Ty _Max;
    static constexpr int _Nwords = (_Wx + 31) / 32;

    template <class _Gen>
    static _Cy_t _Reset(_Gen& _Gx, _Ty* _Ax, bool _Readcy) { 
                                                             
                                                             
        for (size_t _Ix = 0; _Ix < _Rx; ++_Ix) { 
            _Ty _Factor = 1;
            _Ty _Val    = 0;
            for (int _Jx = 0; _Jx < _Nwords - 1; ++_Jx) { 
                _Factor /= static_cast<_Ty>(_Two32);
                _Val += _Gx() * _Factor;
            }
            _Ty _Temp = (static_cast<unsigned long>(_Gx()) & _Mask) / _Scale1;
            _Val += (_Temp - static_cast<unsigned long>(_Temp)) * _Factor;
            _Ax[_Ix] = _Val;
        }
        if (!_Readcy) {
            return _Ax[_Rx - 1] != 0 ? 0 : _Cy;
        } else {
            return _Gx() == 0 ? 0 : _Cy;
        }
    }

    template <class _Elem, class _Traits>
    static void _Write(
        basic_ostream<_Elem, _Traits>& _Ostr, const _Circ_buf<_Ty, _Rx>& _Buf, _Cy_t _Cy) { 
        for (size_t _Ix = 0; _Ix < _Rx; ++_Ix) { 
            _Ty _Val = _Buf._At(_Ix);
            unsigned long _Temp;
            for (int _Jx = 0; _Jx < _Nwords - 1; ++_Jx) { 
                _Val *= static_cast<_Ty>(_Two32);
                _Temp = static_cast<unsigned long>(_Val);
                _Val -= _Temp;
                _Ostr << _Temp << ' ';
            }
            _Temp = static_cast<unsigned long>(_Val * _Scale1);
            _Ostr << _Temp << ' ';
        }
        _Ostr << (_Cy ? 1 : 0);
    }

private:
    static const _Ty _Scale1;
    static constexpr unsigned long _Mask = ~((~0UL) << (_Wx % 32));
};

template <class _Ty, size_t _Wx, size_t _Rx>
const typename _Swc_01_traits<_Ty, _Wx, _Rx>::_Cy_t
    _Swc_01_traits<_Ty, _Wx, _Rx>::_Cy = static_cast<typename _Swc_01_traits<_Ty, _Wx, _Rx>::_Cy_t>(
        :: ldexp(1.0, static_cast<int>(-static_cast<ptrdiff_t>(_Wx))));

template <class _Ty, size_t _Wx, size_t _Rx>
const typename _Swc_01_traits<_Ty, _Wx, _Rx>::_Mod_t _Swc_01_traits<_Ty, _Wx, _Rx>::_Mod = 1;

template <class _Ty, size_t _Wx, size_t _Rx>
const _Ty _Swc_01_traits<_Ty, _Wx, _Rx>::_Max = 1;

template <class _Ty, size_t _Wx, size_t _Rx>
const _Ty _Swc_01_traits<_Ty, _Wx, _Rx>::_Scale1 = static_cast<_Ty>(:: ldexp(1.0, _Wx % 32));

template <class _Ty, size_t _Wx, size_t _Sx, size_t _Rx>
class [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] subtract_with_carry_01
    : public _Swc_base<_Ty, _Sx, _Rx, _Swc_01_traits<_Ty, _Wx, _Rx>> { 
public:
    static constexpr size_t word_size = _Wx;

    using _Mybase = _Swc_base<_Ty, _Sx, _Rx, _Swc_01_traits<_Ty, _Wx, _Rx>>;

    subtract_with_carry_01() : _Mybase() {}

    explicit subtract_with_carry_01(typename _Mybase::_Seed_t _Value) : _Mybase(_Value) {}

    template <class _Gen, _Enable_if_seed_seq_t<_Gen, subtract_with_carry_01> = 0>
    subtract_with_carry_01(_Gen& _Gx) : _Mybase(_Gx) {}
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty, size_t _Wx, size_t _Sx, size_t _Rx>
const size_t subtract_with_carry_01<_Ty, _Wx, _Sx, _Rx>::word_size;
__pragma(warning(pop))

#line 1007 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"

template <class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx, _Ty _Bx, int _Tx, _Ty _Cx, int _Lx>
class mersenne_twister : public _Circ_buf<_Ty, _Nx> { 
public:
    using result_type = _Ty;

    static constexpr int word_size   = _Wx;
    static constexpr int state_size  = _Nx;
    static constexpr int shift_size  = _Mx;
    static constexpr int mask_bits   = _Rx;
    static constexpr _Ty parameter_a = _Px;
    static constexpr int output_u    = _Ux;
    static constexpr int output_s    = _Sx;
    static constexpr _Ty output_b    = _Bx;
    static constexpr int output_t    = _Tx;
    static constexpr _Ty output_c    = _Cx;
    static constexpr int output_l    = _Lx;

    static constexpr _Ty default_seed = 5489U;

    mersenne_twister() : _Dxval(_WMSK) {
        seed(default_seed, static_cast<_Ty>(1812433253));
    }

    explicit mersenne_twister(_Ty _Xx0, _Ty _Dxarg = _WMSK, _Ty _Fxarg = static_cast<_Ty>(1812433253))
        : _Dxval(_Dxarg) {
        seed(_Xx0, _Fxarg);
    }

    template <class _Gen, _Enable_if_seed_seq_t<_Gen, mersenne_twister> = 0>
    explicit mersenne_twister(_Gen& _Gx) : _Dxval(_WMSK) {
        seed(_Gx);
    }

    void seed(_Ty _Xx0 = default_seed, _Ty _Fx = static_cast<_Ty>(1812433253)) {
        
        _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;
        for (size_t _Ix = 1; _Ix < _Nx; ++_Ix) {
            _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
        }

        this->_Idx = _Nx;
    }

    template <class _Gen, _Enable_if_seed_seq_t<_Gen, mersenne_twister> = 0>
    void seed(_Gen& _Gx, bool = false) { 
        for (size_t _Ix = 0; _Ix < _Nx; ++_Ix) {
            this->_Ax[_Ix] = _Gx() & _WMSK;
        }

        this->_Idx = _Nx;
    }

    template <class _Elem, class _S_Traits>
    basic_ostream<_Elem, _S_Traits>& _Write(basic_ostream<_Elem, _S_Traits>& _Ostr) const { 
        for (size_t _Ix = 0; _Ix < _Nx; ++_Ix) {
            _Ostr << this->_At(_Ix) << ' ';
        }

        return _Ostr;
    }

    [[nodiscard]] result_type(min)() const {
        return 0;
    }

    [[nodiscard]] result_type(max)() const {
        return _WMSK;
    }

    [[nodiscard]] result_type operator()() {
        if (this->_Idx == _Nx) {
            _Refill_upper();
        } else if (2 * _Nx <= this->_Idx) {
            _Refill_lower();
        }

        _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;
        _Res ^= (_Res >> _Ux) & _Dxval;
        _Res ^= (_Res << _Sx) & _Bx;
        _Res ^= (_Res << _Tx) & _Cx;
        _Res ^= (_Res & _WMSK) >> _Lx;
        return _Res;
    }

    void discard(unsigned long long _Nskip) { 
        for (; 0 < _Nskip; --_Nskip) {
            (void) (*this)();
        }
    }

protected:
     

        void _Refill_lower() { 
        size_t _Ix;
        for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix) { 
            _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);
            this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
        }

        for (; _Ix < _Nx - 1; ++_Ix) { 
            _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);
            this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
        }

        _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);
        this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
        this->_Idx     = 0;
    }

    void _Refill_upper() { 
        size_t _Ix;
        for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { 
            _Ty _Tmp       = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + 1] & _LMSK);
            this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
        }
    }

    _Ty _Dxval;

    static constexpr _Ty _WMSK = ~((~_Ty{0} << (_Wx - 1)) << 1);
    static constexpr _Ty _HMSK = (_WMSK << _Rx) & _WMSK;
    static constexpr _Ty _LMSK = ~_HMSK & _WMSK;
};

template <class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx, _Ty _Bx, int _Tx, _Ty _Cx, int _Lx>
[[nodiscard]] bool operator==(const mersenne_twister<_Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx>& _Left,
    const mersenne_twister<_Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx>& _Right) {
    return _Left._Equals(_Right);
}

template <class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx, _Ty _Bx, int _Tx, _Ty _Cx, int _Lx>
[[nodiscard]] bool operator!=(const mersenne_twister<_Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx>& _Left,
    const mersenne_twister<_Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx>& _Right) {
    return !_Left._Equals(_Right);
}

template <class _Elem, class _S_Traits, class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx,
    _Ty _Bx, int _Tx, _Ty _Cx, int _Lx>
basic_istream<_Elem, _S_Traits>& operator>>(basic_istream<_Elem, _S_Traits>& _Istr,
    mersenne_twister<_Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx>& _Eng) { 
    _Wrap_istream<_Elem, _S_Traits, _Ty> _Gen(_Istr);
    _Eng.seed(_Gen);
    return _Istr;
}

template <class _Elem, class _S_Traits, class _Ty, int _Wx, int _Nx, int _Mx, int _Rx, _Ty _Px, int _Ux, int _Sx,
    _Ty _Bx, int _Tx, _Ty _Cx, int _Lx>
basic_ostream<_Elem, _S_Traits>& operator<<(basic_ostream<_Elem, _S_Traits>& _Ostr,
    const mersenne_twister<_Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx>& _Eng) { 
    return _Eng._Write(_Ostr);
}

template <class _Ty, size_t _Wx, size_t _Nx, size_t _Mx, size_t _Rx, _Ty _Px, size_t _Ux, _Ty _Dx, size_t _Sx, _Ty _Bx,
    size_t _Tx, _Ty _Cx, size_t _Lx, _Ty _Fx>
class mersenne_twister_engine : public mersenne_twister<_Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx> {
public:
    static constexpr unsigned long long _Max = (((1ULL << (_Wx - 1)) - 1) << 1) + 1;

    static_assert(_Is_any_of_v<_Ty, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "mersenne_twister_engine" ": N4659 29.6.1.1 [rand.req.genl]/1f requires one of " "unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Ty>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    static_assert(0 < _Mx && _Mx <= _Nx && 2U < _Wx && _Rx <= _Wx && _Ux <= _Wx && _Sx <= _Wx && _Tx <= _Wx
                      && _Lx <= _Wx && _Wx <= numeric_limits<_Ty>::digits && _Px <= _Max && _Bx <= _Max && _Cx <= _Max
                      && _Dx <= _Max && _Fx <= _Max,
        "invalid template argument for mersenne_twister_engine");

    using _Mybase     = mersenne_twister<_Ty, _Wx, _Nx, _Mx, _Rx, _Px, _Ux, _Sx, _Bx, _Tx, _Cx, _Lx>;
    using result_type = _Ty;

    static constexpr size_t word_size              = _Wx;
    static constexpr size_t state_size             = _Nx;
    static constexpr size_t shift_size             = _Mx;
    static constexpr size_t mask_bits              = _Rx;
    static constexpr _Ty xor_mask                  = _Px;
    static constexpr size_t tempering_u            = _Ux;
    static constexpr _Ty tempering_d               = _Dx;
    static constexpr size_t tempering_s            = _Sx;
    static constexpr _Ty tempering_b               = _Bx;
    static constexpr size_t tempering_t            = _Tx;
    static constexpr _Ty tempering_c               = _Cx;
    static constexpr size_t tempering_l            = _Lx;
    static constexpr _Ty initialization_multiplier = _Fx;

    static constexpr result_type default_seed = 5489U;

    mersenne_twister_engine() : _Mybase(default_seed, _Dx, _Fx) {}

    explicit mersenne_twister_engine(result_type _Xx0) : _Mybase(_Xx0, _Dx, _Fx) {}

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, mersenne_twister_engine> = 0>
    explicit mersenne_twister_engine(_Seed_seq& _Seq) : _Mybase(default_seed, _Dx, _Fx) {
        seed(_Seq);
    }

    void seed(result_type _Xx0 = default_seed) { 
        _Mybase::seed(_Xx0, _Fx);
    }

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, mersenne_twister_engine> = 0>
    void seed(_Seed_seq& _Seq) { 
        constexpr int _Kx = (_Wx + 31) / 32;
        unsigned long _Arr[_Kx * _Nx];
        _Seq.generate(&_Arr[0], &_Arr[_Kx * _Nx]);

        int _Idx0 = 0;
        _Ty _Sum  = 0;
        for (size_t _Ix = 0; _Ix < _Nx; ++_Ix, _Idx0 += _Kx) { 
            this->_Ax[_Ix] = _Arr[_Idx0];
            for (int _Jx = 1; _Jx < _Kx; ++_Jx) {
                this->_Ax[_Ix] |= static_cast<_Ty>(_Arr[_Idx0 + _Jx]) << (32 * _Jx);
            }

            this->_Ax[_Ix] &= this->_WMSK;

            if (_Ix == 0) {
                _Sum = this->_Ax[_Ix] >> _Rx;
            } else {
                _Sum |= this->_Ax[_Ix];
            }
        }

        if (_Sum == 0) {
            this->_Ax[0] = this->_WMSK;
        }

        this->_Idx = _Nx;
    }

    [[nodiscard]] static constexpr result_type(min)() {
        return 0;
    }

    [[nodiscard]] static constexpr result_type(max)() {
        return _Mybase::_WMSK;
    }
};

template <class _Engine, int _Px, int _Rx>
class discard_block { 
public:
    using base_type   = _Engine;
    using result_type = typename _Engine::result_type;

    static constexpr int block_size = _Px;
    static constexpr int used_block = _Rx;

    discard_block() : _Eng(), _Nx(0) {}

    explicit discard_block(const _Engine& _Ex) : _Eng(_Ex), _Nx(0) {}

    explicit discard_block(result_type _Seed) : _Eng(_Seed), _Nx(0) {}

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, discard_block, _Engine> = 0>
    explicit discard_block(_Seed_seq& _Seq) : _Eng(_Seq), _Nx(0) {}

    void seed() { 
        _Eng.seed();
        _Nx = 0;
    }

    void seed(result_type _Xx0) { 
        _Eng.seed(_Xx0);
        _Nx = 0;
    }

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, discard_block> = 0>
    void seed(_Seed_seq& _Seq) { 
        _Eng.seed(_Seq);
        _Nx = 0;
    }

    [[nodiscard]] const base_type& base() const noexcept {
        return _Eng;
    }

    [[nodiscard]] result_type(min)() const {
        return (_Eng.min)();
    }

    [[nodiscard]] result_type(max)() const {
        return (_Eng.max)();
    }

    [[nodiscard]] result_type operator()() {
        if (_Rx <= _Nx) { 
            while (_Nx++ < _Px) {
                (void) _Eng();
            }

            _Nx = 0;
        }
        ++_Nx;
        return _Eng();
    }

    void discard(unsigned long long _Nskip) { 
        for (; 0 < _Nskip; --_Nskip) {
            (void) (*this)();
        }
    }

    bool _Equals(const discard_block& _Right) const {
        return _Eng == _Right._Eng && _Nx == _Right._Nx;
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        return _Istr >> _Eng >> _Nx;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        return _Ostr << _Eng << ' ' << _Nx;
    }

private:
    base_type _Eng;
    int _Nx;
};

template <class _Engine, int _Px, int _Rx>
const int discard_block<_Engine, _Px, _Rx>::block_size;

template <class _Engine, int _Px, int _Rx>
const int discard_block<_Engine, _Px, _Rx>::used_block;

template <class _Engine, int _Px, int _Rx>
[[nodiscard]] bool operator==(
    const discard_block<_Engine, _Px, _Rx>& _Left, const discard_block<_Engine, _Px, _Rx>& _Right) {
    return _Left._Equals(_Right);
}

template <class _Engine, int _Px, int _Rx>
[[nodiscard]] bool operator!=(
    const discard_block<_Engine, _Px, _Rx>& _Left, const discard_block<_Engine, _Px, _Rx>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Engine, int _Px, int _Rx>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, discard_block<_Engine, _Px, _Rx>& _Eng) { 
    return _Eng._Read(_Istr);
}

template <class _Elem, class _Traits, class _Engine, int _Px, int _Rx>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const discard_block<_Engine, _Px, _Rx>& _Eng) { 
    return _Eng._Write(_Ostr);
}

template <class _Engine, size_t _Px, size_t _Rx>
class discard_block_engine : public discard_block<_Engine, _Px, _Rx> { 
public:
    static_assert(0 < _Rx && _Rx <= _Px, "invalid template argument for discard_block_engine");

    using _Mybase     = discard_block<_Engine, _Px, _Rx>;
    using result_type = typename _Engine::result_type;

    discard_block_engine() : _Mybase() {}

    explicit discard_block_engine(const _Engine& _Ex) : _Mybase(_Ex) {}

    explicit discard_block_engine(_Engine&& _Ex) : _Mybase(::std:: move(_Ex)) {}

    explicit discard_block_engine(result_type _Xx0) : _Mybase(_Xx0) {}

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, discard_block_engine, _Engine> = 0>
    explicit discard_block_engine(_Seed_seq& _Seq) : _Mybase(_Seq) {}

    [[nodiscard]] static constexpr typename _Engine::result_type(min)() {
        return (_Engine::min)();
    }

    [[nodiscard]] static constexpr typename _Engine::result_type(max)() {
        return (_Engine::max)();
    }
};

template <class _Engine, size_t _Wx, class _UIntType>
class independent_bits_engine { 
public:
    static_assert(_Is_any_of_v<_UIntType, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "independent_bits_engine" ": N4659 29.6.1.1 [rand.req.genl]/1f requires one of " "unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_UIntType>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    static_assert(
        0 < _Wx && _Wx <= numeric_limits<_UIntType>::digits, "invalid template argument for independent_bits_engine");

    using base_type   = _Engine;
    using result_type = _UIntType;
    using _Eres       = typename _Engine::result_type;

    independent_bits_engine() {
        _Init();
    }

    explicit independent_bits_engine(const _Engine& _Ex) : _Eng(_Ex) {
        _Init();
    }

    explicit independent_bits_engine(_Engine&& _Ex) : _Eng(::std:: move(_Ex)) {
        _Init();
    }

    explicit independent_bits_engine(result_type _Xx0) : _Eng(static_cast<_Eres>(_Xx0)) {
        _Init();
    }

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, independent_bits_engine, _Engine> = 0>
    explicit independent_bits_engine(_Seed_seq& _Seq) : _Eng(_Seq) {
        _Init();
    }

    void seed() { 
        _Eng.seed();
    }

    void seed(result_type _Xx0) { 
        _Eng.seed(static_cast<_Eres>(_Xx0));
    }

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, independent_bits_engine> = 0>
    void seed(_Seed_seq& _Seq) { 
        _Eng.seed(_Seq);
    }

    [[nodiscard]] const _Engine& base() const noexcept {
        return _Eng;
    }

    [[nodiscard]] static constexpr result_type(min)() {
        return 0;
    }

    [[nodiscard]] static constexpr result_type(max)() {
        return ((result_type{1} << (_Wx - 1)) << 1) - 1;
    }

    [[nodiscard]] result_type operator()() {
        size_t _Idx       = 0;
        result_type _Res  = 0;
        result_type _Mask = ((result_type{1} << (_Wx0 - 1)) << 1) - 1;
        _Eres _Val;

        for (; _Idx < _Nx0; ++_Idx) { 
            for (;;) { 
                _Val = _Eng() - (_Engine::min)();
                if (_Val <= _Yx0) {
                    break;
                }
            }
            _Res = _Res << _Wx0 | (static_cast<result_type>(_Val) & _Mask);
        }

        _Mask = _Mask << 1 | 1;
        for (; _Idx < _Nx; ++_Idx) { 
            for (;;) { 
                _Val = _Eng() - (_Engine::min)();
                if (_Val <= _Yx1) {
                    break;
                }
            }
            _Res = _Res << (_Wx0 + 1) | (static_cast<result_type>(_Val) & _Mask);
        }
        return _Res;
    }

    void discard(unsigned long long _Nskip) { 
        for (; 0 < _Nskip; --_Nskip) {
            (void) (*this)();
        }
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        return _Istr >> _Eng;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        return _Ostr << _Eng;
    }

private:
    void _Init() { 
        size_t _Mx = 0;
        _Eres _Rx  = (_Engine::max)() - (_Engine::min)() + 1;

        _Eres _Tmp = _Rx;
        if (_Tmp == 0) { 
            _Mx = 1;
            --_Tmp;
        }
        for (; 1 < _Tmp; _Tmp >>= 1) {
            ++_Mx; 
        }

        for (size_t _Nfix = 0;; ++_Nfix) { 
            _Nx  = (_Wx + _Mx - 1) / _Mx + _Nfix; 
            _Wx0 = _Wx / _Nx;
            _Nx0 = _Nx - _Wx % _Nx;
            _Yx0 = (_Rx >> _Wx0) << _Wx0;
            _Yx1 = (((_Rx >> _Wx0) >> 1) << _Wx0) << 1;
            if (_Nfix == 1 || _Rx - _Yx0 <= _Yx0 / _Nx) {
                break; 
            }
        }
        --_Yx0;
        --_Yx1;
    }

    _Engine _Eng; 
    size_t _Nx0; 
    size_t _Nx; 
    size_t _Wx0; 
    _Eres _Yx0; 
    _Eres _Yx1; 
};

template <class _Engine, size_t _Wx, class _UIntType>
[[nodiscard]] bool operator==(const independent_bits_engine<_Engine, _Wx, _UIntType>& _Left,
    const independent_bits_engine<_Engine, _Wx, _UIntType>& _Right) {
    return _Left.base() == _Right.base();
}

template <class _Engine, size_t _Wx, class _UIntType>
[[nodiscard]] bool operator!=(const independent_bits_engine<_Engine, _Wx, _UIntType>& _Left,
    const independent_bits_engine<_Engine, _Wx, _UIntType>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Engine, size_t _Wx, class _UIntType>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    independent_bits_engine<_Engine, _Wx, _UIntType>& _Eng) { 
    return _Eng._Read(_Istr);
}

template <class _Elem, class _Traits, class _Engine, size_t _Wx, class _UIntType>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const independent_bits_engine<_Engine, _Wx, _UIntType>& _Eng) { 
    return _Eng._Write(_Ostr);
}

template <class _Engine, size_t _Kx>
class shuffle_order_engine { 
public:
    static_assert(0 < _Kx, "invalid template argument for shuffle_order_engine");

    using base_type   = _Engine;
    using result_type = typename _Engine::result_type;

    static constexpr size_t table_size = _Kx;

    shuffle_order_engine() {
        _Init();
    }

    explicit shuffle_order_engine(const _Engine& _Ex) : _Eng(_Ex) {
        _Init();
    }

    explicit shuffle_order_engine(_Engine&& _Ex) : _Eng(::std:: move(_Ex)) {
        _Init();
    }

    explicit shuffle_order_engine(result_type _Xx0) : _Eng(_Xx0) {
        _Init();
    }

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, shuffle_order_engine, _Engine> = 0>
    explicit shuffle_order_engine(_Seed_seq& _Seq) : _Eng(_Seq) {
        _Init();
    }

    void seed() { 
        _Eng.seed();
        _Init();
    }

    void seed(result_type _Xx0) { 
        _Eng.seed(_Xx0);
        _Init();
    }

    template <class _Seed_seq, _Enable_if_seed_seq_t<_Seed_seq, shuffle_order_engine> = 0>
    void seed(_Seed_seq& _Seq) { 
        _Eng.seed(_Seq);
        _Init();
    }

    [[nodiscard]] const _Engine& base() const noexcept {
        return _Eng;
    }

    [[nodiscard]] static constexpr result_type(min)() {
        return (_Engine::min)();
    }

    [[nodiscard]] static constexpr result_type(max)() {
        return (_Engine::max)();
    }

    [[nodiscard]] result_type operator()() {
        size_t _Idx = static_cast<size_t>(static_cast<double>(_Yx - (_Eng.min)()) * _Scale);

        _Yx        = _Arr[_Idx];
        _Arr[_Idx] = _Eng();
        return _Yx;
    }

    void discard(unsigned long long _Nskip) { 
        for (; 0 < _Nskip; --_Nskip) {
            (void) (*this)();
        }
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Istr >> _Eng;
        for (size_t _Idx = 0; _Idx < _Kx; ++_Idx) {
            _Istr >> _Arr[_Idx];
        }

        return _Istr >> _Yx;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Ostr << _Eng;
        for (size_t _Idx = 0; _Idx < _Kx; ++_Idx) {
            _Ostr << ' ' << _Arr[_Idx];
        }

        return _Ostr << ' ' << _Yx;
    }

private:
    void _Init() { 
        for (size_t _Idx = 0; _Idx < _Kx; ++_Idx) {
            _Arr[_Idx] = _Eng();
        }

        _Yx = _Eng();
        _Scale =
            static_cast<double>(_Kx) / (static_cast<double>((_Eng.max)()) - static_cast<double>((_Eng.min)()) + 1.0);
    }

    _Engine _Eng; 
    result_type _Arr[_Kx];
    result_type _Yx;
    double _Scale;
};

template <class _Engine, size_t _Kx>
[[nodiscard]] bool operator==(
    const shuffle_order_engine<_Engine, _Kx>& _Left, const shuffle_order_engine<_Engine, _Kx>& _Right) {
    return _Left.base() == _Right.base();
}

template <class _Engine, size_t _Kx>
[[nodiscard]] bool operator!=(
    const shuffle_order_engine<_Engine, _Kx>& _Left, const shuffle_order_engine<_Engine, _Kx>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Engine, size_t _Kx>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, shuffle_order_engine<_Engine, _Kx>& _Eng) { 
    return _Eng._Read(_Istr);
}

template <class _Elem, class _Traits, class _Engine, size_t _Kx>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const shuffle_order_engine<_Engine, _Kx>& _Eng) { 
    return _Eng._Write(_Ostr);
}

template <class _Ty = int>
class uniform_int { 
public:
    using result_type = _Ty;

    struct param_type { 
        using distribution_type = uniform_int;

        param_type() {
            _Init(0, 9);
        }

        explicit param_type(result_type _Min0, result_type _Max0 = 9) {
            _Init(_Min0, _Max0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Min == _Right._Min && _Max == _Right._Max;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] result_type a() const {
            return _Min;
        }

        [[nodiscard]] result_type b() const {
            return _Max;
        }

        void _Init(_Ty _Min0, _Ty _Max0) { 
            ;
            _Min = _Min0;
            _Max = _Max0;
        }

        result_type _Min;
        result_type _Max;
    };

    uniform_int() : _Par(0, 9) {}

    explicit uniform_int(_Ty _Min0, _Ty _Max0 = 9) : _Par(_Min0, _Max0) {}

    explicit uniform_int(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] result_type a() const {
        return _Par.a();
    }

    [[nodiscard]] result_type b() const {
        return _Par.b();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const {
        return _Par._Min;
    }

    [[nodiscard]] result_type(max)() const {
        return _Par._Max;
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par._Min, _Par._Max);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0._Min, _Par0._Max);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, result_type _Nx) const {
        return _Eval(_Eng, 0, _Nx - 1);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Min0;
        _Ty _Max0;
        _Istr >> _Min0 >> _Max0;
        _Par._Init(_Min0, _Max0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        return _Ostr << _Par._Min << ' ' << _Par._Max;
    }

private:
    using _Uty = make_unsigned_t<_Ty>;

    template <class _Engine>
    result_type _Eval(_Engine& _Eng, _Ty _Min, _Ty _Max) const { 
        _Rng_from_urng<_Uty, _Engine> _Generator(_Eng);

        const _Uty _Umin = _Adjust(static_cast<_Uty>(_Min));
        const _Uty _Umax = _Adjust(static_cast<_Uty>(_Max));

        _Uty _Uret;

        if (_Umax - _Umin == static_cast<_Uty>(-1)) {
            _Uret = static_cast<_Uty>(_Generator._Get_all_bits());
        } else {
            _Uret = static_cast<_Uty>(_Generator(static_cast<_Uty>(_Umax - _Umin + 1)));
        }

        return static_cast<_Ty>(_Adjust(static_cast<_Uty>(_Uret + _Umin)));
    }

    static _Uty _Adjust(_Uty _Uval) { 
        if constexpr (is_signed_v<_Ty>) {
            const _Uty _Adjuster = (static_cast<_Uty>(-1) >> 1) + 1; 

            if (_Uval < _Adjuster) {
                return static_cast<_Uty>(_Uval + _Adjuster);
            } else {
                return static_cast<_Uty>(_Uval - _Adjuster);
            }
        } else { 
            return _Uval;
        }
    }

    param_type _Par;
};

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    uniform_int<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const uniform_int<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = int>
class uniform_int_distribution : public uniform_int<_Ty> { 
public:
    static_assert(_Is_any_of_v<_Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "uniform_int_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1e requires one of " "short, int, long, long long, unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Ty>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    using _Mybase     = uniform_int<_Ty>;
    using _Mypbase    = typename _Mybase::param_type;
    using result_type = typename _Mybase::result_type;

    struct param_type : _Mypbase { 
        using distribution_type = uniform_int_distribution;

        param_type() : _Mypbase(0, (numeric_limits<_Ty>::max)()) {}

        explicit param_type(result_type _Min0, result_type _Max0 = (numeric_limits<_Ty>::max)())
            : _Mypbase(_Min0, _Max0) {}

        param_type(const _Mypbase& _Right) : _Mypbase(_Right) {}
    };

    uniform_int_distribution() : _Mybase(0, (numeric_limits<_Ty>::max)()) {}

    explicit uniform_int_distribution(_Ty _Min0, _Ty _Max0 = (numeric_limits<_Ty>::max)()) : _Mybase(_Min0, _Max0) {}

    explicit uniform_int_distribution(const param_type& _Par0) : _Mybase(_Par0) {}
};

template <class _Ty>
[[nodiscard]] bool operator==(const uniform_int_distribution<_Ty>& _Left, const uniform_int_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const uniform_int_distribution<_Ty>& _Left, const uniform_int_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

class bernoulli_distribution { 
public:
    using result_type = bool;

    struct param_type { 
        using distribution_type = bernoulli_distribution;

        param_type() {
            _Init(0.5);
        }

        explicit param_type(double _Px0) {
            _Init(_Px0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Px == _Right._Px;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] double p() const {
            return _Px;
        }

        void _Init(double _Px0) { 
            ;

            _Px = _Px0;
        }

        double _Px;
    };

    bernoulli_distribution() : _Par(0.5) {}

    explicit bernoulli_distribution(double _Px0) : _Par(_Px0) {}

    explicit bernoulli_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] double p() const {
        return _Par.p();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return false;
    }

    [[nodiscard]] result_type(max)() const { 
        return true;
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        double _Px0;
        _In(_Istr, _Px0);
        _Par._Init(_Px0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Px);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        return (::std:: generate_canonical<double, static_cast<size_t>(-1)>(_Eng)) < _Par0._Px;
    }

    param_type _Par;
};

[[nodiscard]] inline bool operator==(const bernoulli_distribution& _Left, const bernoulli_distribution& _Right) {
    return _Left.param() == _Right.param();
}

[[nodiscard]] inline bool operator!=(const bernoulli_distribution& _Left, const bernoulli_distribution& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    bernoulli_distribution& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const bernoulli_distribution& _Dist) { 
    return _Dist._Write(_Ostr);
}





template <class _Flt, class _Ty>
[[nodiscard]] _Flt _Float_upper_bound(_Ty _Val) {
    static_assert(is_unsigned_v<_Ty> && is_integral_v<_Ty> && is_floating_point_v<_Flt>,
        "invalid template argument for _Float_upper_bound");
    constexpr auto _Ty_digits  = numeric_limits<_Ty>::digits;
    constexpr auto _Flt_digits = numeric_limits<_Flt>::digits;
    using _Ty_32or64           = conditional_t<_Ty_digits <= 32, uint32_t, uint64_t>;

    if constexpr (_Ty_digits <= _Flt_digits) {
        return static_cast<_Flt>(_Val) + _Flt{1};
    } else {
#pragma warning(push)
#pragma warning(disable : 4146 4293) 
        constexpr auto _Mask = static_cast<_Ty>(-1) << (_Ty_digits - _Flt_digits);




        const auto _Log_plus1 = _Bit_scan_reverse(static_cast<_Ty_32or64>(_Val | _Ty{1}));
#line 2014 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
        const auto _Shifted_mask = _Mask >> (_Ty_digits - _Log_plus1);
        const auto _Ceil_ulp     = _Shifted_mask & -_Shifted_mask;
        _Val &= _Shifted_mask;
        if (_Val == _Mask) {
            
            constexpr auto _Big_ulp = static_cast<_Flt>(_Mask & -_Mask);
            return static_cast<_Flt>(_Val) + _Big_ulp;
        } else {
            return static_cast<_Flt>(_Val + _Ceil_ulp);
        }
#pragma warning(pop)
    }
}

template <class _Ty = int>
class geometric_distribution { 
public:
    using _Ty1 = double;

    using result_type = _Ty;

    static_assert(_Is_any_of_v<_Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "geometric_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1e requires one of " "short, int, long, long long, unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Ty>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    struct param_type { 
        using distribution_type = geometric_distribution;

        param_type() {
            _Init(_Ty1(0.5));
        }

        explicit param_type(_Ty1 _Px0) {
            _Init(_Px0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Px == _Right._Px;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty1 p() const {
            return _Px;
        }

        void _Init(_Ty1 _Px0) { 
            ;
            _Px      = _Px0;
            _Log_1_p = :: log(1 - _Px);
        }

        _Ty1 _Px;
        _Ty1 _Log_1_p;
    };

    geometric_distribution() : _Par(_Ty1(0.5)) {}

    explicit geometric_distribution(_Ty1 _Px0) : _Par(_Px0) {}

    explicit geometric_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty1 p() const {
        return _Par.p();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return 0;
    }

    [[nodiscard]] result_type(max)() const { 
        return (numeric_limits<result_type>::max)();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty1 _Px0;
        _In(_Istr, _Px0);
        _Par._Init(_Px0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Px);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        using _Uty = make_unsigned_t<_Ty>;
        constexpr auto _Ty_max{(numeric_limits<_Ty>::max)()};
        const auto _Ty1_max{_Float_upper_bound<_Ty1>(static_cast<_Uty>(_Ty_max))};

        _Ty1 _Val;
        do {
            _Val = :: log((::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng))) / _Par0._Log_1_p;
        } while (_Val >= _Ty1_max);
        return static_cast<_Ty>(_Val);
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const geometric_distribution<_Ty>& _Left, const geometric_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const geometric_distribution<_Ty>& _Left, const geometric_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    geometric_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const geometric_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = int>
class _Small_poisson_distribution { 
public:
    using _Ty1 = double;

    template <class _Engine>
    [[nodiscard]] _Ty operator()(_Engine& _Eng) const {
        _Ty _Res;
        _Ty1 _Val;
        for (_Res = 0, _Val = 1.0;; ++_Res) { 
            _Val *= (::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng));
            if (_Val <= _Gx0) {
                break;
            }
        }
        return _Res;
    }

    void _Init(const _Ty1& _Mean0) { 
        _Gx0 = :: exp(-_Mean0);
    }

private:
    _Ty1 _Gx0;
};

template <class _Ty = int>
class poisson_distribution { 
public:
    using _Ty1 = double;

    using result_type = _Ty;

    static_assert(_Is_any_of_v<_Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "poisson_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1e requires one of " "short, int, long, long long, unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Ty>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    struct param_type { 
        using distribution_type = poisson_distribution;

        param_type() {
            _Init(_Ty1(1));
        }

        explicit param_type(_Ty1 _Mean0) {
            _Init(_Mean0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Mean == _Right._Mean;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty1 mean() const {
            return _Mean;
        }

        void _Init(_Ty1 _Mean0) { 
            ;
            _Mean = _Mean0;
            _Sqrt = :: sqrt(2.0 * _Mean0);
            _Logm = :: log(_Mean0);
            _Gx1  = _Mean0 * _Logm - _XLgamma(_Mean0 + 1.0);
            _Small._Init(_Mean0);
        }

        _Ty1 _Mean;
        _Ty1 _Sqrt;
        _Ty1 _Logm;
        _Ty1 _Gx1;

        _Small_poisson_distribution<_Ty> _Small;
    };

    poisson_distribution() : _Par(_Ty1(1)) {}

    explicit poisson_distribution(_Ty1 _Mean0) : _Par(_Mean0) {}

    explicit poisson_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty1 mean() const {
        return _Par.mean();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return 0;
    }

    [[nodiscard]] result_type(max)() const { 
        return (numeric_limits<result_type>::max)();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty1 _Mean0;
        _In(_Istr, _Mean0);
        _Par._Init(_Mean0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Mean);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        if (_Par0._Mean < 12.0) {
            return _Par0._Small(_Eng);
        }

        for (;;) { 
            using _Uty = make_unsigned_t<_Ty>;
            constexpr auto _Ty_max{(numeric_limits<_Ty>::max)()};
            const auto _Ty1_max{_Float_upper_bound<_Ty1>(static_cast<_Uty>(_Ty_max))};

            _Ty _Res;
            _Ty1 _Yx;
            for (;;) { 
                _Yx = static_cast<_Ty1>(:: tan(_Pi * (::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng))));
                const _Ty1 _Mx{_Par0._Sqrt * _Yx + _Par0._Mean};
                if (0.0 <= _Mx && _Mx < _Ty1_max) {
                    _Res = static_cast<_Ty>(_Mx);
                    break;
                }
            }

            if ((::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng))
                <= 0.9 * (1.0 + _Yx * _Yx) * :: exp(_Res * _Par0._Logm - _XLgamma(_Res + 1.0) - _Par0._Gx1)) {
                return _Res;
            }
        }
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const poisson_distribution<_Ty>& _Left, const poisson_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const poisson_distribution<_Ty>& _Left, const poisson_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    poisson_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const poisson_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = int>
class binomial_distribution { 
public:
    using _Ty1 = double;

    using result_type = _Ty;

    static_assert(_Is_any_of_v<_Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "binomial_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1e requires one of " "short, int, long, long long, unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Ty>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    struct param_type { 
        using distribution_type = binomial_distribution;

        param_type() {
            _Init(1, _Ty1(0.5));
        }

        explicit param_type(_Ty _Tx0, _Ty1 _Px0 = _Ty1(0.5)) {
            _Init(_Tx0, _Px0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Tx == _Right._Tx && _Px == _Right._Px;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty t() const {
            return _Tx;
        }

        [[nodiscard]] _Ty1 p() const {
            return _Px;
        }

        void _Init(_Ty _Tx0, _Ty1 _Px0) { 
            ;
            ;
            _Tx    = _Tx0;
            _Px    = _Px0;
            _Pp    = _Px < 0.5 ? _Px : (1.0 - _Px);
            _Mean  = _Tx * _Pp;
            _Gx1   = _XLgamma(_Tx + 1.0);
            _Sqrt  = :: sqrt(2 * _Mean * (1 - _Pp));
            _Logp  = :: log(_Pp);
            _Logp1 = :: log(1.0 - _Pp);
            _Small._Init(_Mean);
        }

        _Ty _Tx;
        _Ty1 _Px;
        _Ty1 _Pp;
        _Ty1 _Mean;
        _Ty1 _Gx1;
        _Ty1 _Sqrt;
        _Ty1 _Logp;
        _Ty1 _Logp1;

        _Small_poisson_distribution<_Ty> _Small; 
    };

    binomial_distribution() : _Par(1, _Ty1(0.5)) {}

    explicit binomial_distribution(_Ty _Tx0, _Ty1 _Px0 = _Ty1(0.5)) : _Par(_Tx0, _Px0) {}

    explicit binomial_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty t() const {
        return _Par.t();
    }

    [[nodiscard]] _Ty1 p() const {
        return _Par.p();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return 0;
    }

    [[nodiscard]] result_type(max)() const { 
        return _Par.t();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Tx0;
        _Ty1 _Px0;
        _In(_Istr, _Px0);
        _In(_Istr, _Tx0);
        _Par._Init(_Tx0, _Px0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Px);
        _Out(_Ostr, _Par._Tx);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(
        _Engine& _Eng, const param_type& _Par0) const { 
        _Ty _Res;
        if (_Par0._Tx < 25) { 
            _Res = 0;
            for (_Ty _Ix = 0; _Ix < _Par0._Tx; ++_Ix) {
                if ((::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng)) < _Par0._Px) {
                    ++_Res;
                }
            }

            return _Res;
        } else if (_Par0._Mean < 1.0) {
            
            const _Ty1 _Rand = (::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng));

            
            
            
            
            
            const _Ty1 _Ub =
                (::std:: min)(_Par0._Mean, _Ty1{3.678794411714423216e-1} * _Par0._Pp + _Ty1{6.32120558828557678e-1});
            if (_Rand > _Ub) {
                _Res = _Ty{0};
            } else {
                _Ty _Denom = _Par0._Tx;
                _Ty1 _Sum  = :: log(_Ty1{1.0} - _Rand) / _Denom;
                while (_Sum >= _Par0._Logp1 && --_Denom != 0) {
                    _Sum += :: log(_Ty1{1.0} - (::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng))) / _Denom;
                }
                _Res = static_cast<_Ty>(_Par0._Tx - _Denom);
            }
        } else { 
            using _Uty = make_unsigned_t<_Ty>;
            const auto _Ty1_Tx{_Float_upper_bound<_Ty1>(static_cast<_Uty>(_Par0._Tx))};

            for (;;) { 
                _Ty1 _Yx;
                for (;;) { 
                    _Yx = static_cast<_Ty1>(:: tan(_Pi * (::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng))));
                    const _Ty1 _Mx{_Par0._Sqrt * _Yx + _Par0._Mean};
                    if (0.0 <= _Mx && _Mx < _Ty1_Tx) {
                        _Res = static_cast<_Ty>(_Mx);
                        break;
                    }
                }
                if ((::std:: generate_canonical<_Ty1, static_cast<size_t>(-1)>(_Eng))
                    <= 1.2 * _Par0._Sqrt * (1.0 + _Yx * _Yx)
                           * :: exp(_Par0._Gx1 - _XLgamma(_Res + 1.0) - _XLgamma(_Par0._Tx - _Res + 1.0)
                                       + _Res * _Par0._Logp + (_Par0._Tx - _Res) * _Par0._Logp1)) {
                    break;
                }
            }
        }
        return _Par0._Px == _Par0._Pp ? _Res : static_cast<_Ty>(_Par0._Tx - _Res);
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const binomial_distribution<_Ty>& _Left, const binomial_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const binomial_distribution<_Ty>& _Left, const binomial_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    binomial_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const binomial_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class uniform_real { 
public:
    using result_type = _Ty;

    struct param_type { 
        using distribution_type = uniform_real;

        param_type() {
            _Init(_Ty{0}, _Ty{1});
        }

        explicit param_type(_Ty _Min0, _Ty _Max0 = _Ty{1}) {
            _Init(_Min0, _Max0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Min == _Right._Min && _Max == _Right._Max;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] result_type a() const {
            return _Min;
        }

        [[nodiscard]] result_type b() const {
            return _Max;
        }

        void _Init(_Ty _Min0, _Ty _Max0) { 
            ;
#line 2584 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
            _Min = _Min0;
            _Max = _Max0;
        }

        result_type _Min;
        result_type _Max;
    };

    uniform_real() : _Par(_Ty{0}, _Ty{1}) {}

    explicit uniform_real(_Ty _Min0, _Ty _Max0 = _Ty{1}) : _Par(_Min0, _Max0) {}

    explicit uniform_real(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] result_type a() const {
        return _Par.a();
    }

    [[nodiscard]] result_type b() const {
        return _Par.b();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const {
        return _Par._Min;
    }

    [[nodiscard]] result_type(max)() const {
        return _Par._Max;
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Min0;
        _Ty _Max0;
        _In(_Istr, _Min0);
        _In(_Istr, _Max0);
        _Par._Init(_Min0, _Max0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Min);
        _Out(_Ostr, _Par._Max);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        return (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng)) * (_Par0._Max - _Par0._Min) + _Par0._Min;
    }

    param_type _Par;
};

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    uniform_real<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const uniform_real<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class uniform_real_distribution : public uniform_real<_Ty> { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "uniform_real_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using _Mybase     = uniform_real<_Ty>;
    using _Mypbase    = typename _Mybase::param_type;
    using result_type = typename _Mybase::result_type;

    struct param_type : _Mypbase { 
        using distribution_type = uniform_real_distribution;

        param_type() : _Mypbase(_Ty{0}, _Ty{1}) {}

        explicit param_type(_Ty _Min0, _Ty _Max0 = _Ty{1}) : _Mypbase(_Min0, _Max0) {}

        param_type(const _Mypbase& _Right) : _Mypbase(_Right) {}
    };

    uniform_real_distribution() : _Mybase(_Ty{0}, _Ty{1}) {}

    explicit uniform_real_distribution(_Ty _Min0, _Ty _Max0 = _Ty{1}) : _Mybase(_Min0, _Max0) {}

    explicit uniform_real_distribution(const param_type& _Par0) : _Mybase(_Par0) {}
};

template <class _Ty>
[[nodiscard]] bool operator==(const uniform_real_distribution<_Ty>& _Left, const uniform_real_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const uniform_real_distribution<_Ty>& _Left, const uniform_real_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Ty = double>
class exponential_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "exponential_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = exponential_distribution;

        param_type() {
            _Init(_Ty{1});
        }

        explicit param_type(_Ty _Lambda0) {
            _Init(_Lambda0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Lambda == _Right._Lambda;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty lambda() const {
            return _Lambda;
        }

        void _Init(_Ty _Lambda0) { 
            ;
            _Lambda = _Lambda0;
        }

        _Ty _Lambda;
    };

    exponential_distribution() : _Par(_Ty{1}) {}

    explicit exponential_distribution(_Ty _Lambda0) : _Par(_Lambda0) {}

    explicit exponential_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty lambda() const {
        return _Par.lambda();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return 0;
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Lambda0;
        _In(_Istr, _Lambda0);
        _Par._Init(_Lambda0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Lambda);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        return -:: log(_Ty{1} - (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng))) / _Par0._Lambda;
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const exponential_distribution<_Ty>& _Left, const exponential_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const exponential_distribution<_Ty>& _Left, const exponential_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    exponential_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const exponential_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class normal_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "normal_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = normal_distribution;

        param_type() {
            _Init(0.0, 1.0);
        }

        explicit param_type(_Ty _Mean0, _Ty _Sigma0 = 1.0) {
            _Init(_Mean0, _Sigma0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Mean == _Right._Mean && _Sigma == _Right._Sigma;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty mean() const {
            return _Mean;
        }

        [[nodiscard]] _Ty sigma() const {
            return _Sigma;
        }

        [[nodiscard]] _Ty stddev() const {
            return _Sigma;
        }

        void _Init(_Ty _Mean0, _Ty _Sigma0) { 
            ;
            _Mean  = _Mean0;
            _Sigma = _Sigma0;
        }

        _Ty _Mean;
        _Ty _Sigma;
    };

    normal_distribution() : _Par(0.0, 1.0), _Valid(false), _Xx2(0) {}

    explicit normal_distribution(_Ty _Mean0, _Ty _Sigma0 = 1.0) : _Par(_Mean0, _Sigma0), _Valid(false), _Xx2(0) {}

    explicit normal_distribution(const param_type& _Par0) : _Par(_Par0), _Valid(false), _Xx2(0) {}

    [[nodiscard]] _Ty mean() const {
        return _Par.mean();
    }

    [[nodiscard]] _Ty sigma() const {
        return _Par.sigma();
    }

    [[nodiscard]] _Ty stddev() const {
        return _Par.sigma();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
        reset();
    }

    [[nodiscard]] result_type(min)() const { 
        return -numeric_limits<result_type>::infinity();
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() { 
        _Valid = false;
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) {
        reset();
        return _Eval(_Eng, _Par0, false);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Mean0;
        _Ty _Sigma0;
        _In(_Istr, _Mean0);
        _In(_Istr, _Sigma0);
        _Par._Init(_Mean0, _Sigma0);

        _Istr >> _Valid;
        _In(_Istr, _Xx2);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Mean);
        _Out(_Ostr, _Par._Sigma);

        _Ostr << ' ' << _Valid;
        _Out(_Ostr, _Xx2);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0,
        bool _Keep = true) { 
                             
        _Ty _Res;
        if (_Keep && _Valid) {
            _Res   = _Xx2;
            _Valid = false;
        } else { 
            _Ty _Vx1;
            _Ty _Vx2;
            _Ty _Sx;
            for (;;) { 
                _Vx1 = 2 * (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng)) - 1;
                _Vx2 = 2 * (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng)) - 1;
                _Sx  = _Vx1 * _Vx1 + _Vx2 * _Vx2;
                if (_Sx < _Ty{1} && _Vx1 != _Ty{0} && _Vx2 != _Ty{0}) {
                    
                    break;
                }
            }

            _Ty _LogSx;
            if (_Sx > _Ty{1e-4}) {
                _LogSx = ::std:: log(_Sx);
            } else {
                
                
                const _Ty _Ln2{_Ty{0.69314718055994530941723212145818}};
                const _Ty _Maxabs{(::std:: max)(::std:: abs(_Vx1), ::std:: abs(_Vx2))};
                const int _ExpMax{::std:: ilogb(_Maxabs)};
                _Vx1   = ::std:: scalbn(_Vx1, -_ExpMax);
                _Vx2   = ::std:: scalbn(_Vx2, -_ExpMax);
                _Sx    = _Vx1 * _Vx1 + _Vx2 * _Vx2;
                _LogSx = ::std:: log(_Sx) + static_cast<_Ty>(_ExpMax) * (_Ln2 * 2);
            }

            const auto _Fx = _Ty{::std:: sqrt(_Ty{-2} * _LogSx / _Sx)};
            if (_Keep) { 
                _Xx2   = _Fx * _Vx2;
                _Valid = true;
            }
            _Res = _Fx * _Vx1;
        }
        return _Res * _Par0._Sigma + _Par0._Mean;
    }

    param_type _Par;
    bool _Valid;
    _Ty _Xx2;
};

template <class _Ty>
[[nodiscard]] bool operator==(const normal_distribution<_Ty>& _Left, const normal_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const normal_distribution<_Ty>& _Left, const normal_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    normal_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const normal_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class gamma_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "gamma_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = gamma_distribution;

        param_type() {
            _Init(_Ty{1}, _Ty{1});
        }

        explicit param_type(_Ty _Alpha0, _Ty _Beta0 = _Ty{1}) {
            _Init(_Alpha0, _Beta0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Alpha == _Right._Alpha && _Beta == _Right._Beta;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty alpha() const {
            return _Alpha;
        }

        [[nodiscard]] _Ty beta() const {
            return _Beta;
        }

        void _Init(_Ty _Alpha0, _Ty _Beta0) { 
            ;
            ;
            _Alpha = _Alpha0;
            _Beta  = _Beta0;
            _Px    = static_cast<_Ty>(_Exp1 / (_Alpha + _Exp1));
            _Sqrt  = :: sqrt(2 * _Alpha - 1);
        }

        _Ty _Alpha;
        _Ty _Beta;
        _Ty _Px;
        _Ty _Sqrt;
        exponential_distribution<_Ty> _Exp;
    };

    gamma_distribution() : _Par(_Ty{1}, _Ty{1}) {}

    explicit gamma_distribution(_Ty _Alpha0, _Ty _Beta0 = _Ty{1}) : _Par(_Alpha0, _Beta0) {}

    explicit gamma_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty alpha() const {
        return _Par.alpha();
    }

    [[nodiscard]] _Ty beta() const {
        return _Par.beta();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return result_type{0.0};
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Alpha0;
        _Ty _Beta0;
        _In(_Istr, _Alpha0);
        _In(_Istr, _Beta0);
        _Par._Init(_Alpha0, _Beta0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Alpha);
        _Out(_Ostr, _Par._Beta);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, param_type _Par0) const {
        _Ty _Ux;
        _Ty _Vx;
        _Ty _Xx;
        _Ty _Yx;
        _Ty _Qx;
        int _Count;
        if (_Par0._Alpha < 1) { 
                                
            for (;;) { 
                _Ux = (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng));
                do {
                    _Vx = (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng));
                } while (_Vx == 0);

                if (_Ux < _Par0._Px) { 
                    _Xx = :: pow(_Vx, _Ty{1} / _Par0._Alpha);
                    _Qx = :: exp(-_Xx);
                } else { 
                    _Xx = 1 - :: log(_Vx);
                    _Qx = :: pow(_Xx, _Par0._Alpha - 1);
                }

                if ((::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng)) < _Qx) {
                    return _Par0._Beta * _Xx;
                }
            }
        }

        if (_Par0._Alpha == 1) {
            return _Par0._Beta * _Par0._Exp(_Eng);
        }

        if (_Par0._Alpha < 20.0 && (_Count = static_cast<int>(_Par0._Alpha)) == _Par0._Alpha) {
            
            _Yx = (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng));
            while (--_Count) { 
                do {
                    _Ux = (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng));
                } while (_Ux == 0);

                _Yx *= _Ux;
            }
            return _Par0._Beta * -:: log(_Yx);
        }

        
        for (;;) { 
            _Yx = static_cast<_Ty>(:: tan(_Pi * (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng))));
            _Xx = _Par0._Sqrt * _Yx + _Par0._Alpha - 1;
            if (0 < _Xx
                && (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng)) <= (1 + _Yx * _Yx)
                                            * :: exp((_Par0._Alpha - 1) * :: log(_Xx / (_Par0._Alpha - 1))
                                                        - _Par0._Sqrt * _Yx)) {
                return _Par0._Beta * _Xx;
            }
        }
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const gamma_distribution<_Ty>& _Left, const gamma_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const gamma_distribution<_Ty>& _Left, const gamma_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    gamma_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const gamma_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class weibull_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "weibull_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = weibull_distribution;

        param_type() {
            _Init(_Ty{1}, _Ty{1});
        }

        explicit param_type(_Ty _Ax0, _Ty _Bx0 = _Ty{1}) {
            _Init(_Ax0, _Bx0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Ax == _Right._Ax && _Bx == _Right._Bx;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty a() const {
            return _Ax;
        }

        [[nodiscard]] _Ty b() const {
            return _Bx;
        }

        void _Init(_Ty _Ax0, _Ty _Bx0) { 
            ;
            ;
            _Ax = _Ax0;
            _Bx = _Bx0;
        }

        _Ty _Ax;
        _Ty _Bx;
    };

    weibull_distribution() : _Par(_Ty{1}, _Ty{1}) {}

    explicit weibull_distribution(_Ty _Ax0, _Ty _Bx0 = _Ty{1}) : _Par(_Ax0, _Bx0) {}

    explicit weibull_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty a() const {
        return _Par.a();
    }

    [[nodiscard]] _Ty b() const {
        return _Par.b();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return 0;
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Ax0;
        _Ty _Bx0;
        _In(_Istr, _Ax0);
        _In(_Istr, _Bx0);
        _Par._Init(_Ax0, _Bx0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Ax);
        _Out(_Ostr, _Par._Bx);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const { 
        _Ty _Px = (_Ty{1} - (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng)));
        return _Par0._Bx * :: pow(-:: log(_Px), _Ty{1} / _Par0._Ax);
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const weibull_distribution<_Ty>& _Left, const weibull_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const weibull_distribution<_Ty>& _Left, const weibull_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    weibull_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const weibull_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class extreme_value_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "extreme_value_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = extreme_value_distribution;

        param_type() {
            _Init(_Ty{0}, _Ty{1});
        }

        explicit param_type(_Ty _Ax0, _Ty _Bx0 = _Ty{1}) {
            _Init(_Ax0, _Bx0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Ax == _Right._Ax && _Bx == _Right._Bx;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty a() const {
            return _Ax;
        }

        [[nodiscard]] _Ty b() const {
            return _Bx;
        }

        void _Init(_Ty _Ax0, _Ty _Bx0) { 
            ;
            _Ax = _Ax0;
            _Bx = _Bx0;
        }

        _Ty _Ax;
        _Ty _Bx;
    };

    extreme_value_distribution() : _Par(_Ty{0}, _Ty{1}) {}

    explicit extreme_value_distribution(_Ty _Ax0, _Ty _Bx0 = _Ty{1}) : _Par(_Ax0, _Bx0) {}

    explicit extreme_value_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty a() const {
        return _Par.a();
    }

    [[nodiscard]] _Ty b() const {
        return _Par.b();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return -numeric_limits<result_type>::infinity();
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Ax0;
        _Ty _Bx0;
        _In(_Istr, _Ax0);
        _In(_Istr, _Bx0);
        _Par._Init(_Ax0, _Bx0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Ax);
        _Out(_Ostr, _Par._Bx);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const { 
        _Ty _Px = (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng));
        return _Par0._Ax - _Par0._Bx * :: log(-:: log(_Px));
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(
    const extreme_value_distribution<_Ty>& _Left, const extreme_value_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(
    const extreme_value_distribution<_Ty>& _Left, const extreme_value_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    extreme_value_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const extreme_value_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class lognormal_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "lognormal_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = lognormal_distribution;

        param_type() {
            _Init(_Ty{0}, _Ty{1});
        }

        explicit param_type(_Ty _Mx0, _Ty _Sx0 = _Ty{1}) {
            _Init(_Mx0, _Sx0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Mx == _Right._Mx && _Sx == _Right._Sx;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty m() const {
            return _Mx;
        }

        [[nodiscard]] _Ty s() const {
            return _Sx;
        }

        void _Init(_Ty _Mx0, _Ty _Sx0) { 
            ;
            _Mx = _Mx0;
            _Sx = _Sx0;
        }

        _Ty _Mx;
        _Ty _Sx;
    };

    lognormal_distribution() : _Par(_Ty{0}, _Ty{1}) {}

    explicit lognormal_distribution(_Ty _Mx0, _Ty _Sx0 = _Ty{1}) : _Par(_Mx0, _Sx0) {}

    explicit lognormal_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty m() const {
        return _Par.m();
    }

    [[nodiscard]] _Ty s() const {
        return _Par.s();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return result_type{0.0};
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Mx0;
        _Ty _Sx0;
        _In(_Istr, _Mx0);
        _In(_Istr, _Sx0);
        _Par._Init(_Mx0, _Sx0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Mx);
        _Out(_Ostr, _Par._Sx);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, param_type _Par0) const { 
        normal_distribution<_Ty> _Dist(_Par0._Mx, _Par0._Sx);
        return :: exp(_Dist(_Eng));
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const lognormal_distribution<_Ty>& _Left, const lognormal_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const lognormal_distribution<_Ty>& _Left, const lognormal_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    lognormal_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const lognormal_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class chi_squared_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "chi_squared_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = chi_squared_distribution;

        param_type() {
            _Init(_Ty{1});
        }

        explicit param_type(_Ty _Nx0) {
            _Init(_Nx0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Nx == _Right._Nx;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty n() const {
            return _Nx;
        }

        void _Init(_Ty _Nx0) { 
            ;
            _Nx = _Nx0;
        }

        _Ty _Nx;
    };

    chi_squared_distribution() : _Par(_Ty{1}) {}

    explicit chi_squared_distribution(_Ty _Nx0) : _Par(_Nx0) {}

    explicit chi_squared_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty n() const {
        return _Par.n();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return result_type{0.0};
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Nx0;
        _Istr >> _Nx0;
        _Par._Init(_Nx0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        return _Ostr << ' ' << _Par._Nx;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        gamma_distribution<_Ty> _Dist(static_cast<_Ty>(_Par0._Nx) * static_cast<_Ty>(0.5), _Ty{2});
        return _Dist(_Eng);
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const chi_squared_distribution<_Ty>& _Left, const chi_squared_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const chi_squared_distribution<_Ty>& _Left, const chi_squared_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    chi_squared_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const chi_squared_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class cauchy_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "cauchy_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = cauchy_distribution;

        param_type() {
            _Init(_Ty{0}, _Ty{1});
        }

        explicit param_type(_Ty _Ax0, _Ty _Bx0 = _Ty{1}) {
            _Init(_Ax0, _Bx0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Ax == _Right._Ax && _Bx == _Right._Bx;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty a() const {
            return _Ax;
        }

        [[nodiscard]] _Ty b() const {
            return _Bx;
        }

        void _Init(_Ty _Ax0, _Ty _Bx0) { 
            ;
            _Ax = _Ax0;
            _Bx = _Bx0;
        }

        _Ty _Ax;
        _Ty _Bx;
    };

    cauchy_distribution() : _Par(_Ty{0}, _Ty{1}) {}

    explicit cauchy_distribution(_Ty _Ax0, _Ty _Bx0 = _Ty{1}) : _Par(_Ax0, _Bx0) {}

    explicit cauchy_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty a() const {
        return _Par.a();
    }

    [[nodiscard]] _Ty b() const {
        return _Par.b();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return -numeric_limits<result_type>::infinity();
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Ax0;
        _Ty _Bx0;
        _In(_Istr, _Ax0);
        _In(_Istr, _Bx0);
        _Par._Init(_Ax0, _Bx0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Ax);
        _Out(_Ostr, _Par._Bx);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const { 
        _Ty Px = (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng));
        return static_cast<_Ty>(_Par0._Ax + _Par0._Bx * :: tan(_Pi * (Px - static_cast<_Ty>(0.5))));
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const cauchy_distribution<_Ty>& _Left, const cauchy_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const cauchy_distribution<_Ty>& _Left, const cauchy_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    cauchy_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const cauchy_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class _Beta_distribution { 
public:
    using result_type = _Ty;

    explicit _Beta_distribution(const _Ty& _Ax0 = _Ty{1}, const _Ty& _Bx0 = _Ty{1}) {
        _Init(_Ax0, _Bx0);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        if (_Ax < _Ty{1} && _Bx < _Ty{1}) { 
            _Ty _Wx;
            _Ty _Px1;
            _Ty _Px2;
            for (;;) { 
                _Px1 = (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng));
                _Px2 = (::std:: generate_canonical<_Ty, static_cast<size_t>(-1)>(_Eng));
                _Px1 = :: pow(_Px1, _Ty{1} / _Ax);
                _Px2 = :: pow(_Px2, _Ty{1} / _Bx);
                _Wx  = _Px1 + _Px2;
                if (_Wx <= _Ty{1} && _Wx != _Ty{0}) {
                    break;
                }
            }
            return _Px1 / _Wx;
        } else { 
            _Ty _Px1;
            _Ty _Px2;
            _Ty _PSum;
            gamma_distribution<_Ty> _Dist1(_Ax, 1);
            gamma_distribution<_Ty> _Dist2(_Bx, 1);

            for (;;) { 
                _Px1  = _Dist1(_Eng);
                _Px2  = _Dist2(_Eng);
                _PSum = _Px1 + _Px2;

                if (_PSum != _Ty{0}) {
                    break;
                }
            }

            return _Px1 / _PSum;
        }
    }

private:
    void _Init(_Ty _Ax0, _Ty _Bx0) { 
        ;
        ;
        _Ax = _Ax0;
        _Bx = _Bx0;
    }

    _Ty _Ax;
    _Ty _Bx;
};

template <class _Ty = double>
class fisher_f_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "fisher_f_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = fisher_f_distribution;

        param_type() {
            _Init(_Ty{1}, _Ty{1});
        }

        explicit param_type(_Ty _Mx0, _Ty _Nx0 = _Ty{1}) {
            _Init(_Mx0, _Nx0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Mx == _Right._Mx && _Nx == _Right._Nx;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty m() const {
            return _Mx;
        }

        [[nodiscard]] _Ty n() const {
            return _Nx;
        }

        void _Init(_Ty _Mx0, _Ty _Nx0) { 
            ;
            ;
            _Mx = _Mx0;
            _Nx = _Nx0;
        }

        _Ty _Mx;
        _Ty _Nx;
    };

    fisher_f_distribution() : _Par(_Ty{1}, _Ty{1}) {}

    explicit fisher_f_distribution(_Ty _Mx0, _Ty _Nx0 = _Ty{1}) : _Par(_Mx0, _Nx0) {}

    explicit fisher_f_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty m() const {
        return _Par.m();
    }

    [[nodiscard]] _Ty n() const {
        return _Par.n();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return result_type(0);
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Mx0;
        _Ty _Nx0;
        _Istr >> _Mx0 >> _Nx0;
        _Par._Init(_Mx0, _Nx0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Ostr << ' ' << _Par._Mx << ' ' << _Par._Nx;
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        _Ty _Px;
        _Ty _Vx1;
        _Ty _Vx2;
        const _Ty _Vx3{1};
        _Vx1 = static_cast<_Ty>(_Par0._Mx) * static_cast<_Ty>(0.5);
        _Vx2 = static_cast<_Ty>(_Par0._Nx) * static_cast<_Ty>(0.5);
        _Beta_distribution<_Ty> _Dist(_Vx1, _Vx2);
        for (;;) { 
            _Px = _Dist(_Eng);
            if (_Px != _Vx3) {
                break;
            }
        }

        return (_Vx2 / _Vx1) * (_Px / (_Vx3 - _Px));
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const fisher_f_distribution<_Ty>& _Left, const fisher_f_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const fisher_f_distribution<_Ty>& _Left, const fisher_f_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    fisher_f_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const fisher_f_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class student_t_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "student_t_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = student_t_distribution;

        param_type() {
            _Init(_Ty{1});
        }

        explicit param_type(_Ty _Nx0) {
            _Init(_Nx0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Nx == _Right._Nx;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty n() const {
            return _Nx;
        }

        void _Init(_Ty _Nx0) { 
            ;
            _Nx = _Nx0;
        }

        _Ty _Nx;
    };

    student_t_distribution() : _Par(_Ty{1}) {}

    explicit student_t_distribution(_Ty _Nx0) : _Par(_Nx0) {}

    explicit student_t_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty n() const {
        return _Par.n();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return -numeric_limits<result_type>::infinity();
    }

    [[nodiscard]] result_type(max)() const { 
        return numeric_limits<result_type>::infinity();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Nx0;
        _Istr >> _Nx0;
        _Par._Init(_Nx0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        return _Ostr << ' ' << _Par._Nx;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        _Ty _Vx1;
        _Ty _Vx2;
        _Ty _Rx0;
        _Ty _Rs;
        uniform_real<_Ty> _Dist(-1, 1);
        for (;;) { 
            _Vx1 = _Dist(_Eng);
            _Vx2 = _Dist(_Eng);
            _Rs  = _Vx1 * _Vx1 + _Vx2 * _Vx2;

            
            if (_Rs < _Ty{1} && _Rs > _Ty{1e-12}) {
                break;
            }
        }
        _Rx0 = ::std:: sqrt(_Rs);
        return _Vx1 * ::std:: sqrt(_Par0._Nx * (::std:: pow(_Rx0, -_Ty{4} / _Par0._Nx) - _Ty{1}) / _Rs);
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const student_t_distribution<_Ty>& _Left, const student_t_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const student_t_distribution<_Ty>& _Left, const student_t_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    student_t_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const student_t_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = int>
class negative_binomial_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "negative_binomial_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1e requires one of " "short, int, long, long long, unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Ty>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    using result_type = _Ty;

    struct param_type { 
        using distribution_type = negative_binomial_distribution;

        param_type() {
            _Init(1, 0.5);
        }

        explicit param_type(_Ty _Kx0, double _Px0 = 0.5) {
            _Init(_Kx0, _Px0);
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Kx == _Right._Kx && _Px == _Right._Px;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Ty k() const {
            return _Kx;
        }

        [[nodiscard]] double p() const {
            return _Px;
        }

        void _Init(_Ty _Kx0, double _Px0) { 
            ;
#line 4263 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
            ;
#line 4265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
            _Kx = _Kx0;
            _Px = _Px0;
        }

        _Ty _Kx;
        double _Px;
    };

    negative_binomial_distribution() : _Par(1, 0.5) {}

    explicit negative_binomial_distribution(_Ty _Kx0, double _Px0 = 0.5) : _Par(_Kx0, _Px0) {}

    explicit negative_binomial_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Ty k() const {
        return _Par.k();
    }

    [[nodiscard]] double p() const {
        return _Par.p();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const { 
        return 0;
    }

    [[nodiscard]] result_type(max)() const { 
        return (numeric_limits<result_type>::max)();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Ty _Kx0;
        double _Px0;
        _In(_Istr, _Px0);
        _In(_Istr, _Kx0);
        _Par._Init(_Kx0, _Px0);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Out(_Ostr, _Par._Px);
        _Out(_Ostr, _Par._Kx);
        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        double _Vx1;
        gamma_distribution<double> _Dist1(
            static_cast<double>(_Par0._Kx), static_cast<double>((_Ty{1} - _Par0._Px) / _Par0._Px));
        _Vx1 = _Dist1(_Eng);
        poisson_distribution<_Ty> _Dist2(_Vx1);

        return _Dist2(_Eng);
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(
    const negative_binomial_distribution<_Ty>& _Left, const negative_binomial_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(
    const negative_binomial_distribution<_Ty>& _Left, const negative_binomial_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    negative_binomial_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const negative_binomial_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = int>
class discrete_distribution { 
public:
    static_assert(_Is_any_of_v<_Ty, short, int, long, long long, unsigned short, unsigned int, unsigned long, unsigned long long>, "invalid template argument for " "discrete_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1e requires one of " "short, int, long, long long, unsigned short, unsigned int, unsigned long, or unsigned long long"); static_assert(!_Is_character<_Ty>::value, "note: char, signed char, unsigned char, char8_t, int8_t, and uint8_t are not allowed");

    using _Myvec      = vector<double>;
    using result_type = _Ty;

    struct param_type { 
        using distribution_type = discrete_distribution;

        param_type(_Uninitialized) {} 

        param_type() {
            _Init();
        }

        template <class _InIt>
        param_type(_InIt _First, _InIt _Last) : _Pvec(_First, _Last) {
            _Init();
        }

        param_type(initializer_list<double> _Ilist) : _Pvec(_Ilist) {
            _Init();
        }

        template <class _Fn>
        param_type(size_t _Count, double _Low, double _High, _Fn _Func) {
            double _Range = _High - _Low;
            ;
            if (_Count <= 0) {
                _Count = 1;
            }

            _Range /= static_cast<double>(_Count);
            _Low += 0.5 * _Range; 
            for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
                _Pvec.push_back(_Func(_Low + _Idx * _Range));
            }

            _Init();
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return _Pvec == _Right._Pvec;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] _Myvec probabilities() const {
            return _Pvec;
        }

        void _Init(bool _Renorm = true) { 
            size_t _Size = _Pvec.size();
            size_t _Idx;

            if (_Renorm) {
                if (_Pvec.empty()) {
                    _Pvec.push_back(1.0); 
                } else { 
                    double _Sum = 0;

                    for (_Idx = 0; _Idx < _Size; ++_Idx) { 
                        ;
                        _Sum += _Pvec[_Idx];
                    }

                    ;
                    if (_Sum != 1.0) {
                        for (_Idx = 0; _Idx < _Size; ++_Idx) {
                            _Pvec[_Idx] /= _Sum;
                        }
                    }
                }
            }

            _Pcdf.assign(1, _Pvec[0]);
            for (_Idx = 1; _Idx < _Size; ++_Idx) {
                _Pcdf.push_back(_Pvec[_Idx] + _Pcdf[_Idx - 1]);
            }
        }

        _Myvec _Pvec;
        _Myvec _Pcdf;
    };

    discrete_distribution() {}

    template <class _InIt>
    discrete_distribution(_InIt _First, _InIt _Last) : _Par(_First, _Last) {}

    discrete_distribution(initializer_list<double> _Ilist) : _Par(_Ilist) {}

    template <class _Fn>
    discrete_distribution(size_t _Count, double _Low, double _High, _Fn _Func) : _Par(_Count, _Low, _High, _Func) {}

    explicit discrete_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] _Myvec probabilities() const {
        return _Par.probabilities();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const {
        return 0;
    }

    [[nodiscard]] result_type(max)() const {
        return static_cast<result_type>(_Par._Pvec.size() - 1);
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr,
        param_type& _Par0) { 
        size_t _Nvals;
        _Istr >> _Nvals;
        _Par0._Pvec.clear();
        for (; 0 < _Nvals; --_Nvals) { 
            double _Val;
            _In(_Istr, _Val);
            _Par0._Pvec.push_back(_Val);
        }
        _Par0._Init(false); 
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr,
        const param_type& _Par0) const { 
        size_t _Nvals = _Par0._Pvec.size();
        _Ostr << ' ' << _Nvals;

        for (size_t _Idx = 0; _Idx < _Par0._Pvec.size(); ++_Idx) {
            _Out(_Ostr, _Par0._Pvec[_Idx]);
        }

        return _Ostr;
    }

private:
    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        double _Px           = (::std:: generate_canonical<double, static_cast<size_t>(-1)>(_Eng));
        const auto _First    = _Par0._Pcdf.begin();
        const auto _Position = ::std:: lower_bound(_First, _Prev_iter(_Par0._Pcdf.end()), _Px);
        return static_cast<result_type>(_Position - _First);
    }

public:
    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(const discrete_distribution<_Ty>& _Left, const discrete_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const discrete_distribution<_Ty>& _Left, const discrete_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    discrete_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr, _Dist._Par);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const discrete_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr, _Dist._Par);
}

template <class _Ty = double>
class piecewise_constant_distribution
    : public discrete_distribution<size_t> { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "piecewise_constant_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using _Mybase     = discrete_distribution<size_t>;
    using _Mypbase    = typename _Mybase::param_type;
    using result_type = _Ty;

    struct param_type : _Mypbase { 
        using distribution_type = piecewise_constant_distribution;

        param_type() : _Bvec{0, 1} {}

        template <class _InIt1, class _InIt2>
        param_type(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2) : _Mypbase(_Noinit), _Bvec(_First1, _Last1) {
            if (2 <= _Bvec.size()) {
                for (size_t _Idx = 0; _Idx < _Bvec.size() - 1; ++_Idx) {
                    this->_Pvec.push_back(static_cast<double>(*_First2++));
                }
            } else { 
                _Bvec = {0, 1};
            }

            _Init();
        }

        template <class _Fn>
        param_type(initializer_list<_Ty> _Ilist, _Fn _Func) : _Mypbase(_Noinit) {
            if (2 <= _Ilist.size()) {
                _Bvec.assign(_Ilist);

                for (size_t _Idx = 0; _Idx < _Bvec.size() - 1; ++_Idx) {
                    this->_Pvec.push_back(_Func(_Ty{0.5} * (_Bvec[_Idx] + _Bvec[_Idx + 1])));
                }
            } else { 
                _Bvec = {0, 1};
            }

            _Init();
        }

        template <class _Fn>
        param_type(size_t _Count, _Ty _Low, _Ty _High, _Fn _Func) : _Mypbase(_Count, _Low, _High, _Func) {
            _Ty _Range = _High - _Low;
            if (_Count <= 0) {
                _Count = 1;
            }

            _Range /= static_cast<_Ty>(_Count);
            for (size_t _Idx = 0; _Idx <= _Count; ++_Idx) {
                _Bvec.push_back(_Low + _Idx * _Range);
            }
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return static_cast<const _Mypbase&>(*this) == static_cast<const _Mypbase&>(_Right) && _Bvec == _Right._Bvec;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] vector<_Ty> intervals() const {
            return _Bvec;
        }

        [[nodiscard]] vector<_Ty> densities() const {
            vector<_Ty> _Ans(this->_Pvec.begin(), this->_Pvec.end());

            for (size_t _Idx = 0; _Idx < _Ans.size(); ++_Idx) {
                _Ans[_Idx] /= _Bvec[_Idx + 1] - _Bvec[_Idx];
            }

            return _Ans;
        }

        void _Init() { 
            _Mypbase::_Init();
        }

        vector<_Ty> _Bvec;
    };

    piecewise_constant_distribution() {}

    template <class _InIt1, class _InIt2>
    piecewise_constant_distribution(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2) : _Par(_First1, _Last1, _First2) {}

    template <class _Fn>
    piecewise_constant_distribution(initializer_list<_Ty> _Ilist, _Fn _Func) : _Par(_Ilist, _Func) {}

    template <class _Fn>
    piecewise_constant_distribution(size_t _Count, _Ty _Low, _Ty _High, _Fn _Func) : _Par(_Count, _Low, _High, _Func) {}

    explicit piecewise_constant_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] vector<_Ty> intervals() const {
        return _Par.intervals();
    }

    [[nodiscard]] vector<_Ty> densities() const {
        return _Par.densities();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const {
        return _Par._Bvec.front();
    }

    [[nodiscard]] result_type(max)() const {
        return _Par._Bvec.back();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr) { 
        _Mybase::_Read(_Istr, _Par);

        _Par._Bvec.clear();
        for (size_t _Idx = _Par._Pvec.size() + 1; 0 < _Idx; --_Idx) { 
            double _Val;
            _In(_Istr, _Val);
            _Par._Bvec.push_back(_Val);
        }
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Mybase::_Write(_Ostr, _Par);

        for (size_t _Idx = 0; _Idx < _Par._Bvec.size(); ++_Idx) {
            _Out(_Ostr, _Par._Bvec[_Idx]);
        }

        return _Ostr;
    }

    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        size_t _Px = _Mybase::operator()(_Eng, _Par0);
        uniform_real<_Ty> _Dist(_Par0._Bvec[_Px], _Par0._Bvec[_Px + 1]);
        return _Dist(_Eng);
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(
    const piecewise_constant_distribution<_Ty>& _Left, const piecewise_constant_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(
    const piecewise_constant_distribution<_Ty>& _Left, const piecewise_constant_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    piecewise_constant_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const piecewise_constant_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

template <class _Ty = double>
class piecewise_linear_distribution
    : public discrete_distribution<size_t> { 
public:
    static_assert(_Is_any_of_v<_Ty, float, double, long double>, "invalid template argument for " "piecewise_linear_distribution" ": N4659 29.6.1.1 [rand.req.genl]/1d requires one of " "float, double, or long double");

    using _Mybase     = discrete_distribution<size_t>;
    using _Mypbase    = typename _Mybase::param_type;
    using result_type = _Ty;

    struct param_type : _Mypbase { 
        
        
        using distribution_type = piecewise_linear_distribution;

        param_type() : _Bvec{0, 1} {
            this->_Pvec.push_back(1.0);
        }

        template <class _InIt1, class _InIt2>
        param_type(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2) : _Mypbase(_Noinit), _Bvec(_First1, _Last1) {
            if (2 <= _Bvec.size()) {
                for (size_t _Idx = 0; _Idx < _Bvec.size(); ++_Idx) {
                    this->_Pvec.push_back(static_cast<double>(*_First2++));
                }
            } else { 
                _Bvec = {0, 1};
            }

            _Init();
        }

        template <class _Fn>
        param_type(initializer_list<_Ty> _Ilist, _Fn _Func) : _Mypbase(_Noinit) {
            if (2 <= _Ilist.size()) {
                _Bvec.assign(_Ilist);

                for (const auto& _Bval : _Bvec) {
                    this->_Pvec.push_back(_Func(_Bval));
                }
            } else { 
                _Bvec = {0, 1};
            }

            _Init();
        }

        template <class _Fn>
        param_type(size_t _Count, _Ty _Low, _Ty _High, _Fn _Func) : _Mypbase(_Noinit) {
            _Ty _Range = _High - _Low;
            ;
            if (_Count < 1) {
                _Count = 1;
            }

            _Range /= static_cast<double>(_Count);
            for (size_t _Idx = 0; _Idx <= _Count; ++_Idx) { 
                _Ty _Bval = _Low + _Idx * _Range;
                _Bvec.push_back(_Bval);
                this->_Pvec.push_back(_Func(_Bval));
            }
            _Init();
        }

        [[nodiscard]] bool operator==(const param_type& _Right) const {
            return static_cast<const _Mypbase&>(*this) == static_cast<const _Mypbase&>(_Right) && _Bvec == _Right._Bvec;
        }

        [[nodiscard]] bool operator!=(const param_type& _Right) const {
            return !(*this == _Right);
        }

        [[nodiscard]] vector<_Ty> intervals() const {
            return _Bvec;
        }

        [[nodiscard]] vector<_Ty> densities() const {
            vector<_Ty> _Ans(this->_Pvec.begin(), this->_Pvec.end());
            return _Ans;
        }

        [[nodiscard]] double _Piece_probability(const size_t _Idx) const {
            return 0.5 * (this->_Pvec[_Idx] + this->_Pvec[_Idx + 1])
                 * static_cast<double>(_Bvec[_Idx + 1] - _Bvec[_Idx]);
        }

        void _Init(bool _Renorm = true) { 
            size_t _Size = this->_Pvec.size();
            size_t _Idx;

            if (_Renorm) {
                if (this->_Pvec.empty()) { 
                    this->_Pvec = {1.0, 1.0};
                } else { 
                    double _Sum = 0;

                    ;
#line 4857 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
                    for (_Idx = 1; _Idx < _Size; ++_Idx) { 
                        ;
#line 4860 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
                        _Sum += _Piece_probability(_Idx - 1);
                    }

                    ;
#line 4865 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
                    if (_Sum != 1.0) {
                        for (_Idx = 0; _Idx < _Size; ++_Idx) {
                            this->_Pvec[_Idx] /= _Sum;
                        }
                    }
                }
            }

            this->_Pcdf.assign(1, _Piece_probability(0));
            for (_Idx = 2; _Idx < _Size; ++_Idx) {
                this->_Pcdf.push_back(_Piece_probability(_Idx - 1) + this->_Pcdf[_Idx - 2]);
            }
        }

        vector<_Ty> _Bvec;
    };

    piecewise_linear_distribution() {}

    template <class _InIt1, class _InIt2>
    piecewise_linear_distribution(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2) : _Par(_First1, _Last1, _First2) {}

    template <class _Fn>
    piecewise_linear_distribution(initializer_list<_Ty> _Ilist, _Fn _Func) : _Par(_Ilist, _Func) {}

    template <class _Fn>
    piecewise_linear_distribution(size_t _Count, _Ty _Low, _Ty _High, _Fn _Func) : _Par(_Count, _Low, _High, _Func) {}

    explicit piecewise_linear_distribution(const param_type& _Par0) : _Par(_Par0) {}

    [[nodiscard]] vector<_Ty> intervals() const {
        return _Par.intervals();
    }

    [[nodiscard]] vector<_Ty> densities() const {
        return _Par.densities();
    }

    [[nodiscard]] param_type param() const {
        return _Par;
    }

    void param(const param_type& _Par0) { 
        _Par = _Par0;
    }

    [[nodiscard]] result_type(min)() const {
        return _Par._Bvec.front();
    }

    [[nodiscard]] result_type(max)() const {
        return _Par._Bvec.back();
    }

    void reset() {} 

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng) const {
        return _Eval(_Eng, _Par);
    }

    template <class _Engine>
    [[nodiscard]] result_type operator()(_Engine& _Eng, const param_type& _Par0) const {
        return _Eval(_Eng, _Par0);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Read(basic_istream<_Elem, _Traits>& _Istr,
        param_type& _Par0) { 
        size_t _Nvals;
        _Istr >> _Nvals;
        _Par0._Pvec.clear();
        for (; 0 < _Nvals; --_Nvals) { 
            double _Val;
            _In(_Istr, _Val);
            _Par0._Pvec.push_back(_Val);
        }

        _Par0._Bvec.clear();
        for (size_t _Idx = _Par0._Pvec.size(); 0 < _Idx; --_Idx) { 
            double _Val;
            _In(_Istr, _Val);
            _Par0._Bvec.push_back(_Val);
        }
        _Par0._Init(false); 
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& _Write(basic_ostream<_Elem, _Traits>& _Ostr) const { 
        _Mybase::_Write(_Ostr, _Par);

        for (size_t _Idx = 0; _Idx < _Par._Bvec.size(); ++_Idx) {
            _Out(_Ostr, _Par._Bvec[_Idx]);
        }

        return _Ostr;
    }

    template <class _Engine>
    result_type _Eval(_Engine& _Eng, const param_type& _Par0) const {
        size_t _Px  = _Mybase::operator()(_Eng, _Par0);
        double _Px0 = _Par0._Pvec[_Px];
        double _Px1 = _Par0._Pvec[_Px + 1];
        uniform_real<_Ty> _Dist;
        result_type _Xx0 = _Dist(_Eng);

        if (_Px0 != _Px1) {
            _Xx0 = static_cast<result_type>(
                (::std:: sqrt(_Px0 * _Px0 * (1.0 - _Xx0) + _Px1 * _Px1 * _Xx0) - _Px0) / (_Px1 - _Px0));
        }

        return _Par0._Bvec[_Px] + _Xx0 * (_Par0._Bvec[_Px + 1] - _Par0._Bvec[_Px]);
    }

    param_type _Par;
};

template <class _Ty>
[[nodiscard]] bool operator==(
    const piecewise_linear_distribution<_Ty>& _Left, const piecewise_linear_distribution<_Ty>& _Right) {
    return _Left.param() == _Right.param();
}

template <class _Ty>
[[nodiscard]] bool operator!=(
    const piecewise_linear_distribution<_Ty>& _Left, const piecewise_linear_distribution<_Ty>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Ty>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr,
    piecewise_linear_distribution<_Ty>& _Dist) { 
    return _Dist._Read(_Istr, _Dist._Par);
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const piecewise_linear_distribution<_Ty>& _Dist) { 
    return _Dist._Write(_Ostr);
}

using minstd_rand0 = linear_congruential_engine<unsigned int, 16807, 0, 2147483647>;
using minstd_rand  = linear_congruential_engine<unsigned int, 48271, 0, 2147483647>;

using mt19937 = mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 0x9908b0df, 11, 0xffffffff, 7, 0x9d2c5680, 15,
    0xefc60000, 18, 1812433253>;


__pragma(warning(push)) __pragma(warning(disable : 4996))
using _Ranbase = subtract_with_carry<unsigned int, 1 << 24, 10, 24>;
[[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef discard_block<_Ranbase, 223, 24> ranlux3;
[[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef discard_block<_Ranbase, 389, 24> ranlux4;

[[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef subtract_with_carry_01<float, 24, 10, 24> ranlux_base_01;
[[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef subtract_with_carry_01<double, 48, 5, 12> ranlux64_base_01;
[[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef discard_block<ranlux_base_01, 223, 24> ranlux3_01;
[[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] typedef discard_block<ranlux_base_01, 389, 24> ranlux4_01;
__pragma(warning(pop))
#line 5025 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"

using mt19937_64 = mersenne_twister_engine<unsigned long long, 64, 312, 156, 31, 0xb5026f5aa96619e9ULL, 29,
    0x5555555555555555ULL, 17, 0x71d67fffeda60000ULL, 37, 0xfff7eee000000000ULL, 43, 6364136223846793005ULL>;

using ranlux24_base = subtract_with_carry_engine<unsigned int, 24, 10, 24>;
using ranlux48_base = subtract_with_carry_engine<unsigned long long, 48, 5, 12>;
using ranlux24      = discard_block_engine<ranlux24_base, 223, 23>;
using ranlux48      = discard_block_engine<ranlux48_base, 389, 11>;
using knuth_b       = shuffle_order_engine<minstd_rand0, 256>;

using default_random_engine = mt19937;


 unsigned int __cdecl _Random_device();

class random_device { 
public:
    using result_type = unsigned int;

    random_device() {}

    explicit random_device(const string&) {}

    [[nodiscard]] static constexpr result_type(min)() {
        return 0;
    }

    [[nodiscard]] static constexpr result_type(max)() {
        return static_cast<result_type>(-1);
    }

    [[nodiscard]] double entropy() const noexcept {
        return 32.0;
    }

    [[nodiscard]] result_type operator()() {
        return _Random_device();
    }

    random_device(const random_device&) = delete;
    random_device& operator=(const random_device&) = delete;
};


__pragma(warning(push)) __pragma(warning(disable : 4996))
namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: bernoulli_distribution;
    using ::std:: binomial_distribution;
    using ::std:: discard_block;
    using ::std:: exponential_distribution;
    using ::std:: gamma_distribution;
    using ::std:: geometric_distribution;
    using ::std:: linear_congruential;
    using ::std:: mersenne_twister;
    using ::std:: minstd_rand;
    using ::std:: minstd_rand0;
    using ::std:: mt19937;
    using ::std:: normal_distribution;
    using ::std:: poisson_distribution;
    using ::std:: random_device;
    using ::std:: ranlux3;
    using ::std:: ranlux3_01;
    using ::std:: ranlux4;
    using ::std:: ranlux4_01;
    using ::std:: ranlux64_base_01;
    using ::std:: ranlux_base_01;
    using ::std:: subtract_with_carry;
    using ::std:: subtract_with_carry_01;
    using ::std:: uniform_int;
    using ::std:: uniform_real;
    using ::std:: cauchy_distribution;
    using ::std:: chi_squared_distribution;
    using ::std:: default_random_engine;
    using ::std:: discard_block_engine;
    using ::std:: discrete_distribution;
    using ::std:: extreme_value_distribution;
    using ::std:: fisher_f_distribution;
    using ::std:: generate_canonical;
    using ::std:: independent_bits_engine;
    using ::std:: knuth_b;
    using ::std:: linear_congruential_engine;
    using ::std:: lognormal_distribution;
    using ::std:: mersenne_twister_engine;
    using ::std:: mt19937_64;
    using ::std:: negative_binomial_distribution;
    using ::std:: piecewise_constant_distribution;
    using ::std:: piecewise_linear_distribution;
    using ::std:: ranlux24;
    using ::std:: ranlux24_base;
    using ::std:: ranlux48;
    using ::std:: ranlux48_base;
    using ::std:: seed_seq;
    using ::std:: shuffle_order_engine;
    using ::std:: student_t_distribution;
    using ::std:: subtract_with_carry_engine;
    using ::std:: uniform_int_distribution;
    using ::std:: uniform_real_distribution;
    using ::std:: weibull_distribution;
} 
__pragma(warning(pop))
#line 5126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
}





#pragma warning(pop)
#pragma pack(pop)
#line 5135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
#line 5136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\random"
#pragma external_header(pop)
#line 22 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ratio"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <intmax_t _Val>
struct _Abs : integral_constant<intmax_t, (_Val < 0 ? -_Val : _Val)> {}; 

template <intmax_t _Ax, intmax_t _Bx, bool _Sfinae = false,
    bool _Good = (_Abs<_Ax>::value <= 9223372036854775807i64 / (_Bx == 0 ? 1 : _Abs<_Bx>::value))>
struct _Safe_mult : integral_constant<intmax_t, _Ax * _Bx> {}; 

template <intmax_t _Ax, intmax_t _Bx, bool _Sfinae>
struct _Safe_mult<_Ax, _Bx, _Sfinae, false> { 
    static_assert(_Sfinae, "integer arithmetic overflow");
};

template <intmax_t _Val>
struct _Sign_of : integral_constant<intmax_t, (_Val < 0 ? -1 : 1)> {}; 

template <intmax_t _Ax, intmax_t _Bx, bool _Good, bool _Also_good>
struct _Safe_addX : integral_constant<intmax_t, _Ax + _Bx> {}; 

template <intmax_t _Ax, intmax_t _Bx>
struct _Safe_addX<_Ax, _Bx, false, false> { 
    static_assert(_Always_false<_Safe_addX>, "integer arithmetic overflow");
};

template <intmax_t _Ax, intmax_t _Bx>
struct _Safe_add : _Safe_addX<_Ax, _Bx, _Sign_of<_Ax>::value != _Sign_of<_Bx>::value,
                       (_Abs<_Ax>::value <= 9223372036854775807i64 - _Abs<_Bx>::value)>::type {
    
};

template <intmax_t _Ax, intmax_t _Bx>
struct _GcdX : _GcdX<_Bx, _Ax % _Bx>::type {}; 

template <intmax_t _Ax>
struct _GcdX<_Ax, 0> : integral_constant<intmax_t, _Ax> {}; 

template <intmax_t _Ax, intmax_t _Bx>
struct _Gcd : _GcdX<_Abs<_Ax>::value, _Abs<_Bx>::value>::type {}; 

template <>
struct _Gcd<0, 0> : integral_constant<intmax_t, 1> {
    
};

template <intmax_t _Nx, intmax_t _Dx = 1>
struct ratio { 
    static_assert(_Dx != 0, "zero denominator");
    static_assert(-9223372036854775807i64 <= _Nx, "numerator too negative");
    static_assert(-9223372036854775807i64 <= _Dx, "denominator too negative");

    static constexpr intmax_t num =
        _Sign_of<_Nx>::value * _Sign_of<_Dx>::value * _Abs<_Nx>::value / _Gcd<_Nx, _Dx>::value;

    static constexpr intmax_t den = _Abs<_Dx>::value / _Gcd<_Nx, _Dx>::value;

    using type = ratio<num, den>;
};

template <class _Ty>
 constexpr bool _Is_ratio_v = false; 

template <intmax_t _Rx1, intmax_t _Rx2>
 constexpr bool _Is_ratio_v<ratio<_Rx1, _Rx2>> = true;

template <class _Rx1, class _Rx2>
struct _Ratio_add { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_add<R1, R2> requires R1 and R2 to be ratio<>s.");

    static constexpr intmax_t _Nx1 = _Rx1::num;
    static constexpr intmax_t _Dx1 = _Rx1::den;
    static constexpr intmax_t _Nx2 = _Rx2::num;
    static constexpr intmax_t _Dx2 = _Rx2::den;

    static constexpr intmax_t _Gx = _Gcd<_Dx1, _Dx2>::value;

    
    using type =
        typename ratio<_Safe_add<_Safe_mult<_Nx1, _Dx2 / _Gx>::value, _Safe_mult<_Nx2, _Dx1 / _Gx>::value>::value,
            _Safe_mult<_Dx1, _Dx2 / _Gx>::value>::type;
};

template <class _Rx1, class _Rx2>
using ratio_add = typename _Ratio_add<_Rx1, _Rx2>::type;

template <class _Rx1, class _Rx2>
struct _Ratio_subtract { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_subtract<R1, R2> requires R1 and R2 to be ratio<>s.");

    static constexpr intmax_t _Nx2 = _Rx2::num;
    static constexpr intmax_t _Dx2 = _Rx2::den;

    using type = ratio_add<_Rx1, ratio<-_Nx2, _Dx2>>;
};

template <class _Rx1, class _Rx2>
using ratio_subtract = typename _Ratio_subtract<_Rx1, _Rx2>::type;

template <class _Rx1, class _Rx2>
struct _Ratio_multiply { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");

    static constexpr intmax_t _Nx1 = _Rx1::num;
    static constexpr intmax_t _Dx1 = _Rx1::den;
    static constexpr intmax_t _Nx2 = _Rx2::num;
    static constexpr intmax_t _Dx2 = _Rx2::den;

    static constexpr intmax_t _Gx = _Gcd<_Nx1, _Dx2>::value;
    static constexpr intmax_t _Gy = _Gcd<_Nx2, _Dx1>::value;

    using _Num = _Safe_mult<_Nx1 / _Gx, _Nx2 / _Gy, true>;
    using _Den = _Safe_mult<_Dx1 / _Gy, _Dx2 / _Gx, true>;
};

template <class _Rx1, class _Rx2, bool _Sfinae = true, class = void>
struct _Ratio_multiply_sfinae { 
    static_assert(_Sfinae, "integer arithmetic overflow");
};

template <class _Rx1, class _Rx2, bool _Sfinae>
struct _Ratio_multiply_sfinae<_Rx1, _Rx2, _Sfinae,
    void_t<typename _Ratio_multiply<_Rx1, _Rx2>::_Num::type,
        typename _Ratio_multiply<_Rx1, _Rx2>::_Den::type>> { 
    using type = ratio<_Ratio_multiply<_Rx1, _Rx2>::_Num::value, _Ratio_multiply<_Rx1, _Rx2>::_Den::value>;
};

template <class _Rx1, class _Rx2>
using ratio_multiply = typename _Ratio_multiply_sfinae<_Rx1, _Rx2, false>::type;

template <class _Rx1, class _Rx2>
struct _Ratio_divide { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");

    static constexpr intmax_t _Nx2 = _Rx2::num;
    static constexpr intmax_t _Dx2 = _Rx2::den;

    using _Rx2_inverse = ratio<_Dx2, _Nx2>;
};

template <class _Rx1, class _Rx2, bool _Sfinae = true>
using _Ratio_divide_sfinae =
    typename _Ratio_multiply_sfinae<_Rx1, typename _Ratio_divide<_Rx1, _Rx2>::_Rx2_inverse, _Sfinae>::type;

template <class _Rx1, class _Rx2>
using ratio_divide = _Ratio_divide_sfinae<_Rx1, _Rx2, false>;

template <class _Rx1, class _Rx2>
struct ratio_equal : bool_constant<_Rx1::num == _Rx2::num && _Rx1::den == _Rx2::den> { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_equal_v = ratio_equal<_Rx1, _Rx2>::value;

template <class _Rx1, class _Rx2>
struct ratio_not_equal : bool_constant<!ratio_equal_v<_Rx1, _Rx2>> { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_not_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_not_equal_v = ratio_not_equal<_Rx1, _Rx2>::value;

struct _Big_uint128 {
    uint64_t _Upper;
    uint64_t _Lower;

    constexpr bool operator<(const _Big_uint128 _Rhs) const noexcept {
        if (_Upper != _Rhs._Upper) {
            return _Upper < _Rhs._Upper;
        }

        return _Lower < _Rhs._Lower;
    }
};

constexpr _Big_uint128 _Big_multiply(const uint64_t _Lfactor,
    const uint64_t _Rfactor) noexcept { 
    const uint64_t _Llow  = _Lfactor & 0xFFFF'FFFFULL;
    const uint64_t _Lhigh = _Lfactor >> 32;
    const uint64_t _Rlow  = _Rfactor & 0xFFFF'FFFFULL;
    const uint64_t _Rhigh = _Rfactor >> 32;

    uint64_t _Temp          = _Llow * _Rlow;
    const uint64_t _Lower32 = _Temp & 0xFFFF'FFFFULL;
    uint64_t _Carry         = _Temp >> 32;

    _Temp                     = _Llow * _Rhigh + _Carry;
    const uint64_t _Mid_lower = _Temp & 0xFFFF'FFFFULL;
    const uint64_t _Mid_upper = _Temp >> 32;

    _Temp  = _Lhigh * _Rlow + _Mid_lower;
    _Carry = _Temp >> 32;

    return {_Lhigh * _Rhigh + _Mid_upper + _Carry, (_Temp << 32) + _Lower32};
}

constexpr bool _Ratio_less(const int64_t _Nx1, const int64_t _Dx1, const int64_t _Nx2, const int64_t _Dx2) noexcept {
    if (_Nx1 >= 0 && _Nx2 >= 0) {
        return _Big_multiply(static_cast<uint64_t>(_Nx1), static_cast<uint64_t>(_Dx2))
             < _Big_multiply(static_cast<uint64_t>(_Nx2), static_cast<uint64_t>(_Dx1));
    }

    if (_Nx1 < 0 && _Nx2 < 0) {
        return _Big_multiply(static_cast<uint64_t>(-_Nx2), static_cast<uint64_t>(_Dx1))
             < _Big_multiply(static_cast<uint64_t>(-_Nx1), static_cast<uint64_t>(_Dx2));
    }

    return _Nx1 < _Nx2;
}

template <class _Rx1, class _Rx2>
struct ratio_less : bool_constant<_Ratio_less(_Rx1::num, _Rx1::den, _Rx2::num, _Rx2::den)> { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_less<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_less_v = ratio_less<_Rx1, _Rx2>::value;

template <class _Rx1, class _Rx2>
struct ratio_less_equal : bool_constant<!ratio_less_v<_Rx2, _Rx1>> { 
    static_assert(
        _Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_less_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_less_equal_v = ratio_less_equal<_Rx1, _Rx2>::value;

template <class _Rx1, class _Rx2>
struct ratio_greater : ratio_less<_Rx2, _Rx1>::type { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_greater<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_greater_v = ratio_greater<_Rx1, _Rx2>::value;

template <class _Rx1, class _Rx2>
struct ratio_greater_equal : bool_constant<!ratio_less_v<_Rx1, _Rx2>> { 
    static_assert(
        _Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_greater_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_greater_equal_v = ratio_greater_equal<_Rx1, _Rx2>::value;

using atto  = ratio<1, 1000000000000000000LL>;
using femto = ratio<1, 1000000000000000LL>;
using pico  = ratio<1, 1000000000000LL>;
using nano  = ratio<1, 1000000000>;
using micro = ratio<1, 1000000>;
using milli = ratio<1, 1000>;
using centi = ratio<1, 100>;
using deci  = ratio<1, 10>;
using deca  = ratio<10, 1>;
using hecto = ratio<100, 1>;
using kilo  = ratio<1000, 1>;
using mega  = ratio<1000000, 1>;
using giga  = ratio<1000000000, 1>;
using tera  = ratio<1000000000000LL, 1>;
using peta  = ratio<1000000000000000LL, 1>;
using exa   = ratio<1000000000000000000LL, 1>;
}


#pragma warning(pop)
#pragma pack(pop)
#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ratio"
#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\ratio"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"






#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
namespace chrono {
    template <class _Rep>
    struct treat_as_floating_point : is_floating_point<_Rep> {}; 

    template <class _Rep>
     constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;

    template <class _Rep>
    struct duration_values { 
        [[nodiscard]] static constexpr _Rep zero() noexcept {
            
            return _Rep(0);
        }

        [[nodiscard]] static constexpr _Rep(min)() noexcept {
            
            return numeric_limits<_Rep>::lowest();
        }

        [[nodiscard]] static constexpr _Rep(max)() noexcept {
            
            return (numeric_limits<_Rep>::max)();
        }
    };















#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"

    template <class _Rep, class _Period = ratio<1>>
    class duration;

    template <class _Ty>
     constexpr bool _Is_duration_v = _Is_specialization_v<_Ty, duration>;

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    constexpr _To duration_cast(const duration<_Rep, _Period>&) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>); 

    template <class _Rep, class _Period>
    class duration { 
    public:
        using rep    = _Rep;
        using period = typename _Period::type;

        static_assert(!_Is_duration_v<_Rep>, "duration can't have duration as first template argument");
        static_assert(_Is_ratio_v<_Period>, "period not an instance of std::ratio");
        static_assert(0 < _Period::num, "period negative or zero");

        constexpr duration() = default;

        template <class _Rep2,
            enable_if_t<is_convertible_v<const _Rep2&,
                            _Rep> && (treat_as_floating_point_v<_Rep> || !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr explicit duration(const _Rep2& _Val) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) 
            : _MyRep(static_cast<_Rep>(_Val)) {}

        template <class _Rep2, class _Period2,
            enable_if_t<
                treat_as_floating_point_v<
                    _Rep> || (_Ratio_divide_sfinae<_Period2, _Period>::den == 1 && !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr duration(const duration<_Rep2, _Period2>& _Dur) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) 
            : _MyRep(::std::chrono:: duration_cast<duration>(_Dur).count()) {}

        [[nodiscard]] constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>)  {
            return _MyRep;
        }

        [[nodiscard]] constexpr common_type_t<duration> operator+() const
            noexcept(is_arithmetic_v<_Rep>)  {
            return common_type_t<duration>(*this);
        }

        [[nodiscard]] constexpr common_type_t<duration> operator-() const
            noexcept(is_arithmetic_v<_Rep>)  {
            return common_type_t<duration>(-_MyRep);
        }

        inline duration& operator++() noexcept(is_arithmetic_v<_Rep>)  {
            ++_MyRep;
            return *this;
        }

        inline duration operator++(int) noexcept(is_arithmetic_v<_Rep>)  {
            return duration(_MyRep++);
        }

        inline duration& operator--() noexcept(is_arithmetic_v<_Rep>)  {
            --_MyRep;
            return *this;
        }

        inline duration operator--(int) noexcept(is_arithmetic_v<_Rep>)  {
            return duration(_MyRep--);
        }

        inline duration& operator+=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep += _Right._MyRep;
            return *this;
        }

        inline duration& operator-=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep -= _Right._MyRep;
            return *this;
        }

        inline duration& operator*=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep *= _Right;
            return *this;
        }

        inline duration& operator/=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep /= _Right;
            return *this;
        }

        inline duration& operator%=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep %= _Right;
            return *this;
        }

        inline duration& operator%=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep %= _Right.count();
            return *this;
        }

        [[nodiscard]] static constexpr duration zero() noexcept {
            
            return duration(duration_values<_Rep>::zero());
        }

        [[nodiscard]] static constexpr duration(min)() noexcept {
            
            return duration((duration_values<_Rep>::min)());
        }

        [[nodiscard]] static constexpr duration(max)() noexcept {
            
            return duration((duration_values<_Rep>::max)());
        }

    private:
        _Rep _MyRep; 
    };

    template <class _Clock, class _Duration = typename _Clock::duration>
    class time_point { 
    public:
        using clock    = _Clock;
        using duration = _Duration;
        using rep      = typename _Duration::rep;
        using period   = typename _Duration::period;

        static_assert(_Is_duration_v<_Duration>,
            "N4885 [time.point.general]/1 mandates Duration to be a specialization of chrono::duration.");

        constexpr time_point() = default;

        constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) 
            : _MyDur(_Other) {}

        template <class _Duration2, enable_if_t<is_convertible_v<_Duration2, _Duration>, int> = 0>
        constexpr time_point(const time_point<_Clock, _Duration2>& _Tp) noexcept(
            is_arithmetic_v<rep>&& is_arithmetic_v<typename _Duration2::rep>) 
            : _MyDur(_Tp.time_since_epoch()) {}

        [[nodiscard]] constexpr _Duration time_since_epoch() const noexcept(is_arithmetic_v<rep>)  {
            return _MyDur;
        }
















#line 232 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"

        inline time_point& operator+=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>)  {
            _MyDur += _Dur;
            return *this;
        }

        inline time_point& operator-=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>)  {
            _MyDur -= _Dur;
            return *this;
        }

        [[nodiscard]] static constexpr time_point(min)() noexcept {
            return time_point((_Duration::min)());
        }

        [[nodiscard]] static constexpr time_point(max)() noexcept {
            return time_point((_Duration::max)());
        }

    private:
        _Duration _MyDur{duration::zero()}; 
    };
} 

template <class _Rep, class _Period>
 constexpr bool _Is_trivially_swappable_v<chrono::duration<_Rep, _Period>> = _Is_trivially_swappable_v<_Rep>;

template <class _Clock, class _Duration>
 constexpr bool _Is_trivially_swappable_v<chrono::time_point<_Clock, _Duration>> =
    _Is_trivially_swappable_v<_Duration>;

template <intmax_t _Ax, intmax_t _Bx, bool = ((_Ax / _Gcd<_Ax, _Bx>::value) <= 9223372036854775807i64 / _Bx)>
struct _Lcm : integral_constant<intmax_t, (_Ax / _Gcd<_Ax, _Bx>::value) * _Bx> {};
template <intmax_t _Ax, intmax_t _Bx>
struct _Lcm<_Ax, _Bx, false> {};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<::std::chrono:: duration<_Rep1, _Period1>, ::std::chrono:: duration<_Rep2, _Period2>> {
    using type = ::std::chrono:: duration<common_type_t<_Rep1, _Rep2>,
        ratio<_Gcd<_Period1::num, _Period2::num>::value, _Lcm<_Period1::den, _Period2::den>::value>>;
};

template <class _Clock, class _Duration1, class _Duration2>
struct common_type<::std::chrono:: time_point<_Clock, _Duration1>,
    ::std::chrono:: time_point<_Clock, _Duration2>> { 
    using type = ::std::chrono:: time_point<_Clock, common_type_t<_Duration1, _Duration2>>;
};

namespace chrono {
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator+(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() + _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator-(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() - _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2,
        enable_if_t<is_convertible_v<const _Rep2&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    [[nodiscard]] constexpr duration<common_type_t<_Rep1, _Rep2>, _Period1> operator*(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() * _Right);
    }

    template <class _Rep1, class _Rep2, class _Period2,
        enable_if_t<is_convertible_v<const _Rep1&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    [[nodiscard]] constexpr duration<common_type_t<_Rep1, _Rep2>, _Period2>
        operator*(const _Rep1& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return _Right * _Left;
    }

    template <class _CR, class _Period1, class _Rep2, bool = is_convertible_v<const _Rep2&, _CR>>
    struct _Duration_div_mod1 { 
        using type = duration<_CR, _Period1>;
    };

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod1<_CR, _Period1, _Rep2, false> {}; 

    template <class _CR, class _Period1, class _Rep2, bool = _Is_duration_v<_Rep2>>
    struct _Duration_div_mod {}; 

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod<_CR, _Period1, _Rep2, false> : _Duration_div_mod1<_CR, _Period1, _Rep2> {
        
    };

    template <class _Rep1, class _Period1, class _Rep2>
    [[nodiscard]] constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator/(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() / _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr common_type_t<_Rep1, _Rep2>
        operator/(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_Left).count() / _CD(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2>
    [[nodiscard]] constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator%(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() % _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator%(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() % _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator==(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() == _CT(_Right).count();
    }


    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator!=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return !(_Left == _Right);
    }
#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator<(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() < _CT(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator<=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return !(_Right < _Left);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator>(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return _Right < _Left;
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator>=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return !(_Left < _Right);
    }














    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> _Enabled>
    [[nodiscard]] constexpr _To duration_cast(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        using _CF = ratio_divide<_Period, typename _To::period>;

        using _ToRep = typename _To::rep;
        using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;

        constexpr bool _Num_is_one = _CF::num == 1;
        constexpr bool _Den_is_one = _CF::den == 1;

        if (_Den_is_one) {
            if (_Num_is_one) {
                return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));
            } else {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
            }
        } else {
            if (_Num_is_one) {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
            } else {
                return static_cast<_To>(static_cast<_ToRep>(
                    static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
            }
        }
    }

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr _To floor(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        
        const _To _Casted{::std::chrono:: duration_cast<_To>(_Dur)};
        if (_Casted > _Dur) {
            return _To{_Casted.count() - static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr _To ceil(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        
        const _To _Casted{::std::chrono:: duration_cast<_To>(_Dur)};
        if (_Casted < _Dur) {
            return _To{_Casted.count() + static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    template <class _Rep>
    constexpr bool _Is_even(_Rep _Val) noexcept(is_arithmetic_v<_Rep>)  {
        
        return _Val % 2 == 0;
    }

    template <class _To, class _Rep, class _Period,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    [[nodiscard]] constexpr _To round(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        const _To _Floored{::std::chrono:: floor<_To>(_Dur)};
        const _To _Ceiled{_Floored + _To{1}};
        const auto _Floor_adjustment = _Dur - _Floored;
        const auto _Ceil_adjustment  = _Ceiled - _Dur;
        if (_Floor_adjustment < _Ceil_adjustment
            || (_Floor_adjustment == _Ceil_adjustment && _Is_even(_Floored.count()))) {
            return _Floored;
        }

        return _Ceiled;
    }

    template <class _Rep, class _Period, enable_if_t<numeric_limits<_Rep>::is_signed, int> = 0>
    [[nodiscard]] constexpr duration<_Rep, _Period> abs(const duration<_Rep, _Period> _Dur) noexcept(
        is_arithmetic_v<_Rep>)  {
        
        return _Dur < duration<_Rep, _Period>::zero() ? duration<_Rep, _Period>::zero() - _Dur : _Dur;
    }

    using nanoseconds  = duration<long long, nano>;
    using microseconds = duration<long long, micro>;
    using milliseconds = duration<long long, milli>;
    using seconds      = duration<long long>;
    using minutes      = duration<int, ratio<60>>;
    using hours        = duration<int, ratio<3600>>;





#line 522 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"

    template <class _Clock, class _Duration, class _Rep, class _Period>
    [[nodiscard]] constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator+(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>)  {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() + _Right);
    }

    template <class _Rep, class _Period, class _Clock, class _Duration>
    [[nodiscard]] constexpr time_point<_Clock, common_type_t<duration<_Rep, _Period>, _Duration>>
        operator+(const duration<_Rep, _Period>& _Left, const time_point<_Clock, _Duration>& _Right) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _Duration::rep>)  {
        return _Right + _Left;
    }

    template <class _Clock, class _Duration, class _Rep, class _Period>
    [[nodiscard]] constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator-(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>)  {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() - _Right);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr common_type_t<_Duration1, _Duration2>
        operator-(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return _Left.time_since_epoch() - _Right.time_since_epoch();
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator==(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return _Left.time_since_epoch() == _Right.time_since_epoch();
    }


    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator!=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return !(_Left == _Right);
    }
#line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator<(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return _Left.time_since_epoch() < _Right.time_since_epoch();
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator<=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return !(_Right < _Left);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator>(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return _Right < _Left;
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator>=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return !(_Left < _Right);
    }










    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr time_point<_Clock, _To> time_point_cast(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        return time_point<_Clock, _To>(::std::chrono:: duration_cast<_To>(_Time.time_since_epoch()));
    }

    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr time_point<_Clock, _To> floor(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        return time_point<_Clock, _To>(::std::chrono:: floor<_To>(_Time.time_since_epoch()));
    }

    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr time_point<_Clock, _To> ceil(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        return time_point<_Clock, _To>(::std::chrono:: ceil<_To>(_Time.time_since_epoch()));
    }

    template <class _To, class _Clock, class _Duration,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    [[nodiscard]] constexpr time_point<_Clock, _To> round(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        return time_point<_Clock, _To>(::std::chrono:: round<_To>(_Time.time_since_epoch()));
    }

    struct system_clock { 
        using rep                       = long long;
        using period                    = ratio<1, 10'000'000>; 
        using duration                  = ::std::chrono:: duration<rep, period>;
        using time_point                = ::std::chrono:: time_point<system_clock>;
        static constexpr bool is_steady = false;

        [[nodiscard]] static time_point now() noexcept { 
            return time_point(duration(_Xtime_get_ticks()));
        }

        [[nodiscard]] static __time64_t to_time_t(const time_point& _Time) noexcept { 
            return duration_cast<seconds>(_Time.time_since_epoch()).count();
        }

        [[nodiscard]] static time_point from_time_t(__time64_t _Tm) noexcept { 
            return time_point{seconds{_Tm}};
        }
    };






#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"

    struct steady_clock { 
        using rep                       = long long;
        using period                    = nano;
        using duration                  = nanoseconds;
        using time_point                = ::std::chrono:: time_point<steady_clock>;
        static constexpr bool is_steady = true;

        [[nodiscard]] static time_point now() noexcept { 
            const long long _Freq = _Query_perf_frequency(); 
            const long long _Ctr  = _Query_perf_counter();
            static_assert(period::num == 1, "This assumes period::num == 1.");
            
            
            
            constexpr long long _TenMHz = 10'000'000;
            if (_Freq == _TenMHz) {
                static_assert(period::den % _TenMHz == 0, "It should never fail.");
                constexpr long long _Multiplier = period::den / _TenMHz;
                return time_point(duration(_Ctr * _Multiplier));
            } else {
                
                
                
                
                
                const long long _Whole = (_Ctr / _Freq) * period::den;
                const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;
                return time_point(duration(_Whole + _Part));
            }
        }
    };

    using high_resolution_clock = steady_clock;
} 

template <class _Rep, class _Period>
[[nodiscard]] bool _To_xtime_10_day_clamped(:: xtime& _Xt, const ::std::chrono:: duration<_Rep, _Period>& _Rel_time) noexcept(
    is_arithmetic_v<_Rep>) {
    
    
    
    
    constexpr ::std::chrono:: nanoseconds _Ten_days{::std::chrono:: hours{24} * 10};
    constexpr ::std::chrono:: duration<double> _Ten_days_d{_Ten_days};
    ::std::chrono:: nanoseconds _Tx0 = ::std::chrono:: system_clock::now().time_since_epoch();
    const bool _Clamped      = _Ten_days_d < _Rel_time;
    if (_Clamped) {
        _Tx0 += _Ten_days;
    } else {
        _Tx0 += ::std::chrono:: duration_cast<::std::chrono:: nanoseconds>(_Rel_time);
    }

    const auto _Whole_seconds = ::std::chrono:: duration_cast<::std::chrono:: seconds>(_Tx0);
    _Xt.sec                   = _Whole_seconds.count();
    _Tx0 -= _Whole_seconds;
    _Xt.nsec = static_cast<long>(_Tx0.count());
    return _Clamped;
}

inline namespace literals {
    inline namespace chrono_literals {
        [[nodiscard]] constexpr ::std::chrono:: hours operator"" h(unsigned long long _Val) noexcept  {
            return ::std::chrono:: hours(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, ratio<3600>> operator"" h(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, ratio<3600>>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: minutes(operator"" min)(unsigned long long _Val) noexcept  {
            return ::std::chrono:: minutes(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, ratio<60>>(operator"" min)(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, ratio<60>>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: seconds operator"" s(unsigned long long _Val) noexcept  {
            return ::std::chrono:: seconds(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double> operator"" s(long double _Val) noexcept  {
            return ::std::chrono:: duration<double>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: milliseconds operator"" ms(unsigned long long _Val) noexcept  {
            return ::std::chrono:: milliseconds(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, milli> operator"" ms(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, milli>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: microseconds operator"" us(unsigned long long _Val) noexcept  {
            return ::std::chrono:: microseconds(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, micro> operator"" us(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, micro>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: nanoseconds operator"" ns(unsigned long long _Val) noexcept  {
            return ::std::chrono:: nanoseconds(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, nano> operator"" ns(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, nano>(_Val);
        }
    } 
} 

namespace chrono {
    using namespace literals::chrono_literals;
} 
}



#pragma warning(pop)
#pragma pack(pop)
#line 788 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
#line 789 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\__msvc_chrono.hpp"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"

























#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 2653 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"
























































#line 2710 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"



}


#pragma warning(pop)
#pragma pack(pop)
#line 5908 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"
#line 5909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\chrono"
#pragma external_header(pop)
#line 23 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"





#pragma once








#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Mydeque>
class _Deque_unchecked_const_iterator {
private:
    using _Size_type = typename _Mydeque::size_type;

    static constexpr int _Block_size = _Mydeque::_Block_size;

public:
    using iterator_category = random_access_iterator_tag;

    using value_type      = typename _Mydeque::value_type;
    using difference_type = typename _Mydeque::difference_type;
    using pointer         = typename _Mydeque::const_pointer;
    using reference       = const value_type&;

    _Deque_unchecked_const_iterator() noexcept : _Mycont(), _Myoff(0) {}

    _Deque_unchecked_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept
        : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

    [[nodiscard]] reference operator*() const noexcept {
        _Size_type _Block = _Mycont->_Getblock(_Myoff);
        _Size_type _Off   = _Myoff % _Block_size;
        return _Mycont->_Map[_Block][_Off];
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _Deque_unchecked_const_iterator& operator++() noexcept {
        ++_Myoff;
        return *this;
    }

    _Deque_unchecked_const_iterator operator++(int) noexcept {
        _Deque_unchecked_const_iterator _Tmp = *this;
        ++_Myoff;
        return _Tmp;
    }

    _Deque_unchecked_const_iterator& operator--() noexcept {
        --_Myoff;
        return *this;
    }

    _Deque_unchecked_const_iterator operator--(int) noexcept {
        _Deque_unchecked_const_iterator _Tmp = *this;
        --_Myoff;
        return _Tmp;
    }

    _Deque_unchecked_const_iterator& operator+=(const difference_type _Off) noexcept {
        _Myoff += _Off;
        return *this;
    }

    [[nodiscard]] _Deque_unchecked_const_iterator operator+(const difference_type _Off) const noexcept {
        _Deque_unchecked_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _Deque_unchecked_const_iterator& operator-=(const difference_type _Off) noexcept {
        _Myoff -= _Off;
        return *this;
    }

    [[nodiscard]] _Deque_unchecked_const_iterator operator-(const difference_type _Off) const noexcept {
        _Deque_unchecked_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

    [[nodiscard]] difference_type operator-(const _Deque_unchecked_const_iterator& _Right) const noexcept {
        return static_cast<difference_type>(_Myoff - _Right._Myoff);
    }

    [[nodiscard]] reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] bool operator==(const _Deque_unchecked_const_iterator& _Right) const noexcept {
        return _Myoff == _Right._Myoff;
    }





#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
    [[nodiscard]] bool operator!=(const _Deque_unchecked_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _Deque_unchecked_const_iterator& _Right) const noexcept {
        return _Myoff < _Right._Myoff;
    }

    [[nodiscard]] bool operator>(const _Deque_unchecked_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _Deque_unchecked_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _Deque_unchecked_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

    const _Container_base12* _Getcont() const noexcept { 
        return _Mycont;
    }

    const _Mydeque* _Mycont;
    _Size_type _Myoff; 
};

template <class _Mydeque>
[[nodiscard]] _Deque_unchecked_const_iterator<_Mydeque> operator+(
    typename _Deque_unchecked_const_iterator<_Mydeque>::difference_type _Off,
    _Deque_unchecked_const_iterator<_Mydeque> _Next) noexcept {
    return _Next += _Off;
}

template <class _Mydeque>
class _Deque_unchecked_iterator : public _Deque_unchecked_const_iterator<_Mydeque> {
private:
    using _Size_type = typename _Mydeque::size_type;
    using _Mybase    = _Deque_unchecked_const_iterator<_Mydeque>;

public:
    using iterator_category = random_access_iterator_tag;

    using value_type      = typename _Mydeque::value_type;
    using difference_type = typename _Mydeque::difference_type;
    using pointer         = typename _Mydeque::pointer;
    using reference       = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _Deque_unchecked_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _Deque_unchecked_iterator operator++(int) noexcept {
        _Deque_unchecked_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _Deque_unchecked_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _Deque_unchecked_iterator operator--(int) noexcept {
        _Deque_unchecked_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    _Deque_unchecked_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] _Deque_unchecked_iterator operator+(const difference_type _Off) const noexcept {
        _Deque_unchecked_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _Deque_unchecked_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    [[nodiscard]] _Deque_unchecked_iterator operator-(const difference_type _Off) const noexcept {
        _Deque_unchecked_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

    [[nodiscard]] difference_type operator-(const _Mybase& _Right) const noexcept {
        return _Mybase::operator-(_Right);
    }

    [[nodiscard]] reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }
};

template <class _Mydeque>
[[nodiscard]] _Deque_unchecked_iterator<_Mydeque> operator+(
    typename _Deque_unchecked_iterator<_Mydeque>::difference_type _Off,
    _Deque_unchecked_iterator<_Mydeque> _Next) noexcept {
    return _Next += _Off;
}

template <class _Mydeque>
class _Deque_const_iterator : public _Iterator_base12 {
private:
    using _Size_type = typename _Mydeque::size_type;

    static constexpr int _Block_size = _Mydeque::_Block_size;

public:
    using iterator_category = random_access_iterator_tag;

    using value_type      = typename _Mydeque::value_type;
    using difference_type = typename _Mydeque::difference_type;
    using pointer         = typename _Mydeque::const_pointer;
    using reference       = const value_type&;

    using _Mydeque_t = _Mydeque; 
    enum { _EEN_DS = _Block_size }; 
    _Deque_const_iterator() noexcept : _Myoff(0) {
        _Setcont(nullptr);
    }

    _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {
        _Setcont(static_cast<const _Mydeque*>(_Pdeque));
    }

    [[nodiscard]] reference operator*() const noexcept {
        const auto _Mycont = static_cast<const _Mydeque*>(this->_Getcont());




#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        _Size_type _Block = _Mycont->_Getblock(_Myoff);
        _Size_type _Off   = _Myoff % _Block_size;
        return _Mycont->_Map[_Block][_Off];
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _Deque_const_iterator& operator++() noexcept {




#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        ++_Myoff;
        return *this;
    }

    _Deque_const_iterator operator++(int) noexcept {
        _Deque_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Deque_const_iterator& operator--() noexcept {




#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        --_Myoff;
        return *this;
    }

    _Deque_const_iterator operator--(int) noexcept {
        _Deque_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _Deque_const_iterator& operator+=(const difference_type _Off) noexcept {








#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        _Myoff += _Off;
        return *this;
    }

    [[nodiscard]] _Deque_const_iterator operator+(const difference_type _Off) const noexcept {
        _Deque_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _Deque_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] _Deque_const_iterator operator-(const difference_type _Off) const noexcept {
        _Deque_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

    [[nodiscard]] difference_type operator-(const _Deque_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return static_cast<difference_type>(this->_Myoff - _Right._Myoff);
    }

    [[nodiscard]] reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] bool operator==(const _Deque_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myoff == _Right._Myoff;
    }






#line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
    [[nodiscard]] bool operator!=(const _Deque_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _Deque_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myoff < _Right._Myoff;
    }

    [[nodiscard]] bool operator>(const _Deque_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _Deque_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _Deque_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 378 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

    void _Compat(const _Deque_const_iterator& _Right) const noexcept { 

        (void) _Right;


#line 385 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
    }

    void _Setcont(const _Mydeque* _Pdeque) noexcept { 
        this->_Adopt(_Pdeque);
    }

    using _Prevent_inheriting_unwrap = _Deque_const_iterator;

    [[nodiscard]] _Deque_unchecked_const_iterator<_Mydeque> _Unwrapped() const noexcept {
        return {this->_Myoff, this->_Getcont()};
    }

    void _Verify_offset(const difference_type _Off) const noexcept {

        (void) _Off;








#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
    }






#line 417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

    void _Seek_to(const _Deque_unchecked_const_iterator<_Mydeque>& _UIt) noexcept {
        _Myoff = _UIt._Myoff;
    }

    _Size_type _Myoff; 
};

template <class _Mydeque>
[[nodiscard]] _Deque_const_iterator<_Mydeque> operator+(
    typename _Deque_const_iterator<_Mydeque>::difference_type _Off, _Deque_const_iterator<_Mydeque> _Next) noexcept {
    return _Next += _Off;
}

template <class _Mydeque>
class _Deque_iterator : public _Deque_const_iterator<_Mydeque> {
private:
    using _Size_type = typename _Mydeque::size_type;
    using _Mybase    = _Deque_const_iterator<_Mydeque>;

public:
    using _Deque_unchecked_type = _Deque_unchecked_iterator<_Mydeque>;
    using iterator_category     = random_access_iterator_tag;

    using value_type      = typename _Mydeque::value_type;
    using difference_type = typename _Mydeque::difference_type;
    using pointer         = typename _Mydeque::pointer;
    using reference       = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _Deque_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _Deque_iterator operator++(int) noexcept {
        _Deque_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _Deque_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _Deque_iterator operator--(int) noexcept {
        _Deque_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    _Deque_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] _Deque_iterator operator+(const difference_type _Off) const noexcept {
        _Deque_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _Deque_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] _Deque_iterator operator-(const difference_type _Off) const noexcept {
        _Deque_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

    [[nodiscard]] reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _Deque_iterator;

    [[nodiscard]] _Deque_unchecked_iterator<_Mydeque> _Unwrapped() const noexcept {
        return {this->_Myoff, this->_Getcont()};
    }
};

template <class _Mydeque>
[[nodiscard]] _Deque_iterator<_Mydeque> operator+(
    typename _Deque_iterator<_Mydeque>::difference_type _Off, _Deque_iterator<_Mydeque> _Next) noexcept {
    return _Next += _Off;
}

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference, class _Mapptr_type>
struct _Deque_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
    using _Mapptr         = _Mapptr_type;
};

template <class _Ty>
struct _Deque_simple_types : _Simple_types<_Ty> {
    using _Mapptr = _Ty**;
};

template <class _Val_types>
class _Deque_val : public _Container_base12 {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;
    using _Mapptr         = typename _Val_types::_Mapptr;

private:
    static constexpr size_t _Bytes = sizeof(value_type);

public:
    static constexpr int _Block_size = _Bytes <= 1 ? 16
                                     : _Bytes <= 2 ? 8
                                     : _Bytes <= 4 ? 4
                                     : _Bytes <= 8 ? 2
                                                   : 1; 

    _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

    size_type _Getblock(size_type _Off) const noexcept {
        
        return (_Off / _Block_size) & (_Mapsize - 1);
    }

    _Mapptr _Map; 
    size_type _Mapsize; 
    size_type _Myoff; 
    size_type _Mysize; 
};

template <class _Ty, class _Alloc = allocator<_Ty>>
class deque {
private:
    friend _Tidy_guard<deque>;
    static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>,
        "deque<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

    using _Alty           = _Rebind_alloc_t<_Alloc, _Ty>;
    using _Alty_traits    = allocator_traits<_Alty>;
    using _Alpty          = _Rebind_alloc_t<_Alloc, typename _Alty_traits::pointer>;
    using _Alpty_traits   = allocator_traits<_Alpty>;
    using _Mapptr         = typename _Alpty_traits::pointer;
    using _Alproxy_ty     = _Rebind_alloc_t<_Alty, _Container_proxy>;
    using _Alproxy_traits = allocator_traits<_Alproxy_ty>;

    using _Scary_val = _Deque_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Deque_simple_types<_Ty>,
        _Deque_iter_types<_Ty, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Ty&, const _Ty&, _Mapptr>>>;

    static constexpr int _Minimum_map_size = 8;
    static constexpr int _Block_size       = _Scary_val::_Block_size;

public:
    using allocator_type  = _Alloc;
    using value_type      = _Ty;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = _Ty&;
    using const_reference = const _Ty&;

    using iterator                  = _Deque_iterator<_Scary_val>;
    using const_iterator            = _Deque_const_iterator<_Scary_val>;
    using _Unchecked_iterator       = _Deque_unchecked_iterator<_Scary_val>;
    using _Unchecked_const_iterator = _Deque_unchecked_const_iterator<_Scary_val>;

    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
    enum { _EEN_DS = _Block_size }; 

    deque() : _Mypair(_Zero_then_variadic_args_t{}) {
        _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));
    }

    explicit deque(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));
    }

    explicit deque( size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        resize(_Count);
        _Proxy._Release();
    }

    deque( size_type _Count, const _Ty& _Val) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct_n(_Count, _Val);
        _Proxy._Release();
    }

    deque( size_type _Count, const _Ty& _Val, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct_n(_Count, _Val);
        _Proxy._Release();
    }

    deque(const deque& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_Right._Unchecked_begin(), _Right._Unchecked_end());
        _Proxy._Release();
    }

    deque(const deque& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_Right._Unchecked_begin(), _Right._Unchecked_end());
        _Proxy._Release();
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    deque(_Iter _First, _Iter _Last) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_First, _Last);
        _Proxy._Release();
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    deque(_Iter _First, _Iter _Last, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_First, _Last);
        _Proxy._Release();
    }

private:
    template <class _Iter>
    void _Construct(_Iter _First, _Iter _Last) { 
        _Tidy_guard<deque> _Guard{this};
        for (; _First != _Last; ++_First) {
            emplace_back(*_First);
        }

        _Guard._Target = nullptr;
    }

    void _Construct_n(size_type _Count, const _Ty& _Val) { 
        _Tidy_guard<deque> _Guard{this};
        for (; 0 < _Count; --_Count) {
            _Emplace_back_internal(_Val);
        }

        _Guard._Target = nullptr;
    }

public:
    deque(deque&& _Right) : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal())) {
        _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));
        _Take_contents(_Right);
    }

    deque(deque&& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Alproxy_ty _Alproxy(_Getal());
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
                _Construct(::std:: make_move_iterator(_Right._Unchecked_begin()),
                    ::std:: make_move_iterator(_Right._Unchecked_end()));
                _Proxy._Release();
                return;
            }
        }

        _Get_data()._Alloc_proxy(_Alproxy);
        _Take_contents(_Right);
    }

private:
    void _Move_assign(deque& _Right, _Equal_allocators) noexcept {
        _Tidy();
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right);
    }

    void _Move_assign(deque& _Right, _Propagate_allocators) {
        auto& _Al       = _Getal();
        auto& _Right_al = _Right._Getal();
        if (_Al == _Right_al) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            _Alproxy_ty _Alproxy(_Al);
            _Alproxy_ty _Right_alproxy(_Right_al);
            _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
            _Tidy();
            _Pocma(_Al, _Right_al);
            _Proxy._Bind(_Alproxy, ::std:: addressof(_Get_data()));
            _Take_contents(_Right);
        }
    }

    void _Move_assign(deque& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            assign(
                ::std:: make_move_iterator(_Right._Unchecked_begin()), ::std:: make_move_iterator(_Right._Unchecked_end()));
        }
    }

public:
    deque& operator=(deque&& _Right) noexcept(_Alty_traits::is_always_equal::value) {
        if (this != ::std:: addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }

        return *this;
    }

private:
    void _Take_contents(deque& _Right) noexcept {
        
        
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        _My_data._Swap_proxy_and_iterators(_Right_data);
        _My_data._Map     = _Right_data._Map;
        _My_data._Mapsize = _Right_data._Mapsize;
        _My_data._Myoff   = _Right_data._Myoff;
        _My_data._Mysize  = _Right_data._Mysize;

        _Right_data._Map     = nullptr;
        _Right_data._Mapsize = 0;
        _Right_data._Myoff   = 0;
        _Right_data._Mysize  = 0;
    }

public:
    void push_front(_Ty&& _Val) {
        emplace_front(::std:: move(_Val));
    }

    void push_back(_Ty&& _Val) {
        _Orphan_all();
        _Emplace_back_internal(::std:: move(_Val));
    }

    iterator insert(const_iterator _Where, _Ty&& _Val) {
        return emplace(_Where, ::std:: move(_Val));
    }

    template <class... _Valty>
    decltype(auto) emplace_front(_Valty&&... _Val) {
        _Orphan_all();

        if (_Myoff() % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {
            _Growmap(1);
        }
        _Myoff() &= _Mapsize() * _Block_size - 1;
        size_type _Newoff = _Myoff() != 0 ? _Myoff() : _Mapsize() * _Block_size;
        size_type _Block  = _Getblock(--_Newoff);
        if (_Map()[_Block] == nullptr) {
            _Map()[_Block] = _Getal().allocate(_Block_size);
        }

        _Alty_traits::construct(
            _Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size), ::std:: forward<_Valty>(_Val)...);

        _Myoff() = _Newoff;
        ++_Mysize();



#line 809 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
    }

    template <class... _Valty>
    decltype(auto) emplace_back(_Valty&&... _Val) {
        _Orphan_all();
        _Emplace_back_internal(::std:: forward<_Valty>(_Val)...);



#line 819 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
    }

    template <class... _Valty>
    iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        const auto _Off = static_cast<size_type>(_Where - begin());



#line 828 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        if (_Off <= _Mysize() / 2) { 
            emplace_front(::std:: forward<_Valty>(_Val)...);
            ::std:: rotate(begin(), _Next_iter(begin()), begin() + static_cast<difference_type>(1 + _Off));
        } else { 
            emplace_back(::std:: forward<_Valty>(_Val)...);
            ::std:: rotate(begin() + static_cast<difference_type>(_Off), _Prev_iter(end()), end());
        }
        return begin() + static_cast<difference_type>(_Off);
    }

    deque(initializer_list<_Ty> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_Ilist.begin(), _Ilist.end());
        _Proxy._Release();
    }

    deque& operator=(initializer_list<_Ty> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    void assign(initializer_list<_Ty> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
    }

    iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    ~deque() noexcept {
        _Tidy();
        _Alproxy_ty _Proxy_allocator(_Getal());
        _Delete_plain_internal(_Proxy_allocator, ::std:: exchange(_Get_data()._Myproxy, nullptr));
    }

    void _Copy_assign(const deque& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        assign(_Right._Unchecked_begin(), _Right._Unchecked_end());
    }

    void _Copy_assign(const deque& _Right, true_type) {
        if (_Getal() != _Right._Getal()) {
            _Tidy();
            _Get_data()._Reload_proxy(static_cast<_Alproxy_ty>(_Getal()), static_cast<_Alproxy_ty>(_Right._Getal()));
        }

        _Copy_assign(_Right, false_type{});
    }

    deque& operator=(const deque& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }

        return *this;
    }

    [[nodiscard]] iterator begin() noexcept {
        return iterator(_Myoff(), ::std:: addressof(_Get_data()));
    }

    [[nodiscard]] const_iterator begin() const noexcept {
        return const_iterator(_Myoff(), ::std:: addressof(_Get_data()));
    }

    [[nodiscard]] iterator end() noexcept {
        return iterator(_Myoff() + _Mysize(), ::std:: addressof(_Get_data()));
    }

    [[nodiscard]] const_iterator end() const noexcept {
        return const_iterator(_Myoff() + _Mysize(), ::std:: addressof(_Get_data()));
    }

    _Unchecked_iterator _Unchecked_begin() noexcept {
        return _Unchecked_iterator(_Myoff(), ::std:: addressof(_Get_data()));
    }

    _Unchecked_const_iterator _Unchecked_begin() const noexcept {
        return _Unchecked_const_iterator(_Myoff(), ::std:: addressof(_Get_data()));
    }

    _Unchecked_iterator _Unchecked_end() noexcept {
        return _Unchecked_iterator(_Myoff() + _Mysize(), ::std:: addressof(_Get_data()));
    }

    _Unchecked_const_iterator _Unchecked_end() const noexcept {
        return _Unchecked_const_iterator(_Myoff() + _Mysize(), ::std:: addressof(_Get_data()));
    }

    iterator _Make_iter(const_iterator _Where) const noexcept {
        return iterator(_Where._Myoff, ::std:: addressof(_Get_data()));
    }

    [[nodiscard]] reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] const_reverse_iterator crend() const noexcept {
        return rend();
    }

    void shrink_to_fit() {
        size_type _Oldcapacity = _Block_size * _Mapsize();
        size_type _Newcapacity = _Oldcapacity / 2;

        if (_Newcapacity < _Block_size * _Minimum_map_size) {
            _Newcapacity = _Block_size * _Minimum_map_size;
        }

        if ((empty() && 0 < _Mapsize())
            || (!empty() && size() <= _Newcapacity && _Newcapacity < _Oldcapacity)) { 
            deque _Tmp(::std:: make_move_iterator(begin()), ::std:: make_move_iterator(end()));
            swap(_Tmp);
        }
    }

    void resize( size_type _Newsize) {
        while (_Mysize() < _Newsize) {
            emplace_back();
        }

        while (_Newsize < _Mysize()) {
            pop_back();
        }
    }

    void resize( size_type _Newsize, const _Ty& _Val) {
        _Orphan_all();
        while (_Mysize() < _Newsize) {
            _Emplace_back_internal(_Val);
        }

        while (_Newsize < _Mysize()) {
            pop_back();
        }
    }

    [[nodiscard]] size_type size() const noexcept {
        return _Mysize();
    }

    [[nodiscard]] size_type max_size() const noexcept {
        return (::std:: min)(
            static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
    }

    [[nodiscard]] bool empty() const noexcept {
        return _Mysize() == 0;
    }

    [[nodiscard]] allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

    [[nodiscard]] const_reference at(size_type _Pos) const {
        if (_Mysize() <= _Pos) {
            _Xran();
        }

        return *(begin() + static_cast<difference_type>(_Pos));
    }

    [[nodiscard]] reference at(size_type _Pos) {
        if (_Mysize() <= _Pos) {
            _Xran();
        }

        return *(begin() + static_cast<difference_type>(_Pos));
    }

    [[nodiscard]] const_reference operator[](size_type _Pos) const noexcept  {


#line 1029 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        return *(_Unchecked_begin() + static_cast<difference_type>(_Pos));
    }

    [[nodiscard]] reference operator[](size_type _Pos) noexcept  {


#line 1037 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        return *(_Unchecked_begin() + static_cast<difference_type>(_Pos));
    }

    [[nodiscard]] reference front() noexcept  {


#line 1045 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        return *_Unchecked_begin();
    }

    [[nodiscard]] const_reference front() const noexcept  {


#line 1053 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        return *_Unchecked_begin();
    }

    [[nodiscard]] reference back() noexcept  {


#line 1061 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        return *_Prev_iter(_Unchecked_end());
    }

    [[nodiscard]] const_reference back() const noexcept  {


#line 1069 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        return *_Prev_iter(_Unchecked_end());
    }

    void push_front(const _Ty& _Val) {
        emplace_front(_Val);
    }

    void pop_front() noexcept  {














#line 1093 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
        size_type _Block = _Getblock(_Myoff());
        _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Myoff() % _Block_size));
        if (--_Mysize() == 0) {
            _Myoff() = 0;
        } else {
            ++_Myoff();
        }
#line 1101 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
    }

private:
    template <class... _Tys>
    void _Emplace_back_internal(_Tys&&... _Vals) {
        if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {
            _Growmap(1);
        }
        _Myoff() &= _Mapsize() * _Block_size - 1;
        size_type _Newoff = _Myoff() + _Mysize();
        size_type _Block  = _Getblock(_Newoff);
        if (_Map()[_Block] == nullptr) {
            _Map()[_Block] = _Getal().allocate(_Block_size);
        }

        _Alty_traits::construct(
            _Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size), ::std:: forward<_Tys>(_Vals)...);

        ++_Mysize();
    }

public:
    void push_back(const _Ty& _Val) {
        _Orphan_all();
        _Emplace_back_internal(_Val);
    }

    void pop_back() noexcept  {













#line 1143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
        size_type _Newoff = _Myoff() + _Mysize() - 1;
        size_type _Block  = _Getblock(_Newoff);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size));
        if (--_Mysize() == 0) {
            _Myoff() = 0;
        }
#line 1150 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    void assign(_Iter _First, _Iter _Last) {
        _Orphan_all();
        _Adl_verify_range(_First, _Last);
        auto _UFirst       = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        auto _Myfirst      = _Unchecked_begin();
        const auto _Mylast = _Unchecked_end();
        for (; _UFirst != _ULast; ++_UFirst) { 
            if (_Myfirst == _Mylast) { 
                do {
                    emplace_back(*_UFirst);
                    ++_UFirst;
                } while (_UFirst != _ULast);
                return;
            }

            *_Myfirst = *_UFirst;
            ++_Myfirst;
        }

        _Erase_last_n(static_cast<size_type>(_Mylast - _Myfirst));
    }

    void assign( size_type _Count, const _Ty& _Val) { 
        _Orphan_all();
        auto _Myfirst       = _Unchecked_begin();
        const auto _Oldsize = _Mysize();
        auto _Assign_count  = (::std:: min)(_Count, _Oldsize);
        for (; 0 < _Assign_count; --_Assign_count) {
            *_Myfirst = _Val;
            ++_Myfirst;
        }

        const auto _Shrink_by = _Oldsize - _Assign_count;
        auto _Extend_by       = _Count - _Assign_count;
        _Erase_last_n(_Shrink_by);
        for (; 0 < _Extend_by; --_Extend_by) {
            _Emplace_back_internal(_Val);
        }
    }

    iterator insert(const_iterator _Where, const _Ty& _Val) {
        size_type _Off = static_cast<size_type>(_Where - begin());



#line 1200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        if (_Off <= _Mysize() / 2) { 
            push_front(_Val);
            ::std:: rotate(begin(), _Next_iter(begin()), begin() + static_cast<difference_type>(1 + _Off));
        } else { 
            push_back(_Val);
            ::std:: rotate(begin() + static_cast<difference_type>(_Off), _Prev_iter(end()), end());
        }

        return begin() + static_cast<difference_type>(_Off);
    }

    iterator insert(const_iterator _Where,  size_type _Count, const _Ty& _Val) {
        
        size_type _Off = static_cast<size_type>(_Where - begin());
        _Insert_n(_Where, _Count, _Val);
        return begin() + static_cast<difference_type>(_Off);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        
        size_type _Off = static_cast<size_type>(_Where - begin());



#line 1227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        _Adl_verify_range(_First, _Last);
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);

        size_type _Oldsize = _Mysize();

        if (_UFirst != _ULast) {
            if (_Off <= _Mysize() / 2) { 
                try {
                for (; _UFirst != _ULast; ++_UFirst) {
                    emplace_front(*_UFirst); 
                }

                } catch (...) {
                while (_Oldsize < _Mysize()) {
                    pop_front(); 
                }

                throw;
                }

                size_type _Num = _Mysize() - _Oldsize;
                ::std:: reverse(begin(), begin() + static_cast<difference_type>(_Num)); 
                ::std:: rotate(begin(), begin() + static_cast<difference_type>(_Num),
                    begin() + static_cast<difference_type>(_Num + _Off));
            } else { 
                try {
                _Orphan_all();
                for (; _UFirst != _ULast; ++_UFirst) {
                    _Emplace_back_internal(*_UFirst);
                }

                } catch (...) {
                while (_Oldsize < _Mysize()) {
                    pop_back(); 
                }

                throw;
                }

                ::std:: rotate(begin() + static_cast<difference_type>(_Off),
                    begin() + static_cast<difference_type>(_Oldsize), end());
            }
        }

        return begin() + static_cast<difference_type>(_Off);
    }

    iterator erase(const_iterator _Where) noexcept(is_nothrow_move_assignable_v<value_type>)  {
        return erase(_Where, _Next_iter(_Where));
    }

    iterator erase(const_iterator _First_arg, const_iterator _Last_arg) noexcept(
        is_nothrow_move_assignable_v<value_type>)  {
        iterator _First = _Make_iter(_First_arg);
        iterator _Last  = _Make_iter(_Last_arg);









#line 1294 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
        auto _Off   = static_cast<size_type>(_First - begin());
        auto _Count = static_cast<size_type>(_Last - _First);
#line 1297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        if (_Count == 0) {
            return _First;
        }

        if (_Off < static_cast<size_type>(end() - _Last)) { 
            ::std:: move_backward(begin(), _First, _Last); 
            for (; 0 < _Count; --_Count) {
                pop_front(); 
            }
        } else { 
            ::std:: move(_Last, end(), _First); 
            for (; 0 < _Count; --_Count) {
                pop_back(); 
            }
        }





#line 1319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        return begin() + static_cast<difference_type>(_Off);
    }

private:
    void _Erase_last_n(size_type _Count) noexcept {
        for (; 0 < _Count; --_Count) {
            pop_back();
        }
    }

public:
    void clear() noexcept { 
        _Tidy();
    }

    void swap(deque& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            auto& _My_data    = _Get_data();
            auto& _Right_data = _Right._Get_data();
            _My_data._Swap_proxy_and_iterators(_Right_data);
            _Swap_adl(_My_data._Map, _Right_data._Map);
            ::std:: swap(_My_data._Mapsize, _Right_data._Mapsize);
            ::std:: swap(_My_data._Myoff, _Right_data._Myoff);
            ::std:: swap(_My_data._Mysize, _Right_data._Mysize);
        }
    }

private:
    void _Insert_n(const_iterator _Where, size_type _Count, const _Ty& _Val) { 
        iterator _Mid;
        size_type _Num;
        size_type _Off     = static_cast<size_type>(_Where - begin());
        size_type _Oldsize = _Mysize();
        size_type _Rem     = _Oldsize - _Off;



#line 1359 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

        if (_Off < _Rem) { 
            try {
            if (_Off < _Count) { 
                for (_Num = _Count - _Off; 0 < _Num; --_Num) {
                    push_front(_Val); 
                }
                for (_Num = _Off; 0 < _Num; --_Num) {
                    push_front(begin()[static_cast<difference_type>(_Count - 1)]); 
                }

                _Mid = begin() + static_cast<difference_type>(_Count);
                ::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Off), _Val); 
            } else { 
                for (_Num = _Count; 0 < _Num; --_Num) {
                    push_front(begin()[static_cast<difference_type>(_Count - 1)]); 
                }

                _Mid = begin() + static_cast<difference_type>(_Count);
                _Alloc_temporary2<_Alty> _Tmp(_Getal(), _Val); 
                ::std:: move(_Mid + static_cast<difference_type>(_Count), _Mid + static_cast<difference_type>(_Off),
                    _Mid); 
                ::std:: fill(begin() + static_cast<difference_type>(_Off), _Mid + static_cast<difference_type>(_Off),
                    _Tmp._Get_value()); 
            }
            } catch (...) {
            while (_Oldsize < _Mysize()) {
                pop_front(); 
            }

            throw;
            }
        } else { 
            try {
            if (_Rem < _Count) { 
                _Orphan_all();
                for (_Num = _Count - _Rem; 0 < _Num; --_Num) {
                    _Emplace_back_internal(_Val); 
                }
                for (_Num = 0; _Num < _Rem; ++_Num) {
                    _Emplace_back_internal(begin()[static_cast<difference_type>(_Off + _Num)]); 
                }

                _Mid = begin() + static_cast<difference_type>(_Off);
                ::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Rem), _Val); 
            } else { 
                for (_Num = 0; _Num < _Count; ++_Num) {
                    _Emplace_back_internal(
                        begin()[static_cast<difference_type>(_Off + _Rem - _Count + _Num)]); 
                }

                _Mid = begin() + static_cast<difference_type>(_Off);
                _Alloc_temporary2<_Alty> _Tmp(_Getal(), _Val); 
                ::std:: move_backward(_Mid, _Mid + static_cast<difference_type>(_Rem - _Count),
                    _Mid + static_cast<difference_type>(_Rem)); 
                ::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Count),
                    _Tmp._Get_value()); 
            }
            } catch (...) {
            _Erase_last_n(_Mysize() - _Oldsize);
            throw;
            }
        }
    }

    [[noreturn]] void _Xlen() const {
        _Xlength_error("deque<T> too long");
    }

    [[noreturn]] void _Xran() const {
        _Xout_of_range("invalid deque<T> subscript");
    }

    void _Growmap(size_type _Count) { 
        static_assert(1 < _Minimum_map_size, "The _Xlen() test should always be performed.");

        _Alpty _Almap(_Getal());
        size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;
        while (_Newsize - _Mapsize() < _Count || _Newsize < _Minimum_map_size) {
            
            if (max_size() / _Block_size - _Newsize < _Newsize) {
                _Xlen(); 
            }

            _Newsize *= 2;
        }
        _Count = _Newsize - _Mapsize();

        size_type _Myboff = _Myoff() / _Block_size;
        _Mapptr _Newmap   = _Almap.allocate(_Mapsize() + _Count);
        _Mapptr _Myptr    = _Newmap + _Myboff;

        _Myptr = ::std:: uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); 
        if (_Myboff <= _Count) { 
            _Myptr = ::std:: uninitialized_copy(_Map(), _Map() + _Myboff, _Myptr); 
            _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count - _Myboff); 
            _Uninitialized_value_construct_n_unchecked1(_Newmap, _Myboff); 
        } else { 
            ::std:: uninitialized_copy(_Map(), _Map() + _Count, _Myptr); 
            _Myptr = ::std:: uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); 
            _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count); 
        }

        _Destroy_range(_Map() + _Myboff, _Map() + _Mapsize());
        if (_Map() != _Mapptr()) {
            _Almap.deallocate(_Map(), _Mapsize()); 
        }

        _Map() = _Newmap; 
        _Mapsize() += _Count;
    }

    void _Tidy() noexcept { 
        _Orphan_all();

        _Alpty _Almap(_Getal());
        while (!empty()) {
            pop_back();
        }

        for (size_type _Block = _Mapsize(); 0 < _Block;) { 
            if (_Map()[--_Block]) { 
                _Getal().deallocate(_Map()[_Block], _Block_size);
                _Destroy_in_place(_Map()[_Block]);
            }
        }

        if (_Map() != _Mapptr()) {
            _Almap.deallocate(_Map(), _Mapsize()); 
        }

        _Mapsize() = 0;
        _Map()     = _Mapptr();
    }




















#line 1514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

    size_type _Getblock(size_type _Off) const noexcept {
        return _Get_data()._Getblock(_Off);
    }

    void _Orphan_all() noexcept {
        _Get_data()._Orphan_all();
    }

    _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    _Scary_val& _Get_data() noexcept {
        return _Mypair._Myval2;
    }

    const _Scary_val& _Get_data() const noexcept {
        return _Mypair._Myval2;
    }

    _Mapptr& _Map() noexcept {
        return _Get_data()._Map;
    }

    const _Mapptr& _Map() const noexcept {
        return _Get_data()._Map;
    }

    size_type& _Mapsize() noexcept {
        return _Get_data()._Mapsize;
    }

    const size_type& _Mapsize() const noexcept {
        return _Get_data()._Mapsize;
    }

    size_type& _Myoff() noexcept {
        return _Get_data()._Myoff;
    }

    const size_type& _Myoff() const noexcept {
        return _Get_data()._Myoff;
    }

    size_type& _Mysize() noexcept {
        return _Get_data()._Mysize;
    }

    const size_type& _Mysize() const noexcept {
        return _Get_data()._Mysize;
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};





#line 1579 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"

template <class _Ty, class _Alloc>
void swap(deque<_Ty, _Alloc>& _Left, deque<_Ty, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}

template <class _Ty, class _Alloc>
[[nodiscard]] bool operator==(const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) {
    return _Left.size() == _Right.size()
        && ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
}


template <class _Ty, class _Alloc>
[[nodiscard]] bool operator!=(const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) {
    return !(_Left == _Right);
}
#line 1597 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"








template <class _Ty, class _Alloc>
[[nodiscard]] bool operator<(const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) {
    return ::std:: lexicographical_compare(
        _Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin(), _Right._Unchecked_end());
}

template <class _Ty, class _Alloc>
[[nodiscard]] bool operator<=(const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) {
    return !(_Right < _Left);
}

template <class _Ty, class _Alloc>
[[nodiscard]] bool operator>(const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) {
    return _Right < _Left;
}

template <class _Ty, class _Alloc>
[[nodiscard]] bool operator>=(const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) {
    return !(_Left < _Right);
}
#line 1626 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"











#line 1638 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"






#line 1645 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
}



#pragma warning(pop)
#pragma pack(pop)
#line 1652 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
#line 1653 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\deque"
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {
template <class _Ty, class _Container = deque<_Ty>>
class queue {
public:
    using value_type      = typename _Container::value_type;
    using reference       = typename _Container::reference;
    using const_reference = typename _Container::const_reference;
    using size_type       = typename _Container::size_type;
    using container_type  = _Container;

    static_assert(is_same_v<_Ty, value_type>, "container adaptors require consistent types");

    queue() = default;

    explicit queue(const _Container& _Cont) : c(_Cont) {}

    explicit queue(_Container&& _Cont) noexcept(is_nothrow_move_constructible_v<_Container>) 
        : c(::std:: move(_Cont)) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    explicit queue(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Container, const _Alloc&>) 
        : c(_Al) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    queue(const _Container& _Cont, const _Alloc& _Al) : c(_Cont, _Al) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    queue(_Container&& _Cont, const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Container, _Container, const _Alloc&>) 
        : c(::std:: move(_Cont), _Al) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    queue(const queue& _Right, const _Alloc& _Al) : c(_Right.c, _Al) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    queue(queue&& _Right, const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Container, _Container, const _Alloc&>) 
        : c(::std:: move(_Right.c), _Al) {}

    [[nodiscard]] bool empty() const noexcept(noexcept(c.empty()))  {
        return c.empty();
    }

    [[nodiscard]] size_type size() const noexcept(noexcept(c.size()))  {
        return c.size();
    }

    [[nodiscard]] reference front() noexcept(noexcept(c.front()))  {
        return c.front();
    }

    [[nodiscard]] const_reference front() const noexcept(noexcept(c.front()))  {
        return c.front();
    }

    [[nodiscard]] reference back() noexcept(noexcept(c.back()))  {
        return c.back();
    }

    [[nodiscard]] const_reference back() const noexcept(noexcept(c.back()))  {
        return c.back();
    }

    void push(const value_type& _Val) {
        c.push_back(_Val);
    }

    void push(value_type&& _Val) {
        c.push_back(::std:: move(_Val));
    }

    template <class... _Valty>
    decltype(auto) emplace(_Valty&&... _Val) {


#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
        c.emplace_back(::std:: forward<_Valty>(_Val)...);
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
    }

    void pop() noexcept(noexcept(c.pop_front()))  {
        c.pop_front();
    }

    void swap(queue& _Right) noexcept(_Is_nothrow_swappable<_Container>::value) {
        _Swap_adl(c, _Right.c);
    }

    [[nodiscard]] const _Container& _Get_container() const noexcept { 
        return c;
    }

protected:
    _Container c{};
};










#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"

template <class _Ty, class _Container>
[[nodiscard]] bool operator==(const queue<_Ty, _Container>& _Left, const queue<_Ty, _Container>& _Right) {
    return _Left._Get_container() == _Right._Get_container();
}

template <class _Ty, class _Container>
[[nodiscard]] bool operator!=(const queue<_Ty, _Container>& _Left, const queue<_Ty, _Container>& _Right) {
    return _Left._Get_container() != _Right._Get_container();
}

template <class _Ty, class _Container>
[[nodiscard]] bool operator<(const queue<_Ty, _Container>& _Left, const queue<_Ty, _Container>& _Right) {
    return _Left._Get_container() < _Right._Get_container();
}

template <class _Ty, class _Container>
[[nodiscard]] bool operator>(const queue<_Ty, _Container>& _Left, const queue<_Ty, _Container>& _Right) {
    return _Left._Get_container() > _Right._Get_container();
}

template <class _Ty, class _Container>
[[nodiscard]] bool operator<=(const queue<_Ty, _Container>& _Left, const queue<_Ty, _Container>& _Right) {
    return _Left._Get_container() <= _Right._Get_container();
}

template <class _Ty, class _Container>
[[nodiscard]] bool operator>=(const queue<_Ty, _Container>& _Left, const queue<_Ty, _Container>& _Right) {
    return _Left._Get_container() >= _Right._Get_container();
}









template <class _Ty, class _Container, enable_if_t<_Is_swappable<_Container>::value, int> = 0>
void swap(queue<_Ty, _Container>& _Left, queue<_Ty, _Container>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

template <class _Ty, class _Container, class _Alloc>
struct uses_allocator<queue<_Ty, _Container>, _Alloc> : uses_allocator<_Container, _Alloc>::type {};

template <class _Ty, class _Container = vector<_Ty>, class _Pr = less<typename _Container::value_type>>
class priority_queue {
public:
    using value_type      = typename _Container::value_type;
    using reference       = typename _Container::reference;
    using const_reference = typename _Container::const_reference;
    using size_type       = typename _Container::size_type;
    using container_type  = _Container;
    using value_compare   = _Pr;

    static_assert(is_same_v<_Ty, value_type>, "container adaptors require consistent types");

    priority_queue() = default;

    explicit priority_queue(const _Pr& _Pred) noexcept(
        is_nothrow_default_constructible_v<_Container>&& is_nothrow_copy_constructible_v<value_compare>) 
        : c(), comp(_Pred) {}

    priority_queue(const _Pr& _Pred, const _Container& _Cont) : c(_Cont), comp(_Pred) {
        ::std:: make_heap(c.begin(), c.end(), comp);
    }

    priority_queue(const _Pr& _Pred, _Container&& _Cont) : c(::std:: move(_Cont)), comp(_Pred) {
        ::std:: make_heap(c.begin(), c.end(), comp);
    }

    template <class _InIt>
    priority_queue(_InIt _First, _InIt _Last, const _Pr& _Pred, const _Container& _Cont) : c(_Cont), comp(_Pred) {
        c.insert(c.end(), _First, _Last);
        ::std:: make_heap(c.begin(), c.end(), comp);
    }

    template <class _InIt>
    priority_queue(_InIt _First, _InIt _Last) : c(_First, _Last), comp() {
        ::std:: make_heap(c.begin(), c.end(), comp);
    }

    template <class _InIt>
    priority_queue(_InIt _First, _InIt _Last, const _Pr& _Pred) : c(_First, _Last), comp(_Pred) {
        ::std:: make_heap(c.begin(), c.end(), comp);
    }

    template <class _InIt>
    priority_queue(_InIt _First, _InIt _Last, const _Pr& _Pred, _Container&& _Cont) : c(::std:: move(_Cont)), comp(_Pred) {
        c.insert(c.end(), _First, _Last);
        ::std:: make_heap(c.begin(), c.end(), comp);
    }

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    explicit priority_queue(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Container, const _Alloc&>&&
            is_nothrow_default_constructible_v<value_compare>) 
        : c(_Al), comp() {}

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    priority_queue(const _Pr& _Pred, const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Container, const _Alloc&>&&
            is_nothrow_copy_constructible_v<value_compare>) 
        : c(_Al), comp(_Pred) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    priority_queue(const _Pr& _Pred, const _Container& _Cont, const _Alloc& _Al) : c(_Cont, _Al), comp(_Pred) {
        ::std:: make_heap(c.begin(), c.end(), comp);
    }

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    priority_queue(const _Pr& _Pred, _Container&& _Cont, const _Alloc& _Al) : c(::std:: move(_Cont), _Al), comp(_Pred) {
        ::std:: make_heap(c.begin(), c.end(), comp);
    }

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    priority_queue(const priority_queue& _Right, const _Alloc& _Al) : c(_Right.c, _Al), comp(_Right.comp) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<_Container, _Alloc>, int> = 0>
    priority_queue(priority_queue&& _Right, const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Container, _Container, const _Alloc&>&&
            is_nothrow_move_constructible_v<value_compare>) 
        : c(::std:: move(_Right.c), _Al), comp(::std:: move(_Right.comp)) {}

    [[nodiscard]] bool empty() const noexcept(noexcept(c.empty()))  {
        return c.empty();
    }

    [[nodiscard]] size_type size() const noexcept(noexcept(c.size()))  {
        return c.size();
    }

    [[nodiscard]] const_reference top() const noexcept(noexcept(c.front()))  {
        return c.front();
    }

    void push(const value_type& _Val) {
        c.push_back(_Val);
        ::std:: push_heap(c.begin(), c.end(), comp);
    }

    void push(value_type&& _Val) {
        c.push_back(::std:: move(_Val));
        ::std:: push_heap(c.begin(), c.end(), comp);
    }

    template <class... _Valty>
    void emplace(_Valty&&... _Val) {
        c.emplace_back(::std:: forward<_Valty>(_Val)...);
        ::std:: push_heap(c.begin(), c.end(), comp);
    }

    void pop() {
        ::std:: pop_heap(c.begin(), c.end(), comp);
        c.pop_back();
    }

    void swap(priority_queue& _Right) noexcept(
        _Is_nothrow_swappable<_Container>::value&& _Is_nothrow_swappable<_Pr>::value) {
        _Swap_adl(c, _Right.c);
        _Swap_adl(comp, _Right.comp);
    }

protected:
    _Container c{};
    _Pr comp{};
};

















#line 313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"

template <class _Ty, class _Container, class _Pr,
    enable_if_t<_Is_swappable<_Container>::value && _Is_swappable<_Pr>::value, int> = 0>
void swap(priority_queue<_Ty, _Container, _Pr>& _Left, priority_queue<_Ty, _Container, _Pr>& _Right) noexcept(
    noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

template <class _Ty, class _Container, class _Pr, class _Alloc>
struct uses_allocator<priority_queue<_Ty, _Container, _Pr>, _Alloc> : uses_allocator<_Container, _Alloc>::type {};

}



#pragma warning(pop)
#pragma pack(pop)
#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\queue"
#pragma external_header(pop)
#line 24 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"





#pragma once












#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"








#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"








#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"















#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\vcruntime_startup.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {



typedef enum _crt_argv_mode
{
    _crt_argv_no_arguments,
    _crt_argv_unexpanded_arguments,
    _crt_argv_expanded_arguments,
} _crt_argv_mode;

typedef enum _crt_exit_return_mode
{
    _crt_exit_terminate_process,
    _crt_exit_return_to_caller
} _crt_exit_return_mode;

typedef enum _crt_exit_cleanup_mode
{
    _crt_exit_full_cleanup,
    _crt_exit_quick_cleanup,
    _crt_exit_no_cleanup
} _crt_exit_cleanup_mode;

extern _crt_exit_return_mode __current_exit_return_mode;



__vcrt_bool __cdecl __vcrt_initialize(void);
__vcrt_bool __cdecl __vcrt_uninitialize(  __vcrt_bool _Terminating);
__vcrt_bool __cdecl __vcrt_uninitialize_critical(void);
__vcrt_bool __cdecl __vcrt_thread_attach(void);
__vcrt_bool __cdecl __vcrt_thread_detach(void);

int __cdecl __isa_available_init(void);
_crt_argv_mode __cdecl _get_startup_argv_mode(void);



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








struct _EXCEPTION_POINTERS;

 int __cdecl _seh_filter_dll(
      unsigned long               _ExceptionNum,
      struct _EXCEPTION_POINTERS* _ExceptionPtr
    );

 int __cdecl _seh_filter_exe(
      unsigned long               _ExceptionNum,
      struct _EXCEPTION_POINTERS* _ExceptionPtr
    );








typedef enum _crt_app_type
{
    _crt_unknown_app,
    _crt_console_app,
    _crt_gui_app
} _crt_app_type;

 _crt_app_type __cdecl _query_app_type(void);

 void __cdecl _set_app_type(
      _crt_app_type _Type
    );

typedef int (__cdecl *_UserMathErrorFunctionPointer)(struct _exception *);

 void __cdecl __setusermatherr(
    _UserMathErrorFunctionPointer _UserMathErrorFunction
    );

int __cdecl _is_c_termination_complete(void);








 errno_t __cdecl _configure_narrow_argv(
      _crt_argv_mode mode
    );

 errno_t __cdecl _configure_wide_argv(
      _crt_argv_mode mode
    );



int __cdecl _initialize_narrow_environment(void);
int __cdecl _initialize_wide_environment(void);

 char**    __cdecl _get_initial_narrow_environment(void);
 wchar_t** __cdecl _get_initial_wide_environment(void);

char*    __cdecl _get_narrow_winmain_command_line(void);
wchar_t* __cdecl _get_wide_winmain_command_line(void);

 char**    __cdecl __p__acmdln(void);
 wchar_t** __cdecl __p__wcmdln(void);





    
    
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"








typedef void (__cdecl* _PVFV)(void);
typedef int  (__cdecl* _PIFV)(void);
typedef void (__cdecl* _PVFI)(int);


     void __cdecl _initterm(
            _PVFV*  _First,
                                     _PVFV*  _Last
        );

     int  __cdecl _initterm_e(
               _PIFV*  _First,
                                     _PIFV*  _Last
        );
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"










typedef struct _onexit_table_t
{
    _PVFV* _first;
    _PVFV* _last;
    _PVFV* _end;
} _onexit_table_t;

 int __cdecl _initialize_onexit_table(
      _onexit_table_t* _Table
    );

 int __cdecl _register_onexit_function(
      _onexit_table_t* _Table,
      _onexit_t        _Function
    );

 int __cdecl _execute_onexit_table(
      _onexit_table_t* _Table
    );

 int __cdecl _crt_atexit(
      _PVFV _Function
    );

 int __cdecl _crt_at_quick_exit(
      _PVFV _Function
    );










     
    __crt_bool __cdecl __acrt_initialize(void);

     
    __crt_bool __cdecl __acrt_uninitialize(
          __crt_bool _Terminating
        );

     
    __crt_bool __cdecl __acrt_uninitialize_critical(
          __crt_bool _Terminating
        );

     
    __crt_bool __cdecl __acrt_thread_attach(void);

     
    __crt_bool __cdecl __acrt_thread_detach(void);

#line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_startup.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"


#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




















     __declspec(noreturn) void __cdecl exit(  int _Code);
     __declspec(noreturn) void __cdecl _exit(  int _Code);
     __declspec(noreturn) void __cdecl _Exit(  int _Code);
     __declspec(noreturn) void __cdecl quick_exit(  int _Code);
     __declspec(noreturn) void __cdecl abort(void);

     int __cdecl system(  char const* _Command);

     void __cdecl _cexit(void);
     void __cdecl _c_exit(void);

    typedef void (__stdcall *_tls_callback_type)(void *, unsigned long, void *);
     void __cdecl _register_thread_local_exe_atexit_callback(  _tls_callback_type _Callback);

#line 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"



























typedef void     (__cdecl*   _beginthread_proc_type  )(void*);
typedef unsigned (__stdcall* _beginthreadex_proc_type)(void*);

 uintptr_t __cdecl _beginthread(
          _beginthread_proc_type _StartAddress,
          unsigned               _StackSize,
      void*                  _ArgList
    );

 void __cdecl _endthread(void);

 
 uintptr_t __cdecl _beginthreadex(
       void*                    _Security,
           unsigned                 _StackSize,
           _beginthreadex_proc_type _StartAddress,
       void*                    _ArgList,
           unsigned                 _InitFlag,
      unsigned*                _ThrdAddr
    );

 void __cdecl _endthreadex(
      unsigned _ReturnCode
    );





     int __cdecl _getpid(void);

     intptr_t __cdecl _cwait(
          int*     _TermStat,
               intptr_t _ProcHandle,
               int      _Action
        );

     intptr_t __cdecl _execl(
          char const* _FileName,
          char const* _Arguments,
        ...);

     intptr_t __cdecl _execle(
          char const* _FileName,
          char const* _Arguments,
        ...);

     intptr_t __cdecl _execlp(
          char const* _FileName,
          char const* _Arguments,
        ...);

     intptr_t __cdecl _execlpe(
          char const* _FileName,
          char const* _Arguments,
        ...);

     intptr_t __cdecl _execv(
          char const*        _FileName,
          char const* const* _Arguments
        );

     intptr_t __cdecl _execve(
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

     intptr_t __cdecl _execvp(
          char const*        _FileName,
          char const* const* _Arguments
        );

     intptr_t __cdecl _execvpe(
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

     intptr_t __cdecl _spawnl(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

     intptr_t __cdecl _spawnle(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

     intptr_t __cdecl _spawnlp(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

     intptr_t __cdecl _spawnlpe(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

     intptr_t __cdecl _spawnv(
            int                _Mode,
          char const*        _FileName,
          char const* const* _Arguments
        );

     intptr_t __cdecl _spawnve(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

     intptr_t __cdecl _spawnvp(
            int                _Mode,
          char const*        _FileName,
          char const* const* _Arguments
        );

     intptr_t __cdecl _spawnvpe(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "LoadLibrary" " " "instead. See online help for details."))
     intptr_t __cdecl _loaddll(
          char* _FileName
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "FreeLibrary" " " "instead. See online help for details."))
     int __cdecl _unloaddll(
          intptr_t _Handle
        );

    typedef int (__cdecl* _GetDllProcAddrProcType)(void);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetProcAddress" " " "instead. See online help for details."))
     _GetDllProcAddrProcType __cdecl _getdllprocaddr(
                intptr_t _Handle,
          char*    _ProcedureName,
                intptr_t _Ordinal
        );

#line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"





    
    
    
    
    
    
    
    

    

        
         intptr_t __cdecl cwait(
              int*     _TermStat,
                   intptr_t _ProcHandle,
                   int      _Action
            );

        
         intptr_t __cdecl execl(
              char const* _FileName,
              char const* _Arguments,
            ...);

        
         intptr_t __cdecl execle(
              char const* _FileName,
              char const* _Arguments,
            ...);

        
         intptr_t __cdecl execlp(
              char const* _FileName,
              char const* _Arguments,
            ...);

        
         intptr_t __cdecl execlpe(
              char const* _FileName,
              char const* _Arguments,
            ...);

        
         intptr_t __cdecl execv(
              char const*        _FileName,
              char const* const* _Arguments
            );

        
         intptr_t __cdecl execve(
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        
         intptr_t __cdecl execvp(
              char const*        _FileName,
              char const* const* _Arguments
            );

        
         intptr_t __cdecl execvpe(
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        
         intptr_t __cdecl spawnl(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        
         intptr_t __cdecl spawnle(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        
         intptr_t __cdecl spawnlp(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        
         intptr_t __cdecl spawnlpe(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        
         intptr_t __cdecl spawnv(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments);

        
         intptr_t __cdecl spawnve(
                    int                _Mode,
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        
         intptr_t __cdecl spawnvp(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments
            );

        
         intptr_t __cdecl spawnvpe(
                    int                _Mode,
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        
         int __cdecl getpid(void);

    #line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"

#line 369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\process.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"





#pragma once










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {











#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_implicit_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_implicit_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_constructible<_Dests, _Srcs>..., is_convertible<_Srcs, _Dests>...>;

template <class _Dest, class... _Srcs>
struct _Tuple_implicit_val
    : bool_constant<_Tuple_implicit_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>> {};


template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_explicit_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_explicit_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_constructible<_Dests, _Srcs>..., negation<conjunction<is_convertible<_Srcs, _Dests>...>>>;

template <class _Dest, class... _Srcs>
struct _Tuple_explicit_val
    : bool_constant<_Tuple_explicit_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>> {};
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_constructible_v =
    _Tuple_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_constructible_val : bool_constant<_Tuple_constructible_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_nothrow_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_nothrow_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_nothrow_constructible_v =
    _Tuple_nothrow_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_assignable<_Dests&, _Srcs>...>; 

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_assignable_v =
    _Tuple_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_assignable_val : bool_constant<_Tuple_assignable_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_nothrow_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_nothrow_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_assignable<_Dests&, _Srcs>...>; 

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_nothrow_assignable_v =
    _Tuple_nothrow_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;


template <class _Myself, class... _Other>
struct _Tuple_convert_copy_val : true_type {};

template <class _This, class _Uty>
struct _Tuple_convert_copy_val<tuple<_This>, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, const tuple<_Uty>&>,
          is_convertible<const tuple<_Uty>&, _This>>> {};


template <class _Myself, class... _Other>
struct _Tuple_convert_move_val : true_type {};

template <class _This, class _Uty>
struct _Tuple_convert_move_val<tuple<_This>, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, tuple<_Uty>>,
          is_convertible<tuple<_Uty>, _This>>> {};


template <class _Myself, class _This2, class... _Rest2>
struct _Tuple_perfect_val : true_type {};

template <class _Myself, class _This2>
struct _Tuple_perfect_val<_Myself, _This2>
    : bool_constant<!is_same_v<_Myself, remove_const_t<remove_reference_t<_This2>>>> {};

struct _Ignore { 
    template <class _Ty>
    constexpr const _Ignore& operator=(const _Ty&) const noexcept  {
        
        return *this;
    }
};

 constexpr _Ignore ignore{};






template <class _Ty>
struct _Tuple_val { 
    constexpr _Tuple_val() : _Val() {}

    template <class _Other>
    constexpr _Tuple_val(_Other&& _Arg) : _Val(::std:: forward<_Other>(_Arg)) {}

    template <class _Alloc, class... _Other, enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
    constexpr _Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg) : _Val(::std:: forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: uses_allocator<_Ty, _Alloc>,
                        ::std:: is_constructible<_Ty, ::std:: allocator_arg_t, const _Alloc&, _Other...>>,
            int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: uses_allocator<_Ty, _Alloc>,
                        ::std:: negation<::std:: is_constructible<_Ty, ::std:: allocator_arg_t, const _Alloc&, _Other...>>>,
            int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(::std:: forward<_Other>(_Arg)..., _Al) {}

    _Ty _Val;
};

struct _Exact_args_t {
    explicit _Exact_args_t() = default;
}; 

struct _Unpack_tuple_t {
    explicit _Unpack_tuple_t() = default;
}; 

struct _Alloc_exact_args_t {
    explicit _Alloc_exact_args_t() = default;
}; 

struct _Alloc_unpack_tuple_t {
    explicit _Alloc_unpack_tuple_t() = default;
}; 

template <class... _Types>
class tuple;

template <>
class tuple<> { 
public:
    constexpr tuple() noexcept = default; 

    constexpr tuple(const tuple&) noexcept  {} 

    template <class _Alloc>
    inline tuple(allocator_arg_t, const _Alloc&) noexcept  {}

    template <class _Alloc>
    inline tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept  {}

    template <class _Tag, enable_if_t<is_same_v<_Tag, ::std:: _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag) noexcept  {}

    template <class _Tag, class _Alloc, enable_if_t<is_same_v<_Tag, ::std:: _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc&) noexcept  {}

    constexpr tuple& operator=(const tuple&) = default;

    inline void swap(tuple&) noexcept {}

    constexpr bool _Equals(const tuple&) const noexcept {
        return true;
    }






    [[nodiscard]] constexpr bool _Less(const tuple&) const noexcept {
        return false;
    }
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
};

template <class _This, class... _Rest>
class tuple<_This, _Rest...> : private tuple<_Rest...> { 
public:
    using _This_type = _This;
    using _Mybase    = tuple<_Rest...>;

    template <class _Tag, class _This2, class... _Rest2, enable_if_t<is_same_v<_Tag, ::std:: _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...), _Myfirst(::std:: forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Tpl, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right)
        : tuple(_Unpack_tuple_t{}, ::std:: forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}

    template <class _Tag, class _Alloc, class _This2, class... _Rest2,
        enable_if_t<is_same_v<_Tag, ::std:: _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
          _Myfirst(_Al, allocator_arg, ::std:: forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
        enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Alloc, class _Tpl, enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}










#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _This2 = _This,
        enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...,
                        _Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>,
            int>           = 0>
    constexpr tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>,
        is_nothrow_default_constructible<_Rest>...>) 
        : _Mybase(), _Myfirst() {}

    template <class _This2 = _This,
        enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...,
                        negation<conjunction<_Is_implicitly_default_constructible<_This2>,
                            _Is_implicitly_default_constructible<_Rest>...>>>,
            int>           = 0>
    constexpr explicit tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>,
        is_nothrow_default_constructible<_Rest>...>) 
        : _Mybase(), _Myfirst() {}
#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"







#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _This2                                                                  = _This,
        enable_if_t<_Tuple_implicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
    constexpr tuple(const _This& _This_arg, const _Rest&... _Rest_arg) noexcept(
        conjunction_v<is_nothrow_copy_constructible<_This2>,
            is_nothrow_copy_constructible<_Rest>...>) 
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

    template <class _This2                                                                  = _This,
        enable_if_t<_Tuple_explicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
    constexpr explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg) noexcept(
        conjunction_v<is_nothrow_copy_constructible<_This2>,
            is_nothrow_copy_constructible<_Rest>...>) 
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}
#line 319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"









#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _This2, class... _Rest2,
        enable_if_t<
            conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_implicit_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg) noexcept(
        _Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>) 
        : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}

    template <class _This2, class... _Rest2,
        enable_if_t<
            conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_explicit_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg) noexcept(
        _Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>) 
        : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

    tuple(const tuple&) = default;
    tuple(tuple&&)      = default;









#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class... _Other, enable_if_t<conjunction_v<_Tuple_implicit_val<tuple, const _Other&...>,
                                               _Tuple_convert_copy_val<tuple, _Other...>>,
                                   int> = 0>
    constexpr tuple(const tuple<_Other...>& _Right) noexcept(
        _Tuple_nothrow_constructible_v<tuple, const _Other&...>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}

    template <class... _Other, enable_if_t<conjunction_v<_Tuple_explicit_val<tuple, const _Other&...>,
                                               _Tuple_convert_copy_val<tuple, _Other...>>,
                                   int> = 0>
    constexpr explicit tuple(const tuple<_Other...>& _Right) noexcept(
        _Tuple_nothrow_constructible_v<tuple, const _Other&...>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}
#line 372 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"








#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class... _Other,
        enable_if_t<conjunction_v<_Tuple_implicit_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    constexpr tuple(tuple<_Other...>&& _Right) noexcept(
        _Tuple_nothrow_constructible_v<tuple, _Other...>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}

    template <class... _Other,
        enable_if_t<conjunction_v<_Tuple_explicit_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    constexpr explicit tuple(tuple<_Other...>&& _Right) noexcept(
        _Tuple_nothrow_constructible_v<tuple, _Other...>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}
#line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"








#line 404 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _First, class _Second,
        enable_if_t<_Tuple_implicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
    constexpr tuple(const pair<_First, _Second>& _Right) noexcept(
        _Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}

    template <class _First, class _Second,
        enable_if_t<_Tuple_explicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
    constexpr explicit tuple(const pair<_First, _Second>& _Right) noexcept(
        _Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}
#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"






#line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _First, class _Second, enable_if_t<_Tuple_implicit_val<tuple, _First, _Second>::value, int> = 0>
    constexpr tuple(pair<_First, _Second>&& _Right) noexcept(
        _Tuple_nothrow_constructible_v<tuple, _First, _Second>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}

    template <class _First, class _Second, enable_if_t<_Tuple_explicit_val<tuple, _First, _Second>::value, int> = 0>
    constexpr explicit tuple(pair<_First, _Second>&& _Right) noexcept(
        _Tuple_nothrow_constructible_v<tuple, _First, _Second>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}
#line 433 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"









#line 443 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _Alloc, class _This2 = _This,
        enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...,
                        _Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>,
            int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al)
        : _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg) {}

    template <class _Alloc, class _This2 = _This,
        enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...,
                        negation<conjunction<_Is_implicitly_default_constructible<_This2>,
                            _Is_implicitly_default_constructible<_Rest>...>>>,
            int> = 0>
    inline explicit tuple(allocator_arg_t, const _Alloc& _Al)
        : _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg) {}
#line 458 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"







#line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_implicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...) {}

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_explicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
    inline explicit tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...) {}
#line 476 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"









#line 486 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _Alloc, class _This2, class... _Rest2,
        enable_if_t<
            conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_implicit_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}

    template <class _Alloc, class _This2, class... _Rest2,
        enable_if_t<
            conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_explicit_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    inline explicit tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}
#line 500 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, const tuple& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, _This2, _Rest...>, int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, tuple&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}









#line 519 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _Alloc, class... _Other,
        enable_if_t<
            conjunction_v<_Tuple_implicit_val<tuple, const _Other&...>, _Tuple_convert_copy_val<tuple, _Other...>>,
            int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class... _Other,
        enable_if_t<
            conjunction_v<_Tuple_explicit_val<tuple, const _Other&...>, _Tuple_convert_copy_val<tuple, _Other...>>,
            int> = 0>
    inline explicit tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"









#line 543 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_Tuple_implicit_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_Tuple_explicit_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    inline explicit tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}
#line 555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"







#line 563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_implicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_explicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
    inline explicit tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
#line 573 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"







#line 581 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_implicit_val<tuple, _First, _Second>::value, int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_explicit_val<tuple, _First, _Second>::value, int> = 0>
    inline explicit tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}
#line 591 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

    tuple& operator=(const volatile tuple&) = delete;

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_copy_assignable_no_precondition_check<_This2>,
                        ::std:: _Is_copy_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    inline tuple& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_This2>, is_nothrow_copy_assignable<_Rest>...>)  {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_move_assignable_no_precondition_check<_This2>,
                        ::std:: _Is_move_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    inline tuple& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {
        _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<_Mybase>(_Right._Get_rest());
        return *this;
    }

    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<tuple, const _Other&...>>,
                                   int> = 0>
    inline tuple& operator=(const tuple<_Other...>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _Other&...>)  {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }

    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<tuple, _Other...>>,
                                   int> = 0>
    inline tuple& operator=(tuple<_Other...>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _Other...>)  {
        _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
        return *this;
    }

    template <class _First, class _Second,
        enable_if_t<_Tuple_assignable_v<tuple, const _First&, const _Second&>, int> = 0>
    inline tuple& operator=(const pair<_First, _Second>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _First&, const _Second&>)  {
        _Myfirst._Val             = _Right.first;
        _Get_rest()._Myfirst._Val = _Right.second;
        return *this;
    }

    template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<tuple, _First, _Second>, int> = 0>
    inline tuple& operator=(pair<_First, _Second>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _First, _Second>)  {
        _Myfirst._Val             = ::std:: forward<_First>(_Right.first);
        _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
        return *this;
    }

    inline void swap(tuple& _Right) noexcept(
        conjunction_v<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>) {
        _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
        _Mybase::swap(_Right._Get_rest());
    }

    constexpr _Mybase& _Get_rest() noexcept { 
        return *this;
    }

    constexpr const _Mybase& _Get_rest() const noexcept { 
        return *this;
    }

    template <class... _Other>
    constexpr bool _Equals(const tuple<_Other...>& _Right) const {
        return _Myfirst._Val == _Right._Myfirst._Val && _Mybase::_Equals(_Right._Get_rest());
    }












    template <class... _Other>
    [[nodiscard]] constexpr bool _Less(const tuple<_Other...>& _Right) const {
        return _Myfirst._Val < _Right._Myfirst._Val
            || (!(_Right._Myfirst._Val < _Myfirst._Val) && _Mybase::_Less(_Right._Get_rest()));
    }
#line 689 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept;

    _Tuple_val<_This> _Myfirst; 
};
















#line 736 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator==(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Equals(_Right);
}










template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator!=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Left == _Right);
}
#line 757 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator<(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Less(_Right);
}

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator>=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Left < _Right);
}

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator>(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return _Right < _Left;
}

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator<=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Right < _Left);
}
#line 779 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

template <class... _Types, enable_if_t<conjunction_v<::std:: _Is_swappable<_Types>...>, int> = 0>
inline void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    return _Left.swap(_Right);
}

template <class _Ty, class _Tuple>
struct _Tuple_element {}; 

template <class _This, class... _Rest>
struct _Tuple_element<_This, tuple<_This, _Rest...>> { 
    static_assert(!_Is_any_of_v<_This, _Rest...>, "duplicate type T in get<T>(tuple)");
    using _Ttype = tuple<_This, _Rest...>;
};

template <class _Ty, class _This, class... _Rest>
struct _Tuple_element<_Ty, tuple<_This, _Rest...>> { 
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Rest...>>::_Ttype;
};

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept {
    
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _Ty, class... _Types>
[[nodiscard]] constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

template <class _Ty, class... _Types>
[[nodiscard]] constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

template <class _Ty, class... _Types>
[[nodiscard]] constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _Ty, class... _Types>
[[nodiscard]] constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _This, class... _Rest>
template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int>>
constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Exact_args_t{}, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) {}

template <class _This, class... _Rest>
template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
    enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int>>
constexpr tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Alloc_exact_args_t{}, _Al, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) {}

template <class... _Types>
[[nodiscard]] constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { 
    using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
    return _Ttype(::std:: forward<_Types>(_Args)...);
}

template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&...> tie(_Types&... _Args) noexcept { 
    using _Ttype = tuple<_Types&...>;
    return _Ttype(_Args...);
}

template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { 
    return tuple<_Types&&...>(::std:: forward<_Types>(_Args)...);
}

template <class _Seq_type1, class _Seq_type2>
struct _Cat_sequences;

template <size_t... _Indexes1, size_t... _Indexes2>
struct _Cat_sequences<index_sequence<_Indexes1...>,
    index_sequence<_Indexes2...>> { 
    using type = index_sequence<_Indexes1..., _Indexes2...>;
};

template <class _Ty, size_t _Size>
class array;

template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;

template <class _Ty, class... _For_array>
struct _View_as_tuple { 
    static_assert(_Always_false<_Ty>, "Unsupported tuple_cat arguments.");
};

template <class... _Types>
struct _View_as_tuple<tuple<_Types...>> { 
    using type = tuple<_Types...>;
};

template <class _Ty1, class _Ty2>
struct _View_as_tuple<pair<_Ty1, _Ty2>> { 
    using type = tuple<_Ty1, _Ty2>;
};

template <class _Ty, class... _Types>
struct _View_as_tuple<array<_Ty, 0>, _Types...> { 
    using type = tuple<_Types...>;
};

template <class _Ty, size_t _Size, class... _Types>
struct _View_as_tuple<array<_Ty, _Size>, _Types...>
    : _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...> { 
};

template <size_t _Nx, class _Ty>
struct _Repeat_for : integral_constant<size_t, _Nx> {}; 

template <class _Ret, class _Kx_arg, class _Ix_arg, size_t _Ix_next, class... _Tuples>
struct _Tuple_cat2 { 
    static_assert(sizeof...(_Tuples) == 0, "Unsupported tuple_cat arguments.");
    using type        = _Ret;
    using _Kx_arg_seq = _Kx_arg;
    using _Ix_arg_seq = _Ix_arg;
};

template <class... _Types1, class _Kx_arg, size_t... _Ix, size_t _Ix_next, class... _Types2, class... _Rest>
struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, index_sequence<_Ix...>, _Ix_next, tuple<_Types2...>, _Rest...>
    : _Tuple_cat2<tuple<_Types1..., _Types2...>, typename _Cat_sequences<_Kx_arg, index_sequence_for<_Types2...>>::type,
          index_sequence<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>, _Ix_next + 1,
          _Rest...> { 
};

template <class... _Tuples>
struct _Tuple_cat1 : _Tuple_cat2<tuple<>, index_sequence<>, index_sequence<>, 0,
                         typename _View_as_tuple<decay_t<_Tuples>>::type...> { 
                                                                               
};

template <class _Ret, size_t... _Kx, size_t... _Ix, class _Ty>
constexpr _Ret _Tuple_cat(index_sequence<_Kx...>, index_sequence<_Ix...>, _Ty&& _Arg) { 
    return _Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...);
}

template <class... _Tuples>
[[nodiscard]] constexpr typename _Tuple_cat1<_Tuples...>::type tuple_cat(_Tuples&&... _Tpls) { 
    using _Cat1 = _Tuple_cat1<_Tuples...>;
    return _Tuple_cat<typename _Cat1::type>(typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
        ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...));
}

























#line 995 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

template <class... _Types, class _Alloc>
struct uses_allocator<tuple<_Types...>, _Alloc> : true_type {}; 


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: get;
    using ::std:: ignore;
    using ::std:: make_tuple;
    using ::std:: ref;
    using ::std:: tie;
    using ::std:: tuple;
} 
#line 1009 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"

}



#pragma warning(pop)
#pragma pack(pop)
#line 1017 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
#line 1018 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\tuple"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"




#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {


#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"

class thread { 
public:
    class id;

    using native_handle_type = void*;

    thread() noexcept : _Thr{} {}

private:


#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"

    template <class _Tuple, size_t... _Indices>
    static unsigned int __stdcall _Invoke(void* _RawVals) noexcept  {
        
        const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals));
        _Tuple& _Tup = *_FnVals;
        ::std:: invoke(::std:: move(::std:: get<_Indices>(_Tup))...);
        _Cnd_do_broadcast_at_thread_exit(); 
        return 0;
    }

    template <class _Tuple, size_t... _Indices>
    [[nodiscard]] static constexpr auto _Get_invoke(index_sequence<_Indices...>) noexcept {
        return &_Invoke<_Tuple, _Indices...>;
    }

    template <class _Fn, class... _Args>
    void _Start(_Fn&& _Fx, _Args&&... _Ax) {
        using _Tuple                 = tuple<decay_t<_Fn>, decay_t<_Args>...>;
        auto _Decay_copied           = ::std:: make_unique<_Tuple>(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...);
        constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{});

#pragma warning(push)
#pragma warning(disable : 5039) 
                                
                                
        _Thr._Hnd =
            reinterpret_cast<void*>(:: _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
#pragma warning(pop)

        if (_Thr._Hnd) { 
            (void) _Decay_copied.release();
        } else { 
            _Thr._Id = 0;
            _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);
        }
    }

public:
    template <class _Fn, class... _Args, enable_if_t<!is_same_v<_Remove_cvref_t<_Fn>, thread>, int> = 0>
    [[nodiscard]] explicit thread(_Fn&& _Fx, _Args&&... _Ax) {
        _Start(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...);
    }

    ~thread() noexcept {
        if (joinable()) {
            ::std:: terminate();
        }
    }

    thread(thread&& _Other) noexcept : _Thr(::std:: exchange(_Other._Thr, {})) {}

    thread& operator=(thread&& _Other) noexcept {
        if (joinable()) {
            ::std:: terminate();
        }

        _Thr = ::std:: exchange(_Other._Thr, {});
        return *this;
    }

    thread(const thread&) = delete;
    thread& operator=(const thread&) = delete;

    void swap(thread& _Other) noexcept {
        ::std:: swap(_Thr, _Other._Thr);
    }

    [[nodiscard]] bool joinable() const noexcept {
        return _Thr._Id != 0;
    }

    void join() {
        if (!joinable()) {
            _Throw_Cpp_error(_INVALID_ARGUMENT);
        }

        if (_Thr._Id == _Thrd_id()) {
            _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);
        }

        if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {
            _Throw_Cpp_error(_NO_SUCH_PROCESS);
        }

        _Thr = {};
    }

    void detach() {
        if (!joinable()) {
            _Throw_Cpp_error(_INVALID_ARGUMENT);
        }

        _Check_C_return(_Thrd_detach(_Thr));
        _Thr = {};
    }

    [[nodiscard]] id get_id() const noexcept;

    [[nodiscard]] static unsigned int hardware_concurrency() noexcept {
        return _Thrd_hardware_concurrency();
    }

    [[nodiscard]] native_handle_type native_handle() { 
        return _Thr._Hnd;
    }

private:
    _Thrd_t _Thr;
};

template <class _Rep, class _Period>
[[nodiscard]] auto _To_absolute_time(const chrono::duration<_Rep, _Period>& _Rel_time) noexcept {
    constexpr auto _Zero                 = chrono::duration<_Rep, _Period>::zero();
    const auto _Now                      = chrono::steady_clock::now();
    decltype(_Now + _Rel_time) _Abs_time = _Now; 
    if (_Rel_time > _Zero) {
        constexpr auto _Forever = (chrono::steady_clock::time_point::max)();
        if (_Abs_time < _Forever - _Rel_time) {
            _Abs_time += _Rel_time;
        } else {
            _Abs_time = _Forever;
        }
    }
    return _Abs_time;
}

namespace this_thread {
    [[nodiscard]] thread::id get_id() noexcept;

    inline void yield() noexcept {
        _Thrd_yield();
    }

    inline void sleep_until(const xtime* _Abs_time) {
        _Thrd_sleep(_Abs_time);
    }

    template <class _Clock, class _Duration>
    void sleep_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {


#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
        for (;;) {
            const auto _Now = _Clock::now();
            if (_Abs_time <= _Now) {
                return;
            }

            :: xtime _Tgt;
            (void) _To_xtime_10_day_clamped(_Tgt, _Abs_time - _Now);
            _Thrd_sleep(&_Tgt);
        }
    }

    template <class _Rep, class _Period>
    void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time) {
        sleep_until(_To_absolute_time(_Rel_time));
    }
} 

class thread::id { 
public:
    id() noexcept : _Id(0) {} 

private:
    id(_Thrd_id_t _Other_id) : _Id(_Other_id) {}

    _Thrd_id_t _Id;

    friend thread::id thread::get_id() const noexcept;
    friend thread::id this_thread::get_id() noexcept;
    friend bool operator==(thread::id _Left, thread::id _Right) noexcept;


#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
    friend bool operator<(thread::id _Left, thread::id _Right) noexcept;
#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
    template <class _Ch, class _Tr>
    friend basic_ostream<_Ch, _Tr>& operator<<(basic_ostream<_Ch, _Tr>& _Str, thread::id _Id);
    friend hash<thread::id>;
};

[[nodiscard]] inline thread::id thread::get_id() const noexcept {
    return _Thr._Id;
}

[[nodiscard]] inline thread::id this_thread::get_id() noexcept {
    return _Thrd_id();
}

inline void swap(thread& _Left, thread& _Right) noexcept {
    _Left.swap(_Right);
}

[[nodiscard]] inline bool operator==(thread::id _Left, thread::id _Right) noexcept {
    return _Left._Id == _Right._Id;
}





#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
[[nodiscard]] inline bool operator!=(thread::id _Left, thread::id _Right) noexcept {
    return !(_Left == _Right);
}

[[nodiscard]] inline bool operator<(thread::id _Left, thread::id _Right) noexcept {
    return _Left._Id < _Right._Id;
}

[[nodiscard]] inline bool operator<=(thread::id _Left, thread::id _Right) noexcept {
    return !(_Right < _Left);
}

[[nodiscard]] inline bool operator>(thread::id _Left, thread::id _Right) noexcept {
    return _Right < _Left;
}

[[nodiscard]] inline bool operator>=(thread::id _Left, thread::id _Right) noexcept {
    return !(_Left < _Right);
}
#line 273 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"

template <class _Ch, class _Tr>
basic_ostream<_Ch, _Tr>& operator<<(basic_ostream<_Ch, _Tr>& _Str, thread::id _Id) {
    return _Str << _Id._Id;
}

template <>
struct hash<thread::id> {
     typedef thread::id argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const thread::id _Keyval) const noexcept {
        return _Hash_representation(_Keyval._Id);
    }
};

























































































#line 378 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
}



#pragma warning(pop)
#pragma pack(pop)
#line 385 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
#line 386 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\thread"
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"



#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )




namespace std {


class condition_variable;
class condition_variable_any;

class _Mutex_base { 
public:
    _Mutex_base(int _Flags = 0) noexcept {
        _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);
    }

    ~_Mutex_base() noexcept {
        _Mtx_destroy_in_situ(_Mymtx());
    }

    _Mutex_base(const _Mutex_base&) = delete;
    _Mutex_base& operator=(const _Mutex_base&) = delete;

    void lock() {
        _Check_C_return(_Mtx_lock(_Mymtx()));
    }

    [[nodiscard]] bool try_lock() {
        const auto _Res = _Mtx_trylock(_Mymtx());
        switch (_Res) {
        case _Thrd_success:
            return true;
        case _Thrd_busy:
            return false;
        default:
            _Throw_C_error(_Res);
        }
    }

    void unlock() {
        _Mtx_unlock(_Mymtx());
    }

    using native_handle_type = void*;

    [[nodiscard]] native_handle_type native_handle() {
        return _Mtx_getconcrtcs(_Mymtx());
    }

private:
    friend condition_variable;
    friend condition_variable_any;

    aligned_storage_t<80, 8> _Mtx_storage;

    _Mtx_t _Mymtx() noexcept { 
        return reinterpret_cast<_Mtx_t>(&_Mtx_storage);
    }
};

class mutex : public _Mutex_base { 
public:
     mutex() noexcept 
        : _Mutex_base() {}

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;
};

class recursive_mutex : public _Mutex_base { 
public:
    recursive_mutex() : _Mutex_base(_Mtx_recursive) {}

    [[nodiscard]] bool try_lock() noexcept {
        return _Mutex_base::try_lock();
    }

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;
};
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"

struct adopt_lock_t { 
    explicit adopt_lock_t() = default;
};

struct defer_lock_t { 
    explicit defer_lock_t() = default;
};

struct try_to_lock_t { 
    explicit try_to_lock_t() = default;
};

 constexpr adopt_lock_t adopt_lock{};
 constexpr defer_lock_t defer_lock{};
 constexpr try_to_lock_t try_to_lock{};

template <class _Mutex>
class unique_lock { 
public:
    using mutex_type = _Mutex;

    unique_lock() noexcept : _Pmtx(nullptr), _Owns(false) {}

    [[nodiscard]] explicit unique_lock(_Mutex& _Mtx)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(false) { 
        _Pmtx->lock();
        _Owns = true;
    }

    [[nodiscard]] unique_lock(_Mutex& _Mtx, adopt_lock_t)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(true) {} 

    unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(false) {} 

    [[nodiscard]] unique_lock(_Mutex& _Mtx, try_to_lock_t)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock()) {} 

    template <class _Rep, class _Period>
    [[nodiscard]] unique_lock(_Mutex& _Mtx, const chrono::duration<_Rep, _Period>& _Rel_time)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock_for(_Rel_time)) {} 

    template <class _Clock, class _Duration>
    [[nodiscard]] unique_lock(_Mutex& _Mtx, const chrono::time_point<_Clock, _Duration>& _Abs_time)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock_until(_Abs_time)) {
        


#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
    }

    [[nodiscard]] unique_lock(_Mutex& _Mtx, const xtime* _Abs_time)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(false) { 
        _Owns = _Pmtx->try_lock_until(_Abs_time);
    }

    [[nodiscard]] unique_lock(unique_lock&& _Other) noexcept : _Pmtx(_Other._Pmtx), _Owns(_Other._Owns) {
        _Other._Pmtx = nullptr;
        _Other._Owns = false;
    }

    unique_lock& operator=(unique_lock&& _Other) {
        if (this != ::std:: addressof(_Other)) {
            if (_Owns) {
                _Pmtx->unlock();
            }

            _Pmtx        = _Other._Pmtx;
            _Owns        = _Other._Owns;
            _Other._Pmtx = nullptr;
            _Other._Owns = false;
        }
        return *this;
    }

    ~unique_lock() noexcept {
        if (_Owns) {
            _Pmtx->unlock();
        }
    }

    unique_lock(const unique_lock&) = delete;
    unique_lock& operator=(const unique_lock&) = delete;

    void lock() { 
        _Validate();
        _Pmtx->lock();
        _Owns = true;
    }

    [[nodiscard]] bool try_lock() {
        _Validate();
        _Owns = _Pmtx->try_lock();
        return _Owns;
    }

    template <class _Rep, class _Period>
    [[nodiscard]] bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time) {
        _Validate();
        _Owns = _Pmtx->try_lock_for(_Rel_time);
        return _Owns;
    }

    template <class _Clock, class _Duration>
    [[nodiscard]] bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {


#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
        _Validate();
        _Owns = _Pmtx->try_lock_until(_Abs_time);
        return _Owns;
    }

    [[nodiscard]] bool try_lock_until(const xtime* _Abs_time) {
        _Validate();
        _Owns = _Pmtx->try_lock_until(_Abs_time);
        return _Owns;
    }

    void unlock() {
        if (!_Pmtx || !_Owns) {
            _Throw_system_error(errc::operation_not_permitted);
        }

        _Pmtx->unlock();
        _Owns = false;
    }

    void swap(unique_lock& _Other) noexcept {
        ::std:: swap(_Pmtx, _Other._Pmtx);
        ::std:: swap(_Owns, _Other._Owns);
    }

    _Mutex* release() noexcept {
        _Mutex* _Res = _Pmtx;
        _Pmtx        = nullptr;
        _Owns        = false;
        return _Res;
    }

    [[nodiscard]] bool owns_lock() const noexcept {
        return _Owns;
    }

    explicit operator bool() const noexcept {
        return _Owns;
    }

    [[nodiscard]] _Mutex* mutex() const noexcept {
        return _Pmtx;
    }

private:
    _Mutex* _Pmtx;
    bool _Owns;

    void _Validate() const { 
        if (!_Pmtx) {
            _Throw_system_error(errc::operation_not_permitted);
        }

        if (_Owns) {
            _Throw_system_error(errc::resource_deadlock_would_occur);
        }
    }
};

template <class _Mutex>
void swap(unique_lock<_Mutex>& _Left, unique_lock<_Mutex>& _Right) noexcept {
    _Left.swap(_Right);
}

template <size_t... _Indices, class... _LockN>
void _Lock_from_locks(const int _Target, index_sequence<_Indices...>, _LockN&... _LkN) { 
    int _Ignored[] = {((static_cast<int>(_Indices) == _Target ? (void) _LkN.lock() : void()), 0)...};
    (void) _Ignored;
}

template <size_t... _Indices, class... _LockN>
bool _Try_lock_from_locks(
    const int _Target, index_sequence<_Indices...>, _LockN&... _LkN) { 
    bool _Result{};
    int _Ignored[] = {((static_cast<int>(_Indices) == _Target ? (void) (_Result = _LkN.try_lock()) : void()), 0)...};
    (void) _Ignored;
    return _Result;
}

template <size_t... _Indices, class... _LockN>
void _Unlock_locks(const int _First, const int _Last, index_sequence<_Indices...>, _LockN&... _LkN) noexcept
 {
    
    int _Ignored[] = {
        ((_First <= static_cast<int>(_Indices) && static_cast<int>(_Indices) < _Last ? (void) _LkN.unlock() : void()),
            0)...};
    (void) _Ignored;
}

template <class... _LockN>
int _Try_lock_range(const int _First, const int _Last, _LockN&... _LkN) {
    using _Indices = index_sequence_for<_LockN...>;
    int _Next      = _First;
    try {
    for (; _Next != _Last; ++_Next) {
        if (!_Try_lock_from_locks(_Next, _Indices{}, _LkN...)) { 
            _Unlock_locks(_First, _Next, _Indices{}, _LkN...);
            return _Next;
        }
    }
    } catch (...) {
    _Unlock_locks(_First, _Next, _Indices{}, _LkN...);
    throw;
    }

    return -1;
}

template <class _Lock0, class _Lock1, class _Lock2, class... _LockN>
int _Try_lock1(_Lock0& _Lk0, _Lock1& _Lk1, _Lock2& _Lk2, _LockN&... _LkN) { 
    return _Try_lock_range(0, sizeof...(_LockN) + 3, _Lk0, _Lk1, _Lk2, _LkN...);
}

template <class _Lock0, class _Lock1>
int _Try_lock1(_Lock0& _Lk0, _Lock1& _Lk1) {
    
    if (!_Lk0.try_lock()) {
        return 0;
    }

    try {
    if (!_Lk1.try_lock()) {
        _Lk0.unlock();
        return 1;
    }
    } catch (...) {
    _Lk0.unlock();
    throw;
    }

    return -1;
}

template <class _Lock0, class _Lock1, class... _LockN>
[[nodiscard]] int try_lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN) { 
    return _Try_lock1(_Lk0, _Lk1, _LkN...);
}

template <class... _LockN>
int _Lock_attempt(const int _Hard_lock, _LockN&... _LkN) {
    
    using _Indices = index_sequence_for<_LockN...>;
    _Lock_from_locks(_Hard_lock, _Indices{}, _LkN...);
    int _Failed        = -1;
    int _Backout_start = _Hard_lock; 

    try {
    _Failed = _Try_lock_range(0, _Hard_lock, _LkN...);
    if (_Failed == -1) {
        _Backout_start = 0; 
        _Failed        = _Try_lock_range(_Hard_lock + 1, sizeof...(_LockN), _LkN...);
        if (_Failed == -1) { 
            return -1;
        }
    }
    } catch (...) {
    _Unlock_locks(_Backout_start, _Hard_lock + 1, _Indices{}, _LkN...);
    throw;
    }

    
    _Unlock_locks(_Backout_start, _Hard_lock + 1, _Indices{}, _LkN...);
    ::std:: this_thread::yield();
    return _Failed;
}

template <class _Lock0, class _Lock1, class _Lock2, class... _LockN>
void _Lock_nonmember1(_Lock0& _Lk0, _Lock1& _Lk1, _Lock2& _Lk2, _LockN&... _LkN) {
    
    int _Hard_lock = 0;
    while (_Hard_lock != -1) {
        _Hard_lock = _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...);
    }
}

template <class _Lock0, class _Lock1>
bool _Lock_attempt_small(_Lock0& _Lk0, _Lock1& _Lk1) {
    
    _Lk0.lock();
    try {
    if (_Lk1.try_lock()) {
        return false;
    }
    } catch (...) {
    _Lk0.unlock();
    throw;
    }

    _Lk0.unlock();
    ::std:: this_thread::yield();
    return true;
}

template <class _Lock0, class _Lock1>
void _Lock_nonmember1(_Lock0& _Lk0, _Lock1& _Lk1) {
    
    while (_Lock_attempt_small(_Lk0, _Lk1) && _Lock_attempt_small(_Lk1, _Lk0)) { 
    }
}

template <class _Lock0, class _Lock1, class... _LockN>
void lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN) { 
    _Lock_nonmember1(_Lk0, _Lk1, _LkN...);
}

template <class _Mutex>
class [[nodiscard]] lock_guard { 
public:
    using mutex_type = _Mutex;

    explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { 
        _MyMutex.lock();
    }

    lock_guard(_Mutex& _Mtx, adopt_lock_t) : _MyMutex(_Mtx) {} 

    ~lock_guard() noexcept {
        _MyMutex.unlock();
    }

    lock_guard(const lock_guard&) = delete;
    lock_guard& operator=(const lock_guard&) = delete;

private:
    _Mutex& _MyMutex;
};






















































#line 497 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"







#line 505 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"










extern "C" [[nodiscard]] int __declspec(dllimport) __stdcall __std_init_once_begin_initialize(
    void** _LpInitOnce, unsigned long _DwFlags, int* _FPending, void** _LpContext) noexcept;









extern "C" [[nodiscard]] int __declspec(dllimport) __stdcall __std_init_once_complete(
    void** _LpInitOnce, unsigned long _DwFlags, void* _LpContext) noexcept;



 constexpr unsigned long _Init_once_init_failed = 0x4UL;

struct _Init_once_completer {
    once_flag& _Once;
    unsigned long _DwFlags;
    ~_Init_once_completer() {
        if (__std_init_once_complete(&_Once._Opaque, _DwFlags, nullptr) == 0) {
            :: abort();
        }
    }
};

template <class _Fn, class... _Args>
void(call_once)(once_flag& _Once, _Fn&& _Fx, _Args&&... _Ax) noexcept(
    noexcept(::std:: invoke(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...)))  {
    
    
    int _Pending;
    if (__std_init_once_begin_initialize(&_Once._Opaque, 0, &_Pending, nullptr) == 0) {
        :: abort();
    }

    if (_Pending != 0) {
        _Init_once_completer _Op{_Once, _Init_once_init_failed};
        ::std:: invoke(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...);
        _Op._DwFlags = 0;
    }
}






enum class cv_status { 
    no_timeout,
    timeout
};

class condition_variable { 
public:
    using native_handle_type = _Cnd_t;

    condition_variable() {
        _Cnd_init_in_situ(_Mycnd());
    }

    ~condition_variable() noexcept {
        _Cnd_destroy_in_situ(_Mycnd());
    }

    condition_variable(const condition_variable&) = delete;
    condition_variable& operator=(const condition_variable&) = delete;

    void notify_one() noexcept { 
        _Cnd_signal(_Mycnd());
    }

    void notify_all() noexcept { 
        _Cnd_broadcast(_Mycnd());
    }

    void wait(unique_lock<mutex>& _Lck) { 
        
        _Cnd_wait(_Mycnd(), _Lck.mutex()->_Mymtx());
    }

    template <class _Predicate>
    void wait(unique_lock<mutex>& _Lck, _Predicate _Pred) { 
        while (!_Pred()) {
            wait(_Lck);
        }
    }

    template <class _Rep, class _Period>
    cv_status wait_for(unique_lock<mutex>& _Lck, const chrono::duration<_Rep, _Period>& _Rel_time) {
        
        if (_Rel_time <= chrono::duration<_Rep, _Period>::zero()) {
            return cv_status::timeout;
        }

        
        
        :: xtime _Tgt;
        const bool _Clamped     = _To_xtime_10_day_clamped(_Tgt, _Rel_time);
        const cv_status _Result = wait_until(_Lck, &_Tgt);
        if (_Clamped) {
            return cv_status::no_timeout;
        }

        return _Result;
    }

    template <class _Rep, class _Period, class _Predicate>
    bool wait_for(unique_lock<mutex>& _Lck, const chrono::duration<_Rep, _Period>& _Rel_time, _Predicate _Pred) {
        
        return _Wait_until1(_Lck, _To_absolute_time(_Rel_time), _Pred);
    }

    template <class _Clock, class _Duration>
    cv_status wait_until(unique_lock<mutex>& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        


#line 636 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
        for (;;) {
            const auto _Now = _Clock::now();
            if (_Abs_time <= _Now) {
                return cv_status::timeout;
            }

            :: xtime _Tgt;
            (void) _To_xtime_10_day_clamped(_Tgt, _Abs_time - _Now);
            const cv_status _Result = wait_until(_Lck, &_Tgt);
            if (_Result == cv_status::no_timeout) {
                return cv_status::no_timeout;
            }
        }
    }

    template <class _Clock, class _Duration, class _Predicate>
    bool wait_until(
        unique_lock<mutex>& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time, _Predicate _Pred) {
        


#line 658 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
        return _Wait_until1(_Lck, _Abs_time, _Pred);
    }

    cv_status wait_until(unique_lock<mutex>& _Lck, const xtime* _Abs_time) {
        
        if (!_Mtx_current_owns(_Lck.mutex()->_Mymtx())) {
            _Throw_Cpp_error(_OPERATION_NOT_PERMITTED);
        }

        
        const int _Res = _Cnd_timedwait(_Mycnd(), _Lck.mutex()->_Mymtx(), _Abs_time);
        switch (_Res) {
        case _Thrd_success:
            return cv_status::no_timeout;
        case _Thrd_timedout:
            return cv_status::timeout;
        default:
            _Throw_C_error(_Res);
        }
    }

    template <class _Predicate>
    bool wait_until(unique_lock<mutex>& _Lck, const xtime* _Abs_time, _Predicate _Pred) {
        
        return _Wait_until1(_Lck, _Abs_time, _Pred);
    }

    [[nodiscard]] native_handle_type native_handle() {
        return _Mycnd();
    }

    void _Register(unique_lock<mutex>& _Lck, int* _Ready) { 
        _Cnd_register_at_thread_exit(_Mycnd(), _Lck.release()->_Mymtx(), _Ready);
    }

    void _Unregister(mutex& _Mtx) { 
        _Cnd_unregister_at_thread_exit(_Mtx._Mymtx());
    }

private:
    aligned_storage_t<72, 8> _Cnd_storage;

    _Cnd_t _Mycnd() noexcept { 
        return reinterpret_cast<_Cnd_t>(&_Cnd_storage);
    }

    template <class _Predicate>
    bool _Wait_until1(unique_lock<mutex>& _Lck, const xtime* _Abs_time, _Predicate& _Pred) {
        
        while (!_Pred()) {
            if (wait_until(_Lck, _Abs_time) == cv_status::timeout) {
                return _Pred();
            }
        }

        return true;
    }

    template <class _Clock, class _Duration, class _Predicate>
    bool _Wait_until1(
        unique_lock<mutex>& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time, _Predicate& _Pred) {
        while (!_Pred()) {
            const auto _Now = _Clock::now();
            if (_Abs_time <= _Now) {
                return false;
            }

            :: xtime _Tgt;
            const bool _Clamped = _To_xtime_10_day_clamped(_Tgt, _Abs_time - _Now);
            if (wait_until(_Lck, &_Tgt) == cv_status::timeout && !_Clamped) {
                return _Pred();
            }
        }

        return true;
    }
};

struct _UInt_is_zero {
    const unsigned int& _UInt;

    [[nodiscard]] bool operator()() const {
        return _UInt == 0;
    }
};

class timed_mutex { 
public:
    timed_mutex() noexcept : _My_locked(0) {}

    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;

    void lock() { 
        unique_lock<mutex> _Lock(_My_mutex);
        while (_My_locked != 0) {
            _My_cond.wait(_Lock);
        }

        _My_locked = 0xffffffff;
    }

    [[nodiscard]] bool try_lock() noexcept { 
        lock_guard<mutex> _Lock(_My_mutex);
        if (_My_locked != 0) {
            return false;
        } else {
            _My_locked = 0xffffffff;
            return true;
        }
    }

    void unlock() { 
        {
            
            lock_guard<mutex> _Lock(_My_mutex);
            _My_locked = 0;
        }
        _My_cond.notify_one();
    }

    template <class _Rep, class _Period>
    [[nodiscard]] bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time) { 
        return try_lock_until(_To_absolute_time(_Rel_time));
    }

    template <class _Time>
    bool _Try_lock_until(_Time _Abs_time) { 
        unique_lock<mutex> _Lock(_My_mutex);
        if (!_My_cond.wait_until(_Lock, _Abs_time, _UInt_is_zero{_My_locked})) {
            return false;
        }

        _My_locked = 0xffffffff;
        return true;
    }

    template <class _Clock, class _Duration>
    [[nodiscard]] bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        


#line 801 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
        return _Try_lock_until(_Abs_time);
    }

    [[nodiscard]] bool try_lock_until(const xtime* _Abs_time) { 
        return _Try_lock_until(_Abs_time);
    }

private:
    mutex _My_mutex;
    condition_variable _My_cond;
    unsigned int _My_locked;
};

class recursive_timed_mutex { 
public:
    recursive_timed_mutex() noexcept : _My_locked(0) {}

    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

    void lock() { 
        const thread::id _Tid = this_thread::get_id();

        unique_lock<mutex> _Lock(_My_mutex);

        if (_Tid == _My_owner) {
            if (_My_locked < 0xffffffff) {
                ++_My_locked;
            } else {
                _Throw_system_error(errc::device_or_resource_busy);
            }
        } else {
            while (_My_locked != 0) {
                _My_cond.wait(_Lock);
            }

            _My_locked = 1;
            _My_owner  = _Tid;
        }
    }

    [[nodiscard]] bool try_lock() noexcept { 
        const thread::id _Tid = this_thread::get_id();

        lock_guard<mutex> _Lock(_My_mutex);

        if (_Tid == _My_owner) {
            if (_My_locked < 0xffffffff) {
                ++_My_locked;
            } else {
                return false;
            }
        } else {
            if (_My_locked != 0) {
                return false;
            } else {
                _My_locked = 1;
                _My_owner  = _Tid;
            }
        }
        return true;
    }

    void unlock() { 
        bool _Do_notify = false;

        {
            lock_guard<mutex> _Lock(_My_mutex);
            --_My_locked;
            if (_My_locked == 0) {
                _Do_notify = true;
                _My_owner  = thread::id();
            }
        }

        if (_Do_notify) {
            _My_cond.notify_one();
        }
    }

    template <class _Rep, class _Period>
    [[nodiscard]] bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time) { 
        return try_lock_until(_To_absolute_time(_Rel_time));
    }

    template <class _Time>
    bool _Try_lock_until(_Time _Abs_time) { 
        const thread::id _Tid = this_thread::get_id();

        unique_lock<mutex> _Lock(_My_mutex);

        if (_Tid == _My_owner) {
            if (_My_locked < 0xffffffff) {
                ++_My_locked;
            } else {
                return false;
            }
        } else {
            if (!_My_cond.wait_until(_Lock, _Abs_time, _UInt_is_zero{_My_locked})) {
                return false;
            }

            _My_locked = 1;
            _My_owner  = _Tid;
        }
        return true;
    }

    template <class _Clock, class _Duration>
    [[nodiscard]] bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        


#line 915 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
        return _Try_lock_until(_Abs_time);
    }

    [[nodiscard]] bool try_lock_until(const xtime* _Abs_time) { 
        return _Try_lock_until(_Abs_time);
    }

private:
    mutex _My_mutex;
    condition_variable _My_cond;
    unsigned int _My_locked;
    thread::id _My_owner;
};
#line 929 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
}


#pragma warning(pop)
#pragma pack(pop)
#line 935 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
#line 936 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\mutex"
#pragma external_header(pop)
#line 25 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"





#pragma once










#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984  )








namespace std {
template <class _Lock>
struct [[nodiscard]] _Unlock_guard {
    explicit _Unlock_guard(_Lock& _Mtx_) : _Mtx(_Mtx_) {
        _Mtx.unlock();
    }

    ~_Unlock_guard() noexcept  {
        
        
        
        
        _Mtx.lock();
    }

    _Unlock_guard(const _Unlock_guard&) = delete;
    _Unlock_guard& operator=(const _Unlock_guard&) = delete;

private:
    _Lock& _Mtx;
};

class condition_variable_any { 
public:
    condition_variable_any() : _Myptr{::std:: make_shared<mutex>()} {
        _Cnd_init_in_situ(_Mycnd());
    }

    ~condition_variable_any() noexcept {
        _Cnd_destroy_in_situ(_Mycnd());
    }

    condition_variable_any(const condition_variable_any&) = delete;
    condition_variable_any& operator=(const condition_variable_any&) = delete;

    void notify_one() noexcept { 
        lock_guard<mutex> _Guard{*_Myptr};
        _Cnd_signal(_Mycnd());
    }

    void notify_all() noexcept { 
        lock_guard<mutex> _Guard{*_Myptr};
        _Cnd_broadcast(_Mycnd());
    }

    template <class _Lock>
    void wait(_Lock& _Lck) noexcept  { 
        const shared_ptr<mutex> _Ptr = _Myptr; 
        unique_lock<mutex> _Guard{*_Ptr};
        _Unlock_guard<_Lock> _Unlock_outer{_Lck};
        _Cnd_wait(_Mycnd(), _Ptr->_Mymtx());
        _Guard.unlock();
    } 

    template <class _Lock, class _Predicate>
    void wait(_Lock& _Lck, _Predicate _Pred) noexcept(noexcept(static_cast<bool>(_Pred())))  {
        
        while (!static_cast<bool>(_Pred())) {
            wait(_Lck);
        }
    }

    template <class _Lock, class _Clock, class _Duration>
    cv_status wait_until(_Lock& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        


#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
        return wait_for(_Lck, _Abs_time - _Clock::now());
    }

    template <class _Lock, class _Clock, class _Duration, class _Predicate>
    bool wait_until(_Lock& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time, _Predicate _Pred) {
        


#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
        while (!_Pred()) {
            if (wait_until(_Lck, _Abs_time) == cv_status::timeout) {
                return _Pred();
            }
        }

        return true;
    }

    template <class _Lock, class _Rep, class _Period>
    cv_status wait_for(_Lock& _Lck, const chrono::duration<_Rep, _Period>& _Rel_time) { 
        if (_Rel_time <= chrono::duration<_Rep, _Period>::zero()) {
            _Unlock_guard<_Lock> _Unlock_outer{_Lck};
            (void) _Unlock_outer;
            return cv_status::timeout;
        }

        
        
        :: xtime _Tgt;
        const bool _Clamped     = _To_xtime_10_day_clamped(_Tgt, _Rel_time);
        const cv_status _Result = _Wait_until(_Lck, &_Tgt);
        if (_Clamped) {
            return cv_status::no_timeout;
        }

        return _Result;
    }

    template <class _Lock, class _Rep, class _Period, class _Predicate>
    bool wait_for(_Lock& _Lck, const chrono::duration<_Rep, _Period>& _Rel_time, _Predicate _Pred) {
        
        return wait_until(_Lck, _To_absolute_time(_Rel_time), ::std:: move(_Pred));
    }

    template <class _Lock>
    cv_status wait_until(_Lock& _Lck, const xtime* const _Abs_time) { 
        return _Wait_until(_Lck, _Abs_time);
    }

    template <class _Lock, class _Predicate>
    bool wait_until(_Lock& _Lck, const xtime* const _Abs_time, _Predicate _Pred) {
        
        while (!_Pred()) {
            if (_Wait_until(_Lck, _Abs_time) == cv_status::timeout) {
                return _Pred();
            }
        }
        return true;
    }























































































#line 245 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"

private:
    shared_ptr<mutex> _Myptr;

    aligned_storage_t<72, 8> _Cnd_storage;

    [[nodiscard]] _Cnd_t _Mycnd() noexcept { 
        return reinterpret_cast<_Cnd_t>(&_Cnd_storage);
    }

    template <class _Lock>
    cv_status _Wait_until(_Lock& _Lck, const xtime* const _Abs_time) { 
        const shared_ptr<mutex> _Ptr = _Myptr; 
        unique_lock<mutex> _Guard{*_Ptr};
        _Unlock_guard<_Lock> _Unlock_outer{_Lck};
        const int _Res = _Cnd_timedwait(_Mycnd(), _Ptr->_Mymtx(), _Abs_time);
        _Guard.unlock();

        switch (_Res) {
        case _Thrd_success:
            return cv_status::no_timeout;
        case _Thrd_timedout:
            return cv_status::timeout;
        default:
            _Throw_C_error(_Res);
        }
    }
};

inline void notify_all_at_thread_exit(condition_variable& _Cnd, unique_lock<mutex> _Lck) {
    
    _Cnd._Register(_Lck, nullptr);
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.29.30133\\include\\condition_variable"
#pragma external_header(pop)
#line 26 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"


inline void check(cudaError_t err, const char* const func, const char* const file, const int line)
{
	if (err != cudaSuccess)
	{
		std::cerr << "CUDA Runtime Error at: " << file << ":" << line << std::endl;
		std::cerr << cudaGetErrorString(err) << " " << func << std::endl;
		std::exit(1);
	}
}


inline void check_last(const char* const file, const int line)
{
	cudaError_t const err{ cudaPeekAtLastError() };
	if (err != cudaSuccess)
	{
		std::cerr << "CUDA Runtime Error at: " << file << ":" << line << std::endl;
		std::cerr << cudaGetErrorString(err) << std::endl;
		std::exit(1);
	}
}

const unsigned MOD = 65537;
const unsigned SPECIAL = MOD - 1;
const unsigned ROOT = 3;
const unsigned ROOT_INV = 21846;
const unsigned MAX_LOG = 16;

const unsigned LOG_DATA = 10;
const unsigned LOG_SYMBOL = LOG_DATA - 1;
const unsigned LOG_SEG = LOG_SYMBOL - 1;
const unsigned SYMBOL_PER_PACKET = 1 << LOG_SYMBOL;
const unsigned NUM_OF_PACKET = 1 << (MAX_LOG - LOG_SYMBOL);
const unsigned NUM_OF_NEED_PACKET = NUM_OF_PACKET >> 1;
const unsigned SEG_PER_PACKET = 1 << LOG_SEG;
const unsigned SEG_DIFF = 1 << (MAX_LOG - 1);
const unsigned NUM_OF_NEED_SYMBOL = 1 << (MAX_LOG - 1);

const unsigned LEN_ROOT_LAYER_POW = (1 << MAX_LOG) - 1;
const unsigned LEN_ROOT_LAYER_POW_2 = LEN_ROOT_LAYER_POW << 1;
const unsigned LEN_N_POS = ((1 << (MAX_LOG + 1)) - 1);
const unsigned LEN_PACKET_PRODUCT = NUM_OF_PACKET * (SYMBOL_PER_PACKET << 1);
const unsigned LEN_ONE_PACKET_PRODUCT = 1 << (LOG_SYMBOL + 1);

const unsigned LEN_SMALL = NUM_OF_NEED_SYMBOL;
const unsigned LEN_LARGE = LEN_SMALL << 1;

const unsigned SIZE_SMALL = LEN_SMALL * sizeof(unsigned);
const unsigned SIZE_LARGE = LEN_LARGE * sizeof(unsigned);
const unsigned SIZE_ONE_PACKET_PRODUCT = LEN_ONE_PACKET_PRODUCT * sizeof(unsigned);

const unsigned LOG_LEN_ENCODE_P = MAX_LOG - 1;
const unsigned LOG_LEN_ENCODE_Y = MAX_LOG;
const unsigned LOG_LEN_DECODE_X = MAX_LOG - 1;
const unsigned LOG_LEN_DECODE_Y = MAX_LOG - 1;
const unsigned LOG_LEN_DECODE_P = MAX_LOG - 1;

const unsigned LEN_ENCODE_P = 1 << LOG_LEN_ENCODE_P;
const unsigned LEN_ENCODE_Y = 1 << LOG_LEN_ENCODE_Y;
const unsigned LEN_DECODE_X = 1 << LOG_LEN_DECODE_X;
const unsigned LEN_DECODE_Y = 1 << LOG_LEN_DECODE_Y;
const unsigned LEN_DECODE_P = 1 << LOG_LEN_DECODE_P;

const unsigned SIZE_ENCODE_P = LEN_ENCODE_P * sizeof(unsigned);
const unsigned SIZE_ENCODE_Y = LEN_ENCODE_Y * sizeof(unsigned);
const unsigned SIZE_DECODE_X = LEN_DECODE_X * sizeof(unsigned);
const unsigned SIZE_DECODE_Y = LEN_DECODE_Y * sizeof(unsigned);
const unsigned SIZE_DECODE_P = LEN_DECODE_P * sizeof(unsigned);




const unsigned MAX_ACTIVE_ENCODE = 1024;
const unsigned MAX_ACTIVE_DECODE = 1024;
const unsigned MAX_ENCODE_LAUNCH_CNT = 16;
const unsigned MAX_DECODE_LAUNCH_CNT = 128;

const unsigned LOG_THREAD_PER_OP = 9;
const unsigned THREAD_PER_OP = 1 << LOG_THREAD_PER_OP;

const unsigned LOG_LEN_WARP = 5;
const unsigned LEN_WARP = 1 << LOG_LEN_WARP;
const unsigned ALGO_N_2_CUTOFF = 64;

const size_t SIZE_ENCODE_P_SLOT = sizeof(unsigned) * LEN_ENCODE_P * MAX_ACTIVE_ENCODE;
const size_t SIZE_ENCODE_Y_SLOT = sizeof(unsigned) * LEN_ENCODE_Y * MAX_ACTIVE_ENCODE;

const size_t SIZE_DECODE_X_SLOT = sizeof(unsigned) * LEN_DECODE_X * MAX_ACTIVE_DECODE;
const size_t SIZE_DECODE_Y_SLOT = sizeof(unsigned) * LEN_DECODE_Y * MAX_ACTIVE_DECODE;

const size_t SIZE_DECODE_T1_SLOT = sizeof(unsigned) * LEN_LARGE * MAX_ACTIVE_DECODE;
const size_t SIZE_DECODE_T2_SLOT = sizeof(unsigned) * LEN_LARGE * MAX_ACTIVE_DECODE;
const size_t SIZE_DECODE_AX_SLOT = sizeof(unsigned) * LEN_LARGE * MAX_ACTIVE_DECODE;
const size_t SIZE_DECODE_DAX_SLOT = sizeof(unsigned) * LEN_SMALL * MAX_ACTIVE_DECODE;
const size_t SIZE_DECODE_VDAX_SLOT = sizeof(unsigned) * LEN_LARGE * MAX_ACTIVE_DECODE;
const size_t SIZE_DECODE_N1_SLOT = sizeof(unsigned) * LEN_SMALL * MAX_ACTIVE_DECODE;
const size_t SIZE_DECODE_N2_SLOT = sizeof(unsigned) * LEN_LARGE * MAX_ACTIVE_DECODE;
const size_t SIZE_DECODE_N3_SLOT = sizeof(unsigned) * LEN_SMALL * MAX_ACTIVE_DECODE;

unsigned** h_encode_p_slot;
unsigned** h_encode_y_slot;
unsigned** h_decode_x_slot;
unsigned** h_decode_y_slot;
unsigned** h_decode_p_slot;

unsigned* d_encode_p_slot;
unsigned* d_encode_y_slot;
unsigned* d_decode_x_slot;
unsigned* d_decode_y_slot;

unsigned* d_decode_t1_slot;
unsigned* d_decode_t2_slot;
unsigned* d_decode_ax_slot;
unsigned* d_decode_dax_slot;
unsigned* d_decode_vdax_slot;
unsigned* d_decode_n1_slot;
unsigned* d_decode_n2_slot;
unsigned* d_decode_n3_slot;

unsigned* d_N_pos;
unsigned* d_root_pow;
unsigned* d_root_inv_pow;
unsigned* d_inv;
unsigned* d_root_layer_pow;
unsigned* d_packet_product;

struct CB_DATA {
	unsigned slot_id;
	unsigned* dst;
	unsigned* src;
	size_t size_res;
	std::queue<unsigned>& slot; 
	std::mutex& mt; 
	std::condition_variable& cv;
};

std::queue<unsigned> encode_slot, decode_slot;
std::mutex mt_encode_slot, mt_decode_slot;
std::condition_variable cv_encode_slot, cv_decode_slot;

inline unsigned pop_slot(std::queue<unsigned> &slot, std::mutex &mt, std::condition_variable &cv) {
	std::unique_lock<std::mutex> lock(mt);
	cv.wait(lock, [&] { return !slot.empty(); });
	unsigned id = slot.front();
	slot.pop();
	return id;
}

inline void push_slot(unsigned id, std::queue<unsigned>& slot, std::mutex& mt, std::condition_variable& cv) {
	{
		std::lock_guard<std::mutex> lock(mt);
		slot.push(id);
	}
	cv.notify_one();
}

void init_batch_slot() {

	for (unsigned i = 0; i < MAX_ACTIVE_ENCODE; i++)
		push_slot(i, encode_slot, mt_encode_slot, cv_encode_slot);

	for (unsigned i = 0; i < MAX_ACTIVE_DECODE; i++)
		push_slot(i, decode_slot, mt_decode_slot, cv_decode_slot);

}

void __stdcall h_end_batch_slot(void* data) {

	CB_DATA* dat = static_cast<CB_DATA*>(data);

	memcpy(dat->dst, dat->src, dat->size_res);
	push_slot(dat->slot_id, dat->slot, dat->mt, dat->cv);

	delete dat;
}





__declspec(__host__) __declspec(__device__) __forceinline inline unsigned mul_mod(unsigned a, unsigned b)
{
	if (a == SPECIAL && b == SPECIAL)
		return 1; 
	return (a * b) % MOD;
}

__declspec(__device__) __forceinline inline unsigned div_mod(unsigned a, unsigned b,
	unsigned* d_inv)
{
	return mul_mod(a, d_inv[b]);
}

__declspec(__host__) __declspec(__device__) __forceinline inline unsigned add_mod(unsigned a, unsigned b)
{
	return (a + b) % MOD;
}

__declspec(__host__) __declspec(__device__) __forceinline inline unsigned sub_mod(unsigned a, unsigned b)
{
	return (a - b + MOD) % MOD;
}

__declspec(__host__) __declspec(__device__) __forceinline inline unsigned pow_mod(unsigned a, unsigned b)
{
	unsigned res = 1;
	while (b > 0)
	{
		if (b & 1)
			res = mul_mod(res, a);
		a = mul_mod(a, a);
		b >>= 1;
	}
	return res;
}

__declspec(__global__) void fnt(unsigned* a, unsigned* b, unsigned log_na, unsigned log_nb, unsigned opt,
	unsigned* d_N_pos, unsigned* d_root_layer_pow, unsigned* d_inv, unsigned wpt)
{

	





	
	

	

	unsigned id = blockIdx.x * blockDim.x + threadIdx.x;
	unsigned na = 1 << log_na, nb = 1 << log_nb, wp = (opt & 2) >> 1, st = nb - 1;
	unsigned id_l = id * wpt, id_r = min(id_l + wpt, nb >> 1);
	unsigned os1 = nb >> 1, os2 = LEN_ROOT_LAYER_POW * wp;
	for (unsigned k = id_l; k < id_r; k++) {
		if (k < na) b[d_N_pos[st + k]] = a[k];
		if (log_na == log_nb) b[d_N_pos[st + k + os1]] = a[k + os1];
	}

	__syncthreads();

	for (unsigned i = 0; i < log_nb; i++) {

		unsigned haft_len = 1 << i;
		for (unsigned k = id_l; k < id_r; k++) {
			unsigned bl_st = ((k >> i) << (i + 1)), th_id = (k & (haft_len - 1));
			unsigned pos = bl_st + th_id;
			unsigned u = b[pos];
			unsigned v = mul_mod(b[pos + haft_len], d_root_layer_pow[os2 + haft_len - 1 + th_id]);
			b[pos] = add_mod(u, v);
			b[pos + haft_len] = sub_mod(u, v);
		}

		__syncthreads();

	}

	if (opt & 1) {
		for (unsigned k = id_l; k < id_r; k++) {
			b[k] = div_mod(b[k], nb, d_inv);
			b[k + os1] = div_mod(b[k + os1], nb, d_inv);
		}

	}
}

__declspec(__global__) void g_vector_mul_i(unsigned* a, unsigned* b, unsigned* c, unsigned n, unsigned wpt)
{

	unsigned id = blockIdx.x * blockDim.x + threadIdx.x;
	unsigned id_l = id * wpt, id_r = min(id_l + wpt, n);
	for (unsigned k = id_l; k < id_r; k++)
		c[k] = mul_mod(a[k], b[k]);


}

__declspec(__global__) void g_fill(unsigned* a, unsigned val, unsigned n, unsigned wpt) {

	unsigned id = blockIdx.x * blockDim.x + threadIdx.x;
	unsigned id_l = id * wpt, id_r = min(id_l + wpt, n);
	for (unsigned k = id_l; k < id_r; k++)
		a[k] = val;

}

inline void h_poly_mul(unsigned* a, unsigned* b, unsigned* t1, unsigned* t2, unsigned* c, unsigned log_n,
	unsigned* d_N_pos, unsigned* d_root_layer_pow, unsigned* d_inv, cudaStream_t stream) {


	unsigned na = 1 << log_n, nc = 1 << (log_n + 1), size_nc = nc * sizeof(unsigned);

	unsigned wpt1 = max(nc >> LOG_THREAD_PER_OP, 1), wpt2 = max(na >> LOG_THREAD_PER_OP, 1);
	g_fill <<< 1, THREAD_PER_OP, 0, stream >>> (t1, 0, nc, wpt1);
	g_fill <<< 1, THREAD_PER_OP, 0, stream >>> (t2, 0, nc, wpt1);

	fnt <<< 1, THREAD_PER_OP, 0, stream >>> (a, t1, log_n, log_n + 1, 0, d_N_pos, d_root_layer_pow, d_inv, wpt2);
	fnt <<< 1, THREAD_PER_OP, 0, stream >>> (b, t2, log_n, log_n + 1, 0, d_N_pos, d_root_layer_pow, d_inv, wpt2);

	g_vector_mul_i <<< 1, THREAD_PER_OP, 0, stream >>>(t1, t2, t1, nc, wpt1);

	fnt <<< 1, THREAD_PER_OP, 0, stream >>> (t1, c, log_n + 1, log_n + 1, 3, d_N_pos, d_root_layer_pow, d_inv, wpt2);

}

__declspec(__global__) void g_poly_deriv(unsigned* ax, unsigned* dax, unsigned wpt)
{

	unsigned id = blockIdx.x * blockDim.x + threadIdx.x;
	unsigned id_l = id * wpt, id_r = id_l + wpt;
	for (unsigned k = id_l; k < id_r; k++)
		dax[k] = mul_mod(ax[k + 1], k + 1);
}

inline void h_build_product(unsigned* p, unsigned* t1, unsigned* t2, unsigned log_n1, unsigned log_n2, cudaStream_t stream)
{

	

	for (unsigned i = log_n1; i < log_n2; i++)
	{
		unsigned m = 1 << (log_n2 - i - 1), len = 1 << i;
		for (unsigned j = 0; j < m; j++) {
			unsigned st = j << (i + 1);
			h_poly_mul(p + st, p + st + len, t1 + st, t2 + st, p + st, i, d_N_pos, d_root_layer_pow, d_inv, stream);
		}
	}
}

inline void h_build_ax(unsigned* x, unsigned* p, unsigned* t1, unsigned* t2, cudaStream_t stream)
{

	
	

	for (unsigned i = 0; i < NUM_OF_NEED_PACKET; i++)
	{
		unsigned st_p1 = i << (LOG_SYMBOL + 1), st_p2 = x[i << LOG_SYMBOL] << 2;
		check((cudaMemcpyAsync(p + st_p1, d_packet_product + st_p2, SIZE_ONE_PACKET_PRODUCT, cudaMemcpyDeviceToDevice, stream)), "cudaMemcpyAsync(p + st_p1, d_packet_product + st_p2, SIZE_ONE_PACKET_PRODUCT, cudaMemcpyDeviceToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 367);
	}
	h_build_product(p, t1, t2, LOG_SYMBOL + 1, MAX_LOG, stream);
}

__declspec(__global__) void g_build_n1(unsigned* n1, unsigned* vdax, unsigned* x, unsigned* y,
	unsigned* d_inv, unsigned wpt)
{

	unsigned id = blockIdx.x * blockDim.x + threadIdx.x;
	unsigned id_l = id * wpt, id_r = id_l + wpt;
	for (unsigned k = id_l; k < id_r; k++)
		n1[k] = div_mod(y[k], vdax[x[k]], d_inv);

}

__declspec(__global__) void g_build_n2(unsigned* n2, unsigned* n1, unsigned* x, unsigned wpt) {

	unsigned id = blockIdx.x * blockDim.x + threadIdx.x;
	unsigned id_l = id * wpt, id_r = id_l + wpt;
	for (unsigned k = id_l; k < id_r; k++)
		n2[x[k]] = n1[k];

}

__declspec(__global__) void g_build_n3(unsigned* n3, unsigned* p_n3, unsigned wpt) {

	unsigned id = blockIdx.x * blockDim.x + threadIdx.x;
	unsigned id_l = id * wpt, id_r = id_l + wpt;
	for (unsigned k = id_l; k < id_r; k++)
		n3[k] = sub_mod(0, p_n3[k + 1]);

}

inline void h_build_px(unsigned* p, unsigned* ax, unsigned* n3, unsigned* t1, unsigned* t2,
	unsigned* d_N_pos, unsigned* d_root_layer_pow, unsigned* d_inv, cudaStream_t stream) {

	h_poly_mul(ax, n3, t1, t2, p, MAX_LOG - 1, d_N_pos, d_root_layer_pow, d_inv, stream);
	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 405);

}

void h_encode(unsigned* p, unsigned* y)
{

	unsigned slot_id = pop_slot(encode_slot, mt_encode_slot, cv_encode_slot);

	unsigned* sl_p = h_encode_p_slot[slot_id];
	unsigned* sl_y = h_encode_y_slot[slot_id];

	memcpy(sl_p, p, SIZE_ENCODE_P);

	unsigned* d_p = d_encode_p_slot + 1LL * slot_id * LEN_ENCODE_P;
	unsigned* d_y = d_encode_y_slot + 1LL * slot_id * LEN_ENCODE_Y;

	unsigned wpt1 = LEN_LARGE >> LOG_THREAD_PER_OP, wpt2 = LEN_SMALL >> LOG_THREAD_PER_OP;

	CB_DATA* data = new CB_DATA{ slot_id, y, sl_y, SIZE_ENCODE_Y, encode_slot, mt_encode_slot, cv_encode_slot };

	cudaStream_t stream;
	check((cudaStreamCreate(&stream)), "cudaStreamCreate(&stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 427);

	check((cudaMemcpyAsync(d_p, sl_p, SIZE_ENCODE_P, cudaMemcpyHostToDevice, stream)), "cudaMemcpyAsync(d_p, sl_p, SIZE_ENCODE_P, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 429);
	
	g_fill <<< 1, THREAD_PER_OP, 0, stream >>> (d_y, 0, LEN_LARGE, wpt1);

	fnt <<< 1, THREAD_PER_OP, 0, stream >>> (d_p, d_y, MAX_LOG - 1, MAX_LOG, 0, d_N_pos, d_root_layer_pow, d_inv, wpt2);
	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 434);

	check((cudaMemcpyAsync(sl_y, d_y, SIZE_ENCODE_Y, cudaMemcpyDeviceToHost, stream)), "cudaMemcpyAsync(sl_y, d_y, SIZE_ENCODE_Y, cudaMemcpyDeviceToHost, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 436);
	
	check((cudaLaunchHostFunc(stream, h_end_batch_slot, data)), "cudaLaunchHostFunc(stream, h_end_batch_slot, data)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 438);

	check((cudaStreamDestroy(stream)), "cudaStreamDestroy(stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 440);

}

void h_decode(unsigned* x, unsigned* y, unsigned* p)
{

	unsigned slot_id = pop_slot(decode_slot, mt_decode_slot, cv_decode_slot);

	unsigned* sl_x = h_decode_x_slot[slot_id];
	unsigned* sl_y = h_decode_y_slot[slot_id];
	unsigned* sl_p = h_decode_p_slot[slot_id];

	memcpy(sl_x, x, SIZE_DECODE_X);
	memcpy(sl_y, y, SIZE_DECODE_Y);

	unsigned* d_x = d_decode_x_slot + 1LL * slot_id * LEN_DECODE_X;
	unsigned* d_y = d_decode_y_slot + 1LL * slot_id * LEN_DECODE_Y;
	unsigned* d_t1 = d_decode_t1_slot + 1LL * slot_id * LEN_LARGE;
	unsigned* d_t2 = d_decode_t2_slot + 1LL * slot_id * LEN_LARGE;
	unsigned* d_ax = d_decode_ax_slot + 1LL * slot_id * LEN_LARGE;
	unsigned* d_dax = d_decode_dax_slot + 1LL * slot_id * LEN_SMALL;
	unsigned* d_vdax = d_decode_vdax_slot + 1LL * slot_id * LEN_LARGE;
	unsigned* d_n1 = d_decode_n1_slot + 1LL * slot_id * LEN_SMALL;
	unsigned* d_n2 = d_decode_n2_slot + 1LL * slot_id * LEN_LARGE;
	unsigned* d_n3 = d_decode_n3_slot + 1LL * slot_id * LEN_SMALL;

	unsigned wpt1 = LEN_LARGE >> LOG_THREAD_PER_OP, wpt2 = LEN_SMALL >> LOG_THREAD_PER_OP;

	CB_DATA* data = new CB_DATA{ slot_id, p, sl_p, SIZE_DECODE_P, decode_slot, mt_decode_slot, cv_decode_slot };

	cudaStream_t stream;
	check((cudaStreamCreate(&stream)), "cudaStreamCreate(&stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 472);

	check((cudaMemcpyAsync(d_x, sl_x, SIZE_DECODE_X, cudaMemcpyHostToDevice, stream)), "cudaMemcpyAsync(d_x, sl_x, SIZE_DECODE_X, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 474);
	check((cudaMemcpyAsync(d_y, sl_y, SIZE_DECODE_Y, cudaMemcpyHostToDevice, stream)), "cudaMemcpyAsync(d_y, sl_y, SIZE_DECODE_Y, cudaMemcpyHostToDevice, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 475);

	g_fill <<< 1, THREAD_PER_OP, 0, stream >>>(d_vdax, 0, LEN_LARGE, wpt1);
	g_fill <<< 1, THREAD_PER_OP, 0, stream >>>(d_n2, 0, LEN_LARGE, wpt1);

	h_build_ax(x, d_ax, d_t1, d_t2, stream);

	g_poly_deriv <<< 1, THREAD_PER_OP, 0, stream >>>(d_ax, d_dax, wpt2);
	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 483);
	
	fnt <<< 1, THREAD_PER_OP, 0, stream >>>(d_dax, d_vdax, MAX_LOG - 1, MAX_LOG, 0, d_N_pos, d_root_layer_pow, d_inv, wpt2);
	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 486);
	
	g_build_n1 <<< 1, THREAD_PER_OP, 0, stream >>>(d_n1, d_vdax, d_x, d_y, d_inv, wpt2);
	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 489);
	
	g_build_n2 <<< 1, THREAD_PER_OP, 0, stream >>>(d_n2, d_n1, d_x, wpt2);
	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 492);
	
	fnt <<< 1, THREAD_PER_OP, 0, stream >>>(d_n2, d_t2, MAX_LOG, MAX_LOG, 2, d_N_pos, d_root_layer_pow, d_inv, wpt2);
	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 495);
	g_build_n3 <<< 1, THREAD_PER_OP, 0, stream >>>(d_n3, d_t2, wpt2);
	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 497);
	
	h_build_px(d_n2, d_ax, d_n3, d_t1, d_t2, d_N_pos, d_root_layer_pow, d_inv, stream);
	check((cudaMemcpyAsync(sl_p, d_n2, SIZE_SMALL, cudaMemcpyDeviceToHost, stream)), "cudaMemcpyAsync(sl_p, d_n2, SIZE_SMALL, cudaMemcpyDeviceToHost, stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 500);

	check((cudaLaunchHostFunc(stream, h_end_batch_slot, data)), "cudaLaunchHostFunc(stream, h_end_batch_slot, data)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 502);

	check((cudaStreamDestroy(stream)), "cudaStreamDestroy(stream)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 504);

}

void init()
{
	

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 512);
	check((cudaDeviceReset()), "cudaDeviceReset()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 513);
	check((cudaDeviceSetLimit(cudaLimitDevRuntimePendingLaunchCount, max(MAX_ACTIVE_DECODE * MAX_DECODE_LAUNCH_CNT, MAX_ACTIVE_ENCODE * MAX_ENCODE_LAUNCH_CNT))), "cudaDeviceSetLimit(cudaLimitDevRuntimePendingLaunchCount, max(MAX_ACTIVE_DECODE * MAX_DECODE_LAUNCH_CNT, MAX_ACTIVE_ENCODE * MAX_ENCODE_LAUNCH_CNT))", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 515);
#line 516 "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu"

	h_encode_p_slot = (unsigned**)malloc(MAX_ACTIVE_ENCODE * sizeof(unsigned*));
	h_encode_y_slot = (unsigned**)malloc(MAX_ACTIVE_ENCODE * sizeof(unsigned*));
	h_decode_x_slot = (unsigned**)malloc(MAX_ACTIVE_DECODE * sizeof(unsigned*));
	h_decode_y_slot = (unsigned**)malloc(MAX_ACTIVE_DECODE * sizeof(unsigned*));
	h_decode_p_slot = (unsigned**)malloc(MAX_ACTIVE_DECODE * sizeof(unsigned*));

	for (unsigned i = 0; i < MAX_ACTIVE_ENCODE; i++) {
		check((cudaMallocHost(&(h_encode_p_slot[i]), SIZE_ENCODE_P)), "cudaMallocHost(&(h_encode_p_slot[i]), SIZE_ENCODE_P)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 524);
		check((cudaMallocHost(&(h_encode_y_slot[i]), SIZE_ENCODE_Y)), "cudaMallocHost(&(h_encode_y_slot[i]), SIZE_ENCODE_Y)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 525);
	}

	for (unsigned i = 0; i < MAX_ACTIVE_DECODE; i++) {
		check((cudaMallocHost(&(h_decode_x_slot[i]), SIZE_DECODE_X)), "cudaMallocHost(&(h_decode_x_slot[i]), SIZE_DECODE_X)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 529);
		check((cudaMallocHost(&(h_decode_y_slot[i]), SIZE_DECODE_Y)), "cudaMallocHost(&(h_decode_y_slot[i]), SIZE_DECODE_Y)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 530);
		check((cudaMallocHost(&(h_decode_p_slot[i]), SIZE_DECODE_P)), "cudaMallocHost(&(h_decode_p_slot[i]), SIZE_DECODE_P)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 531);
	}

	check((cudaMalloc(&d_encode_p_slot, SIZE_ENCODE_P_SLOT)), "cudaMalloc(&d_encode_p_slot, SIZE_ENCODE_P_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 534);
	check((cudaMalloc(&d_encode_y_slot, SIZE_ENCODE_Y_SLOT)), "cudaMalloc(&d_encode_y_slot, SIZE_ENCODE_Y_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 535);

	check((cudaMalloc(&d_decode_x_slot, SIZE_DECODE_X_SLOT)), "cudaMalloc(&d_decode_x_slot, SIZE_DECODE_X_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 537);
	check((cudaMalloc(&d_decode_y_slot, SIZE_DECODE_Y_SLOT)), "cudaMalloc(&d_decode_y_slot, SIZE_DECODE_Y_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 538);
	
	check((cudaMalloc(&d_decode_t1_slot, SIZE_DECODE_T1_SLOT)), "cudaMalloc(&d_decode_t1_slot, SIZE_DECODE_T1_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 540);
	check((cudaMalloc(&d_decode_t2_slot, SIZE_DECODE_T2_SLOT)), "cudaMalloc(&d_decode_t2_slot, SIZE_DECODE_T2_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 541);
	check((cudaMalloc(&d_decode_ax_slot, SIZE_DECODE_AX_SLOT)), "cudaMalloc(&d_decode_ax_slot, SIZE_DECODE_AX_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 542);
	check((cudaMalloc(&d_decode_dax_slot, SIZE_DECODE_DAX_SLOT)), "cudaMalloc(&d_decode_dax_slot, SIZE_DECODE_DAX_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 543);
	check((cudaMalloc(&d_decode_vdax_slot, SIZE_DECODE_VDAX_SLOT)), "cudaMalloc(&d_decode_vdax_slot, SIZE_DECODE_VDAX_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 544);
	check((cudaMalloc(&d_decode_n1_slot, SIZE_DECODE_N1_SLOT)), "cudaMalloc(&d_decode_n1_slot, SIZE_DECODE_N1_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 545);
	check((cudaMalloc(&d_decode_n2_slot, SIZE_DECODE_N2_SLOT)), "cudaMalloc(&d_decode_n2_slot, SIZE_DECODE_N2_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 546);
	check((cudaMalloc(&d_decode_n3_slot, SIZE_DECODE_N3_SLOT)), "cudaMalloc(&d_decode_n3_slot, SIZE_DECODE_N3_SLOT)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 547);

	init_batch_slot();

	unsigned size_N_pos = LEN_N_POS * sizeof(unsigned);
	unsigned* N_pos = (unsigned*)malloc(size_N_pos);
	check((cudaMalloc(&d_N_pos, size_N_pos)), "cudaMalloc(&d_N_pos, size_N_pos)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 553);

	for (unsigned i = 1; i <= MAX_LOG; i++)
	{
		unsigned n = 1 << i, st = n - 1;
		for (unsigned j = 0; j < n; j++)
			N_pos[st + j] = j;
	}

	for (unsigned i = 1; i <= MAX_LOG; i++)
	{
		unsigned n = 1 << i, st = n - 1;
		for (unsigned j = 0; j < n; j++)
		{
			unsigned rev_num = 0;
			for (unsigned k = 0; k < i; k++)
			{
				if (j & (1 << k))
					rev_num |= (1 << (i - 1 - k));
			}
			if (j < rev_num)
				std::swap(N_pos[st + j], N_pos[st + rev_num]);
		}
	}

	check((cudaMemcpy(d_N_pos, N_pos, size_N_pos, cudaMemcpyHostToDevice)), "cudaMemcpy(d_N_pos, N_pos, size_N_pos, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 578);
	free(N_pos);

	unsigned size_root = MOD * sizeof(unsigned);
	unsigned* root_pow = (unsigned*)malloc(size_root);
	unsigned* root_inv_pow = (unsigned*)malloc(size_root);
	unsigned* inv = (unsigned*)malloc(size_root);
	check((cudaMalloc(&d_root_pow, size_root)), "cudaMalloc(&d_root_pow, size_root)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 585);
	check((cudaMalloc(&d_root_inv_pow, size_root)), "cudaMalloc(&d_root_inv_pow, size_root)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 586);
	check((cudaMalloc(&d_inv, size_root)), "cudaMalloc(&d_inv, size_root)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 587);

	root_pow[0] = 1, root_inv_pow[0] = 1, inv[0] = 0;
	for (unsigned i = 1; i < MOD; i++)
	{
		root_pow[i] = mul_mod(root_pow[i - 1], ROOT);
		root_inv_pow[i] = mul_mod(root_inv_pow[i - 1], ROOT_INV);
		inv[i] = pow_mod(i, MOD - 2);
	}

	check((cudaMemcpy(d_root_pow, root_pow, size_root, cudaMemcpyHostToDevice)), "cudaMemcpy(d_root_pow, root_pow, size_root, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 597);
	check((cudaMemcpy(d_root_inv_pow, root_inv_pow, size_root, cudaMemcpyHostToDevice)), "cudaMemcpy(d_root_inv_pow, root_inv_pow, size_root, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 598);
	check((cudaMemcpy(d_inv, inv, size_root, cudaMemcpyHostToDevice)), "cudaMemcpy(d_inv, inv, size_root, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 599);

	unsigned size_root_layer_pow = LEN_ROOT_LAYER_POW_2 * sizeof(unsigned);
	unsigned* root_layer_pow = (unsigned*)malloc(size_root_layer_pow);
	check((cudaMalloc(&d_root_layer_pow, size_root_layer_pow)), "cudaMalloc(&d_root_layer_pow, size_root_layer_pow)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 603);

	for (unsigned i = 0; i < 2; i++)
	{
		unsigned st_i = LEN_ROOT_LAYER_POW * i;
		for (unsigned j = 0; j < MAX_LOG; j++)
		{
			unsigned haft_len = 1 << j;
			unsigned st_j = haft_len - 1;
			unsigned ang = 1 << (MAX_LOG - j - 1);
			unsigned wn = i ? root_inv_pow[ang] : root_pow[ang], w = 1;
			for (unsigned k = 0; k < haft_len; k++)
			{
				root_layer_pow[st_i + st_j + k] = w;
				w = mul_mod(w, wn);
			}
		}
	}

	check((cudaMemcpy(d_root_layer_pow, root_layer_pow, size_root_layer_pow, cudaMemcpyHostToDevice)), "cudaMemcpy(d_root_layer_pow, root_layer_pow, size_root_layer_pow, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 622);
	free(root_layer_pow);

	unsigned size_packet_product = LEN_PACKET_PRODUCT * sizeof(unsigned);
	unsigned* packet_product = (unsigned*)malloc(size_packet_product);
	check((cudaMalloc(&d_packet_product, size_packet_product)), "cudaMalloc(&d_packet_product, size_packet_product)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 627);

	for (unsigned i = 0; i < NUM_OF_PACKET; i++)
	{
		unsigned st = i << (LOG_SYMBOL + 1);
		for (unsigned j = 0; j < SEG_PER_PACKET; j++)
		{
			unsigned k = (i << LOG_SEG) + j;
			packet_product[st + (j << 1)] = sub_mod(0, root_pow[k]);
			packet_product[st + ((j << 1) | 1)] = 1;
			packet_product[st + ((j + SEG_PER_PACKET) << 1)] = sub_mod(0, root_pow[k + SEG_DIFF]);
			packet_product[st + (((j + SEG_PER_PACKET) << 1) | 1)] = 1;
		}
	}
	check((cudaMemcpy(d_packet_product, packet_product, size_packet_product, cudaMemcpyHostToDevice)), "cudaMemcpy(d_packet_product, packet_product, size_packet_product, cudaMemcpyHostToDevice)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 641);
	free(packet_product);
	unsigned* tmp;
	check((cudaMalloc(&tmp, (LEN_ONE_PACKET_PRODUCT << 1) * sizeof(unsigned))), "cudaMalloc(&tmp, (LEN_ONE_PACKET_PRODUCT << 1) * sizeof(unsigned))", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 644);
	for (unsigned i = 0; i < NUM_OF_PACKET; i++)
	{
		unsigned st = i << (LOG_SYMBOL + 1);
		h_build_product(d_packet_product + st, tmp, tmp + LEN_ONE_PACKET_PRODUCT, 1, LOG_SYMBOL + 1, 0);
	}
	check((cudaFree(tmp)), "cudaFree(tmp)", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 650);
	free(inv);
	free(root_pow);
	free(root_inv_pow);

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 655);
	std::cout << "Init process completed!" << std::endl;

}

void fin()
{
	

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 664);

	for (unsigned i = 0; i < MAX_ACTIVE_ENCODE; i++) {
		check((cudaFreeHost(h_encode_p_slot[i])), "cudaFreeHost(h_encode_p_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 667);
		check((cudaFreeHost(h_encode_y_slot[i])), "cudaFreeHost(h_encode_y_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 668);
	}

	for (unsigned i = 0; i < MAX_ACTIVE_DECODE; i++) {
		check((cudaFreeHost(h_decode_x_slot[i])), "cudaFreeHost(h_decode_x_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 672);
		check((cudaFreeHost(h_decode_y_slot[i])), "cudaFreeHost(h_decode_y_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 673);
		check((cudaFreeHost(h_decode_p_slot[i])), "cudaFreeHost(h_decode_p_slot[i])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 674);
	}

	free(h_encode_p_slot);
	free(h_encode_y_slot);
	free(h_decode_x_slot);
	free(h_decode_y_slot);
	free(h_decode_p_slot);

	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 683);

	check((cudaDeviceReset()), "cudaDeviceReset()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 685);
	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 686);

	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 688);

}

void test_fnt();

void test_poly_mul();

void test_build_init_product();

void test_encode_decode();

void test_fnt_performance();

void test_encode_decode_performance();

int main()
{

	init();

	
	
	
	
	
	
	
	
	

	test_encode_decode_performance();

	fin();

	return 0;
}

void test_fnt() {

	

	unsigned N_test = 32;

	for (unsigned tt = 0; tt < N_test; tt++) {
		unsigned log_nc = 15, log_nv = 16, nc = 1 << log_nc, nv = 1 << log_nv;
		unsigned size_nc = nc * sizeof(unsigned), size_nv = nv * sizeof(unsigned);
		std::vector<unsigned> c1(nc), c2(nc);
		unsigned* d_c1, * d_c2, * d_v;
		cudaMalloc(&d_c1, size_nc);
		cudaMemset(d_c1, 0, size_nc);
		cudaMalloc(&d_c2, size_nv);
		cudaMemset(d_c2, 0, size_nv);
		cudaMalloc(&d_v, size_nv);
		cudaMemset(d_v, 0, size_nv);

		for (unsigned i = 0; i < nc; i++)
			c1[i] = rand() % (MOD - 1);
		shuffle(c1.begin(), c1.end(), std::default_random_engine(time(0)));
		cudaMemcpy(d_c1, c1.data(), size_nc, cudaMemcpyHostToDevice);


		unsigned wpt = nv >> (LOG_THREAD_PER_OP + 1);
		fnt <<< 1, THREAD_PER_OP, 0, 0 >>>(d_c1, d_v, log_nc, log_nv, 0, d_N_pos, d_root_layer_pow, d_inv, wpt);
		fnt <<< 1, THREAD_PER_OP, 0, 0 >>>(d_v, d_c2, log_nv, log_nv, 3, d_N_pos, d_root_layer_pow, d_inv, wpt);

		cudaMemcpy(c2.data(), d_c2, size_nc, cudaMemcpyDeviceToHost);
		for (unsigned i = 0; i < nc; i++)
			((void)0);

		cudaFree(d_c1);
		cudaFree(d_c2);
		cudaFree(d_v);

		

	}

	std::cout << "FNT test passed!" << std::endl;

	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 768);

}

void test_build_init_product() {

	
	std::vector<unsigned> a1 = { 64375, 0, 52012, 0, 2347, 0, 23649, 0, 30899, 0 }, b1(10);
	cudaMemcpy(b1.data(), d_packet_product, 10 * sizeof(unsigned), cudaMemcpyDeviceToHost);

	for (unsigned i = 0; i < 10; i++)
		((void)0);

	
	std::vector<unsigned> a2 = { 64375, 0, 31561, 0, 12153, 0, 31103, 0, 20714, 0 }, b2(10);
	cudaMemcpy(b2.data(), d_packet_product + (1 << (LOG_SYMBOL + 1)), 10 * sizeof(unsigned), cudaMemcpyDeviceToHost);

	for (unsigned i = 0; i < 10; i++)
		((void)0);

	std::cout << "Test packet_product passed!" << std::endl;

	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 790);

}

void test_poly_mul() {

	

	srand(time(0));

	unsigned N_test = 32;

	for (unsigned tt = 0; tt < N_test; tt++) {

		unsigned log_n = 11;
		unsigned n = 1 << log_n, size_n = n * sizeof(unsigned);

		std::vector<unsigned> a(n), b(n), c1(n << 1, 0), c2(n << 1, 0);

		for (unsigned i = 0; i < n; i++) {
			a[i] = rand() % (MOD - 1); 
			b[i] = rand() % (MOD - 1); 
		}

		unsigned* t1, * t2, * d_c;
		cudaMalloc(&t1, size_n << 1);
		cudaMalloc(&t2, size_n << 1);
		cudaMalloc(&d_c, size_n << 1);
		cudaMemcpy(d_c, a.data(), size_n, cudaMemcpyHostToDevice);
		cudaMemcpy(d_c + n, b.data(), size_n, cudaMemcpyHostToDevice);
		h_poly_mul(d_c, d_c + n, t1, t2, d_c, log_n, d_N_pos, d_root_layer_pow, d_inv, 0);

		for (unsigned i = 0; i < n; i++)
			for (unsigned j = 0; j < n; j++)
				c1[i + j] = add_mod(c1[i + j], mul_mod(a[i], b[j]));

		






		cudaMemcpy(c2.data(), d_c, size_n << 1, cudaMemcpyDeviceToHost);

		for (unsigned i = 0; i < (n << 1); i++)
			((void)0);

		

		cudaFree(t1);
		cudaFree(t2);
		cudaFree(d_c);

	}

	std::cout << "Poly mul test passed!" << std::endl;

	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 848);

}

void test_encode_decode() {

	

	srand(time(0));

	unsigned N_test = 32;

	for (unsigned tt = 0; tt < N_test; tt++) {
		std::vector<unsigned> a(NUM_OF_NEED_SYMBOL), b(NUM_OF_NEED_SYMBOL << 1), c(NUM_OF_NEED_SYMBOL);

		for (unsigned i = 0; i < NUM_OF_NEED_SYMBOL; i++)
			a[i] = rand() % (MOD - 1); 

		h_encode(a.data(), b.data());
		cudaDeviceSynchronize();

		std::vector<unsigned> x(NUM_OF_NEED_SYMBOL), y(NUM_OF_NEED_SYMBOL);

		for (unsigned i = 0; i < NUM_OF_NEED_PACKET; i++) {
			unsigned stx = i * SYMBOL_PER_PACKET;
			for (unsigned j = 0; j < SEG_PER_PACKET; j++) {
				x[stx + j] = stx + j;
				x[stx + j + SEG_PER_PACKET] = stx + j + SEG_DIFF;
				y[stx + j] = b[stx + j];
				y[stx + j + SEG_PER_PACKET] = b[stx + j + SEG_DIFF];
			}
		}

		h_decode(x.data(), y.data(), c.data());
		cudaDeviceSynchronize();

		for (unsigned i = 0; i < NUM_OF_NEED_SYMBOL; i++)
			((void)0);
		
	}

	std::cout << "Encode decode test passed!" << std::endl;

	check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 891);

}

void test_fnt_performance() {

	

	using namespace std;

	const unsigned N_test = 1024 * 1024 / 64;
	
	unsigned log_n = 16, n = 1 << log_n;
	unsigned size_n = n * sizeof(unsigned);
	vector<vector<unsigned>> a(N_test, vector<unsigned>(n));
	cudaStream_t stream[N_test];
	vector<unsigned*> d_a(N_test), d_b(N_test);

	for (unsigned tt = 0; tt < N_test; tt++) {
		for (unsigned i = 0; i < n; i++)
			a[tt][i] = rand() % (MOD - 1);
		check((cudaStreamCreate(&stream[tt])), "cudaStreamCreate(&stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 912);
		check((cudaMallocAsync(&d_a[tt], size_n, stream[tt])), "cudaMallocAsync(&d_a[tt], size_n, stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 913);
		check((cudaMallocAsync(&d_b[tt], size_n, stream[tt])), "cudaMallocAsync(&d_b[tt], size_n, stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 914);
		check((cudaMemcpyAsync(d_a[tt], a[tt].data(), size_n, cudaMemcpyHostToDevice, stream[tt])), "cudaMemcpyAsync(d_a[tt], a[tt].data(), size_n, cudaMemcpyHostToDevice, stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 915);
	}

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 918);

	cout << "FNT test start" << endl;

	auto start = chrono::high_resolution_clock::now();
	unsigned wpt = n >> (LOG_THREAD_PER_OP + 1);

	for (unsigned tt = 0; tt < N_test; tt++) {
		
		
		
		
		fnt <<< 1, THREAD_PER_OP, 0, stream[tt] >>>(d_a[tt], d_b[tt], log_n, log_n, 0, d_N_pos, d_root_layer_pow, d_inv, wpt);
		check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 931);
		
		
		
	}

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 937);
	auto stop = chrono::high_resolution_clock::now();
	auto duration = chrono::duration_cast<chrono::milliseconds>(stop - start).count();

	cout << "FNT " << N_test << " chunks in " << duration << "ms" << endl;

	for (unsigned tt = 0; tt < N_test; tt++) {
		check((cudaFreeAsync(d_a[tt], stream[tt])), "cudaFreeAsync(d_a[tt], stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 944);
		check((cudaFreeAsync(d_b[tt], stream[tt])), "cudaFreeAsync(d_b[tt], stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 945);
		check((cudaStreamDestroy(stream[tt])), "cudaStreamDestroy(stream[tt])", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 946);
	}

}

void test_encode_decode_performance() {

	

	using namespace std;
	srand(time(0));

	const unsigned N_test = 128 * 1024 / 64;
	
	const long long symbol_bytes = 2;
	const double size_test_gb = 1.0 * symbol_bytes * NUM_OF_NEED_SYMBOL * N_test / (1024 * 1024 * 1024);

	vector<vector<unsigned>> a(N_test, vector<unsigned>(NUM_OF_NEED_SYMBOL));
	vector<vector<unsigned>> b(N_test, vector<unsigned>(NUM_OF_NEED_SYMBOL << 1));
	vector<vector<unsigned>> c(N_test, vector<unsigned>(NUM_OF_NEED_SYMBOL));

	for (unsigned tt = 0; tt < N_test; tt++)
		for (unsigned i = 0; i < NUM_OF_NEED_SYMBOL; i++)
			a[tt][i] = rand() % (MOD - 1); 

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 971);

	cout << "Encode performance test start" << endl;

	auto start1 = chrono::high_resolution_clock::now();

	for (unsigned tt = 0; tt < N_test; tt++) {
		h_encode(a[tt].data(), b[tt].data());
		check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 979);
	}

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 982);
	auto stop1 = chrono::high_resolution_clock::now();
	auto duration1 = chrono::duration_cast<chrono::milliseconds>(stop1 - start1).count();

	cout << "Encode " << N_test << " 64kb chunks in " << duration1 << "ms" << endl;
	cout << "Encode " << (1.0 * size_test_gb) / (1.0 * duration1 / 1000.0) << " GB/s" << endl;

	vector<vector<unsigned>> x(N_test, vector<unsigned>(NUM_OF_NEED_SYMBOL));
	vector<vector<unsigned>> y(N_test, vector<unsigned>(NUM_OF_NEED_SYMBOL));

	for (unsigned tt = 0; tt < N_test; tt++) {
		for (unsigned i = 0; i < NUM_OF_NEED_PACKET; i++) {
			unsigned stx = i * SYMBOL_PER_PACKET;
			for (unsigned j = 0; j < SEG_PER_PACKET; j++) {
				x[tt][stx + j] = stx + j;
				x[tt][stx + j + SEG_PER_PACKET] = stx + j + SEG_DIFF;
				y[tt][stx + j] = b[tt][stx + j];
				y[tt][stx + j + SEG_PER_PACKET] = b[tt][stx + j + SEG_DIFF];
			}
		}
	}

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1004);

	cout << "Decode performance test start" << endl;

	auto start2 = chrono::high_resolution_clock::now();

	for (unsigned tt = 0; tt < N_test; tt++) {
		h_decode(x[tt].data(), y[tt].data(), c[tt].data());
		check_last("C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1012);
	}

	check((cudaDeviceSynchronize()), "cudaDeviceSynchronize()", "C:\\Users\\captain3060\\Projects\\PBL7_DUT_ECC_CUDA\\rs_cuda\\rs_cuda\\kernel.cu", 1015);
	auto stop2 = chrono::high_resolution_clock::now();
	auto duration2 = chrono::duration_cast<chrono::milliseconds>(stop2 - start2).count();

	cout << "Decode " << N_test << " 64kb chunks in " << duration2 << "ms" << endl;
	cout << "Decode " << (1.0 * size_test_gb) / (1.0 * duration2 / 1000.0) << " GB/s" << endl;

	for (unsigned tt = 0; tt < N_test; tt++) {
		for (unsigned i = 0; i < c[tt].size(); i++)
			((void)0);
	}

}
